<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>alonepig's blog</title>
        <description>alonepig's blog - lsj</description>
        <link>http://alonepig.github.io</link>
        <link>http://alonepig.github.io</link>
        <lastBuildDate>2014-08-25T23:53:16+08:00</lastBuildDate>
        <pubDate>2014-08-25T23:53:16+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>windows下的VIM 编辑markdown语法高亮</title>
                <description>&lt;p&gt;Windows使用VIM编辑markdown的语法高亮设置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装git&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装curl&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;在git的安装目录的cmd件夹下的cmd件夹下新建curl.cmd件，复制以下内容：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@rem Do not use &amp;quot;echo off&amp;quot; to not affect any child calls.
@setlocal

@rem Get the abolute path to the parent directory, which is assumed to be the
@rem Git installation root.
@for /F &amp;quot;delims=&amp;quot; %%I in (&amp;quot;%~dp0..&amp;quot;) do @set git_install_root=%%~fI
@set PATH=%git_install_root%\bin;%git_install_root%\mingw\bin;%PATH%

@if not exist &amp;quot;%HOME%&amp;quot; @set HOME=%HOMEDRIVE%%HOMEPATH%
@if not exist &amp;quot;%HOME%&amp;quot; @set HOME=%USERPROFILE%

@curl.exe %*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在命令行中输入curl --version检查是否正确。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装Vundle&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;命令行进入用户目录，(一定要选择用户目录，win7下在C:/Users/xxx/，自己在其他地方clone后不能正确安装，配置文件中rtp和path设置绝对路径貌似没有效果，囧~)，克隆Vundle：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git clone https://github.com/gmarik/Vundle.vim.git 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编辑vim安装目录下的vimrc的配置文件，将以下内容添加到文件的最前面：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;set nocompatible              &amp;quot; be iMproved, required
filetype off                  &amp;quot; required

set rtp+=~/vimfiles/bundle/Vundle.vim/
let path=&amp;#39;~/vimfiles/bundle&amp;#39;
call vundle#begin(path)

&amp;quot; let Vundle manage Vundle, required
Plugin &amp;#39;gmarik/Vundle.vim&amp;#39;

Plugin &amp;#39;godlygeek/tabular&amp;#39;
Plugin &amp;#39;plasticboy/vim-markdown&amp;#39;

call vundle#end()            &amp;quot; required
filetype plugin indent on    &amp;quot; required
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的rtp和path要对应Vundle的目录，不然会找不到后面的命令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装插件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进入vim命令行状态，输入PluginInstall 安装vim-markdown插件&lt;/p&gt;

&lt;p&gt;除此之外还有以下命令可以使用：&lt;/p&gt;

&lt;p&gt;PluginList   查看插件列表&lt;/p&gt;

&lt;p&gt;PluginSearch foo 查询foo插件&lt;/p&gt;

&lt;p&gt;PluginClean     移除不需要的插件&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;https://github.com/gmarik/Vundle.vim&lt;/p&gt;

&lt;p&gt;https://github.com/gmarik/Vundle.vim/wiki/Vundle-for-Windows&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/tools/2014/08/07/vim-markdown-highlight</link>
                <guid>http://alonepig.github.io/tools/2014/08/07/vim-markdown-highlight</guid>
                <pubDate>2014-08-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>bitmapdata</title>
                <description>&lt;p&gt;BitmapData使用过程过的总结：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造函数 BitmapData(width, height, transparent, fillColor)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建一个具有指定的宽度和高度的 BitmapData 对象。如果为 fillColor 参数指定一个值，则位图中的每个像素都将设置为该颜色。&lt;/p&gt;

&lt;p&gt;默认情况下，将位图创建为透明位图，除非您为 transparent 参数传递值 false。创建了不透明位图后，将无法将其更改为透明位图。不透明位图中的每个像素仅使用 24 位的颜色通道信息。如果将位图定义为透明，则每个像素将使用 32 位的颜色通道信息，其中包括 Alpha 透明度通道。&lt;/p&gt;

&lt;p&gt;在 AIR 1.5 和 Flash Player 10 中，BitmapData 对象的最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果 BitmapData 对象的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。如果指定的宽度值或高度值大于 2880，则不会创建新实例。&lt;/p&gt;

&lt;p&gt;这是帮助文档上的解释，在用的时候要注意最后两个参数，比如如果你在截图的时候需要保留透明通道，则需将transparent设置为true，然后根据需求来设置最后一个参数，比如如果要透明，则将其Alpha值设置为0，这时候后面的颜色值就没有效果了；如果需要设置一个背景色，则设置Alpha为FF，再设置后6位的颜色值即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;//不使用透明通道，保存一个背景色为0xF3EBDD的位图
var bmd:BitmapData = new BitmapData(loader.rawContent.width, loader.rawContent.height, false, 0xF3EBDD); 

//保存一个有透明度的位图，背景没有颜色，因为Alpha被设置为0了
var bmd:BitmapData = new BitmapData(loader.rawContent.width, loader.rawContent.height, true, 0x00000000); 

//保存一个有透明度的位图，且背景色为红色
var bmd:BitmapData = new BitmapData(loader.rawContent.width, loader.rawContent.height, true, 0xFFFF0000); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;public function draw(source:IBitmapDrawable, matrix:Matrix = null, colorTransform:flash.geom:ColorTransform = null, blendMode:String = null, clipRect:Rectangle = null, smoothing:Boolean = false):void&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 Flash 运行时矢量渲染器在位图图像上绘制 source 显示对象。可以指定 matrix、colorTransform、blendMode 和目标 clipRect 参数来控制呈现的执行方式。您可以根据需要指定是否应在缩放时对位图进行平滑处理（这只适用于源对象是 BitmapData 对象的情况）。 &lt;/p&gt;

&lt;p&gt;注意：drawWithQuality() 方法与 draw() 方法非常相似，但不使用 Stage.quality 属性确定矢量呈现的品质，您需要为 drawWithQuality() 方法指定 quality 参数。&lt;/p&gt;

&lt;p&gt;此方法与如何在创作工具界面中使用对象的标准矢量渲染器来绘制对像直接对应。&lt;/p&gt;

&lt;p&gt;源显示对象不对此调用使用其任何已应用的转换。它会被视为存在于库或文件中，没有矩阵转换、没有颜色转换，也没有混合模式。要使用对象自己的 transform 属性来绘制显示对象（如影片剪辑），可以将其 transform 属性对象复制到使用 BitmapData 对象的 Bitmap 对象的 transform 属性。&lt;/p&gt;

&lt;p&gt;在 Flash Player 9.0.115.0 及更高版本和 Adobe AIR 中，通过 RTMP 支持此方法。在 Flash Media Server 上，可以在服务器端脚本中控制对流的访问。有关详细信息，请参阅 Server-Side ActionScript Language Reference for Adobe Flash Media Server《Adobe Flash Media Server 服务器端 ActionScript 语言参考》）中的 Client.audioSampleAccess 和 Client.videoSampleAccess。&lt;/p&gt;

&lt;p&gt;如果 source 对象和其所有子对象（如果是 Sprite 或 MovieClip 对象）与调用方不来自同一个域，或者不在调用方可通过调用 Security.allowDomain() 方法访问的内容中，则调用 draw() 将引发 SecurityError 异常。此限制不适用于应用程序安全沙箱中的 AIR 内容。&lt;/p&gt;

&lt;p&gt;对于使用所加载的位图图像作为 source 也有一些限制。如果所加载的图像来自与调用方相同的域，则调用 draw() 方法成功。此外，图像服务器上的跨域策略文件可以向调用 draw() 方法的 SWF 内容的域授予权限。在这种情况下，必须设置 LoaderContext 对象的 checkPolicyFile 属性，并在调用用于加载图像的 Loader 对象的 load() 方法时使用 LoaderContext 对象作为 context 参数。这些限制不适用于应用程序安全沙箱中的 AIR 内容。&lt;/p&gt;

&lt;p&gt;在 Windows 中，draw() 方法无法在 Adobe AIR 的 HTMLLoader 对象中捕获嵌入 HTML 页的 SWF 内容。&lt;/p&gt;

&lt;p&gt;draw() 方法无法捕获 Adobe AIR 中的 PDF 内容。也无法捕获 Adobe AIR 中 wmode 属性设置为“window”的 HTML 中嵌入的 SWF 内容。&lt;/p&gt;

&lt;p&gt;参数
    source:IBitmapDrawable — 要绘制到 BitmapData 对象的显示对象或 BitmapData 对象。（DisplayObject 和 BitmapData 类实现 IBitmapDrawable 接口。）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;matrix:Matrix (default = null) — 一个 Matrix 对象，用于缩放、旋转位图或转换位图的坐标。如果不想将矩阵转换应用于图像，请将此参数设置为恒等矩阵（使用默认 new Matrix() 构造函数创建），或传递 null 值。

colorTransform:flash.geom:ColorTransform (default = null) — 一个 ColorTransform 对象，用于调整位图的颜色值。如果没有提供任何对象，则不会转换位图图像的颜色。如果必须传递此参数但又不想转换图像，请将此参数设置为使用默认 new ColorTransform() 构造函数创建的 ColorTransform 对象。

blendMode:String (default = null) — 来自 flash.display.BlendMode 类的一个字符串值，指定要应用于所生成位图的混合模式。

clipRect:Rectangle (default = null) — 一个 Rectangle 对象，定义要绘制的源对象的区域。 如果不提供此值，则不会进行剪裁，并且将绘制整个源对象。

smoothing:Boolean (default = false) — 一个布尔值，用于确定因在 matrix 参数中指定缩放或旋转而对 BitmapData 对象进行缩放或旋转以后，是否对该对象进行平滑处理。smoothing 参数只有在 source 参数是 BitmapData 对象时才适用。在将 smoothing 设置为 false 的情况下，经过旋转或缩放的 BitmapData 图像可能会显得像素化或带有锯齿。例如，下面两个图像的 source 参数使用同一个 BitmapData 对象，但对左侧的图像，smoothing 参数设置为 true，对右侧的图像，该参数设置为 false：
在将 smoothing 设置为 true 的情况下绘制位图要比在将 smoothing 设置为 false 的情况下执行相同操作更为缓慢。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;应用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;部分剪切：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var bmd:BitmapData = new BitmapData(200, 200);
var m: Matrix = Matrix();
m.tx = -100;
m.ty = -100;
bmd.draw(bmp, m);
var bmp2 = new Bitmap(bmd);
addChild(bmp2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行，是复制的BitmapData的定义，其中200,200是复制出来的内容的宽和高；
第2～3行，是定义要复制的部分的起始坐标，-100，-100，意思就是从要复制的对象的注册点开始算，x:100，y:100坐标开始复制
第4行是复制，其中bmp就是复制的源（也就是一个显示对象），m就是刚才那个Matrix。
第5行是复制，6～7行是把复制的内容显示出来。
因为第一行定义了要复制的区域大小，2，3行定义了从哪个位置复制，这样就实现了按要求区域复制的功能了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public function copyPixels(sourceBitmapData:BitmapData, sourceRect:Rectangle, destPoint:Point, alphaBitmapData:BitmapData = null, alphaPoint:Point = null, mergeAlpha:Boolean = false):void&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为没有拉伸、旋转或色彩效果的图像之间的像素处理提供一个快速例程。此方法在目标 BitmapData 对象的目标点将源图像的矩形区域复制为同样大小的矩形区域。
如果包括 alphaBitmap 参数和 alphaPoint 参数，则可以将另一个图像用作源图像的 Alpha 源。如果源图像具有 Alpha 数据，则这两组 Alpha 数据都用于将源图像中的像素组合到目标图像中。alphaPoint 参数是 Alpha 图像中与源矩形左上角对应的点。源图像和 Alpha 图像交叉区域之外的任何像素都不会被复制到目标图像。
mergeAlpha 属性控制在将透明图像复制到另一透明图像时是否使用 Alpha 通道。若要复制含有 Alpha 通道数据的像素，请将 mergeAlpha 属性设置为 true。默认情况下，mergeAlpha 属性为 false。&lt;/p&gt;

&lt;p&gt;参数
    sourceBitmapData:BitmapData — 要从中复制像素的输入位图图像。源图像可以是另一个 BitmapData 实例，也可以指当前 BitmapData 实例。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sourceRect:Rectangle — 定义要用作输入的源图像区域的矩形。

destPoint:Point — 目标点，它表示将在其中放置新像素的矩形区域的左上角。

alphaBitmapData:BitmapData (default = null) — 第二个 Alpha BitmapData 对象源。

alphaPoint:Point (default = null) — Alpha BitmapData 对象源中与 sourceRect 参数的左上角对应的点。

mergeAlpha:Boolean (default = false) — 要使用 Alpha 通道，请将该值设置为 true。要复制不含 Alpha 通道的像素，请将该值设置为 false。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;应用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下例演示如何将一个 BitmapData 对象中 20 x 20 像素的区域内的像素复制到另一个 BitmapData 对象：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;flexinonroids.wordpress.com/2009/06/17/flex-3-bitmapdata-draw-with-transparency/&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/2014/08/06/bitmapdata</link>
                <guid>http://alonepig.github.io/2014/08/06/bitmapdata</guid>
                <pubDate>2014-08-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>swf文件格式</title>
                <description>&lt;p&gt;关于swf的文件格式，除了官方的文档，也有许多的资料可以参考。在这里只是做一个总结，具体内容请参阅最后给出的链接。&lt;/p&gt;

&lt;p&gt;学习swf的格式，首先你要了解swf的组成，它是有许多的标签按照一定的规则构成。它有自己定义的单位，就像int、number一样。可以查阅官方的文档或http://www.the-labs.com/MacromediaFlash/SWF-Spec/SWFfilereference.html来了解基本的数据类型和标签类型。&lt;/p&gt;

&lt;p&gt;到最新的版本，已有的标签如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Tag-value     Tag-name
0            End
1         ShowFrame
2         DefineShape
4         PlaceObject
5         RemoveObject
6         DefineBits
7         DefineButton
8         JPEGTables
9         SetBackgroundColor
10     DefineFont
11     DefineText
12     DoAction
13     DefineFontInfo
14     DefineSound
15     StartSound
17     DefineButtonSound
18     SoundStreamHead
19     SoundStreamBlock
20     DefineBitsLossless
21     DefineBitsJPEG2
22     DefineShape2
23     DefineButtonCxform
24     Protect
26     PlaceObject2
28     RemoveObject2
32     DefineShape3
33     DefineText2
34     DefineButton2
35     DefineBitsJPEG3
36     DefineBitsLossless2
37     DefineEditText
39     DefineSprite
43     FrameLabel
45     SoundStreamHead2
46     DefineMorphShape
48     DefineFont2
56     ExportAssets
57     ImportAssets
58     EnableDebugger
59     DoInitAction
60     DefineVideoStream
61     VideoFrame
62     DefineFontInfo2
64     EnableDebugger2
65     ScriptLimits
66     SetTabIndex
69     FileAttributes
70     PlaceObject3
71     ImportAssets2
73     DefineFontAlignZones
74     CSMTextSettings
75     DefineFont3
76     SymbolClass
77     Metadata
78     DefineScalingGrid
82     DoABC
83     DefineShape4
84     DefineMorphShape2
86     DefineSceneAndFrameLabelData
87     DefineBinaryData
88     DefineFontName
89     StartSound2
90     DefineBitsJPEG4
91     DefineFont4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，你需要弄明白这个规则。swf是由头和身体两部分组成。&lt;/p&gt;

&lt;p&gt;参考(A simple .swf file and it’s below the line representation)[http://blog.csdn.net/qdlgx/article/details/2868504]，你将明白头是怎么构成的，标签又是按照什么顺序排列的。&lt;/p&gt;

&lt;p&gt;再然后，就是指令集了。AVM虚拟机有自己的指令集。详情参考http://www.adobe.com/content/dam/Adobe/en/devnet/actionscript/articles/avm2overview.pdf&lt;/p&gt;

&lt;p&gt;下面总结出的ABC文件结构：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;abcFile
{
+ minor_version: u16    最低swf版本
+ major_version: u16    最高swf版本
+ method_count: u30     方法数量
+ metadata_count: u30   元数据数量
+ class_count: u30          类数量
+ script_count: u30         脚本数量
+ method_body_count: u30      方法体数量
+ constant_pool: cpool_info      常量池
+ method: method_info (Array)      方法集合
+ metadata: metadata_info (Array)      元数据集合
+ instance: instance_info (Array)      实例集合
+ class: class_info (Array)      类集合
+ script: script_info (Array)      脚本集合
+ method_body: method_body_info (Array)      方法体集合
}



cpool_info
{
+ int_count: u30      整形数量
+ uint_count: u30      无符号整形数量
+ double_count: u30      双精度型数量     
+ string_count: u30      字符串数量
+ namespace_count: u30      命名空间数量
+ ns_set_count: u30      命名空间集合数量
+ multiname_count: u30      复合名字数量
+ string: string_info (Array)      字符串集合
+ namespace: namespace_info (Array)      命名空间集合
+ ns_set: ns_set_info (Array)      命名空间的集合关系
+ multiname: multiname_info (Array)      复合名字集合
}

namespace_info
{
+ CONSTANT_Namespace: u8 = 0x08
+ CONSTANT_PackageNamespace: u8 = 0x16
+ CONSTANT_PackageInternalNs: u8 = 0x17
+ CONSTANT_ProtectedNamespace: u8 = 0x18
+ CONSTANT_ExplicitNamespace: u8 = 0x19
+ CONSTANT_StaticProtectedNs: u8 = 0x1A
+ CONSTANT_PrivateNs: u8 = 0x05
+ kind: u8      类型，有6种常量类型
+ name：u30      string集合的下标，为0的话则是空字符串
}

ns_set_info
{
+ count: u30      数量
+ ns: u30 (Array)      each ns is an integer that indexes into the namespace array of the constant pool
}

multiname_info
{
+ kind: u8      类型
+ CONSTANT_QName: u8 = 0x07
+ CONSTANT_QNameA: u8 = 0x0D
+ CONSTANT_RTQName: u8 = 0x0F
+ CONSTANT_RTQNameA: u8 = 0x10
+ CONSTANT_RTQNameL: u8 = 0x11
+ CONSTANT_RTQNameLA: u8 = 0x12
+ CONSTANT_Multiname: u8 = 0x09
+ CONSTANT_MultinameA: u8 = 0x0E
+ CONSTANT_MultinameL: u8 = 0x1B
+ CONSTANT_MultinameLA: u8 = 0x1C
+ data: u8 (Array)      可变长数据(根据不同类型得到不同的数据)
}

multiname_kind_QName
{
+ ns: u30      namespace集合的索引
+ name: u30      string集合的索引
}

multiname_kind_RTQName
{
+ name: u30      string集合的索引
}

multiname_kind_RTQNameL
{
}

multiname_kind_Multiname
{
+ u30 name      string集合的索引
+ u30 ns_set      ns_set集合的索引
}

multiname_kind_MultinameL
{
+ u30 ns_set      ns_set集合的索引
}


method_info
{
+ u30 param_count      参数的数量
+ u30 return_type      指向multiname索引
+ u30 param_type[param_count]      每一个条目指向multiname集合的索引
+ u30 name      string集合的索引
+ u8 flags      为以下常量类型，提供关于方法的额外信息
+ option_info options      只有在flag为HAS_OPTIONAL时才会出现
+ param_info param_names      只有在flag为HAS_PARAM_NAMES才会出现
+ NEED_ARGUMENTS: u8 = 0x01      Suggests to the run-time that an “arguments” object (as specified by the ActionScript 3.0 Language Reference) be created. Must not be used together with NEED_REST
+ NEED_ACTIVATION: u8 = 0x02      Must be set if this method uses the newactivation opcode
+ NEED_REST: u8 = 0x04      This flag creates an ActionScript 3.0 rest arguments array. Must not be used with NEED_ARGUMENTS
+ HAS_OPTIONAL: u8 = 0x08      Must be set if this method has optional parameters and the options field is present in this method_info structure
+ SET_DXNS: u8 = 0x40      Must be set if this method has optional parameters and the options field is present in this method_info structure
+ HAS_PARAM_NAMES: u8 = 0x80      Must be set when the param_names field is present in this method_info structure
}

option_info
{
+ u30 option_count
+ option_detail option[option_count]
}

option_detail
{
+ u30 val      有kind类型来指向常量池中不同类型集合的索引，如0x03表示整形集合的索引
+ u8 kind      类型，对应kind_constants
}

kind_constants
{
+ CONSTANT_Int: u8 = 0x03
+ CONSTANT_UInt: u8 = 0x04
+ CONSTANT_Double: u8 = 0x06
+ CONSTANT_Utf8: u8 = 0x01
+ CONSTANT_True: u8 = 0x0B
+ CONSTANT_False: u8 = 0x0A
+ CONSTANT_Null: u8 = 0x0C
+ CONSTANT_Undefined: u8 = 0x00
+ CONSTANT_Namespace: u8 = 0x08
+ CONSTANT_PackageNamespace: u8 = 0x16
+ CONSTANT_PackageInternalNs: u8 = 0x17
+ CONSTANT_ProtectedNamespace: u8 = 0x18
+ CONSTANT_ExplicitNamespace: u8 = 0x19
+ CONSTANT_StaticProtectedNs: u8 = 0x1A
+ CONSTANT_PrivateNs: u8 = 0x05
}


metadata_info
{
+ u30 name      string集合的索引
+ u30 item_count      items条目的数量
+ item_info items[item_count]      
}

item_info
{
+ u30 key
+ u30 value
}
The item_info entry consists of item_count elements that are interpreted as key/value pairs of indices into the string table of the constant pool


instance_info
{
+ CONSTANT_ClassSealed: u8 = 0x01      The class is sealed: properties can not be dynamically added to instances of the class
+ CONSTANT_ClassFinal: u8 = 0x02      The class is final: it cannot be a base class for any other class
+ CONSTANT_ClassInterface: u8 = 0x04      The class is an interface
+ CONSTANT_ClassProtectedNs: u8 = 0x08      The class uses its protected namespace and the protectedNs field is present in the interface_info structure
+ u30 name      multiname索引，类名
+ u30 super_name      基类的名字，multiname索引
+ u8 flags      常量类型
+ u30 protectedNs      flags为CONSTANT_ClassProtectedNs时才出现， namespace索引
+ u30 intrf_count      interface长度
+ u30 interface[intrf_count]      interface的条目包含multiname索引
+ u30 iinit      abcFile中method的索引
+ u30 trait_count      trait长度
+ traits_info trait[trait_count]      
}

traits_info
{
+ Trait_Slot: u8 = 0
+ Trait_Method: u8 = 1
+ Trait_Getter: u8 = 2
+ Trait_Setter: u8 = 3
+ Trait_Class: u8 = 4
+ Trait_Function: u8 = 5
+ Trait_Const: u8 = 6
+ ATTR_Final: u8 = 0x1
+ ATTR_Override: u8 = 0x2
+ ATTR_Metadata: u8 = 0x4
+ name: u30      multiname索引，不能为0
+ kind: u8      两个四位字段，低四位决定trait的类型，高四位构成trait的属性(有点不明白)
+ data: u8 (Array)      有trait的类型决定
+ metadata_count: u30      metadata长度
+ metadata: u30 (Array)      
}

trait_slot
{
+ u30 slot_id
+ u30 type_name      multiname索引
+ u30 vindex      
+ u8 vkind      kind_constant索引，当vindex不为0时存在
}
Trait_Slot或Trait_Const类型为trait_slot


trait_class
{
+ u30 slot_id      确定trait的位置
+ u30 classi      abcFile的class集合索引
}
Trait_Class类型为trait_class

trait_function
{
+ u30 slot_id
+ u30 function      abcFile中method索引
}
Trait_Function类型为trait_function

trait_method
{
+ u30 disp_id
+ u30 method      abcFile中method索引
}
Trait_Method、Trait_Getter、Trait_Setter类型为trai_method


class_info
{
+ u30 cinit      method索引
+ u30 trait_count
+ traits_info traits[trait_count]
}

script_info
{
+ u30 init      method索引
+ u30 trait_count
+ traits_info trait[trait_count]
}


method_body_info
{
+ method: u30      abcFile中method索引
+ max_stack: u30
+ local_count: u30      最大本地寄存器索引+1
+ init_scope_depth: u30
+ max_scope_depth: u30
+ code_length: u30
+ code: u8      保存AVM2指令
+ exception_count: u30
+ exception: exception_info (Array)
+ trait_count: u30
+ trait: traits_info (Array)
}

exception_info
{
+ u30 from      代码范围
+ u30 to
+ u30 target      跳转目标
+ u30 exc_type      错误类型, 常量表中 string 索引, 0=所有错误
+ u30 var_name      异常的变量名, 常量表中 string 索引
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;授之以鱼不如授之以渔，由于自己的水平有限，也没有完成弄懂里面的所有东西。在此，只是记录自己的学习过程。除了下面参考的资料，个人觉得最好的学习方法还是找到一个比较好的解析swf开源项目，通过阅读源码来理解(可参考swfinvestigator、as3crypto、JPEXS等)。有任何问题，欢迎跟我探讨。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.the-labs.com/MacromediaFlash/SWF-Spec/SWFfilereference.html&quot;&gt;SWF File Reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.the-labs.com/MacromediaFlash/SWF-Spec/SWFfileformat.html&quot;&gt;SWF File Format Specification&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.adobe.com/content/dam/Adobe/en/devnet/actionscript/articles/avm2overview.pdf&quot;&gt;AVM指令集概要&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qdlgx/article/details/2868504&quot;&gt;一个例子分析swf格式&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/07/30/swf-file-format</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/30/swf-file-format</guid>
                <pubDate>2014-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>mm.cfg</title>
                <description>&lt;p&gt;对于AS程序猿，mm.cfg一定不陌生。因为它真的很强大。&lt;/p&gt;

&lt;p&gt;根据官方文档介绍，你可以使用mm.cfg文件来配置调试版Flash Player的版本。能够将trace语句输出到日志文件中。如果系统中没有这个文件，在相应目录创建一个就好了。&lt;/p&gt;

&lt;p&gt;下面的表格显示了不同系统中mm.cfg的位置。&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;操作系统&lt;/td&gt;
        &lt;td&gt;位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Macintosh OS X&lt;/td&gt;
        &lt;td&gt;Flash Player首先会检查用户根目录(~)。如果没有发现，则检查/Library/Application Support/Macromedia&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Windows 2000/XP&lt;/td&gt;
        &lt;td&gt;
            %HOMEDRIVE%\%HOMEPATH%
            默认路径是c:\Documents and settings\username
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Windows Vista Windows 7&lt;/td&gt;
        &lt;td&gt;
            %HOMEDRIVE%\%HOMEPATH%
            默认路径是c:\Users\username
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Linux&lt;/td&gt;
        &lt;td&gt;/home/username&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;mm.cfg其实就是包含若干键值对的文本文件。&lt;/p&gt;

&lt;p&gt;下面的表格介绍了一些重要的属性：&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;属性&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;ErrorReportingEnable&lt;/td&gt;
        &lt;td&gt;能够输出错误消息。设置为1表示在调试版本的Flash Player的错误信息可以输出到日志文件中。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;TraceOutputFileEnable&lt;/td&gt;
        &lt;td&gt;是否可以输出trace的内容，如果设置为1，则日志文件中会显示所有trace的内容。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;PreloadSWF&lt;/td&gt;
        &lt;td&gt;预加载的swf路径，这个非常有用，下面详细介绍&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;除了以上简单介绍的，还有许多其他的参数可以配置。请参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jpauclair.net/2010/02/10/mmcfg-treasure/&quot;&gt;http://jpauclair.net/2010/02/10/mmcfg-treasure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在来详细谈谈PreloadSWF的作用，再看下面的内容之前可以先看看这篇文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://kanefan.duapp.com/?p=204&quot;&gt;http://kanefan.duapp.com/?p=204&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看完之后就会知道有多强大了。好了，现在总结一下它的作用：&lt;/p&gt;

&lt;p&gt;1.可以预加载到目标swf文件中，这样就可以获取该swf的一些信息了。比如，可以知道这个swf有多大，帧率是多少。更强的地方在于它能直接获取到loaderContentInfo里的ByteArray，是不是想到了什么？！！ 是这样的，直接通过预加载就可以将最终的swf文件导出来，完全不用管它运行前将swf加壳、切分很多块。因为，我们已经直接获取到了最终的文件。&lt;/p&gt;

&lt;p&gt;2.它可以获取到浏览器传过来的flashvars信息，是不是想到了很多页游的一些初始化信息都是从浏览器传过来的。通过增加一些代码，就能获取到这些信息了，是不是非常方便。&lt;/p&gt;

&lt;p&gt;3.还可以跟monsterDebugger、Adobe Scrout等调试工具配合，来看看swf内部运行的数据。&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/07/30/mmcfg</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/30/mmcfg</guid>
                <pubDate>2014-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Flash 游戏破解</title>
                <description>&lt;p&gt;学习编程最好的办法之一就是阅读别人的优秀代码，学习AS最好的方法之一就是阅读别人写的优秀的AS代码。当然，优秀的源码太多，在github一搜就能找到大把的开源项目。但，作为曾经的页游从业者。阅读优秀游戏的源码更是成长速度的方法之一。&lt;/p&gt;

&lt;p&gt;因此，本人也开始了学习破解页游的方法。经过长时间的摸索，自己掌握了一套自己的破解方法。在此，仅供参考。也在此声明，破解只是为了学习优秀的编程思想，对于那种破解之后修改UI后作为自己游戏或转手卖钱的行径，表示鄙视之。&lt;/p&gt;

&lt;p&gt;以下会分为三个部分来介绍破解之道。基础篇介绍需要用到的相关知识，工具篇包含了在破解过程中使用的工具，实战篇将找一款游戏进行实战破解。&lt;/p&gt;

&lt;h4&gt;基础篇&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AS编程基础：这个很重要，如果你连基本的AS语法都不清楚，那就算将源码赤裸裸的摆在您面前，您也看不懂啦！所以，你需要会这个。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;swf格式结构、AVM指令集：adobe是公开了swf的格式的，你需要找到swf&lt;em&gt;file&lt;/em&gt;format&lt;em&gt;spec&lt;/em&gt;v10和avm2overview两份文档，如果您真的读明白了，那读完后自己应该能写出一个解析swf的工具了。
需要了解这个的原因是，大部分的页游都会采用一些加密的方法来保护他们的swf文件，而只要你掌握了这个，那么万变不离其宗啦！请参考(另一篇)[http://alonepig.github.io/posts/2014-07-30-swf-file-format.html]&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mm.cfg：这个文件非常强大，非常有作用。您可以搜索相关的资料了解，也可以查看本人的介绍。关于mm.cfg，请参考(另一篇)[http://alonepig.github.io/posts/2014-07-30-mmcfg.html]：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;工具篇&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;硕思闪客精灵：这个软件最大的优点是能显示出各种资源(Sound、Shape、Image等等)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ActionScript View：这个就是大大有名的ASV了，有很多好用的功能，比如替换常量池的常量，导出swf的资源。相对于硕思闪客，该软件导出的AS源码错误更少一些。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FlashDecompiler：界面跟硕思闪客相似。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AS3 Sorcerer：另一款破解软件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JPEXS：这是一款开源的java项目，强烈推荐。首先，它是开源的(好处太多，自行领会)。再次，功能也很强大。可以显示代码对应的指令集。支持动态修改。有很多结构被修改后的swf文件，我都是通过它来解析成功的。而且，阅读它的源码，你会更加容易理解swf结构和指令集。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Adobe Scrout CC：这是adobe的一款debug软件，可以查看运行中的swf的各种状态。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Monster Debugger：另一款调试工具。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;WinHex：十六进制查看工具。刚您了解了swf结构后，用该工具打开一个swf，就能手动解析里面的数据了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Firefox HttpFox插件： 这个火狐插件是用来找到网页中swf、游戏资源地址的&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fiddler：一款网络监控软件，强大的功能是可以将网络上的文件替换成本地的文件运行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;实战篇&lt;/h4&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/07/29/crack-flash-game</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/29/crack-flash-game</guid>
                <pubDate>2014-07-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>load的缓存</title>
                <description>&lt;p&gt;有时候，在使用URLLoader装载资源的时候，会发现装载不到最新的资源。可以使用以下代码测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;call();

private function call():void
{
    if(urlLoader)
    {
        urlLoader.load(urlRequest); 
        return;
    }
    urlLoader = new URLLoader();                  
    urlRequest = new URLRequest(_url);  

    urlLoader.load(urlRequest);  

    urlLoader.addEventListener(Event.COMPLETE, urlLoaderCompleteHandler);
}

private function urlLoaderCompleteHandler(event:Event):void
{
    setTimeout(call, 2000);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用charles或相关工具监听请求，你会发现，只会发一次请求。这说明第二次就使用了缓存。&lt;/p&gt;

&lt;p&gt;为了解决该问题，只需要在url后添加一个参数，使得URL的地址每次都是唯一的即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;urlRequest = new URLRequest(_url + &amp;quot;?t=&amp;quot; + (new Date()).time);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>http://alonepig.github.io/actionscript/2014/07/25/load-cache</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/25/load-cache</guid>
                <pubDate>2014-07-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Error #2032：流错误</title>
                <description>&lt;p&gt;Error #2032：流错误。 URL:xxx/xxx/xxx 的问题总结：&lt;/p&gt;

&lt;p&gt;使用URLLoader或HttpService装载文件的时候，有时候会出现以上错误。于是开始找寻解决办法，经过搜索，发现很多人都遇到过这个问题，但又是不同的情况。
现整理一份解决办法，希望能帮到后来人。&lt;/p&gt;

&lt;h6&gt;一.由于IE缓存造成的。&lt;/h6&gt;

&lt;p&gt;使用HttpService时，在IE中第一次调用后会缓存资源，下次再使用的时候就会用原来的资源，而出现问题。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;mx:HTTPService id=&amp;quot;accountsRequest&amp;quot;
      method=&amp;quot;POST&amp;quot; url=&amp;quot;accounts.php&amp;quot;
      result=&amp;quot;assignUsersData(event)&amp;quot; fault=&amp;quot;onErrorLoad(event)&amp;quot;&amp;gt;
&amp;lt;/mx:HTTPService&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决办法是在url的地址后面加一个变量：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private function changePage(pageIdValue : Number) : void 
{
      var rnd : Number = Math.round(Math.random()*1000);
      accountsRequest.url = &amp;quot;accounts.php?foo=&amp;quot; + rnd;
      accountsRequest.send();
      pageId = pageIdValue; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;二、可能是IIS造成的，需要设置。进入IIS管理目录，选择MIME类型，然后通过添加菜单，添加一个新的MIME映射，文件拓展名填你需要的，MIME类型填application/octet-stream（可选）。&lt;/h6&gt;

&lt;p&gt;保存设置后，重新启动IIS服务器。&lt;/p&gt;

&lt;h6&gt;三、如果显示的是Error #2032: 流错误。 URL: xxx/xxx/xxx/xxx.swf，则可能需要修改项目设置。&lt;/h6&gt;

&lt;p&gt;修改模块项目的Flex Build Path，取消Use local debug runtime shared libraries when debugging复选框，这样，模块就不会去加载本地的rsls，而是回去加载adobe提供的rsls。&lt;/p&gt;

&lt;p&gt;其他解决办法(仅供参考)：&lt;/p&gt;

&lt;p&gt;1.修改UrlRequest的contentType属性，设置为text/xml。 &lt;/p&gt;

&lt;p&gt;2.修改UrlRequest的method，由POST改成GET。此方法未经验证，因为method原本默认的就是GET。&lt;/p&gt;

&lt;p&gt;如果以上方法都不能解决问题，可以监听HTTPStatusEvent.HTTP&lt;em&gt;STATUS(AIR中卫HTTPStatusEvent.HTTP&lt;/em&gt;RESPONSE_STATUS)事件，可以获得更多的信息来找寻答案。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://jabbypanda.com/blog/2006/11/mxhttpservice-calls-are-cached-in-ie-6-unnecessary/&lt;/p&gt;

&lt;p&gt;http://hydra1983.blog.163.com/blog/static/111750372011020104951205/&lt;/p&gt;

&lt;p&gt;http://www.judahfrangipane.com/blog/2007/02/15/error-2032-stream-error/&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/07/23/stream-error-2032</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/23/stream-error-2032</guid>
                <pubDate>2014-07-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>about h264 setting</title>
                <description>&lt;p&gt;&lt;strong&gt;什么是H264&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;H.264，或称MPEG-4第十部分（AVC,Advanced Video Coding），是由国际电信标准化部门ITU-T和国际标准化组织ISO/IEC于2003年共同推出的最新一代的视频压缩标准。
与就标准相比，它能够在更低带宽下提供优质视频。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;H264和Flash Player&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Flash Player9 就支持了H264回播。Flash Player应该播放 .mp4, .m4v, .m4a, .mov, .3gp文件。H264使用.flv扩展名，也使用新的扩展名。&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;文件扩展名&lt;/td&gt;
        &lt;td&gt;FTYP&lt;/td&gt;
        &lt;td&gt;MIME 类型&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;.4v&lt;/td&gt;
        &lt;td&gt;&#39;F4V&#39;&lt;/td&gt;
        &lt;td&gt;video/mp4&lt;/td&gt;
        &lt;td&gt;视频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;.f4p&lt;/td&gt;
        &lt;td&gt;&#39;F4P&#39;&lt;/td&gt;
        &lt;td&gt;video/mp4&lt;/td&gt;
        &lt;td&gt;受保护的媒体&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;.f4a&lt;/td&gt;
        &lt;td&gt;&#39;F4A&#39;&lt;/td&gt;
        &lt;td&gt;audio/mp4&lt;/td&gt;
        &lt;td&gt;Flash Player音频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;.f4b&lt;/td&gt;
        &lt;td&gt;&#39;F4B&#39;&lt;/td&gt;
        &lt;td&gt;audio/mp4&lt;/td&gt;
        &lt;td&gt;Flash Player有声读物&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;H264编码参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Profile：对视频压缩特性的描述，表示不同的画质级别。目前有21种标准，但AS中只支持2种选择。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cainiaoxiaoxiao.u.qiniudn.com/1279272306301.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Level：对视频本身特性的描述(码率、分辨率、fps)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cainiaoxiaoxiao.u.qiniudn.com/2222.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;在直播中使用H264编码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var cam:camera = Camera.getCamera();
var ns:netStream = new NetStream(nc);
ns.client = this;
ns.addEventListener(NetStatusEvent.NET_STATUS, onNetStatus); 

var h264Settings:H264VideoStreamSettings = new H264VideoStreamSettings();
h264Settings.setProfileLevel(H264Profile.MAIN, H264Level.LEVEL_3_1);
// 以下方法暂无效，不知道adobe什么时候才实现，用Camera对应的API代替
//h264Settings.setQuality(0,90);
//h264Settings.setKeyFrameInterval(15);
//h264Settings.setMode(width, height, fps);

ns.videoStreamSettings = h264Settings;
ns.attachCamera(cam);
ns.publish(&amp;quot;mp4:mplivestream.f4v&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;setProfileLevel(profile:String, level:String)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;H264Profile 类是用于设置 H264VideoStreamSettings 类的配置文件的常数值的枚举。(目前只支持两种)&lt;/p&gt;

&lt;p&gt;public static const BASELINE:String = &amp;quot;baseline&amp;quot;&lt;/p&gt;

&lt;p&gt;用于H.264/AVC基线配置文件的常数。这是 H264VideoStreamSettings 类的默认值。
支持I/P帧，只支持无交错(Progressive)和CAVLC，一般用于低阶或需要额外容错的应用，比如视频通话、手机视频等；&lt;/p&gt;

&lt;p&gt;public static const MAIN:String = &amp;quot;main&amp;quot;&lt;/p&gt;

&lt;p&gt;用于 H.264/AVC 主配置文件的常数。 
提高I/P/B帧，支持无交错(Progressive)和交错(interlaced)，同样提供对于CAVLC和CABAC的支持&lt;/p&gt;

&lt;p&gt;H264Level 类是用于设置 H264VideoStreamSettings 类的级别的常数值的枚举。 &lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://en.wikipedia.org/wiki/H264&lt;/p&gt;

&lt;p&gt;http://www.adobe.com/devnet/adobe-media-server/articles/h264_encoding.html&lt;/p&gt;

&lt;p&gt;http://www.adobe.com/devnet/adobe-media-server/articles/encoding-live-video-h264.html&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/2014/07/18/about-h264-setting</link>
                <guid>http://alonepig.github.io/2014/07/18/about-h264-setting</guid>
                <pubDate>2014-07-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>params on live</title>
                <description>&lt;h4&gt;直播过程中NetStream、Camera、Microphone的参数设置&lt;/h4&gt;

&lt;p&gt;在直播过程中，参数的设置非常重要，它关乎着使用了多少带宽，画面的流畅度等。自己在使用的过程中总结了一些经验，若有不对之处，望看官能指出。&lt;/p&gt;

&lt;h6&gt;关于bufferTime&lt;/h6&gt;

&lt;p&gt;bufferTime是NetStream的属性，表示缓冲的时间，默认值为0.1秒。在直播中如果设置为0则会出现卡顿的现象，要是设置的值较大，则等待的时间较长。
有一个比较好的办法，在开始连接的时候设置一个较小的值(如0.1)，等到缓冲区填满时(&amp;quot;NetStream.Buffer.Full&amp;quot;)，再设置大点(3秒或4秒)。接收到
&amp;quot;NetStream.Buffer.Empty&amp;quot;时再设置回初始值。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private function onNetStreamStatusHandler(event:NetStatusEvent):void
{
    switch(event.info.code)
    {
        case &amp;quot;NetStream.Buffer.Full&amp;quot;:
            _ns.bufferTime = 3;
            break;
        case &amp;quot;NetStream.Buffer.Empty&amp;quot;:
            _ns.bufferTime = 0.1;
            break;
    }
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;关于Camera.setQuality(bandwidth:int, quality:int)方法&lt;/h5&gt;

&lt;p&gt;帮助文档中说的很轻快，这个方法是用来设置每秒的最大带宽或当前输出视频输入信号所需的画面质量。&lt;/p&gt;

&lt;p&gt;使用此方法可以指定输出视频输入信号的哪一方面对于您的应用程序更重要：是带宽使用率还是图片品质。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;要表示带宽使用率更为重要，请将一个值传递给 bandwidth 并将 0 传递给 quality。运行时将在指定的带宽内以可能的最高质量传输视频。如有必要，运行时将降低画面质量以避免超出指定的带宽。通常，随着运动的增加，质量将降低。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要表示品质更为重要，请将 0 传递给 bandwidth 并将一个数值传递给 quality。运行时使用所需数量的带宽来保持指定的质量。如有必要，运行时将降低帧速率以保持画面质量。通常，随着运动的增加，带宽的使用率也将增加。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要指定带宽和品质同等重要，请为这两个参数都传递数值。运行时将传输达到指定质量并且不超过指定带宽的视频。如有必要，运行时将降低帧速率以保持画面质量，而不会超出指定的带宽。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里对于带宽bandwidth要重点理解。这里以每秒字节数(bps)为单位。但我们日常生活中常用到的是Kb/s、Mb/s，表示每秒传输多少兆、多少千字节。它们的转换关系是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;8 bit = 1 Byte = 1/1024 k = 1/1024/1024 M
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，2Mb的带宽最多只有200多K的下载速度就是这样得来的。&lt;/p&gt;

&lt;p&gt;在调试过程中，可以将bandwidth值设置为0，看看当前设置需要多少的带宽才能保持品质。&lt;/p&gt;

&lt;h5&gt;关于Camera.setMode(width:int, height:int, fps:Number, favorArea:Boolean = true)&lt;/h5&gt;

&lt;p&gt;将摄像头的捕获模式设置为最符合指定要求的本机模式。如果摄像头没有与您传递的所有参数相匹配的本机模式，运行时将选择与所请求的模式最接近的合成捕获模式。此操作可能涉及裁切图像和删除帧。&lt;/p&gt;

&lt;p&gt;默认情况下，运行时根据需要删除一些帧以保持图像大小。要将删除的帧数降至最低（即使这意味着减小图像大小），请为 favorArea 参数传递 false。&lt;/p&gt;

&lt;p&gt;在选择本机模式时，运行时将设法尽量保持所请求的高宽比。例如，如果发出 myCam.setMode(400, 400, 30) 命令，并且摄像头上可用的最大宽度和高度值分别为 320 和 288，则运行时将宽度和高度都设置为 288；通过将这些属性设置为相同的值，运行时可以保持所请求的 1:1 高宽比。&lt;/p&gt;

&lt;p&gt;要确定在运行时选择与所请求的值最匹配的模式后分配给这些属性的值，请使用 width、height 和 fps 属性。&lt;/p&gt;

&lt;p&gt;网络上流传一些关于setMode的设置，说带宽的大致算法是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;视频宽度 x 视频高度 x 播放速率 (fps) = 总的带宽( bits/sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后给出了一组推荐的参数设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;1 : //如果使用的是1M以上的宽度的话，可以选用如下设置：
2 : Camera.setMode(320,240,15);
3 : Camera.setQuality(144,000,85 );
4 : Microphone.setRate(22);
5 : //总的消耗带宽：1,196 kbps = 144kbyte

1 : //786 kbps宽带：
2 : Camera.setMode(240,180,12);
3 : Camera.setQuality(64,800,85 );
4 : Microphone.setRate(22);
5 : //总的消耗带宽：562 kbps = 70kbyte

1 : //384 kbps宽带：
2 : Camera.setMode(192,144,7);
3 : Camera.setQuality(24,192,85 );
4 : Microphone.setRate(11);
5 : //总的消耗带宽：216 kbps = 27kbyte

1 : //56 kbps 拨号：
2 : Camera.setMode(80,60,8);
3 : Camera.setQuality(4,800,85 );
4 : Microphone.setRate(8);
5 : //总的消耗带宽：54 kbps = 7kbyte
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自己经过了如下测试：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置setQuality(0, 85); 然后setMode设置为以上值&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;setLoopback(compress:Boolean=false)&lt;/h5&gt;

&lt;p&gt;指定在本地查看摄像头时是否使用压缩视频流。此方法仅在使用 Flash Media Server 传输视频时适用；如果将 compress 设置为 true，则可以更精确地看到在用户实时查看视频时向用户呈现视频的方式。&lt;/p&gt;

&lt;p&gt;虽然压缩流在用于测试（如预览视频品质设置）时很有用，但对它进行处理要花很大的代价，因为对本地视图并不只是进行压缩处理；就像通过实时连接进行传输那样，需要对视频进行压缩和编辑以进行传输，然后要对其进行解压缩处理以供本地查看。&lt;/p&gt;

&lt;p&gt;这个方法的作用感觉就是让用户感受最终传输的流的效果。应根据需求来决定是否需要设置。&lt;/p&gt;

&lt;h5&gt;setKeyFrameInterval(keyFrameInterval:int)&lt;/h5&gt;

&lt;p&gt;指定进行完整传输而不由视频压缩算法进行插值处理的视频帧（称为关键帧）。此方法仅在使用 Flash Media Server 传输视频时适用。&lt;/p&gt;

&lt;p&gt;Flash 视频压缩算法通过只传输自视频的上一帧以来的更改内容来压缩视频；这些部分被视为插补帧。可以根据前一帧的内容插补视频帧。但是，关键帧是完整的视频帧；它并不是根据前面的帧插补的。&lt;/p&gt;

&lt;p&gt;要确定如何设置 keyFrameInterval 参数的值，请考虑带宽使用率和视频播放辅助功能。例如，为 keyFrameInterval 指定较高的值（以较低的频率发送关键帧）可降低带宽使用率。但是，这可能会增加在视频某一特定点上定位播放头所需的时间量；可能需要插补更多以前的视频帧才能继续播放视频。&lt;/p&gt;

&lt;p&gt;反之，为 keyFrameInterval 指定较低的值（以较高的频率发送关键帧）会提高带宽使用率（因为会更频繁地传输所有的视频帧），但可能会减少在已录制视频内搜索特定视频帧所需的时间量。&lt;/p&gt;

&lt;p&gt;这个方法,如果不需要录播视频，那么可以把值设置的高一点来节省带宽。&lt;/p&gt;

&lt;h5&gt;setUseEchoSuppression(useEchoSuppression:Boolean)&lt;/h5&gt;

&lt;p&gt;指定是否使用音频编解码器的回音抑制功能。除非用户已经在 Flash Player 的“麦克风设置”面板中选择了“降低回音”，否则默认值为 false。&lt;/p&gt;

&lt;p&gt;回音抑制是指降低音频回馈效果，当扬声器发出的声音由同一系统上的麦克风拾取时，将导致音频回馈。（这不同于回音消除，后者会完全移除反馈。在调用 getEnhancedMicrophone() 方法以使用回音消除功能时，将忽略 setUseEchoSuppression() 方法。）&lt;/p&gt;

&lt;p&gt;通常情况下，当通过扬声器（而不是耳机）播放所捕获的声音时，建议使用回音抑制。如果您的 SWF 文件允许用户指定声音输出设备，则当他们指定使用扬声器并且还将使用麦克风时，您可能需要调用 Microphone.setUseEchoSuppression(true)。&lt;/p&gt;

&lt;p&gt;用户也可以在 Flash Player 的“麦克风设置”面板中调整这些设置。&lt;/p&gt;

&lt;h5&gt;setLoopBack(state:Boolean=true)&lt;/h5&gt;

&lt;p&gt;将麦克风捕获的音频传送到本地扬声器。如果将本地麦克风的声音传递到本地扬声器，则会存在创建音频回馈循环的风险，这可能导致非常大的振鸣声，并且可能会损坏声音硬件。使用参数值true调用Microphone.setUseEchoSuppression()方法可降低发生音频回馈的风险，但不会完全消除该风险。建议始终在调用Mecrophone.setLoopback(true)之前调用Microphone.setUseEchoSuppression(true)，除非确信用户使用耳机来播放声音，或者使用除扬声器外的设备。在FMS直播中需设置false，不然会有吵杂声。&lt;/p&gt;

&lt;h5&gt;setSilenceLevel(silenceLevel:Number, timeout:int=-1)&lt;/h5&gt;

&lt;p&gt;设置可认定为有声的最低音量输入水平，以及实际静音前需经历的无声时间长度(可选)。此方法用于优化带宽。
     * 要完全禁止麦克风检测声音，请为selenceLevel传递值1000；这样就对不会调度activity事件了。
     * 要确定麦克风当前所检测的音量，请使用Microphone.activityLevel。
Speex具有语音活动检测功能(VAD)，在未检测到语音时将自动减少带宽。使用Speex编码器时，建议将静音级别设置为0.&lt;/p&gt;

&lt;p&gt;第一个参数： 激活麦克风并调度activity事件所需的音量。可接收值的范围为0到100。
第二个参数： 在没有活动的情况下经历过的毫秒数，必须经历这么长的时间，Flash Player才会认为声音已停止并调度dispatch事件。&lt;/p&gt;

&lt;h5&gt;framesPerPacket&lt;/h5&gt;

&lt;p&gt;在一个包（消息）中传输的 Speex 语音帧的数目。每帧长 20 ms。默认值为每个包两帧。&lt;/p&gt;

&lt;p&gt;消息中包含的 Speex 帧越多，需要的带宽就越小，但发送消息延迟的时间就越长。Speex 帧越少，需要的带宽就越大，而延迟的时间就会越短。&lt;/p&gt;

&lt;h5&gt;gain&lt;/h5&gt;

&lt;p&gt;麦克风放大信号的程度。有效值0到100。默认值为50。&lt;/p&gt;

&lt;h5&gt;codec&lt;/h5&gt;

&lt;p&gt;用于压缩音频的编解码器。可用编解码器为 Nellymoser（默认值）和 Speex。枚举类 SoundCodec 包含各种对 codec 属性有效的值。&lt;/p&gt;

&lt;p&gt;如果使用 Nellymoser 编解码器，可使用 Microphone.rate() 设置采样率。如果使用 Speex 编解码器，则采样率会设置为 16 kHz。&lt;/p&gt;

&lt;p&gt;Speex 具有语音活动检测功能 (VAD)，在未检测到语音时将自动减小带宽。使用 Speex 编解码器时，Adobe 建议将静音级别设置为 0。要设置静音级别，请使用 Microphone.setSilenceLevel() 方法。&lt;/p&gt;

&lt;h5&gt;rate&lt;/h5&gt;

&lt;p&gt;麦克风捕获声音时使用的速率，单位是 kHz。可接受的值为 5、8、11、22 和 44。如果您的声音捕获设备支持 8 kHz，则默认值为 8 kHz。否则，默认值是您的声音捕获设备支持的高于 8 kHz 的下一个可用捕获级别，通常为 11 kHz。 &lt;/p&gt;

&lt;p&gt;注意：实际速率与下表中注明的 rate 值稍有不同：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rate 值    实际频率
44  44,100 Hz
22  22,050 Hz
11  11,025 Hz
8   8,000 Hz
5   5,512 Hz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;encodeQuality&lt;/h5&gt;

&lt;p&gt;使用 Speex 编解码器时的编码语音品质。可能值为从 0 到 10 的值。默认值为 6。数字越大，表示品质越高，但需要更多的带宽，如下表所示。列出的比特率值表示净比特率，并不包括信息分包开销。&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;品质值&lt;/td&gt;
        &lt;td&gt;所需的比特率(KB/秒)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;0&lt;/td&gt;
        &lt;td&gt;3.95&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1&lt;/td&gt;
        &lt;td&gt;5.57&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;2&lt;/td&gt;
        &lt;td&gt;7.75&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;3&lt;/td&gt;
        &lt;td&gt;9.80&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;4&lt;/td&gt;
        &lt;td&gt;12.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;5&lt;/td&gt;
        &lt;td&gt;16.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;6&lt;/td&gt;
        &lt;td&gt;20.6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;7&lt;/td&gt;
        &lt;td&gt;23.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;8&lt;/td&gt;
        &lt;td&gt;27.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;9&lt;/td&gt;
        &lt;td&gt;34.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;10&lt;/td&gt;
        &lt;td&gt;42.2&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h5&gt;noiseSuppressionLevel&lt;/h5&gt;

&lt;p&gt;Speex 编码器使用的最大噪音衰减分贝数（负数）。如果启用，则在从 Microphone 捕获的声音进行 Speex 压缩之前应用噪音抑制。设置为 0 以禁用噪音抑制。默认启用噪音抑制，最大衰减为 -30 dB。选择 Nellymoser 编解码器时被忽略。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://www.adobe.com/cn/devnet/flashplayer/articles/acoustic-echo-cancellation.html&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/17/params-on-live</link>
                <guid>http://alonepig.github.io/fms/2014/07/17/params-on-live</guid>
                <pubDate>2014-07-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>air develop ios app</title>
                <description>&lt;p&gt;记录使用AIR开发IOS应用中的点点滴滴&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h4&gt;准备证书、供给配置文件&lt;/h4&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;首先，你得弄明白以下几个概念：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;证书签名请求文件&lt;/strong&gt;：包含用于生成开发证书的个人信息的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Certificates&lt;/strong&gt;：开发证书，用于标识以开发应用程序为目的的开发人员。由证书签名文件上传到apple站点后生成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;p112证书文件&lt;/strong&gt;：用来构建iphone应用。用于windows平台。由从apple站点下载的cer文件转换成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;供给配置文件(Provisioning)&lt;/strong&gt;：一个允许测试或分发iphone应用程序的文件。有几种类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开发供给配置文件：用于开发和测试。满足条件的设备可以安装&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分发供给配置文件：用于提交App Store。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;应用程序 ID&lt;/strong&gt;：标识由特定开发人员开发的 iPhone 应用程序（或多个应用程序）的唯一字符串。应在 iPhone 开发人员中心站点创建应用程序 ID。每个供给配置文件都具有一个关联的应用程序 ID 或应用程序 ID 模式。当开发应用程序时应使用此应用程序 ID（或模式）。应在 Flash Professional CS5 的“iPhone 设置” 对话框中或在应用程序描述符文件中使用应用程序 ID。&lt;/p&gt;

&lt;p&gt;iPhone 开发人员中心的应用程序 ID 包含一个绑定种子 ID （后面带有绑定标识符）。绑定种子 ID 是 Apple 分配给应用程序ID 的一个字符串，例如 5RM86Z4DJM。绑定标识符包含一个您选择的反向域名字符串。绑定标识符可能以星号 (*) 结尾，表示通配符应用程序 ID。例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;5RM86Z4DJM.com.example.helloWorld&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;96LPVWEASL.com.example.* （通配符应用程序 ID）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;iPhone 开发人员中心提供了两种应用程序 ID：&lt;/p&gt;

&lt;p&gt;• 通配符应用程序 ID — 在 iPhone 开发人员中心，这些应用程序 ID 以星号 (&lt;em&gt;) 结尾，例如96LPVWEASL.com.myDomain.&lt;/em&gt; 或 96LPVWEASL.&lt;em&gt;。借助使用这种应用程序 ID 的供给配置文件，您可以生成测试应用程序，并且这些应用程序使用的应用程序 ID 与该模式匹配。对于应用程序的应用程序 ID，您可以将星号替换为任何有效字符字符串。例如，如果 iPhone 开发人员中心站点将 96LPVWEASL.com.example.&lt;/em&gt; 指定为应用程序 ID，则您可以将 com.example.foo 或 com.example.bar 用作应用程序的应用程序 ID。&lt;/p&gt;

&lt;p&gt;• 特定应用程序 ID — 它们定义在应用程序中使用的唯一应用程序 ID。在 iPhone 开发人员中心，这些应用程序 ID 不以星号结尾。例如：96LPVWEASL.com.myDomain.myApp。借助使用这种应用程序 ID 的供给配置文件，应用程序必须与该应用程序 ID 完全匹配。例如，如果 iPhone 开发人员中心站点将 96LPVWEASL.com.example.helloWorld 指定为应用程序 ID，您必须将 com.example.foo 用作应用程序的应用程序 ID。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Devices&lt;/strong&gt;：可以安装应用程序的设备。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;App IDs&lt;/strong&gt;：应用程序ID。创建供给配置文件后，该供给配置文件会绑定到应用程序ID。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;在开发之前，你必须做的事情：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;成为apple开发人员&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生成证书请求文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.Mac OS中，打开钥匙串访问。选择&amp;quot;首选项&amp;quot;--&amp;gt;&amp;quot;证书助手&amp;quot;--&amp;gt;&amp;quot;从证书颁发机构请求证书&amp;quot;。&lt;/p&gt;

&lt;p&gt;2 填写相关资料，输入iPhone开发人员账户ID匹配的电子邮件地址。不要输入CA电子邮件地址。&lt;/p&gt;

&lt;p&gt;3.保存此文件(CertificateSigningRequest.certSingingRequest)。&lt;/p&gt;

&lt;p&gt;4.将此文件上传到https://developer.apple.com/account/ios/certificate/certificateList.action的证书列表中，审核通过后，下载对应的cer文件。如果是在windows下开发，还需要将其转换成p12文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开发人员证书转换为p12文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.打开钥匙串访问应用程序。&lt;/p&gt;

&lt;p&gt;2.将下载下来的证书添加到钥匙串，选择&amp;quot;文件&amp;quot;--&amp;gt;&amp;quot;导入&amp;quot;。&lt;/p&gt;

&lt;p&gt;3.选择密钥类别，选择与iPhone开发证书相关联的私钥，导出项目。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h4&gt;开发中遇到的问题&lt;/h4&gt;

&lt;p&gt;1.在iphone5或iphone中上下出现黑边。解决办法是在跟描述文件同目录下添加一个命名为Default-568@2x.png的空白图片，图片大小为1136*640。参考：&lt;/p&gt;

&lt;p&gt;http://blogs.adobe.com/airodynamics/2012/11/07/deploying-air-apps-on-iphone-5/&lt;/p&gt;

&lt;p&gt;http://zengrong.net/post/1752.htm/comment-page-1#comment-16642&lt;/p&gt;

&lt;p&gt;2.不同的版本需要添加不同的Icon。不然在上传ipa文件时会有警告或直接报错。&lt;/p&gt;

&lt;p&gt;ERROR ITMS-9000: &amp;quot;Missing required icon file. The bundle does not contain an app icon for iPhone / iPod touch of exactly &amp;#39;57x57&amp;#39; pixels, in .png fomat for iOS versions &amp;lt; 7.0.&amp;quot;&lt;/p&gt;

&lt;p&gt;这时候，你应该根据提示来添加不同尺寸的icon。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h4&gt;上传到AppStore&lt;/h4&gt;

&lt;p&gt;1.打开https://itunesconnect.apple.com，选择&amp;quot;Manage Your Applications&amp;quot;，点击&amp;quot;Add New App&amp;quot;，填写相关资料。需要注意的是Bundle ID属性，这个属性是可选择的，必须和你申请证书的appid保持一致。&lt;/p&gt;

&lt;p&gt;2.通过Mac OS中的application uploader工具上传ipa文件。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/akun1103/article/details/8632651&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://help.adobe.com/zh_CN/air/build/air_buildingapps.pdf&quot;&gt;air_deviphoneapps.pdf&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/air/2014/07/16/air-develop-ios-app</link>
                <guid>http://alonepig.github.io/air/2014/07/16/air-develop-ios-app</guid>
                <pubDate>2014-07-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>working with live video</title>
                <description>&lt;h4&gt;使用实时视频&lt;/h4&gt;

&lt;h5&gt;捕获实时流&lt;/h5&gt;

&lt;h6&gt;使用Flash Media Live Encoder捕获视频&lt;/h6&gt;

&lt;h6&gt;实例：自定义视频捕获应用&lt;/h6&gt;

&lt;h5&gt;添加DVR特征&lt;/h5&gt;

&lt;h5&gt;添加元数据&lt;/h5&gt;

&lt;h6&gt;关于元数据&lt;/h6&gt;

&lt;p&gt;元数据流媒体让用户有机会获得他们正在查看的信息媒体。元数据可以包含关于视频的信息,例如标题、版权信息、视频的时间,或创建日期。客户端可以使用元数据来设置宽度和高度的视频播放器&lt;/p&gt;

&lt;h6&gt;向实时流发送元数据&lt;/h6&gt;

&lt;p&gt;客户端中使用send发送元数据&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NetStream.send(@setDataFrame, onMetaData [, metadata]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onMetaData参数指定回调函数。你可以使用多个数据关键帧，每个数据关键帧必须使用唯一的监听器(如onMetaData1..)&lt;/p&gt;

&lt;p&gt;metadata参数可以是Object或Array类型。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var metaData:Object = new Object();
metaData.title = &amp;quot;myStream&amp;quot;;
metaData.width = 400;
metaData.height = 200;
ns.send(&amp;quot;@setDataFrame&amp;quot;, &amp;quot;onMetaData&amp;quot;, metaData);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;清空元数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ns.send(&amp;quot;@clearDataFrame&amp;quot;, &amp;quot;onMetaData&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了在服务器端添加元数据，使用以下代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;s = Stream.get(&amp;quot;myStream&amp;quot;);
metaData = new Object();
metaData.title = &amp;quot;myStream&amp;quot;;
metaData.width = 400;
metaData.height = 200;
s.send(&amp;quot;@setDataFrame&amp;quot;, &amp;quot;onMetaData&amp;quot;, metaData);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器端情况元数据:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.send(&amp;quot;@clearDataFrame&amp;quot;, &amp;quot;onMetaData&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;检索元数据&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;netstream.client = this;

function onMetaData(info:Object):void {
    var key:String;
    for (key in info) {
        trace(key + &amp;quot;: &amp;quot; + info[key]);
    }
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;实例：向实时视频添加元数据&lt;/h6&gt;

&lt;p&gt;这个客户端应用有以下功能：&lt;/p&gt;

&lt;p&gt;· 捕获和编码视频&lt;/p&gt;

&lt;p&gt;· 显示捕获的视频&lt;/p&gt;

&lt;p&gt;· 流从客户端到服务器端&lt;/p&gt;

&lt;p&gt;· 发送元数据到服务器，客户端播放流时服务器发送元数据到客户端&lt;/p&gt;

&lt;p&gt;· 显示来自服务器的流&lt;/p&gt;

&lt;p&gt;· 显示元数据&lt;/p&gt;

&lt;p&gt;参考 nstall/documentation/smaples/metadata&lt;/p&gt;

&lt;h6&gt;Flash Media Live Encoder 元数据属性&lt;/h6&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;元数据属性名&lt;/td&gt;
        &lt;td&gt;数据类型&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;lastkeyframetimestamp&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;width&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;height&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;videodatarate&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;audiodatarate&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;framerate&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;creationdate&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;createdby&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;audiocodecid&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;videocodecid&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;audiodelay&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h6&gt;被录制的实时流的元数据属性&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ns.publish(&amp;quot;myCamera&amp;quot;, &amp;quot;record&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你录制流，AMS会添加如下表格中的元数据：&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;元数据属性名&lt;/td&gt;
        &lt;td&gt;数据类型&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;audiocodecid&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;canSeekToEnd&lt;/td&gt;
        &lt;td&gt;Boolean&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;createdby&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;duration&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;creationdate&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;videocodecid&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    
&lt;/table&gt;

&lt;h5&gt;捕获来自Flash Media Live Encoder的时间码&lt;/h5&gt;

&lt;h5&gt;以RAW格式发布实时流&lt;/h5&gt;

&lt;h5&gt;不同服务器间的多点发布&lt;/h5&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/07/working-with-live-video</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/working-with-live-video</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>securing applications</title>
                <description>&lt;h4&gt;应用安全&lt;/h4&gt;

&lt;h5&gt;资源访问权限&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;关于访问控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当用户访问服务器的时候，默认情况下能访问所有的流和共享对象。你可以使用服务端的ActionScript创建动态访问控制列表。&lt;/p&gt;

&lt;p&gt;当一个客户端连接服务器，服务器脚本会传递一个Client对象。每个Client对象有readAccess和writeAccess属性。你可以使用这些属性来控制访问权限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现动态访问控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;clent.readAccess和client.writeAccess属性为字符串类型，值包含了用分号隔开的字符串。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;client.readAccess = &amp;quot;appStreams;/appSO/&amp;quot;;
client.writeAccess = &amp;quot;appStreams/public/;appSO/public/&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认值为&amp;quot;/&amp;quot;，表示可以访问所有的流和共享对象。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;允许访问流&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在main.asc中，添加onConnect()函数来指定目录文件夹：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function(client, name) {
    // give this new client the same name as passed in
    client.name = name;
    // give write access
    client.writeAccess = &amp;quot;appStreams/public/&amp;quot;;
    // accept the new client&amp;#39;s connection
    application.acceptConnection(client);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;拒绝访问流&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function(client, name) {
    ...
    // deny write access to the server
    client.writeAccess = &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;指定访问共享对象&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;指定共享对象的名字&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function(client, name) {
    ...
    client.writeAccess = &amp;quot;appSO/public/&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;客户端权限&lt;/h5&gt;

&lt;h6&gt;使用Client对象属性&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;检查客户端IP地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;client.ip，如果需要，可以拒绝客户端连接：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;if (client.ip.indexOf(&amp;quot;60.120&amp;quot;) !=0) {
    application.rejectConnection(client, {&amp;quot;Access Denied&amp;quot;} );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;检查原始URL&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;在main.asc中，client.referrer表示拒绝访问的URL列表。确保连接的客户端是来自你期望的地方。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;referrerList = {};
referrerList[&amp;quot;http://www.example.com&amp;quot;] = true;
referrerList[&amp;quot;http://www.abc.com&amp;quot;] = true;

if (!referrerList[client.referrer]) {
    application.rejectConnection(client, {&amp;quot;Access Denied&amp;quot;} );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用唯一的key&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.客户端中，创建一个唯一的key：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var keyDate = String(new Date().getTime());
var keyNum = String(Math.random());
var uniqueKey = keyDate + keyNum;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.发送到服务器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;nc.connect(&amp;quot;rtmp://www.example.com/someApplication&amp;quot;, uniqueKey);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.下面的代码在所有的连接中寻找唯一的key。如果key丢失或者已经存在，则拒绝连接。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function( pClient, uniqueKey ) {
    if ( uniqueKey != undefined ) { 
    // require a unique key with connection request
        if ( clientKeyList[uniqueKey] == undefined ) {
        // first time -- allow connection
            pClient.uniqueKey = uniqueKey;
            clientKeyList[uniqueKey] = pClient;
            this.acceptConnection(pClient);
        } else {
            trace( &amp;quot;Connection rejected&amp;quot; );
            this.rejectConnection(pClient);
        }
    }
}
application.onDisconnect = function( pClient ) {
    delete clientKeyList[pClient.uniqueKey];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用访问插件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Flash Player版本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有两种方法访问这个值：&lt;/p&gt;

&lt;p&gt;虚拟的key： 配置服务器重新映射基于Flash播放器客户端的流&lt;/p&gt;

&lt;p&gt;Client.agent 服务器端代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function( pClient ) {
    var platform = pClient.agent.split(&amp;quot; &amp;quot;);
    var versionMajor = platform[1].split(&amp;quot;,&amp;quot;)[0];
    var versionMinor = platform[1].split(&amp;quot;,&amp;quot;)[1];
    var versionBuild = platform[1].split(&amp;quot;,&amp;quot;)[2];
}

// output example
// Client.agent: WIN 9,0,45,0
// platform[0]: &amp;quot;WIN&amp;quot;
// versionMajor: 9
// versionMinor: 0
// versionBuild: 45
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;验证连接的swf文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在swf文件连接应用之前，你可以配置服务器来验证客户端swf的权限。验证swf的作用是为了防止有人自己创建swf来访问你的资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指定域时，允许或拒绝连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你知道合法客户端来自的域，则可以使用一个白名单。相反的，你也可以使用黑名单。&lt;/p&gt;

&lt;p&gt;在Adaptor.xml文件添加域列表。&lt;/p&gt;

&lt;p&gt;也可以在服务器端代码中保存。下面的例子中，文件bannedIPList.txt包含了不需要的IP地址：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// bannedIPList.txt file contents:
// 192.168.0.1
// 128.493.33.0

function getBannedIPList() {
    var bannedIPFile = new File (&amp;quot;bannedIPList.txt&amp;quot;) ;
    bannedIPFile.open(&amp;quot;text&amp;quot;,&amp;quot;read&amp;quot;);
    application.bannedIPList = bannedIPFile.readAll();
    bannedIPFile.close();
    delete bannedIPFile;
}

application.onConnect = function(pClient) {
    var isIPOK = true;
    getBannedIPList();
    for (var index=0; index&amp;lt;this.bannedIPList.length; index++) {
        var currentIP = this.bannedIPList[index];
        if (pClient.ip == currentIP) {
            isIPOK = false;
            trace(&amp;quot;ip was rejected&amp;quot;);
            break;
        }
    }

    if (isIPOK) {
        this.acceptConnection(pClient);
    } else {
        this.rejectConnection(pClient);
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此外，你也能检查来自特殊域的请求来的太快：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.VERIFY_TIMEOUT_VALUE = 2000;
Client.prototype.verifyTimeOut = function() {
    trace (&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Closing Connection&amp;quot;)
    clearInterval(this.$verifyTimeOut);
    application.disconnect(this);
}

function VerifyClientHandler(pClient) {
    this.onResult = function (pClientRet) {
        // if the client returns the correct key, then clear timer
        if (pClientRet.key == pClient.verifyKey.key) {
            trace(&amp;quot;Connection Passed&amp;quot;);
            clearInterval(pClient.$verifyTimeOut);
        }
    }
}

application.onConnect = function(pClient) {
    this.acceptConnection(pClient);
    // create a random key and package within an Object
    pClient.verifyKey = ({key: Math.random()});

    // send the key to the client
    pClient.call(&amp;quot;verifyClient&amp;quot;,
        new VerifyClientHandler(pClient),
        pClient.verifyKey);

    // set a wait timer
    pClient.$verifyTimeOut = setInterval(pClient,
        $verifyTimeOut,
        this.VERIFY_TIMEOUT_VALUE,
        pClient);
}

application.onDisconnect = function(pClient) {
    clearInterval(pClient.$verifyTimeOut);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;用户权限&lt;/h5&gt;

&lt;h6&gt;使用额外资源的权限&lt;/h6&gt;

&lt;p&gt;对于有限的观众来说，这是他们使用数据库等资源的有效的凭证(登录和密码)。&lt;/p&gt;

&lt;p&gt;1.swf向连接请求提供要给用户认证。&lt;/p&gt;

&lt;p&gt;客户端一般提供账号和密码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var sUsername = &amp;quot;someUsername&amp;quot;;
var sPassword = &amp;quot;somePassword&amp;quot;;
nc.connect(&amp;quot;rtmp://server/secure1/&amp;quot;, sUsername, sPassword);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.AMS验证凭证。&lt;/p&gt;

&lt;p&gt;你可以使用WebService、LoadVars、XML、NetServices等技术来做验证。&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/07/securing-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/securing-applications</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>developing streaming media applications</title>
                <description>&lt;h4&gt;开发流媒体应用&lt;/h4&gt;

&lt;h5&gt;连接服务器&lt;/h5&gt;

&lt;h5&gt;管理连接&lt;/h5&gt;

&lt;h5&gt;流媒体文件&lt;/h5&gt;

&lt;h5&gt;检查视频文件&lt;/h5&gt;

&lt;h5&gt;处理错误&lt;/h5&gt;

&lt;h5&gt;使用播放列表&lt;/h5&gt;

&lt;h5&gt;动态流&lt;/h5&gt;

&lt;h5&gt;当连接断掉时重连流&lt;/h5&gt;

&lt;h6&gt;重连ActionScript API&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NetStream.attach(connection:NetConnection)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetStreamPlayTransitions.RESUME&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetStreamPlayTransitions.APPEND&lt;em&gt;AND&lt;/em&gt;WAIT&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetConnection.Connect.Closed&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用这个事件来重连流&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NetConnection.Connect.NetworkChange&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通知客户端网络连接改变了。&lt;/p&gt;

&lt;h6&gt;使用ActionScript API重连流&lt;/h6&gt;

&lt;p&gt;当NetConnection由于网络改变关闭，流会使用存在的缓存播放一会。同时，客户端代码重连服务器来恢复播放流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重连单一流&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用NetConnection.call()连接服务器A&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个NetStream。设置NetStream.bufferTime使得其有足够的数据在连接断开后播放一会儿。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用NetStream.play2()，使用NetStreamPlayTransitions.RESET来播放&amp;quot;myStream&amp;quot;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监听NetConnection的&amp;quot;NetConnection.Connect.Closed&amp;quot;事件，如果流断掉了则重连服务器。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用NetStream.attach(connection:NetConnection)函数使NetStream附加到新的连接上。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用NetStream.play2()，使用NetStreamPlayTransitions.RESUME来播放&amp;quot;myStream&amp;quot;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你想重连的话，不要调用NetConnection.close()或NetStream.close()。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;重连播放列表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务器负载均衡&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用NetStream.attch(connection:NetConnection)来连接其他的服务器&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;成功连接后，调用以前连接上的NetConnection.close()，防止数据泄露。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用 NetStream.play2() 并设置 NetStreamPlayOptions.transition 的值以执行恢复。将其余的 NetStreamPlayOptions 属性设置为最初调用 NetStream.play() 或 NetStream.play2() 时使用的值以启动流。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;监控网络接口改变&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;监控移动设备上的连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;监控RTMPS或RTMPT连接&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;授权插件事件和属性&lt;/h6&gt;

&lt;h6&gt;服务器日志&lt;/h6&gt;

&lt;p&gt;下面的事件在流重连时会写入AMS日志文件中：
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;事件&lt;/td&gt;
        &lt;td&gt;目录&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;connect&lt;/td&gt;
        &lt;td&gt;session&lt;/td&gt;
        &lt;td&gt;重新建立连接后&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;play&lt;/td&gt;
        &lt;td&gt;stream&lt;/td&gt;
        &lt;td&gt;流恢复播放&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;stop&lt;/td&gt;
        &lt;td&gt;stream&lt;/td&gt;
        &lt;td&gt;流停止播放&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h5&gt;快速切换流&lt;/h5&gt;

&lt;h5&gt;快速搜索&lt;/h5&gt;

&lt;h5&gt;检测带宽&lt;/h5&gt;

&lt;h6&gt;ActionScript3.0 本地带宽检测&lt;/h6&gt;

&lt;p&gt;NetConnect.call(&amp;quot;checkBandWidth&amp;quot;, null);&lt;/p&gt;

&lt;p&gt;Application.xml允许带宽检测&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;BandwidthDetection enabled=&amp;quot;true&amp;quot;&amp;gt;
&amp;lt;MaxRate&amp;gt;-1&amp;lt;/MaxRate&amp;gt;
&amp;lt;DataSize&amp;gt;16384&amp;lt;/DataSize&amp;gt;
&amp;lt;MaxWait&amp;gt;2&amp;lt;/MaxWait&amp;gt;
&amp;lt;/BandwidthDetection&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;监听事件，必须实现onBWCheck和onBWDone两个函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Client {
    public function onBWCheck(... rest):Number {
        return 0;
    }
    public function onBWDone(... rest):void {
        var bandwidthTotal:Number;
        if (rest.length &amp;gt; 0){
            bandwidthTotal = rest[0];
            // This code runs
            // when the bandwidth check is complete.
            trace(&amp;quot;bandwidth = &amp;quot; + bandwidthTotal + &amp;quot; Kbps.&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onBWCheck()函数是必须的。该函数返回一个值，即使是0，也表明告诉服务器客户端接收到了数据，你可以调用onBWCheck()了。&lt;/p&gt;

&lt;p&gt;服务器会在检测带宽之后调用onBWDone()函数。它有四个参数。第一个表示带宽(Kbps)。第二个、第三个还没用到，第四个表示延迟&lt;/p&gt;

&lt;h6&gt;服务器端初始化带宽检测&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function (clientObj){
    this.acceptConnection(clientObj);
    clientObj.checkBandwidth();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不需要在客户端手动调用checkBandwidth()函数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在应用级别禁用带宽检测&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;修改配置文件rootinstall/applications/applicationname/Application.xml&lt;/p&gt;

&lt;p&gt;&lt;Application&gt;
    &lt;Client&gt;
        &lt;BandwidthDetection enabled=&quot;false&quot;&gt;
        &lt;/BandwidthDetection&gt;
    &lt;/Client&gt;
&lt;/Application&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改rootinstall/conf/&lt;em&gt;defaultRoot/&lt;/em&gt;defaultVHost/Application.xml&lt;/p&gt;

&lt;p&gt;&lt;Application&gt;
    ...
    &lt;Client&gt;
        ...
        &lt;BandwidthDetection enabled=&quot;false&quot;&gt;
        &lt;/BandwidthDetection&gt;
        ...
    &lt;/Client&gt;
    ...
&lt;/Application&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;检测流长度&lt;/h5&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/07/developing-streaming-media-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/developing-streaming-media-applications</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>developing social applications</title>
                <description></description>
                <link>http://alonepig.github.io/fms/2014/07/07/developing-social-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/developing-social-applications</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>building peer assisted networking applications</title>
                <description>&lt;h4&gt;构建对等的网络应用&lt;/h4&gt;

&lt;h5&gt;RTMFP&lt;/h5&gt;

&lt;p&gt;Flash Player10和AIR1.5支持实时媒体流协议(RTMFP)。RTMFP是建立在UDP协议上的。RTMP是建立在TCP协议上的。UDP提供了更低的延迟。
它能够在两个客户端之间直接传输。&lt;/p&gt;

&lt;p&gt;RTMFP提供了以下特征：NAT/firewall traversal, congestion control 和 prioritization， IP地址， mobility， partial reliability。&lt;/p&gt;

&lt;p&gt;RTMFP使用了128位加密传输。为了播放RTMFP的流，客户端必须知道发布者的节点ID。节点ID是一个256位的发布者标识符。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.adobe.com/devnet/adobe-media-server/articles/real-time-collaboration.html&quot;&gt;Best practices for real-time collaboration using Adobe Media Server&lt;/a&gt;&lt;/p&gt;

&lt;h6&gt;关于节点ID&lt;/h6&gt;

&lt;p&gt;每个客户端都有一个节点ID。&lt;/p&gt;

&lt;p&gt;NetConnection.nearID为客户端节点ID，NetConnection.farID为服务器节点ID。&lt;/p&gt;

&lt;p&gt;同理在服务器中，client.nearID为服务器节点ID，client.farID为客户端节点ID。&lt;/p&gt;

&lt;p&gt;NetConnection.nearID和client.farID值一样，NetConnection.farID和client.nearID值一样。&lt;/p&gt;

&lt;p&gt;服务器端还有NetConnection.nearID和NetConnection.farID属性，包含了RTMFP连接的所有节点ID。&lt;/p&gt;

&lt;h6&gt;RTMFP上的单一传播，广播，多点发布&lt;/h6&gt;

&lt;p&gt;虽然RTMFP经常在对等网络应用中使用，你也可以使用RTMFP在单一传播、广播、多点发布上。简单的替换RTMP协议即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;netconnection.connect(&amp;quot;rtmfp://fms.exmaple.com/vod&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了在多点发布中使用RTMFP，创建一个服务器端的NetConnection，使用RTMFP URL连接目标服务器。&lt;/p&gt;

&lt;h5&gt;RTMFP 组&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;Peer&lt;/strong&gt; 节点，组的成员，也叫&amp;quot;node&amp;quot;。一个节点就是一个Flash Player或AIR客户端。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Group&lt;/strong&gt; 1个或多个RTMFP节点组成的集合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bootstrapping&lt;/strong&gt; 为了加入组，连接至少一个组成员。你可以写应用逻辑来使得要给客户端加入一个组，或者可以请求AMS自动引导客户端。&lt;/p&gt;

&lt;p&gt;组里的节点可以不经过服务器进行数据传输。节点可以共享数据。&lt;/p&gt;

&lt;p&gt;使用ActionScript3 GroupSpecifier类来定义组的&amp;quot;groupspec&amp;quot;。传递给NetGroup和NetStream的构造函数。使用NetGroup类管理组和发送ActionScript对象。使用
NetStream类来多播音频和视频。&lt;/p&gt;

&lt;p&gt;Groupspecs字符串以&amp;quot;G:&amp;quot;开头，后面接着一串十六进制的数字。&lt;/p&gt;

&lt;h6&gt;创建一个组&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;连接AMS
NetConnection.connect(&amp;quot;rtmfp://fms.exmaple.com/p2pexample/test1&amp;quot;);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：如果Adaptor.xml文件将RTMFP禁用了，客户端会接收&amp;quot;NetConnection.Connect.Failed&amp;quot;状态。   &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在&amp;quot;NetConnection.Connect.Success&amp;quot;中，使用GroupSpecifier类来额创建一个groupspec&lt;/p&gt;

&lt;p&gt;// Called in the &amp;quot;NetConnection.Connect.Success&amp;quot; case in the NetStatusEvent handler.
private function OnConnect():void{
    connected = true;
    // Create a GroupSpecifier object to pass to the NetGroup constructor.
    // The GroupSpecifier determines the properties of the group
    var groupSpecifier:GroupSpecifier;
    groupSpecifier = new GroupSpecifier(&amp;quot;com.example.p2papp&amp;quot;);
    groupSpecifier.postingEnabled = true;
    groupSpecifier.multicastEnabled = true;
    // The serverChannel lets the server do auto-bootstrapping
    groupSpecifier.serverChannelEnabled = true;
    netGroup = new NetGroup(netConnection, groupSpecifier.groupspecWithAuthorizations());
    netGroup.addEventListener(NetStatusEvent.NET_STATUS, NetStatusHandler);
}&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&amp;quot;NetGroup.Connect.Success&amp;quot;中，你可以手动或自动引导节点。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6&gt;向组里引导一个节点&lt;/h6&gt;

&lt;p&gt;连接到服务器后，一个节点必须被加入到一个组里，这个技术叫做&amp;quot;bootstrapping&amp;quot;。Bootstrapping允许同一个组的成员互相可见。&lt;/p&gt;

&lt;p&gt;为了加入一个组，客户端必须知道组定义的GroupSpecifier。如果两个客户端使用相同的GroupSpecifier，但从不联系，则他们在不同的组。如果两个组有联系，
那他们会合并为一个大组。&lt;/p&gt;

&lt;p&gt;每一个客户端都有一个节点ID。客户端和服务器端都可以访问节点ID。&lt;/p&gt;

&lt;p&gt;RTMFP中的节点可以使用以下的方法进行引导：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务器自动引导。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当客户端进行RTMFP连接时，服务器使用相同的NetGroup引导他们。客户端需要设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;GroupSpecifier.serverChannelEnabled为true。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;手动引导&lt;/p&gt;

&lt;p&gt;调用NetGroup.addNeighbor()方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LAN节点发现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用GroupSpecifier类可以激活局域网节点发现。局域网节点发现允许ERMFP NetConnection和NetStream、NetGroup对象自动定位节点和加入组的子组。
下面的代码展示了如果激活LAN节点发现：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var nc = new NetConnection();
// Protocol must be RTMFP
nc.connect(&amp;quot;rtmfp://fms.example.com/appname/appinstance&amp;quot;);
var gs = new GroupSpecifier(&amp;quot;com.example.discovery-test&amp;quot;);
// Must be enabled for LAN peer discovery to work
gs.ipMulticastMemberUpdatesEnabled = true;
// Multicast address over which to exchange peer discovery.
gs.addIPMulticastAddress(&amp;quot;224.0.0.255:30000&amp;quot;);
// Additional GroupSpecifier configuration...
var ns = new NetStream(nc, gs.toString());  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;服务端的RTMFP组&lt;/h6&gt;

&lt;p&gt;使用服务器端的ActionScript来创建一个RTMFP连接。一个服务器端的netConnection是一个虚拟的Flash客户端。它有自己的RTMFP栈。&lt;/p&gt;

&lt;p&gt;注意：服务器端的ActionScript不支持直接在节点之间创建连接。&lt;/p&gt;

&lt;h6&gt;Flash Player 对等节点网络应用安全对话框&lt;/h6&gt;

&lt;p&gt;当groupsec传递给了NetStream或NetGroup。Flash Player会显示一个&amp;quot;对等互助网络&amp;quot;对话框。该对话框询问用户是否可以使用它们的连接在节点之间共享数据。&lt;/p&gt;

&lt;p&gt;如果用户点击允许，对话框就不会在出现。如果用户不允许，所有节点特征将不能使用。你可以使用RTMFP订阅一个纯净的本地IP多播流，这种情况下，对话框不会出现。&lt;/p&gt;

&lt;p&gt;当使用IP多播时(没有对等网络的功能)，你可以禁用安全对话框，设置GroupSpecifier.peerToPeerDisabled属性为true。默认为false。&lt;/p&gt;

&lt;h6&gt;关于RRMFP组的ActionScript类&lt;/h6&gt;

&lt;p&gt;使用下面的ActionScript类和服务器端ActionScript类来创建RTMFP应用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NetConnection&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GroupSpecifier&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup：管理RTMFP组。该类属性提供了组成员的信息&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroupInfo：指定传输质量。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetStream：&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetStreamMulticastInfo：NetStream.multicastinfo 返回当前Qos状态的NetStreamMulticastInfo对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;向组里发送一个消息&lt;/h6&gt;

&lt;p&gt;调用NetGroup.post()方法广播一个ActionScript消息。使用&amp;quot;NetGroup.Posting.Notify&amp;quot;接收。&lt;/p&gt;

&lt;p&gt;这个方法类似于服务器端的Application.broadcastMsg()。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GroupSpecifier.postingEnabled属性必须为true。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接收NetGroup.Neighbor.Connect事件早于你调用post()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息使用AMF序列化。一个消息可以是任何形式的AMF对象。不能是MovieClip。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息传输是无序的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;post()方法返回一个消息ID或null或error。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;post()方法发送一个NetStatusEvent事件&amp;quot;NetGroup.Posting.Notify&amp;quot;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private function OnConnect():void{
    StatusMessage(&amp;quot;Connected\n&amp;quot;);
    connected = true;
    // Create a GroupSpecifier object to pass to the NetGroup constructor.
    // The GroupSpecifier determines the properties of the group
    var groupSpecifier:GroupSpecifier;
    groupSpecifier = new GroupSpecifier(&amp;quot;com.aslrexample/&amp;quot; + groupNameText.text);
    groupSpecifier.postingEnabled = true;
    groupSpecifier.serverChannelEnabled = true;
    netGroup = new NetGroup(netConnection, groupSpecifier.groupspecWithAuthorizations());
    netGroup.addEventListener(NetStatusEvent.NET_STATUS, NetStatusHandler);
    StatusMessage(&amp;quot;Join \&amp;quot;&amp;quot; + groupSpecifier.groupspecWithAuthorizations() + &amp;quot;\&amp;quot;\n&amp;quot;);
}
// Called when you the chatText field has focus and you press Enter.
private function DoPost(e:ComponentEvent):void{
    if(joinedGroup){
        // Build the message to post.
        var message:Object = new Object;
        message.user = userNameText.text;
        message.text = chatText.text;
        message.sequence = sequenceNumber++;
        message.sender = netConnection.nearID;
        // Post the message to the group.
        netGroup.post(message);
        StatusMessage(&amp;quot;==&amp;gt; &amp;quot; + chatText.text + &amp;quot;\n&amp;quot;)
    } else {
        StatusMessage(&amp;quot;Click Connect before sending a chat message&amp;quot;);
    }
    ClearChatText();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;直接向某个节点发送消息&lt;/h6&gt;

&lt;p&gt;客户端能直接向组里的一个节点发送消息而不经过服务器。这个特征叫做directed routing。&lt;/p&gt;

&lt;p&gt;下面是服务器端directed routing API：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Netgroup.sendToAllNeighbors()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToNearest()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToNeighbor()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToAllNeighbors()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToNearest()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToNeighbor()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;在组里复制一个对象&lt;/h6&gt;

&lt;p&gt;客户端可以在组里发送ActionScript对象。这个特征叫做object replication(对象复制)。使用该特征可以复制工作空间，创建白板，传输文件，同步节点操作等。&lt;/p&gt;

&lt;p&gt;使用以下客户端API：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NetGroup.addHaveObjects()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.addWantObjects()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.denyRequestedObject()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.removeHaveObjects()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.removeWantObjects()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.writeRequestedObject()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用以下服务器端API：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ByteArray 类&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;File.readBytes()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;File.writeBytes()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;多播&lt;/h6&gt;

&lt;p&gt;多播是向一个组里的多用户分配视频和音频。服务器不向客户端发送数据。多播允许部分发布者发送大量的数据。为了多播媒体，向NetStream构造器传递groupspec。对多播数据调用NetStream.publish()
或NetStream.play()。&lt;/p&gt;

&lt;p&gt;AMS支持应用级别的多播和IP多播。你可以对一个流同时使用应用多播和IP多播，这种情况叫做multicast fusion(多播融合)。&lt;/p&gt;

&lt;p&gt;关于多播，需要理解的地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;任何数量的流都可以在组内被发布。However, this practice is not recommended because each group member consumes and relays all streams, even if the streams aren’t playing at that specific client&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同名的流可以在组内被发布。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发布者可以调用NetStream.send()来向组里注入数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When a client is in an RTMFP group in which a live multicast stream is playing, the client may act as a relay point for that stream to some number of direct neighbors. To control this number, use the
NetStream.multicastPushNeighborLimit
property. The default value is to 4. All the peers within a group work
co-operatively to get the stream to each other. Each client is not pulling the stream from the server independently. For this reason, consider the expected average client uplink capacity when selecting the bitrate for the multicast stream you publish. Choosing a bitrate that&amp;#39;s too high may result in peers not being able to relay the stream smoothly.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;应用级别多播&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;By default, the peer-to-peer mesh distributes streams published into an RTMFP group&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP 多播&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IP多播使用路由器发送数据到指定的IP地址。&lt;/p&gt;

&lt;p&gt;为了发布流到IP多播地址，在发布前调用服务器端方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NetStream.setIPMulticastPublishAddress()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的订阅节点必须添加IP多播地址。GroupSpecifier.addIPMulticastAddress()&lt;/p&gt;

&lt;p&gt;默认情况下，应用级别多播和IP多播是并行的。这个技术叫做&amp;quot;fusion multicast&amp;quot;。为了运行IP多播而不用应用级别多播，设置以下属性：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;GroupSpecifier.peerToPeerDisabled=true

//关闭点对点多播
GroupSpecifier.multicastEnabled=true 

调用GroupSpecifier.addIPMulticastAddress()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Source-specific IP multicast&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建客户端无服务器的RTMFP连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;融合多播&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;检查多播服务的质量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent the server from unloading an application&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ingest, convert, and record a multicast stream&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;对等网络应用实例&lt;/h6&gt;

&lt;h5&gt;Distribute peer introductions across servers&lt;/h5&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/07/building-peer-assisted-networking-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/building-peer-assisted-networking-applications</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>getting started developing applications</title>
                <description>&lt;h4&gt;开始开发应用&lt;/h4&gt;

&lt;h5&gt;应用结构&lt;/h5&gt;

&lt;p&gt;典型的AMS应用有以下部分：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Client&lt;/strong&gt; 客户端显示用户界面，如控制视频的播放、停止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Client-side ActionScript&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Video or audio files&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Camera or Microphone&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Server-Side ActionScript&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;设置开发环境&lt;/h5&gt;

&lt;p&gt;你可以使用任何版本的AMS来开发和测试应用。为了写客户端代码，可以使用Flash Professional，Flash Builder等。
任何文本编辑器写服务器端代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设置开发环境:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、安装AMS&lt;/p&gt;

&lt;p&gt;2、验证是否安装成功&lt;/p&gt;

&lt;p&gt;3、安装Flash Professional或Flash Builder或Flex SDK&lt;/p&gt;

&lt;p&gt;4、捕获和编码视频&lt;/p&gt;

&lt;p&gt;a 连接一个摄像头或麦克风&lt;/p&gt;

&lt;p&gt;b 下载和安装Adobe Media Live Encoder&lt;/p&gt;

&lt;h5&gt;实例：Hello World应用&lt;/h5&gt;

&lt;h6&gt;概要&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 以下内容不能在Adobe Media Streaming Server中使用，因为你不能在这个版本上写服务器端代码&lt;/p&gt;

&lt;p&gt;这个例子展示了客户端的简单通讯。实例文件在rootinstall/documentation/samples/Hello World文件夹。&lt;/p&gt;

&lt;h6&gt;写用户接口&lt;/h6&gt;

&lt;h6&gt;写客户端脚本&lt;/h6&gt;

&lt;p&gt;package {
import flash.display.MovieClip;
import flash.net.Responder;
import flash.net.NetConnection;
import flash.events.NetStatusEvent;
import flash.events.MouseEvent;
public class HelloWorld extends MovieClip {&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public function HelloWorld() {
    textLbl.text = &amp;quot;&amp;quot;;
    connectBtn.label = &amp;quot;Connect&amp;quot;;
    connectBtn.addEventListener(MouseEvent.CLICK, connectHandler);
}

public function connectHandler(event:MouseEvent):void {
    if (connectBtn.label == &amp;quot;Connect&amp;quot;) {
        trace(&amp;quot;Connecting...&amp;quot;);
        nc = new NetConnection();
        // Connect to the server.
        nc.connect(&amp;quot;rtmp://localhost/HelloWorld&amp;quot;);
        // Call the server&amp;#39;s client function serverHelloMsg, in HelloWorld.asc.
        nc.call(&amp;quot;serverHelloMsg&amp;quot;, myResponder, &amp;quot;World&amp;quot;);
        connectBtn.label = &amp;quot;Disconnect&amp;quot;;
    } else {
        trace(&amp;quot;Disconnecting...&amp;quot;);
        // Close the connection.
        nc.close();
        connectBtn.label = &amp;quot;Connect&amp;quot;;
        textLbl.text = &amp;quot;&amp;quot;;
    }
}

private function onReply(result:Object):void {
    trace(&amp;quot;onReply received value: &amp;quot; + result);
    textLbl.text = String(result);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;}
}&lt;/p&gt;

&lt;h6&gt;写服务器端脚本&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function( client ) {
    client.serverHelloMsg = function( helloStr ) {
    return &amp;quot;Hello, &amp;quot; + helloStr + &amp;quot;!&amp;quot;;
}
application.acceptConnection( client );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;编译和运行应用&lt;/h6&gt;

&lt;p&gt;1、运行服务器&lt;/p&gt;

&lt;p&gt;2、编译客户端文件&lt;/p&gt;

&lt;p&gt;3、测试。&lt;/p&gt;

&lt;h5&gt;创建应用的概要&lt;/h5&gt;

&lt;h6&gt;客户端代码&lt;/h6&gt;

&lt;h6&gt;服务器端代码&lt;/h6&gt;

&lt;p&gt;一般来说，有如下需求的时候服务器端需要写代码：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Authenticate clients&lt;/strong&gt; 权限验证&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Implement connection logic&lt;/strong&gt; 实现连接的逻辑&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update clients&lt;/strong&gt; 通过调用远程方法来更新客户端的共享数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Connect to other server&lt;/strong&gt;  向某个应用或数据库调用web service或socket&lt;/p&gt;

&lt;p&gt;服务器端的代码入口为main.asc或yourApplicationName.asc。&lt;/p&gt;

&lt;p&gt;该文件应在应用的主目录中，或scripts子目录中。&lt;/p&gt;

&lt;p&gt;rootinstall/applications/appName&lt;/p&gt;

&lt;p&gt;rootinstall/applications/appName/scripts&lt;/p&gt;

&lt;p&gt;默认情况下，应用文件夹在安装目录的的applications文件中，也可以在fms.ini或Vhost.xml文件中设置VHOST.APPSDIR。
在Vhost.xml文件中，编辑AppsDir。&lt;/p&gt;

&lt;h5&gt;测试应用&lt;/h5&gt;

&lt;h6&gt;测试和调试客户端脚本&lt;/h6&gt;

&lt;h6&gt;测试和调试服务器端脚本&lt;/h6&gt;

&lt;p&gt;使用trace()，输出相关数据。日志信息也会保存在rootinstall/logs/&lt;em&gt;defaultVHost&lt;/em&gt;/yourApplicationName/yourInstanceName/application.xx.log文件中&lt;/p&gt;

&lt;p&gt;使用管理员控制台。修改.asc文件之后，需要重启应用才会生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用管理员控制台调试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可调式行和可调试会话数由Application.xml配置文件的AllowDebugDefault和MaxPendingDebugConnections决定。默认情况下，是不可调试的。
也可以使用服务器端代码开启调试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.allowDebug = true;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;部署应用&lt;/h5&gt;

&lt;h6&gt;注册应用&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;myNetConnection.connect(&amp;quot;rtmp://fms.examples.com/myApplication&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;复制服务器端脚本文件到服务器&lt;/h6&gt;

&lt;h6&gt;复制多媒体文件&lt;/h6&gt;

&lt;h6&gt;复制客户端文件到web服务器&lt;/h6&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/04/getting-started-developing-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/04/getting-started-developing-applications</guid>
                <pubDate>2014-07-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>communication between client and server</title>
                <description>&lt;h4&gt;一、客户端呼叫服务器&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;服务器main.asc代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Client.prototype.serverFun1 = function(value)
{
    return &amp;quot;value=&amp;quot; +value;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;客户端代码：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&lt;mx:Application xmlns:mx=&quot;http://www.adobe.com/2006/mxml&quot; layout=&quot;absolute&quot; 
    fontSize=&quot;12&quot; creationComplete=&quot;init()&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;mx:Script&amp;gt;
    &amp;lt;![CDATA[    
    import mx.controls.Alert;

    private var netConnection:NetConnection;
    private var responder:Responder;
    private var appServer:String=&amp;quot;rtmp://127.0.0.1/TestCode1&amp;quot;;

    private function init():void
    {
        netConnection = new NetConnection();
        netConnection.connect(appServer);
        netConnection.client=this;
    }

    private function onClick(evt:MouseEvent):void
    {
        responder = new Responder(OkFun,ErrorFun);
        netConnection.call(&amp;quot;serverFun1&amp;quot;,responder,&amp;quot;va&amp;quot;);
    }

    private function OkFun(re:String):void
    {
        Alert.show(re);
    }

    private function ErrorFun(info:Object):void
    {
        Alert.show( &amp;quot;error: &amp;quot; + info.description );
        Alert.show( &amp;quot;error: &amp;quot; + info.code );
    }

    ]]&amp;gt;
&amp;lt;/mx:Script&amp;gt;
&amp;lt;mx:Button x=&amp;quot;43&amp;quot; y=&amp;quot;65&amp;quot; label=&amp;quot;调用服务器&amp;quot; id=&amp;quot;btn&amp;quot; click=&amp;quot;onClick(event)&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;/mx:Application&quot;&gt;/mx:Application&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Responder 类提供了一个对象，该对象是NetConnection.call()中回调函数。&lt;/p&gt;

&lt;p&gt;NetConnection.call的参数分别表示：服务器端方法名、处理服务器的返回值函数(可选对象)、传递给服务器的参数&lt;/p&gt;

&lt;h4&gt;二、服务器端呼叫指定的客户端&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;服务器main.asc代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var handlerObject = function() {};

handlerObject.prototype.onResult = function( result )
{
    trace( result );
};

handlerObject.prototype.onStatus = function( info )
{
    trace( &amp;quot;error: &amp;quot; + info.description );
    trace( &amp;quot;error: &amp;quot; + info.code );
};

application.onConnect = function( client )
{
    this.acceptConnection( client );
    var msg = &amp;quot;Hello client, your IP is: &amp;quot; + client.ip;
    client.call( &amp;quot;asyncServerCall&amp;quot;, new handlerObject, msg );
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;客户端代码：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&lt;mx:Application xmlns:mx=&quot;http://www.adobe.com/2006/mxml&quot; layout=&quot;absolute&quot; 
    fontSize=&quot;12&quot; creationComplete=&quot;init()&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;mx:Script&quot;&gt;mx:Script&lt;/a&gt;
    &amp;lt;![CDATA[
        import mx.controls.Alert;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    private var netConnection:NetConnection;
    private var appServer:String=&amp;quot;rtmp://192.168.0.249/TestCode1&amp;quot;;

    private function init():void
    {
        netConnection = new NetConnection();
        netConnection.connect(appServer);
        netConnection.client=this;
    }

    public function asyncServerCall( msg:String ) : String 
       {
           Alert.show( msg );
           return &amp;quot;I got your message Thanks Server!&amp;quot;;
       }

]]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;/mx:Script&quot;&gt;/mx:Script&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/mx:Application&quot;&gt;/mx:Application&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Client.call(methodName, [resultObj, [p1, ..., pN]]) 在Flash客户机上异步的执行一个方法，并把值从Flash客户机返回到服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;resultObj：客户端的方法名&lt;/p&gt;

&lt;p&gt;[resultObj, [p1, ..., pN]]： 当发送者期待一个来自客户机的返回值时需要这个参数。如果参数被传递但没有返回值被期待的话，则传递值null。结果对象可以是你定义的任何对象，并且，为了有用起见，这个结果对象应该有两个方法-onResult和onStatus，这些方法会在结果到达时被调用。如果远端方法的调用是成功的，则resultObj.onResult会被调用；否则，resultObj.onStatus被触发。&lt;/p&gt;

&lt;h4&gt;三、服务端呼叫所有客户端(广播)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;服务器main.asc代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function(currentClient)
{
    application.acceptConnection(currentClient);
    application.broadcastMsg(&amp;quot;showServerMsg&amp;quot;,application.clients.length );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;客户端代码：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&lt;mx:Application xmlns:mx=&quot;http://www.adobe.com/2006/mxml&quot; layout=&quot;absolute&quot;
 fontSize=&quot;12&quot; creationComplete=&quot;init()&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;mx:Script&amp;gt;
    &amp;lt;![CDATA[

    import mx.controls.Alert;

    private var netConnection:NetConnection;
    private var appServer:String=&amp;quot;rtmp://192.168.0.249/TestCode1&amp;quot;;

    private function init():void
    {
        netConnection = new NetConnection();
        netConnection.connect(appServer);
        netConnection.client=this;
    }

    public function showServerMsg( n:Number ) :void
       {
           var msg:String =&amp;quot;已经有&amp;quot;+n.toString()+&amp;quot;位用户连接&amp;quot;;
           Alert.show( msg );
       }

    ]]&amp;gt;
&amp;lt;/mx:Script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;/mx:Application&quot;&gt;/mx:Application&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Application.broadcastMsg()：把一条消息广播到所有连接的客户机，给每个客户机广播。
这个方法相当于遍历Application.clients数组并在每一个独立的客户机上调用Client.call()，但这个方法的效率更高。唯一不同的是当你调用broadcastMsg()时你不能指定一个响应对象。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; //遍历客户端列表，分别call他们
for(var i=0;i&amp;lt;application.clients.length;i++) {
 application.clients[i].call(&amp;quot;showServerMsg&amp;quot;，application.clients.length);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;四、服务器端呼叫服务器端&lt;/h4&gt;

&lt;p&gt;NetConnection.call(methodName, [resultObj, p1, ..., pN])&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/04/communication-between-client-and-server</link>
                <guid>http://alonepig.github.io/fms/2014/07/04/communication-between-client-and-server</guid>
                <pubDate>2014-07-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ams_config_admin_guide</title>
                <description>&lt;h4&gt;Adobe Media Server Configuration and Administration Guide&lt;/h4&gt;

&lt;h5&gt;第一章、部署服务器&lt;/h5&gt;

&lt;h6&gt;配置端口&lt;/h6&gt;

&lt;p&gt;Adobe Media Server默认端口为1935和80.Adobe Media 管理员服务器端口为1111。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;端口要求&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;端口号&lt;/td&gt;
        &lt;td&gt;协议&lt;/td&gt;
        &lt;td&gt;传输&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1935&lt;/td&gt;
        &lt;td&gt;TRMP/E&lt;/td&gt;
        &lt;td&gt;TCP&lt;/td&gt;
        &lt;td&gt;默认&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1935&lt;/td&gt;
        &lt;td&gt;RTMFP&lt;/td&gt;
        &lt;td&gt;UDP&lt;/td&gt;
        &lt;td&gt;默认&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;80&lt;/td&gt;
        &lt;td&gt;RTMP/E,RTMTP,HTTP&lt;/td&gt;
        &lt;td&gt;TCP&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;19350-65535&lt;/td&gt;
        &lt;td&gt;RTMFP&lt;/td&gt;
        &lt;td&gt;UDP&lt;/td&gt;
        &lt;td&gt;
        默认情况，客户端使用RTMFP协议，在1935和19350-65535端口上连接AMS。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;8134&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;HTTP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;TCP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;1111&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;RTMP,HTTP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;TCP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;默认情况下，Flash Player，HTML客户端连接AMS管理员服务器的端口。&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;443&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;RTMPS&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;TCP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置IP地址和端口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开rootinstall/conf/ams.ini。&lt;/p&gt;

&lt;p&gt;2、编辑ADAPTOR.HOSTPORT参数，默认值为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ADAPTOR.HOSTPORT = :1935, 80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、保存文件重启服务器。&lt;/p&gt;

&lt;p&gt;Adaptor.xml配置文件中Adaptor/HostPortList/HostPort标签中使用ADAPTOR.HOSTPORT参数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;HostPort name=&amp;quot;edge1&amp;quot; ctl_channel=&amp;quot;localhost:19350&amp;quot;
rtmfp=&amp;quot;${ADAPTOR.HOSTPORT}&amp;quot;&amp;gt;${ADAPTOR.HOSTPORT}&amp;lt;/HostPort&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;为RTMFP配置IP地址和端口&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;RTMFP连接流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、RTMFP客户端在1935端口上连接AMS服务器进行UDP传输。&lt;/p&gt;

&lt;p&gt;重要：RTMFP和RTMP/E 客户端使用同样的端口连接AMS。但，RTMFP使用UDP，RTMP/E使用TCP。&lt;/p&gt;

&lt;p&gt;2、The amsedge process redirects the connection to an amscore process listening on a UDP port in the range 19350-65535&lt;/p&gt;

&lt;p&gt;每一个amscore进程有自己的RTMFP监听器。每一个RTMFP监听器绑定一个UDP端口。当amscore进程开始时，监听器绑定一下可用的UDP端口(Adaptor.xml中Adaptor/RTMFP/Core?hostPortList/HostPort标签指定)。
使用的端口的数量取决于amscore进程使用的数量。amscore进程使用的数量取决于应用程序实例是如何分布的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置RTMFP重定向端口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开rootinstall/conf/&lt;em&gt;defaultRoot&lt;/em&gt;/Adaptor.xml文件&lt;/p&gt;

&lt;p&gt;2、编辑HostPort标签，默认情况为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;Adaptor&amp;gt;
    ...
    &amp;lt;RTMFP&amp;gt;
    ...
        &amp;lt;Core&amp;gt;
            &amp;lt;HostPortList&amp;gt;
                &amp;lt;HostPort&amp;gt;:19350-65535&amp;lt;/HostPort&amp;gt;
            &amp;lt;/HostPortList&amp;gt;
        &amp;lt;/Core&amp;gt;
    &amp;lt;/RTMFP&amp;gt;
&amp;lt;/Adaptor&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、If the RTMFP adaptor is behind a NAT, specify the in-front-of-NAT IP address that clients connect to in the public attribute of the HostPort element. The following example uses 12.34.56.78 for the in-front-of-NAT IP address:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;HostPort public=&amp;quot;12.34.56.78:19350-65535&amp;quot;&amp;gt;:19350-65535&amp;lt;/HostPort&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、保存文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于HostPort&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HostPort标签的值为以下格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;value-of-HostPort&amp;gt; := [&amp;lt;host-port-range&amp;gt; [; &amp;lt;host-port-range&amp;gt; [; ... ] ] ]
&amp;lt;host-port-range&amp;gt; := [&amp;lt;host&amp;gt;][:&amp;lt;port-range&amp;gt;[, &amp;lt;port-range&amp;gt; ] ]
&amp;lt;port-range&amp;gt; := &amp;lt;start-port&amp;gt;[ - &amp;lt;end-port&amp;gt; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的例子中，每一个监听器有两个端口集合：一个端口来自host1:2000-2010或host2:3000-3010，一个来自host2:5000或host2:2010-4000。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置服务器在NAT后的公共的IP地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果RTMFP适配器在NAT之后，指定客户端连接的HostPort标签public属性来设置in-front-of-NAT IP地址。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;HostPort public=&amp;quot;&amp;lt;in-front-of-NAT-server-IP&amp;gt;:19350-65535&amp;quot;&amp;gt;:19350-65535&amp;lt;/HostPort&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你不指定public属性，服务器不会知道in-front-of-NAT 地址。amdedge进程会重定向客户端到正确的端口，但它会告诉客户端behind-NAT地址，这个地址客户端不能接触。&lt;/p&gt;

&lt;p&gt;Each HostPort element can specify a public address that corresponds to the specified port. This is the address that is advertised to clients for the given HostPort. To advertise an address, specify a value for the public attribute of the HostPort element. The public attribute has the same format as the HostPort element. The number of ports specified by the public attribute must equal the number of ports specified by the HostPort element. If the core listens on the n-th port of the HostPort value, the n-th port of the public attribute is advertised as its value.&lt;/p&gt;

&lt;p&gt;例子中HostPortList使用public属性，如果核心监听器在host1:1005，它的公共广告地址在host2:4005。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NAT和防火墙穿越&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;NAT(网络地址转换)和防火墙过滤可以阻止点对点的连接。在内部网应用程序中,您为了对整个网络进行控制,执行以下操作以确保客户可以创建点对点连接:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;允许在任何防火墙进行UDP通讯&lt;/li&gt;
&lt;li&gt;使用IFTF BEHAVE工作组推荐的NAT或防火墙&lt;/li&gt;
&lt;li&gt;Use the TURN proxy support in Flash Player to send traffic to a proxy in a DMZ that can comply with the previous recommendations. 
See &lt;a href=&quot;http://www.adobe.com/devnet/adobe-media-server/articles/real-time-collaboration.html&quot;&gt;Best practices for real-time collaboration using Adobe Media Server.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In an Internet application, the application developer must choose how to handle cases in which a firewall or NAT blocks a direct peer-to-peer connection. To create an application that works for connections that aren’t peer-to-peer, create a protocol fallback to client-server RTMP and/or RTMPT. To create an application that never relays media through the server (even though some clients may not see the media), don’t create a protocol fallback&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理解NAT的类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cone&lt;/strong&gt;    当想所有节点说话时重用同样的地址和端口&lt;/p&gt;

&lt;p&gt;多 IP地址，对称的    向一个新节点说话时，使用新地址和端口&lt;/p&gt;

&lt;p&gt;单一 IP地址，对称的 向一个新节点说话时，使用相同的地址和端口&lt;/p&gt;

&lt;p&gt;理解NAT和防火墙的过滤行为很重要：&lt;/p&gt;

&lt;p&gt;None    没有过滤功能的叫&amp;quot;full cone&amp;quot;&lt;/p&gt;

&lt;p&gt;Address-restricted  节点限制在已经使用过的地址&lt;/p&gt;

&lt;p&gt;Address and port-restricted 节点限制在已经使用过的地址和端口&lt;/p&gt;

&lt;p&gt;In addition, some NAT and firewall behaviors aren&amp;#39;t easily defined. For example, a NAT could act as a symmetric NAT that preserves port numbers. When it runs out of resources, it could switch and act as a cone NAT.&lt;/p&gt;

&lt;p&gt;In another example, a NAT could act as one type of NAT for the first client that connected to a server. It could act as a different type of NAT for the second client that tried to connect to the same server. In this case, a simple analysis can fail to predict whether a client can make a peer-to-peer connection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RTMFP连接检查&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RTMFP发明家马修·考夫曼主持一个名为RTMFP连通性检查程序的网站http://cc.rtmfp.net/。使用这个网站,尝试确定一个客户机在一个特定的网络可以创建一个点对点连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为HTTP流配置端口&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;负载平衡&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;部署服务器集群的工作流&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;strong&gt;点对点网络应用的负载均衡&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;部署边缘服务器&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;部署边缘服务器的工作流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设置边缘服务器的缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;连接到一个边缘服务器&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;部署64位服务器&lt;/h6&gt;

&lt;h5&gt;第二章、配置服务器&lt;/h5&gt;

&lt;h6&gt;配置服务器虚拟映射&lt;/h6&gt;

&lt;h6&gt;使用配置文件&lt;/h6&gt;

&lt;h6&gt;配置性能特性&lt;/h6&gt;

&lt;h6&gt;配置安全特性&lt;/h6&gt;

&lt;h6&gt;执行常规配置任务&lt;/h6&gt;

&lt;h6&gt;配置内容存储&lt;/h6&gt;

&lt;h6&gt;配置Apache HTTP服务器&lt;/h6&gt;

&lt;h6&gt;为Adobe HTTP动态流和Apple HTTP 实时流配置Apache&lt;/h6&gt;

&lt;h6&gt;配置HTTP流失效备援&lt;/h6&gt;

&lt;h6&gt;使用第三方的web服务器&lt;/h6&gt;

&lt;h6&gt;配置差分服务(DiffServ)&lt;/h6&gt;

&lt;h5&gt;第三章、使用管理员控制台&lt;/h5&gt;

&lt;h6&gt;连接管理员控制台&lt;/h6&gt;

&lt;h6&gt;检查应用&lt;/h6&gt;

&lt;h6&gt;管理管理员&lt;/h6&gt;

&lt;h6&gt;管理服务器&lt;/h6&gt;

&lt;h5&gt;第四章、监控和管理日志文件&lt;/h5&gt;

&lt;h6&gt;使用日志文件&lt;/h6&gt;

&lt;h6&gt;访问日志&lt;/h6&gt;

&lt;h6&gt;应用日志&lt;/h6&gt;

&lt;h6&gt;诊断日志&lt;/h6&gt;

&lt;h5&gt;第五章、管理服务器&lt;/h5&gt;

&lt;h6&gt;开始和停止服务器&lt;/h6&gt;

&lt;h6&gt;检查服务器状态&lt;/h6&gt;

&lt;h6&gt;检查视频文件&lt;/h6&gt;

&lt;h6&gt;在Linux上管理服务器&lt;/h6&gt;

&lt;h6&gt;Scramble tool&lt;/h6&gt;

&lt;h5&gt;第六章、使用管理员API&lt;/h5&gt;

&lt;h6&gt;使用管理员API工作&lt;/h6&gt;

&lt;h5&gt;第七章、XML配置文件参考&lt;/h5&gt;

&lt;h6&gt;配置文件的版本从4.5到5.0.1发生的改变&lt;/h6&gt;

&lt;h6&gt;配置文件的版本从4.0到4.5发生的改变&lt;/h6&gt;

&lt;h6&gt;Adaptor.xml文件&lt;/h6&gt;

&lt;h6&gt;Application.xml文件&lt;/h6&gt;

&lt;h6&gt;Logger.xml文件&lt;/h6&gt;

&lt;h6&gt;Server.xml文件&lt;/h6&gt;

&lt;h6&gt;Users.xml文件&lt;/h6&gt;

&lt;h6&gt;VHost.xml文件&lt;/h6&gt;

&lt;h5&gt;第八章、诊断日志消息&lt;/h5&gt;

&lt;h6&gt;诊断日志的消息ID&lt;/h6&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/03/ams_config_admin_guide</link>
                <guid>http://alonepig.github.io/fms/2014/07/03/ams_config_admin_guide</guid>
                <pubDate>2014-07-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>server side actionscript language reference</title>
                <description>&lt;h4&gt;服务器端ActionScript语言参考手册&lt;/h4&gt;

&lt;h5&gt;Adobe媒体服务器服务端的APIs&lt;/h5&gt;

&lt;h5&gt;全局函数&lt;/h5&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;函数名&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;clearInterval()&lt;/td&gt;
        &lt;td&gt;停止调用setInterval()&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;getGlobal()&lt;/td&gt;
        &lt;td&gt;当secure.asc文件装载好后提供全局对象的访问&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;load()&lt;/td&gt;
        &lt;td&gt;装载服务器的asc文件到main.asc文件中，方便管理，不然可能会造成main.asc过大&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;protectedObject()&lt;/td&gt;
        &lt;td&gt;保护一个对象的方法&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;setAttribute()&lt;/td&gt;
        &lt;td&gt;防止某些方法和属性被枚举、修改和删除&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;setInterval()&lt;/td&gt;
        &lt;td&gt;指定一个时间间隔调用某方法，直到调用clearInterval()&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;trace()&lt;/td&gt;
        &lt;td&gt;计算表达式并显示结果&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;clearInterval()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;停止调用setInterval()方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;intervalID：setInterval()方法返回的标识符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;function callback(){trace(&amp;quot;interval called&amp;quot;);}
var intervalID;
intervalID = setInterval(callback, 1000);
//sometime later
clearInterval(intervalID);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;getGlobal()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当secure.asc文件装载好后提供全局对象的访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Adobe Media Server有两个脚本执行模式：安全和普通。在安全模式下，只有secure.asc文件被装载和执行(没有其他脚本被装载)。
getGlobal()和protectedObject()函数都只适用于安全模式。这些函数非常强大，因为它们能够完全的访问脚本环境和创建系统对象。
一旦secure.asc被装载，服务器切换到普通脚本执行状态直到应用被卸载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;var global = getGlobal();&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;load()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;装载服务器端asc或js文件到main.asc文件。被装载的文件在main.asc文件成功装载后，application.onAppStart()调用之前编译运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;filename：文件名&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;load(&amp;quot;myLoadfile.asc&amp;quot;);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;protectObject()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;保护一个对象的方法。只能在main.asc中使用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;object：保护的对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var sysobj = {};
sysobj._load = load; // Hide the load function
load = null; // Make it unavailable unpriviliged code.
sysobj.load = function(fname){
// User-defined code to validate/modify fname
return this._load(fname);
}
// Grab the global object.
var global = getGlobal();
// Now protect sysobj and make it available as
// &amp;quot;system&amp;quot; globally. Also, set its attributes
// so that it is read-only and not deletable.
global[&amp;quot;system&amp;quot;] = protectObject(sysobj);
setAttributes(global, &amp;quot;system&amp;quot;, false, true, true);
// Now add a global load() function for compatibility.
// Make it read-only and nondeletable.
global[&amp;quot;load&amp;quot;] = function(path){
return system.load(path);
}
setAttributes(global, &amp;quot;load&amp;quot;, false, true, true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;setAttributes(object, propName, enumerable, readonly, permanent)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;object：一个对象&lt;/p&gt;

&lt;p&gt;propName:&lt;/p&gt;

&lt;p&gt;enumerable:&lt;/p&gt;

&lt;p&gt;readonly:&lt;/p&gt;

&lt;p&gt;permanent:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;setInterval(function, interval [, p1, ..., pN])&lt;/strong&gt;
&lt;strong&gt;setInterval(object.method, interval [, p1, ..., pN])&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;function：一个对象&lt;/p&gt;

&lt;p&gt;object.method:&lt;/p&gt;

&lt;p&gt;[, p1, ..., pN] &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;返回结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;trace()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;
expression:&lt;/p&gt;

&lt;h6&gt;Application&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;属性摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;属性&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.allowDebug&lt;/td&gt;
        &lt;td&gt;一个布尔值，是否允许管理员使用管理员API approveDebugSession()方法访问应用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.clients&lt;/td&gt;
        &lt;td&gt;只读，所有客户端列表&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.config&lt;/td&gt;
        &lt;td&gt;提供访问Application.xml配置文件的ApplicationObject元素&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.hostname&lt;/td&gt;
        &lt;td&gt;只读，主机名&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.name&lt;/td&gt;
        &lt;td&gt;只读，应用实例的名称&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.server&lt;/td&gt;
        &lt;td&gt;只读，服务器的平台和版本&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;函数&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.acceptConnection()&lt;/td&gt;
        &lt;td&gt;接收连接&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.broadcastMsg()&lt;/td&gt;
        &lt;td&gt;广播&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.clearSharedObjects()&lt;/td&gt;
        &lt;td&gt;删除共享对象&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.clearStream()&lt;/td&gt;
        &lt;td&gt;清空录制的流文件&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.denyPeerLookup()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.disconnect()&lt;/td&gt;
        &lt;td&gt;终止客户端连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.gc()&lt;/td&gt;
        &lt;td&gt;垃圾回收&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.getStats()&lt;/td&gt;
        &lt;td&gt;返回一个应用的状态&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.redirectConnection()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.registerClass()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.registerProxy()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.rejectConnection()&lt;/td&gt;
        &lt;td&gt;拒绝连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.sendPeerRedirect()&lt;/td&gt;
        &lt;td&gt;当一个节点查找一个对象节点，这个函数发送一个地址数组给对象节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.shutdown()&lt;/td&gt;
        &lt;td&gt;卸载应用实例&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件监听摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;事件监听器&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.onAppStart()&lt;/td&gt;
        &lt;td&gt;应用装载时调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onAppStop()&lt;/td&gt;
        &lt;td&gt;应用卸载时调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onConnect()&lt;/td&gt;
        &lt;td&gt;客户端调用NetConnection.connect()时被调用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.onConnectAccept()&lt;/td&gt;
        &lt;td&gt;连接成功后被调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onConnectReject()&lt;/td&gt;
        &lt;td&gt;连接被拒绝时调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onDisconnect()&lt;/td&gt;
        &lt;td&gt;客户端断开连接时被调用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.onPeerLookup()&lt;/td&gt;
        &lt;td&gt;服务器接收查找请求是被调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onPublish()&lt;/td&gt;
        &lt;td&gt;发布流时被调用&lt;/td&gt;
    &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;application.onStatus()&lt;/td&gt;
        &lt;td&gt;服务器处理消息出现错误的时候被调用&lt;/td&gt;
    &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;application.onUnpublish()&lt;/td&gt;
        &lt;td&gt;当一个客户端停止发布流的时候被调用&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h6&gt;ByteArray&lt;/h6&gt;

&lt;p&gt;服务器端的ByteArray类等于客户端的ByteArray，除了一下几种情况：&lt;/p&gt;

&lt;p&gt;下面两个方法在服务器端没有被实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ByteArray.inflate()&lt;/li&gt;
&lt;li&gt;ByteArray.deflate()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ActionScript3.0 ByteArray使用int或uint数据类型时，服务器端使用Number数据类型。&lt;/p&gt;

&lt;h6&gt;Client&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;属性摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;属性&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.agent&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.audioSampleAccess&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.farAddress&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.farID&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.farNonce&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.id&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.ip&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.nearAddress&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.nearID&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.nearNonce&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.pageUrl&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.potentialNearAddresses&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.protocol&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.protocolVersion&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.readAccess&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.referrer&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.reportedAddresses&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.secure&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.uri&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.videoSampleAccess&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.virtualKey&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.writeAccess&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.call()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.checkBandwidth()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.getbandwidthLimit()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.getStats()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.introducePeer()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.ping()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.remoteMethod()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.__resolve()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.setBandwidthLimit()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;函数&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.onFarAddressChange()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.onGroupLeave&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.onGroupJoin&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.onReportedAddressChange()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h6&gt;File&lt;/h6&gt;

&lt;h6&gt;GroupSpecifier&lt;/h6&gt;

&lt;h6&gt;GroupControl&lt;/h6&gt;

&lt;h6&gt;LoadVars&lt;/h6&gt;

&lt;h6&gt;Log&lt;/h6&gt;

&lt;p&gt;日志类允许您创建一个日志对象,可以作为一个可选的参数传递给WebService类的构造函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件监听摘要&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;事件监听器&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Log.onLog()&lt;/td&gt;
        &lt;td&gt;当日志消息发送时被调用&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Log 构造器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;new Log([logLevel] [, logName])&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;logLevel： 有以下几种值
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;值&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Log.BRIEF&lt;/td&gt;
        &lt;td&gt;基本的生命周期事件，接收错误错误消息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Log.VERBOSE&lt;/td&gt;
        &lt;td&gt;所有的生命周期事件，接收错误错误消息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Log.DEBUG&lt;/td&gt;
        &lt;td&gt;Metrics and fine-grained events and errors are received&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;logName&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可选参数，用于区分多个日志。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;newLog = new Log();&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Log.onLog()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;发送消息时调用&lt;/p&gt;

&lt;h6&gt;MulticastStreamInfo&lt;/h6&gt;

&lt;h6&gt;MulticastStreamIngest&lt;/h6&gt;

&lt;h6&gt;NetConnection&lt;/h6&gt;

&lt;h6&gt;NetGroup&lt;/h6&gt;

&lt;h6&gt;NetGroupInfo&lt;/h6&gt;

&lt;h6&gt;NetGroupReceiveMode&lt;/h6&gt;

&lt;h6&gt;NetGroupReplicationStrategy&lt;/h6&gt;

&lt;h6&gt;NetGroupSendMode&lt;/h6&gt;

&lt;h6&gt;NetGroupSendResult&lt;/h6&gt;

&lt;h6&gt;NetStream&lt;/h6&gt;

&lt;h6&gt;ProxyStream&lt;/h6&gt;

&lt;h6&gt;SharedObject&lt;/h6&gt;

&lt;p&gt;SharedObject类让你在服务器和多个客户端之间共享储存数据。共享对象可以是临时的，也可以在应用关闭后持久化。
你可以把他看作实时的数据传输设备。&lt;/p&gt;

&lt;p&gt;下面的条目描述了在服务器端使用共享对象的方法：&lt;/p&gt;

&lt;p&gt;1 保存和共享数据。一个共享对象可以在服务器和其他客户端之间检索。比如，你可以打开一个远程共享对象，比如一个电话列表，它在
服务器上持久化了。无论哪个客户端作出改变，修改后的数据都可以同步到服务器和其他连接的客户端。&lt;/p&gt;

&lt;p&gt;2 实时共享数据。&lt;/p&gt;

&lt;p&gt;对于理解服务器端共享对象，下面的信息很重要：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务器端函数SharedObject.get()创建远程共享对象，没有创建本地共享对象的方法。本地共享对象保存在内存中，
除非他们是持久的，这种情况才能保存到.sol文件中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保存在服务器端的远程共享对象的文件扩展名为.fso，它们保存在应用的子目录中。客户端的远程共享对象扩展名为.sor也保存在应用的子目录中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器共享对象可以是无持久化的(存在于应用实例的时间中)，或持久化(应用关闭后也能储存)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了创建持久化共享对象，设置SharedObject.get()的persistence参数为true。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3 每一个远程共享对象都被唯一的名字所标识，包含一组名字-值的键值对。就像其他的ActionScript对象。名字必须是唯一的字符串，值可以为任意的ActionScript数据类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SharedObject.getProperty()获取服务器端远程共享对象的属性。SharedObject.setProperty()设置属性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SharedObject.clear()清除共享对象；application.clearSharedObjects()删除多个共享对象。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器端共享对象可以属于当前应用程序实例或另一个应用程序实例。另一个应用程序实例可以在同一台服务器上或在一个不同的服务器上。
属于不同的应用程序实例的共享对象引用被称为代理共享对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SharedObject.lock()可以防止其他客户端修改共享对象。SharedObject.mark()发送change事件。&lt;/p&gt;

&lt;p&gt;当你得到一个引用代理共享对象,对象的任何更改发送到拥有对象的实例。成功或失败的任何变化是由使用SharedObject.onSync()事件处理程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;属性摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;属性&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.autoCommit&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.isDirty&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.name&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.resyncDepth&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.version&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;函数&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.clear()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.close()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.commit()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.flush()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.get()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.getProperty()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.getPropertyNames()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.lock()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.mark()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.purge()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.send()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.setProperty()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.size()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.unlock()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件监听摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;事件监听器&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.handlerName()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.onStatus&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.onSync&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h6&gt;SHA256&lt;/h6&gt;

&lt;h6&gt;SOAPCall&lt;/h6&gt;

&lt;h6&gt;SOAPFault&lt;/h6&gt;

&lt;h6&gt;Stream&lt;/h6&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/01/server-side-actionscript-language-reference</link>
                <guid>http://alonepig.github.io/fms/2014/07/01/server-side-actionscript-language-reference</guid>
                <pubDate>2014-07-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>getting_started_streaming_media</title>
                <description>&lt;h3&gt;目录&lt;/h3&gt;

&lt;p&gt;一、支持的客户端，编码器，解码器和文件格式&lt;/p&gt;

&lt;p&gt;二、预构建的媒体播放器&lt;/p&gt;

&lt;p&gt;三、实时流媒体(HTTP)&lt;/p&gt;

&lt;p&gt;四、实时流媒体(RTMP)&lt;/p&gt;

&lt;p&gt;五、点播流媒体(HTTP)&lt;/p&gt;

&lt;p&gt;六、点播流媒体(RTMP)&lt;/p&gt;

&lt;p&gt;七、受保护的点播流媒体(pRTMP)&lt;/p&gt;

&lt;p&gt;八、多播媒体(RTMFP)&lt;/p&gt;

&lt;p&gt;九、Configure closed captioning&lt;/p&gt;

&lt;p&gt;十、配置可交换的音频&lt;/p&gt;

&lt;p&gt;十一、配置保护内容&lt;/p&gt;

&lt;p&gt;十二、配置HTTP动态流和HTTP实时流&lt;/p&gt;

&lt;p&gt;十三、HTTP流配置文件参考&lt;/p&gt;

&lt;p&gt;十四、建立自定义媒体播放器&lt;/p&gt;

&lt;p&gt;十五、Offline packaging&lt;/p&gt;

&lt;p&gt;十六、流媒体问题的一些解决办法&lt;/p&gt;

&lt;hr&gt;

&lt;h5&gt;一、支持的客户端，编码器，解码器和文件格式&lt;/h5&gt;

&lt;h6&gt;流服务支持的客户端和服务器&lt;/h6&gt;

&lt;h5&gt;二、预构建的媒体播放器&lt;/h5&gt;

&lt;h5&gt;三、实时流媒体(HTTP)&lt;/h5&gt;

&lt;h5&gt;四、实时流媒体(RTMP)&lt;/h5&gt;

&lt;h5&gt;五、点播流媒体(HTTP)&lt;/h5&gt;

&lt;h5&gt;六、点播流媒体(RTMP)&lt;/h5&gt;

&lt;h5&gt;七、受保护的点播流媒体(pRTMP)&lt;/h5&gt;

&lt;h5&gt;八、多播媒体(RTMFP)&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;关于多播服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要：&lt;/strong&gt; 多播服务(rootinstall/applications/multicast)不能运行在AMS标准版中。&lt;/p&gt;

&lt;p&gt;多播服务是AMS多播解决方案的一部分。多播解决方案包括以下组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多播配置工具(rootinstall/tools/multicast/configurator)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Flash Media Live Encoder&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;捕获、编码和发布实时视频&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多播服务(rootinstall/applications/multicast)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多播播放器(rootinstall/tools/multicast/multicastplayer)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;配置多播事件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开rootinstall/tools/multicast/configurator/configurator.html。&lt;/p&gt;

&lt;p&gt;2、选择多播类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Fusion(simultaneous, cooperative IP and P2P multicast)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IP Multicast&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Peer to Peer&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Peer to Peer with Peer Discovery&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、对于Fusion和Peer to Peer，输入服务器名称(或IP地址)和多播应用的全路径，比如:rtmfp://ams.example.com/multicast。
如果服务器配置的端口大于1935，需指定端口，比如：rtmfp://ams.example.com:1940/multicast。&lt;/p&gt;

&lt;p&gt;4、输入流名字，比如，CorpAllHandsQ2_2010或livestream。&lt;/p&gt;

&lt;p&gt;5、输入发布密码。&lt;/p&gt;

&lt;p&gt;发布密码指定只有多播服务器才能在组内发布多播流，其他节点只能播放。&lt;/p&gt;

&lt;p&gt;6、输入组名字。名字需要唯一。&lt;/p&gt;

&lt;p&gt;7、对于IP Multicast 和Fusion，输入IP多播地址和端口。&lt;/p&gt;

&lt;p&gt;8、(可选的)如果托管AMS的服务器有一个以上的网络接口卡(NIC)，在地址文本框中为一个NIC输入IP地址。AMS使用这个IP地址来决定发布时访问的接口。&lt;/p&gt;

&lt;p&gt;9、(可选的)为了使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Source-specific_multicast&quot;&gt;source-specific multicast&lt;/a&gt;，在对应的输入框输入IP地址和端口。&lt;/p&gt;

&lt;p&gt;10、点击生成。多播配置工具产生以下内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实时流的名字。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;F4M文件。为了观看此文件，点击观看Manifest文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;11、为了使用多播播放器，按照下面的步骤：&lt;/p&gt;

&lt;p&gt;a 点击保存Manifest文件。&lt;/p&gt;

&lt;p&gt;b 保存manifest.f4m文件到multicastplayer.html同目录。默认情况，在rootinstall/tools/multicast/multicastplayer。&lt;/p&gt;

&lt;p&gt;12、为了使用Strobe Media Playback，打开配置器。在设置完成后，你将返回到配置并保存f4m文件到相同的文件夹下的作为Strobe Media Playback。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Flash Media Live Encoder 发布流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开Flash Media Live Encoder3.1或更高版本&lt;/p&gt;

&lt;p&gt;2、从预设菜单中，选择一个单一的流。多播解决方案不支持multi-bitrate流。&lt;/p&gt;

&lt;p&gt;3、对于AMS URL，输入多播服务的URL。如果你在同一台电脑测试，输入：rtmp://localhost/multicast&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;Flash Media Live Encoder 连接AMS是通过RTMP协议传输的，不使用RTMFP。&lt;/p&gt;

&lt;p&gt;4、将在多播配置工具中复制的发布流的名字粘贴。&lt;/p&gt;

&lt;p&gt;5、点击开始。&lt;/p&gt;

&lt;p&gt;6、打开管理员控制台，点击观看Applications&amp;gt;Clients。The RTMP client is the connection from FMLE to the server. The RTMFP client is a server-side peer established by the multicast service to republish the live stream into the target RTMFP Group&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;播放多播流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、开打rootinstall/tools/multicast/multicastplayer/multicastplayer.html&lt;/p&gt;

&lt;p&gt;2、为了在本地系统中运行Flash Player，右键屏幕，选择全局设置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在Flash Player帮助页，选择全局安全设置面板。点击Edit locations &amp;gt; Add location &amp;gt;Browse for folder。选择multicastplayer.swf文件所在目录。
点击添加。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Flash Player设置管理器，选择高级点击Trusted Location Setting。点击添加，选择multicastplayer.swf文件所在目录。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、重新装载multicastplayer.html。点击运行点对点连接。&lt;/p&gt;

&lt;p&gt;4、打开管理员控制台看客户端连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用AMS样例播放器播放流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开rootinstall/samples/videoPlayer/videoplayer.html&lt;/p&gt;

&lt;p&gt;2、从rootinstall/tools/multicast/configurator复制t.f4m文件到rootinstall/smaples/videoPlayer文件夹。&lt;/p&gt;

&lt;p&gt;3、在样例播放器中，在URL流文本框中输入manifest.f4m， 点击播放。&lt;/p&gt;

&lt;p&gt;4、管理员控制台查看信息。&lt;/p&gt;

&lt;h5&gt;九、Configure closed captioning&lt;/h5&gt;

&lt;h5&gt;十、配置可交换的音频&lt;/h5&gt;

&lt;h5&gt;十一、配置保护内容&lt;/h5&gt;

&lt;h5&gt;十二、配置HTTP动态流和HTTP实时流&lt;/h5&gt;

&lt;h5&gt;十三、HTTP流配置文件参考&lt;/h5&gt;

&lt;h5&gt;十四、建立自定义媒体播放器&lt;/h5&gt;

&lt;h6&gt;为实时或点播服务构建媒体播放器&lt;/h6&gt;

&lt;p&gt;OSMF 播放器是基于Flash平台的开源播放器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;连接流服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;跟所有AMS应用一样，通过NetConnection.connect()来连接，URI参数格式如下：&lt;/p&gt;

&lt;p&gt;rtmp://ams-ip-or-dns/serviceName/[formatType:][instanceName/]fileOrStreamName&lt;/p&gt;

&lt;p&gt;hostName AMS域名&lt;/p&gt;

&lt;p&gt;serviceName 直播或点播&lt;/p&gt;

&lt;p&gt;instanceName 如果客户端连接默认的实例，你可以省略或使用&lt;em&gt;definst&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;fotmatType mp3文件则用mp3:,对mp4/f4v文件，则用mp4:，flv文件不做要求。&lt;/p&gt;

&lt;p&gt;fileOrStreamName 文件名或路径，如my&lt;em&gt;video.mp4或subdir/subdir2/my&lt;/em&gt;video.mp4。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不支持的ActionScript API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于实时和点播服务，客户端不能使用 SharedObject.getRemote()&lt;/p&gt;

&lt;p&gt;你不能编辑服务端的代码。但可以通过NetConnection.call()来调用服务器端的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;允许从指定的域连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况，可以从任何域连接。&lt;/p&gt;

&lt;p&gt;rootinstall/applications/live 或 rootinstall/applications/vod 文件夹：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加一个swf客户端的域，编辑allowedSWFdomains.txt文件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加一个HTML客户端的域，编辑allowedHTMLdomains.txt文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;访问音频和视频的原始数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActionScript中通过BitmapData.draw()和SoundMixer.computeSpectrum()方法访问数据。&lt;/p&gt;

&lt;p&gt;默认情况下，AMS阻止你访问流。为了访问，需要做以下事情：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将rootinstall/smaple/applications/live 或 rootinstall/smaple/applications/vod的main.far和main.asc文件复制到rootinstall/applications/live 或 rootinstall/applications/vod&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;去掉下面两行的注释：&lt;/p&gt;

&lt;p&gt;//p&lt;em&gt;client.audioSampleAccess = &amp;quot;/&amp;quot;;
//p&lt;/em&gt;client.videoSampleAccess = &amp;quot;/&amp;quot;;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;流服务API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;getStreamLength(streamObj)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返回流的长度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nc.call(&amp;quot;getStreamLength&amp;quot;, returnObj, &amp;quot;sample_video&amp;quot;);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;getPageUrl()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返回客户端Swf的URL&lt;/p&gt;

&lt;p&gt;//嵌套在html中
getPageUrl 返回： http://www.example.com/trace.html&lt;/p&gt;

&lt;p&gt;//没有嵌套在html中
getPageUrl 返回： http://www.example.com/trace.swf&lt;/p&gt;

&lt;p&gt;这个值必须是http地址。由于安全原因，本地地址不会显示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nc.call(&amp;quot;getPageUrl&amp;quot;, returnObj);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;getReferrer()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返回SWF文件的URL或服务器连接源自哪里&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;myNetConnection.call(&amp;quot;getReferrer&amp;quot;, returnObj);&lt;/p&gt;

&lt;h6&gt;构建动态的HTTP流媒体播放器&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;使用OSMF&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理解HTTP动态流的应用结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流媒体使用Adobe HDS需要Adobe媒体Manifest文件(.f4m)。&lt;/p&gt;

&lt;p&gt;manifest文件包含的信息媒体资源或多播流中的每个流的事件的信息。这些信息包括媒体的位置、DRM额外头数据,媒体引导信息,自适应流比特率等。&lt;/p&gt;

&lt;p&gt;为了产生文件，HTTP模块会执行以下步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;结合请求URL和HttpStreamingLiveEventPath指令来定位实时事件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从Event.xml和multi-lvevel manifest文件总检索元数据&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了流录制文件(.stream)扫描事件目录&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;检索每一个流文件对应的内容。每一个.stream文件都来自manifest文件的&lt;media&gt;标签&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从.meta文件检索元数据&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为引导信息和DRM额外头数据创建链接(如果内容是安全的)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回生成manifest文档&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在rootinstall/applications/livepkgr/streams/&lt;em&gt;definst&lt;/em&gt;文件夹，实时打包器以流的名字创建文件夹：livestream1，livestream2。实时打包器
在每个文件夹中创建了以下文件：&lt;/p&gt;

&lt;p&gt;· livestream#.bootstrap&lt;/p&gt;

&lt;p&gt;· livestream#.control&lt;/p&gt;

&lt;p&gt;· livestream#.meta&lt;/p&gt;

&lt;p&gt;· livestream#.Seg#.f4f&lt;/p&gt;

&lt;p&gt;· livestream#.Seg#.f4x&lt;/p&gt;

&lt;p&gt;下表描述了每个文件类型：
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;文件&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#Seg#.f4f&lt;/td&gt;
        &lt;td&gt;A segment. The Live Packager outputs one or more F4F files. Each file contains a segment of the source file. Each segment contains the fragmented (and optionally protected) content.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#Seg#.f4x&lt;/td&gt;
        &lt;td&gt;An index file listing the fragment offsets in each .f4f file. The Live Packager outputs one or more F4X files. The HTTP Origin Module uses this file to deliver fragments.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#.meta&lt;/td&gt;
        &lt;td&gt;Contains the stream metadata (bitrate, screen size, and so on).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#.bootstrap&lt;/td&gt;
        &lt;td&gt;Contains the bootstrap information for the stream.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#.control&lt;/td&gt;
        &lt;td&gt;Contains internal metadata that the Live Packager uses to manage stream state.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#.drmmeta&lt;/td&gt;
        &lt;td&gt;Contains additional header information when a stream is encrypted for use with Adobe Access.&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;以下是Apache配置HTTP动态流的时候这些文件的URL请求格式：
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;请求格式&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Fragment&lt;/td&gt;
        &lt;td&gt;http://&lt;host&gt;/&lt;location-tag-alias&gt;/streams/&lt;app-name&gt;/streams/&lt;app-instance&gt;/&lt;stream name&gt;Seg&lt;segment #&gt;-Frag&lt;fragment #&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Bootstrap(.bootstrap)&lt;/td&gt;
        &lt;td&gt;http://&lt;host&gt;/&lt;location-tag-alias&gt;/streams/&lt;app-name&gt;/streams/&lt;app-instance&gt;/&lt;stream name&gt;.bootstrap&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流录制文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流记录文件(.stream)是一个XML文档,其中包含的物理位置。服务器创建流记录文件时传入流与实时事件相关联。服务器创建的文件的名称在以下位置进行编码&lt;/p&gt;

&lt;p&gt;applications/appname/events/appinstancename/eventname/MTg1ODAyNigwNg=.stream&lt;/p&gt;

&lt;p&gt;.stream文件格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;stream xmlns=&amp;quot;http://www.adobe.com/liveevent/1.0&amp;quot;&amp;gt;
    &amp;lt;type&amp;gt;
        f4f
    &amp;lt;/type&amp;gt;
    &amp;lt;name&amp;gt;
        livestream
    &amp;lt;/name&amp;gt;
    &amp;lt;path&amp;gt;
        C:\Program Files\Adobe\Adobe Media Server 5\applications\myapp\streams\_definst_\livestream
    &amp;lt;/path&amp;gt;
&amp;lt;/stream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;.f4m manifest文件实例&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;十五、Offline packaging&lt;/h5&gt;

&lt;h5&gt;十六、流媒体问题的一些解决办法&lt;/h5&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/01/getting_started_streaming_media</link>
                <guid>http://alonepig.github.io/fms/2014/07/01/getting_started_streaming_media</guid>
                <pubDate>2014-07-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Learning AMS</title>
                <description>&lt;h3&gt;Adobe Media Server开发笔记&lt;/h3&gt;

&lt;p&gt;一、[adobemediaserver&lt;em&gt;5.0.3&lt;/em&gt;install 总结]&lt;/p&gt;

&lt;p&gt;二、[dev_guide使用手册：开始使用流媒体]&lt;/p&gt;

&lt;p&gt;三、[dev_guide使用手册：内容保护]&lt;/p&gt;

&lt;p&gt;四、[dev_guide使用手册：开始开发应用]&lt;/p&gt;

&lt;p&gt;五、[dev_guide使用手册：开发流媒体应用]&lt;/p&gt;

&lt;p&gt;六、&lt;a href=&quot;http://alonepig.tk/fms/2014/07/07/working-with-live-video/&quot;&gt;dev_guide使用手册：使用实时流&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;七、[dev_guide使用手册：构建点对点的网络应用]&lt;/p&gt;

&lt;p&gt;八、[dev_guide使用手册：开发社交应用]&lt;/p&gt;

&lt;p&gt;九、[dev_guide使用手册：应用安全]&lt;/p&gt;

&lt;p&gt;十、[dev_guide使用手册：开发插件]&lt;/p&gt;

&lt;p&gt;十一、[客户端和服务器端通讯的方法]&lt;/p&gt;

&lt;p&gt;十二、[administrationapi介绍]&lt;/p&gt;

&lt;p&gt;十三、&lt;a href=&quot;&quot;&gt;ams&lt;em&gt;config&lt;/em&gt;admin 手册&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;十四、Server-Side ActionScript语言参考 &lt;/p&gt;

&lt;p&gt;十五、H264编码的使用&lt;/p&gt;

&lt;p&gt;十六、(优化参数(画质、延迟、带宽等))[]&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/06/24/learning-ams</link>
                <guid>http://alonepig.github.io/fms/2014/06/24/learning-ams</guid>
                <pubDate>2014-06-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>adobemediaserver_5.0.3_install 总结</title>
                <description>&lt;h3&gt;一、安装服务&lt;/h3&gt;

&lt;h6&gt;准备安装Adobe媒体服务器&lt;/h6&gt;

&lt;p&gt;1、部署情况：可以部署到单一的电脑上，也可以是复杂的集群边缘服务器。&lt;/p&gt;

&lt;p&gt;2、选择是否安装Apache Http服务，默认是安装的。&lt;/p&gt;

&lt;p&gt;3、安装之前确认序列号。&lt;/p&gt;

&lt;h6&gt;准备升级Adobe媒体服务器&lt;/h6&gt;

&lt;p&gt;1、备份数据&lt;/p&gt;

&lt;p&gt;复制下面的文件夹：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;applications/
conf/
licenses/
modules/
webroot/
Apache2.2/conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、卸载原来的AMS&lt;/p&gt;

&lt;p&gt;3、安装新的AMS&lt;/p&gt;

&lt;h3&gt;二、验证安装&lt;/h3&gt;

&lt;p&gt;http://localhost 进入测试页面&lt;/p&gt;

&lt;p&gt;http://localhost/ams_adminConsole.htm  管理后台&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/06/24/adobemediaserver_503_install-</link>
                <guid>http://alonepig.github.io/fms/2014/06/24/adobemediaserver_503_install-</guid>
                <pubDate>2014-06-24T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
