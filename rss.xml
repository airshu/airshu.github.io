<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>alonepig's blog</title>
        <description>alonepig's blog - lsj</description>
        <link>http://alonepig.github.io</link>
        <link>http://alonepig.github.io</link>
        <lastBuildDate>2014-10-21T17:59:35+08:00</lastBuildDate>
        <pubDate>2014-10-21T17:59:35+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>android fragment学习笔记</title>
                <description>&lt;p&gt;&lt;strong&gt;1、什么是Fragment？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;就像它的字面意思，Fragment表示不同的碎片。主要的作用是在不同尺寸的屏幕中使用，不需要不停的切换activity。Fragments必须绑定到宿主Activities中，不能独立于Activities运行。Fragment能自定义布局视图，有自己的生命周期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、不同SDK版本中如何使用Fragment？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Honeycomb和以后的版本中实现了该API，主要用到的类有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;android.app.Fragment      
android.app.Fragmentmanager      
android.app.FragmentTransaction
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果使用较早的版本则需要添加兼容库，主要用到的类有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;android.support.v4.app.FragmentActivity
android.support.v4.app.Fragment
android.support.v4.app.FragmentManager
android.support.v4.app.FragmentTransaction
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、Fragment的生命周期&lt;/strong&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;td&gt;Activity 状态&lt;/td&gt;
&lt;td&gt;Fragment 回调&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;
onAttach()    当fragment关联到activity时调用&lt;br/&gt;
    ↓&lt;br/&gt;
onCreate()&lt;br/&gt;
    ↓&lt;br/&gt;
onCreateView()    创建视图的时候调用，这个方法重写时一定要super&lt;br/&gt;
    ↓&lt;br/&gt;
onActivityCreated()    当activity的onCreate方法调用时调用&lt;br/&gt;
    ↓&lt;br/&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Started&lt;/td&gt;
&lt;td&gt;
onStart()&lt;br/&gt;
    ↓
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resumed&lt;/td&gt;
&lt;td&gt;
onResume()&lt;br/&gt;
    ↓
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
Paused
&lt;/td&gt;
&lt;td&gt;
onPause()&lt;br/&gt;
    ↓
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Stopped&lt;/td&gt;
&lt;td&gt;
onStop()&lt;br/&gt;
    ↓
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Destroyed&lt;/td&gt;
&lt;td&gt;
onDestroyView()    当层级视图被移除时调用&lt;br/&gt;
    ↓&lt;br/&gt;
onDestroy()&lt;br/&gt;
    ↓&lt;br/&gt;
onDetach()    当fragment与activity断开连接时调用
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;4、创建Fragment&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class MyFragment extends Fragment {

    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
    //R.layout.my_fragment 对应为Fragment的布局文件
        View view = inflater.inflate(R.layout.my_fragment, null);
        return view;
    }

    ....
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5、初始化Fragment&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有两种方式：在布局文件中直接初始化Fragment，或者代码进行初始化。&lt;/p&gt;

&lt;p&gt;布局文件添加Fragment的方法，使用&lt;fragment&gt;标签，android:name属性的值为Fragment的权限定名&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
     android:orientation=&amp;quot;horizontal&amp;quot;
     android:layout_width=&amp;quot;match_parent&amp;quot;
     android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;
     &amp;lt;fragment android:name=&amp;quot;com.example.news.ArticleListFragment&amp;quot;    
          android:id=&amp;quot;@+id/list&amp;quot;
          android:layout_weight=&amp;quot;1&amp;quot;
          android:layout_width=&amp;quot;0dp&amp;quot;
          android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt;
     &amp;lt;fragment android:name=&amp;quot;com.example.news.ArticleReaderFragment&amp;quot;
          android:id=&amp;quot;@+id/viewer&amp;quot;
          android:layout_weight=&amp;quot;2&amp;quot;
          android:layout_width=&amp;quot;0dp&amp;quot;
          android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中初始化：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;FragmentManager fragmentManager = getFragmentManager();//获取FragmentManager
// Or: FragmentManager fragmentManager = getSupportFragmentManager()
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();//获取FragmentTransaction
ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);//添加到容器中
fragmentTransaction.commit();//提交事务
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6、Fragment的操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;add      添加一个fragment到activity。Fragment生命周期中的onAttach-onResume都会被调用一次。
remove      移除一个fragment。onPause-onDetach都会被调用一次。
replace     会使得原来的Fragment被销毁。
hide      隐藏UI，生命周期方法不会被执行，仅仅使View被隐藏。
show      显示前面隐藏的UI
detach     使fragment和UI分开，销毁层次视图但保留fragment实例。onPause-onDestroyView都会被调用。
attach      恢复前面detach的。onCreateView-onResume都会被调用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的地方是：上面这些方法只能用在动态的Fragment中。在不同Fragment来回切换时，每次都会调用onCreateView方法，这里就可以做优化，不需要每次都重新构建布局视图。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、管理Fragment回退栈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将Fragment添加到回退栈中，用户点击回退按钮会响应。只需要在提交事务之前调用addToBackStack方法即可将其添加到回退栈。如果在替换或移除时调用addBackStack方法，系统则只会调用onPause、onStop、onDestroyView，而不会调用onDestroy、onDetach方法。如果用户向前导航，系统就会调用onCreateView、onActivityCreated、onStart、onResume来回到原来的Fragment视图。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、与Activity通讯&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Fragment可以访问Activity实例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;View listView = getActivity().findViewById(R.id.list);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Activity中也可以访问具体某个Fragment：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;getFragmentManager().findFragmentById(R.id.example_fragment);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以创建事件回调方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public static class FragmentA extends ListFragment {
    ...
    // 宿主Activity必须实现这个接口
    public interface OnArticleSelectedListener {
        public void onArticleSelected(Uri articleUri);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (OnArticleSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString() + &amp;quot; must implement OnArticleSelectedListener&amp;quot;);
        }
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        // Append the clicked item&amp;#39;s row ID with the content provider Uri
        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);
        // Send the event and Uri to the host activity
        mListener.onArticleSelected(noteUri);
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;9、Fragment中使用上下文菜单和Menu菜单&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class MyActivity extends Activity {
    // ...
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
       getMenuInflater().inflate(R.menu.activity_options, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.menu_activity_info:
           // Handle activity menu item
           return true;
        default:
           // Handle fragment menu items
           return super.onOptionsItemSelected(item);
       }
    }
    // ...
}



public class MyFragment extends Fragment {
    // ...
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
       setHasOptionsMenu( true);
    }

    @Override
    public void onCreateOptionsMenu( Menu menu, MenuInflater inflater) {
       inflater.inflate(R.menu. myfragment_options, menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.menu_first_info:
           // Handle fragment menu item
           return true;
        default:
           // Not one of ours. Perform default menu processing
           return super.onOptionsItemSelected(item);
       }
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Menu菜单：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public static class ContextMenuFragment extends Fragment {

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        View root = inflater.inflate(R.layout. fragment_context_menu , container, false );
        registerForContextMenu(root.findViewById(R.id. long_press));
        return root;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        menu.add(Menu. NONE, R.id.a_item, Menu.NONE, &amp;quot;Menu A&amp;quot;);
        menu.add(Menu. NONE, R.id.b_item, Menu.NONE, &amp;quot;Menu B&amp;quot;);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.a_item:
                Toast. makeText(getActivity(), &amp;quot;Item 1a was chosen&amp;quot;, Toast.LENGTH_SHORT ).show();
                return true;
            case R.id.b_item:
                Toast. makeText(getActivity(), &amp;quot;Item 1b was chosen&amp;quot;, Toast.LENGTH_SHORT ).show();
                return true;
        }
        return super.onContextItemSelected(item);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>http://alonepig.github.io/android/2014/10/21/android-fragment</link>
                <guid>http://alonepig.github.io/android/2014/10/21/android-fragment</guid>
                <pubDate>2014-10-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ActionScript和JavaScript之间的通讯</title>
                <description>&lt;p&gt;ActionScript和JavaScript间的通讯主要是对ExternalInterface的使用，在这个类中有两个关键的函数：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;addCallback&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将 ActionScript 方法注册为可从容器调用。成功调用 addCallBack() 后，容器中的 JavaScript 或 ActiveX 代码可以调用在 Flash Player 中注册的函数。 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;call&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;调用由 Flash Player 容器公开的函数，不传递参数或传递多个参数。如果该函数不可用，调用将返回 null；否则，它返回由该函数提供的值。不允许在 Opera 或 Netscape 浏览器中使用递归；在这些浏览器上，递归调用将生成 null 响应。（Internet Explorer 和 Firefox 浏览器上支持递归。）。如果该容器是 HTML 页，则此方法在 script 元素中调用 JavaScript 函数。如果该容器是某个其它 ActiveX 容器，此方法将使用指定的名称调度 FlashCall ActiveX 事件，并且该容器将处理该事件。如果该容器承载 Netscape 插件，您可以写入对新 NPRuntime 接口的自定义支持或嵌入 HTML 控件以及在 HTML 控件内嵌入 Flash Player。如果嵌入 HTML 控件，则可以通过本机容器应用程序的 JavaScript 接口与 Flash Player 进行通信。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考例子&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.external.ExternalInterface;
    import flash.text.TextField;
    import flash.utils.Timer;
    import flash.text.TextFieldType;
    import flash.text.TextFieldAutoSize;

    public class ExternalInterfaceExample extends Sprite {
        private var input:TextField;
        private var output:TextField;
        private var sendBtn:Sprite;

        public function ExternalInterfaceExample() {
            input = new TextField();
            input.type = TextFieldType.INPUT;
            input.background = true;
            input.border = true;
            input.width = 350;
            input.height = 18;
            addChild(input);

            sendBtn = new Sprite();
            sendBtn.mouseEnabled = true;
            sendBtn.x = input.width + 10;
            sendBtn.graphics.beginFill(0xCCCCCC);
            sendBtn.graphics.drawRoundRect(0, 0, 80, 18, 10, 10);
            sendBtn.graphics.endFill();
            sendBtn.addEventListener(MouseEvent.CLICK, clickHandler);
            addChild(sendBtn);

            output = new TextField();
            output.y = 25;
            output.width = 450;
            output.height = 325;
            output.multiline = true;
            output.wordWrap = true;
            output.border = true;
            output.text = &amp;quot;Initializing...\n&amp;quot;;
            addChild(output);

            if (ExternalInterface.available) {
                try {
                    output.appendText(&amp;quot;Adding callback...\n&amp;quot;);
                    ExternalInterface.addCallback(&amp;quot;sendToActionScript&amp;quot;, receivedFromJavaScript);
                    if (checkJavaScriptReady()) {
                        output.appendText(&amp;quot;JavaScript is ready.\n&amp;quot;);
                    } else {
                        output.appendText(&amp;quot;JavaScript is not ready, creating timer.\n&amp;quot;);
                        var readyTimer:Timer = new Timer(100, 0);
                        readyTimer.addEventListener(TimerEvent.TIMER, timerHandler);
                        readyTimer.start();
                    }
                } catch (error:SecurityError) {
                    output.appendText(&amp;quot;A SecurityError occurred: &amp;quot; + error.message + &amp;quot;\n&amp;quot;);
                } catch (error:Error) {
                    output.appendText(&amp;quot;An Error occurred: &amp;quot; + error.message + &amp;quot;\n&amp;quot;);
                }
            } else {
                output.appendText(&amp;quot;External interface is not available for this container.&amp;quot;);
            }
        }
        private function receivedFromJavaScript(value:String):void {
            output.appendText(&amp;quot;JavaScript says: &amp;quot; + value + &amp;quot;\n&amp;quot;);
        }
        private function checkJavaScriptReady():Boolean {
            var isReady:Boolean = ExternalInterface.call(&amp;quot;isReady&amp;quot;);
            return isReady;
        }
        private function timerHandler(event:TimerEvent):void {
            output.appendText(&amp;quot;Checking JavaScript status...\n&amp;quot;);
            var isReady:Boolean = checkJavaScriptReady();
            if (isReady) {
                output.appendText(&amp;quot;JavaScript is ready.\n&amp;quot;);
                Timer(event.target).stop();
            }
        }
        private function clickHandler(event:MouseEvent):void {
            if (ExternalInterface.available) {
                ExternalInterface.call(&amp;quot;sendToJavaScript&amp;quot;, input.text);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;html页面&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!-- saved from url=(0014)about:internet --&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt;
&amp;lt;title&amp;gt;ExternalInterfaceExample&amp;lt;/title&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot;&amp;gt;
 var jsReady = false;
 function isReady() {
     return jsReady;
 }
 function pageInit() {
     jsReady = true;
     document.forms[&amp;quot;form1&amp;quot;].output.value += &amp;quot;\n&amp;quot; + &amp;quot;JavaScript is ready.\n&amp;quot;;
 }
 function thisMovie(movieName) {
     if (navigator.appName.indexOf(&amp;quot;Microsoft&amp;quot;) != -1) {
         return window[movieName];
     } else {
         return document[movieName];
     }
 }
 function sendToActionScript(value) {
     thisMovie(&amp;quot;ExternalInterfaceExample&amp;quot;).sendToActionScript(value);
 }
 function sendToJavaScript(value) {
     document.forms[&amp;quot;form1&amp;quot;].output.value += &amp;quot;ActionScript says: &amp;quot; + value + &amp;quot;\n&amp;quot;;
 }
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&amp;quot;pageInit();&amp;quot;&amp;gt;

 &amp;lt;object classid=&amp;quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&amp;quot;
         id=&amp;quot;ExternalInterfaceExample&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;375&amp;quot;
         codebase=&amp;quot;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab&amp;quot;&amp;gt;
     &amp;lt;param name=&amp;quot;movie&amp;quot; value=&amp;quot;ExternalInterfaceExample.swf&amp;quot; /&amp;gt;
     &amp;lt;param name=&amp;quot;quality&amp;quot; value=&amp;quot;high&amp;quot; /&amp;gt;
     &amp;lt;param name=&amp;quot;bgcolor&amp;quot; value=&amp;quot;#869ca7&amp;quot; /&amp;gt;
     &amp;lt;param name=&amp;quot;allowScriptAccess&amp;quot; value=&amp;quot;sameDomain&amp;quot; /&amp;gt;
     &amp;lt;embed src=&amp;quot;ExternalInterfaceExample.swf&amp;quot; quality=&amp;quot;high&amp;quot; bgcolor=&amp;quot;#869ca7&amp;quot;
         width=&amp;quot;500&amp;quot; height=&amp;quot;375&amp;quot; name=&amp;quot;ExternalInterfaceExample&amp;quot; align=&amp;quot;middle&amp;quot;
         play=&amp;quot;true&amp;quot; loop=&amp;quot;false&amp;quot; quality=&amp;quot;high&amp;quot; allowScriptAccess=&amp;quot;sameDomain&amp;quot;
         type=&amp;quot;application/x-shockwave-flash&amp;quot;
         pluginspage=&amp;quot;http://www.macromedia.com/go/getflashplayer&amp;quot;&amp;gt;
     &amp;lt;/embed&amp;gt;
 &amp;lt;/object&amp;gt;

 &amp;lt;form name=&amp;quot;form1&amp;quot; onsubmit=&amp;quot;return false;&amp;quot;&amp;gt;
     &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;input&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
     &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Send&amp;quot; onclick=&amp;quot;sendToActionScript(this.form.input.value);&amp;quot; /&amp;gt;&amp;lt;br /&amp;gt;
     &amp;lt;textarea cols=&amp;quot;60&amp;quot; rows=&amp;quot;20&amp;quot; name=&amp;quot;output&amp;quot; readonly=&amp;quot;true&amp;quot;&amp;gt;Initializing...&amp;lt;/textarea&amp;gt;
 &amp;lt;/form&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的地方：如果是本地测试，需要注意沙箱问题。应该将swf所在文件夹添加到可信任域中。然后在html页中，设置以下标签：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;param name=&amp;quot;allowScriptAccess&amp;quot; value=&amp;quot;always&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在swf文件中，添加以下代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;flash.system.Security.allowDomain(sourceDomain)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>http://alonepig.github.io/actionscript/2014/10/16/communication-between-as-and-js</link>
                <guid>http://alonepig.github.io/actionscript/2014/10/16/communication-between-as-and-js</guid>
                <pubDate>2014-10-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>java 类型转换</title>
                <description>&lt;p&gt;最近在做Android方面的东西，进行的过程中，发现许多地方都不记得了。唉！Number类型是个神马都没印象了。还是再翻一翻《think in java》，总结一下吧！&lt;/p&gt;

&lt;p&gt;简单数据类型之间的转换，由低到高：
(byte,short,char)--&amp;gt;int--&amp;gt;long--&amp;gt;float--&amp;gt;double&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;低级到高级自动转换&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;byte b;
int i = b;
long l = b;
float f = b;
double d = b;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果低级类型为char型，向高级类型(整型)转换时，会转换为对应的ASCII码值，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;char c = &amp;#39;c&amp;#39;;
int i = c;
System.out.println(i);//99
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于byte、short、char三种类型，它们是平级的，不能相互转换，可以使用下面的方法强制转换。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;short i = 99;
char c = (char)i;
System.out.print(c);//&amp;#39;c&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;高级到低级强制类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;int i=99;
byte b=(byte)i;
char c=(char)i;
float f=(float)i;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;包装类过度类型能够转换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;共有6个包装类：Boolean、Character、Integer、Long、Float、Double。它们都基础自Number类型。Number包含了各种数据转换的方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public abstract int intValue();

public abstract long longValue();

public abstract float floatValue();

public abstract double doubleValue();

public byte byteValue()

public short shortValue()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>http://alonepig.github.io/java/2014/09/23/java-type-conversion</link>
                <guid>http://alonepig.github.io/java/2014/09/23/java-type-conversion</guid>
                <pubDate>2014-09-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>关于新股申购</title>
                <description>&lt;p&gt;从朋友口中得知，如果能够申购到新股，就一定能赚钱。这对于我这种刚入市的菜鸟股民来说无疑很有吸引力。于是，在网络上查询了新股申购的流程。大致有以下条件：&lt;/p&gt;

&lt;p&gt;根据投资者持有的市值确定其网上可申购额度，持有市值1万元以上（含1万元）的投资者才能参与新股申购，沪市每1万元市值可申购一个申购单位，不足1万元的部分不计入申购额度。深市每5000元市值可申购一个申购单位，不足5000元的部分不计入申购额度。&lt;/p&gt;

&lt;p&gt;然后来到了9.18号，根据一些所谓的提高中签技巧的文章，十点后进入客户端，选择新股申购，填入对应号码，可始终提示信息码不存在。百思不得其解，自己明明已经按照要求来操作了啊！于是，搜索原因，终于在某个股吧中找到：人家说账号必须要在最近20个交易日持有市值的1W以上的股票才行。唉，我还不满足条件啊！！！&lt;/p&gt;

&lt;p&gt;总结，以后在做某件事情之前一定要做好的充分的准备工作。顺便记录一下申购流程：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;申购流程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;T日，准备好足额资金，通过证券账户进行新股申购，买入委托（和买股票的菜单一样），数量沪市股票需要是1000股的整数倍，深市股票需要是500股的整数倍，超过可申购额度都是废单。如果多次委托仅第一笔委托是有效的。沪市申购时间为T日9:30-11：30；13：00-15：00；深市申购时间为T日9:15-11：30；13：00-15：00。&lt;/p&gt;

&lt;p&gt;T+1日：资金冻结、验资及配号。中国结算公司将申购资金冻结。交易所将根据最终的有效申购总量，按每1000（深圳500股）股配一个号的规则，由交易主机自动对有效申购进行统一连续配号。&lt;/p&gt;

&lt;p&gt;T+2日：摇号抽签。公布中签率，并根据总配号量和中签率组织摇号抽签，于次日公布中签结果。&lt;/p&gt;

&lt;p&gt;T+3日（一般T+2日清算后就可以）可查询到是否中签，如未中签会返款到账户。中签客户在新股上市日可以将中签股票进行交易。&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/stock/2014/09/19/subscribe-new-stock</link>
                <guid>http://alonepig.github.io/stock/2014/09/19/subscribe-new-stock</guid>
                <pubDate>2014-09-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>andengine for android game development读书笔记(一)</title>
                <description>&lt;h4&gt;第一章、AndEngine 游戏引擎架构&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AndEngine引擎最大的特点是其非常容易构建一个游戏。可能在几个星期内就能完成一款游戏从头到尾的设计和编码，但不代表它会是一款完美的游戏。在使用该引擎前最好先理解该引擎，才能创建出好的已扩展的游戏。&lt;/p&gt;

&lt;p&gt;这一章中，我们会先大致了解一下引擎中非常常用的组件。它们是构建游戏的基础。此外，我们将讨论资源和对象类型的不同点，它们在塑造游戏的外观和整体风格中扮演了重要的角色。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;理解游戏初始化的顺序很重要。基本包括创建引擎、装载游戏资源、设置初始化屏幕和设置。这些都是创建一个AndEngine游戏的基础。但为了让你的游戏更加多样性，你需要明白其生命周期。&lt;/p&gt;

&lt;p&gt;参考PacktRecipesActivity&lt;/p&gt;

&lt;p&gt;AndEngine生命周期有几个方法直接负责定义。这些方法包括创建引擎属性(EngineOptions)对象，创建场景(Scene)对象，将子实体填充到场景中。这些方法按照下面的顺序调用：&lt;/p&gt;

&lt;p&gt;1、定义onCreateEngineOptions()方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
public EngineOptions onCreateEngineOptions() {
    // Define our mCamera object
    mCamera = new Camera(0, 0, WIDTH, HEIGHT);
    // Declare &amp;amp; Define our engine options to be applied to our Engine object
    EngineOptions engineOptions = new EngineOptions(true,
    ScreenOrientation.LANDSCAPE_FIXED, new FillResolutionPolicy(), mCamera);
    // It is necessary in a lot of applications to define the following
    // wake lock options in order to disable the device&amp;#39;s display
    // from turning off during gameplay due to inactivity
    engineOptions.setWakeLockOptions(WakeLockOptions.SCREEN_ON);
    // Return the engineOptions object, passing it to the engine
    return engineOptions;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、定义哦那CreateResources()方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@override
public void onCreateResource(OnCreateResourcesCallback pOnCreateResourcesCallback){
//装载好所有资源后调用该方法
    pOnCreateResourcesCallback.onCreateResourcesFinished();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、定义onCreateScene()方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@override 
public void onCreateScene(OnCreateSceneCallback pOnCreateSceneCallback){
    mScene = new Scene();
    // 通知回调已经完成创建场景
    pOnCreateSceneCallback.onCreateSceneFinished(mScene);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、定义onPopulateScene()方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@override 
public void onPopulateScene(Scene pScene, OnPopulateSceneCallback pOnPopulateSceneCallback){
// 完成之后回调此方法
    pOnPopulateSceneCallback.onPopulateSceneFinished();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码是AndEngine游戏的基础。我们建立一个主activity作为我们应用的入口。这个activity包括四个主要的方法，作用分别表示创建EngineOptions属性，创建资源、创建场景和填充场景。&lt;/p&gt;

&lt;p&gt;第一步，我们重写了onCreateEngineOptions()方法。在方法里面，初始化了摄像机对象和引擎属性对象。两个对象的构造函数可以传递我们应用的属性。此外，engineOptions.setWakeLockOptions(WakeLockOptions.SCREEN_ON)表示屏幕常亮。&lt;/p&gt;

&lt;p&gt;第二步，定义了onCreateResources()方法，它用来创建游戏需要的资源。这些资源包括纹理、声音、音乐和字体。在这一步和接下来的两步，我们需要调用相应的方法以进行回调。对于onCreateResources()，我们必须调用pOnCreateResourcesCallback.onCreateResourcesFinished(),放在方法的最后面。&lt;/p&gt;

&lt;p&gt;下面的列表中，我们将生命周期的方法按顺序排列：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;onCreate：这个方法是Android SDK应用入口。在AndEngine开发中，这个方法只是在BaseGameActivity类中简单的调用onCreateEngineOptions()方法。

onResume：另外一个Android方法。在这里，我们从EngineOptions对象获取锁屏属性，然后调用RenderSurfaceView的onResume()方法。

onSurfaceCreated：可能会调用onCreateGame()

onReloadResources：装载资源

onCreateGame：按顺序执行三个回调。

onCreateResources：允许我们声明和定义应用的初始化资源

onPopulateScene：完成设置场景

onGameCreated：表示onCreateGame()队列完成。如有必要重新装载资源，否则什么都不做。

onSurfaceChanged：应用方向发生变化时调用

onResumeGame：启动生命周期最后一个调用的方法。如果启动过程中没有问题，则引擎的start()方法会被调用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生命周期在最小化和终止时：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;onPause：最小化或终止时第一个被调用的方法。

onPauseGame：然后，AndEngine实现的onPause()灰调用引擎的stop()方法。

onDestroy：清除所有资源

onDestroyResources；这个方法会在onDestroy中被调用。清除音乐和声音。

onGameDestroyed：最后调用，将mGameCreated设置为false。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面我们介绍了BaseGameActivity类，下面使用其他可以替代它的类，不同的类有稍许不同。&lt;/p&gt;

&lt;p&gt;LayoutGameActivity类&lt;/p&gt;

&lt;p&gt;这个类可以时原始的Android View添加到游戏中。它的做法就是调用setContentView(layoutID)方法。使用这个类，可以轻松的在游戏中添加广告。&lt;/p&gt;

&lt;p&gt;使用LayoutGameActivity类的步骤如下：&lt;/p&gt;

&lt;p&gt;1、布局文件中添加以下代码：这个View会显示到游戏当中。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;org.andengine.opengl.view.RenderSurfaceView
android:id=&amp;quot;@+id/gameSurfaceView&amp;quot;
android:layout_width=&amp;quot;fill_parent&amp;quot;
android:layout_height=&amp;quot;fill_parent&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、关联到布局文件，假设步骤1中的布局文件名字是main，重写LayoutGameActivity的方法,这样在onSetContentView中就会找到对应的布局文件了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
protected int getLayoutID() {
    return R.layout.main;
}
@Override
protected int getRenderSurfaceViewID() {
    return R.id.gameSurfaceView;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SimpleBaseGameActivity和SimpleLayoutGameActivity类&lt;/p&gt;

&lt;p&gt;重写了一些生命周期中的方法使其更加容易使用。它们不需要我们重写onPopulateScene()方法，我们也不用回调那些方法了。&lt;/p&gt;

&lt;p&gt;SimpleAsyncGameActivity类&lt;/p&gt;

&lt;p&gt;这个类包含了三个方法onCreateResourcesAsync()、onCreateSceneAsync()、onPopulateSceneAsync()。主要作用是在加载各种资源时提供一个进度数据。比如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
public void onCreateResourcesAsync(IProgressListener pProgressListener) throws Exception {
    // Load texture number one
    pProgressListener.onProgressChanged(10);
    // Load texture number two
    pProgressListener.onProgressChanged(20);
    // Load texture number three
    pProgressListener.onProgressChanged(30);
    // We can continue to set progress to whichever value we&amp;#39;d like
    // for each additional step through onCreateResourcesAsync...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;选择引擎类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在开始编码之前，先根据游戏所需的性能选择不同的引擎类型。&lt;/p&gt;

&lt;p&gt;为了指定合适的Engine对象，我们必须重写onCreateEngine()方法，来设置不同类型的Engine。默认情况如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@override 
public Engine onCreateEngine(EngineOptions pEngineOptions){
    return new Engine(pEngineOptions);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是不同Engine类型的介绍：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Engine&lt;/em&gt;：对于大部分游戏来说不实用，因为它没有限制每秒的帧率。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;FixedStepEngine&lt;/em&gt;：会以一个固定速度循环刷新游戏，不需要考虑不同设备。如new FixedStepEngine(pEngineOptions, 60)则每秒刷新60次。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;LimitedFPSEngine&lt;/em&gt;：限制最大帧率。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;SingleSceneSplitScreenEngine和DoubleSceneSplitScreenEngine&lt;/em&gt;：允许创建两个分开的摄像机，这样就可以在一个设备中供两个人一起玩游戏。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择解决策略&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在onCreateEngineOptions方法中：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;EngineOptions engineOptions = new EngineOptions(true, ScreenOrientation.LANDSCAPE_FIXED, new FillResolutionPolicy(), mCamera);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;FillResolutionPolicy&lt;/em&gt; ：全屏使用&lt;/p&gt;

&lt;p&gt;&lt;em&gt;FixedResolutionPolicy&lt;/em&gt; ：允许固定应用尺寸。如new FixedResourcePolicy(800， 480)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;RatioResolutionPolicy&lt;/em&gt; ：按比例显示。raito等于高宽比。new RaitoResourcePolicy(1.6f)或new RaitoResourcePolicy(800, 600)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;RelativeResolutionPolicy&lt;/em&gt; ：提供缩放。可以缩放高宽new RelativeResolutionPolicy(1.5f， 0.5f)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建对象工厂&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建游戏管理器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;介绍声音和音乐&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用不同的纹理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设置纹理属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用AndEngine字体资源&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建资源管理器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;保存和装载游戏数据&lt;/strong&gt;&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/android/2014/09/16/andengine-for-android-game-development1</link>
                <guid>http://alonepig.github.io/android/2014/09/16/andengine-for-android-game-development1</guid>
                <pubDate>2014-09-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>股票入门之术语学习</title>
                <description>&lt;p&gt;今天学习一下市盈率、市净率&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;市盈率(PE)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指在一个考察期(通常为12个月的时间内)，股票的价格和每股收益的比率。即股票的价格与该股上一年度每股税后利润之比。&lt;/p&gt;

&lt;p&gt;如果一家公司股票的市盈率过高，那么该股票的价格具有泡沫，价值被高估。当一家公司增长迅速以及未来的业绩增长非常看好时，利用市盈率比较不同股票的投资价值时，这些股票必须属于同一行业，因为此时公司的每股收益比较接近，相互比较才有效。&lt;/p&gt;

&lt;p&gt;市盈率也分为静态市盈率和动态市盈率，静态市盈率表示过去的的数据，动态市盈率的计算公式是以静态市盈率为基数，乘以动态系数。表达式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;           n 
1 ÷ (1 + i) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;高市盈率通常意味着高风险，高风险意味着可能会有高回报。&lt;/p&gt;

&lt;p&gt;由于不同行业处于不同的生命周期，市场对不同行业的发展前景有较大的差异，对于新兴产业（快速成长期）的预期一般较好，市盈率一般较高；而对部分传统行业（成熟稳定期）的预期一般较稳定，市盈率会维持相对较低的水平，波动幅度也不会很大，对一些夕阳产业（衰落期）的预期一般较差，市盈率会维持在更低的水平。&lt;/p&gt;

&lt;p&gt;如果该股在历史上就享受了较高的市盈率，往往这类公司是更受市场看好的公司。反之如果某公司一直处于低市盈率状态，就可能意味着市场对该公司持续成长性并不看好。&lt;/p&gt;

&lt;p&gt;感觉根据这个指标看不出什么门道，不同行业差别大，高低不能代表好坏，目前暂时了解了解吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;市净率(P/BV)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;市净率指的是每股股价与每股净资产的比率。一般来说市净率较低的股票，投资价值较高，相反，则投资价值较低；在判断投资价值时还要考虑当时的市场环境以及公司经营情况、盈利能力等因素。市净率不适用于短线炒作，提高获利能力。 &lt;/p&gt;

&lt;p&gt;市净率可用于投资分析。每股净资产是股票的账面价值，它是用成本计量的，而每股市价是这些资产的现在价值，它是证券市场上交易的结果。市价高于账面价值时企业资产的质量较好，有发展潜力，反之则资产质量差，没有发展前景。优质股票的市价都超出每股净资产许多，一般说来市净率达到3可以树立较好的公司形象。市价低于每股净资产的股票，就象售价低于成本的商品一样，属于&amp;quot;处理品&amp;quot;。当然，&amp;quot;处理品&amp;quot;也不是没有购买价值，问题在于该公司今后是否有转机，或者购入后经过资产重组能否提高获利能力，是市价与每股净资产之间的比值，比值越低意味着风险越低。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;净资产收益率&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;净资产收益率=税后利润/所有者权益
假定某公司年度税后利润为2亿元，年度平均净资产为15亿元，则其本年度之净资产收益率就是13．33%（即(2亿元/15亿元)*100%）。&lt;/p&gt;

&lt;p&gt;公式非常的简单，几乎一下子就可以完全理解，但是怎么简单明确的认识到这个指标的涵义和价值腻？我们都知道所有者权益，也就是净资产相当于这家公司的全部 现值。净利润是一家公司的盈利能力的体现。他们两之商，净资产收益率其实是一种反应公司盈利速度的指标。你比如说一家公司净资产100亿，净利润是10个 亿。另一家公司净资产10个亿，盈利4个亿。单看盈利的话好像第一家公司很厉害，但是考虑到公司总体量的话，用100一个亿挣10个亿就没有用10个亿挣 4个亿效率高了。差多少腻？就可以用到这个指标了，公司一的净资产收益率是10%，公司二是40%。相差30%，这样一对比盈利效率就清晰了。&lt;/p&gt;

&lt;p&gt;还 有一种更简单的理解方式，用1除以净资产收益率，得到一个新的值。公司一，是10，公司二，是2.5。这里的1代表公司总体量，那么换句话说就是，假如公 司的盈利能力保持不变的情况下，公司一10年能复制一个自己，资产总量翻一倍。公司二两年半能复制一个自己，资
产总量翻一倍。挣钱效率的快慢就一目了然 了。 &lt;/p&gt;

&lt;p&gt;净资产收益率越高，效益越好！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;换手率&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;越高说明关注度越高，但风险也越大。越低表示主要持有者稳定。短线还是要稍微高点，找活跃点的波动才会比较大。&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/stock/2014/09/09/stock2</link>
                <guid>http://alonepig.github.io/stock/2014/09/09/stock2</guid>
                <pubDate>2014-09-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>XML and E4X</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/xml-and-e4x</link>
                <guid>http://alonepig.github.io/2014/09/04/xml-and-e4x</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Essential Actionscript3.0 读书笔记(三、静态变量和静态方法)</title>
                <description>&lt;h4&gt;第三章：静态变量和静态方法&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;静态变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用static关键字修饰的实例变量就是静态变量：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class SomeClass {
    static var identifier = value;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态变量跟实例变量有什么区别呢？首先，实例变量是对具体实例而言的，静态变量是对类而言的。实例变量只能通过具体的实例来访问，静态变量的访问方法是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SomeClass.indentifier
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义的时候，静态变量和实例变量的名字可以相同，在类的内部的实例方法中，会优先访问实例变量。实例方法可以访问静态变量，但静态方法只能访问静态变量。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package
{
    public class Foo
    {
        public function Foo()
        {
            trace(aa);
        }

        public function init():void
        {
            trace(bb);
            trace(cc);
        }

        static public function init2():void
        {
            trace(cc);
        }

        static var cc:int = 40;


        static var aa:int = 20;

        var aa:int = 10;

        var bb:int = 30;
    }
}


var foo:Foo = new Foo();
foo.init();
Foo.aa;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子中，init2静态方法不能访问实例变量。构造函数中输出的结果是10。init方法中能访问实例变量和静态变量。通过测试就能理解两者不同点，书上讲的有点啰嗦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;变量分为静态变量、实例变量和布局变量，那常量也就有静态常量、实例常量和布局常量了。什么叫常量呢，就是不能修改的变量。用const修饰。常量一般用大写英文字母表示。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;static const IDENTIFIER = value

const IDENTIFIER = value
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如表示某个建筑的高度、表示某个时间点，这些都该用常量表示，因为它们是不变的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;静态方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;静态方法跟静态变量的道理类似，用static修饰，只能通过SomeClass.functionName的方式来访问。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class SomeClass {
    static function methodName (identifier1 = value1,
            identifier2 = value2,
            ...
            identifiern = valuen) {
    }
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>http://alonepig.github.io/actionscript/2014/09/04/static-variables-and-static-methods</link>
                <guid>http://alonepig.github.io/actionscript/2014/09/04/static-variables-and-static-methods</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Statements and Operators</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/statements-and-operators</link>
                <guid>http://alonepig.github.io/2014/09/04/statements-and-operators</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Scope</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/scope</link>
                <guid>http://alonepig.github.io/2014/09/04/scope</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Namespaces</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/namespaces</link>
                <guid>http://alonepig.github.io/2014/09/04/namespaces</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Interfaces</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/interfaces</link>
                <guid>http://alonepig.github.io/2014/09/04/interfaces</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Essential Actionscript3.0 读书笔记(五、继承)</title>
                <description>&lt;h4&gt;第无章、继承&lt;/h4&gt;

&lt;p&gt;面向对象编程，就像现实生活中的情况一样，狗是动物、猫也是动物，猫和狗都继承了动物的一些特性。在程序的世界里，继承还能使代码得到重用。ActionScript中只能单继承。静态方法和静态变量不能被继承。但可以在子类中直接访问它们。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;继承的基础&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先来看一段代码，有一个类A：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class A {
    public var v = 10;
    public function m ( ) {
        trace(&amp;quot;Method m( ) was called&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后有一个类B继承了A：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class B extends A {
    // No methods or variables defined
    function n(){
    }
}

var bInstance:B = new B( );
bInstance.m(); // Displays: Method m( ) was called
trace(bInstance.v); // Displays: 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实例化B后，调用m()方法，ActionScript会检查B类中是否有这个方法，没有的话，则会从它继承的类里找。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重写实例方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;动物是可以走路的，但有些动物是用两条腿走路，有些用四条腿走路，所以不同的动物走路方式是不一样的，这个时候就需要重新定义走路的方式了。在ActionSctipt中，这个叫做重定义实例方法。请看代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class Animal{
    public function move(){
        trace(&amp;quot;走路啦！&amp;quot;);
    }
}

public funtion Dog extends Animal {
    override public function move(){
        trace(&amp;quot;四条腿走路！&amp;quot;);
    }
}

public funtion Cat extends Animal {
    override public function move(){
        super.move();// 调用父类的方法
        trace(&amp;quot;两条腿走路！&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重写某个方法需要使用override关键字。重新定义某个方法后，父类的方法就不见了，如果需要调用父级的那个方法，则要使用super关键字，参考Cat类中的写法。还要注意这个用的super和构造函数中的super()是不一样的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子类中的构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果子类提供了构造函数，则需要用super关键字调用父级的构造函数，如果没有，则会调用默认的。需要注意的是，子类的构造函数的参数可以与父级不一样，只要super中的参数与父级对应就可以，这与实例函数不同。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class Rectange
{
    protected var w = 0;
    protected var h = 0;

    public function Rectange(width, height)
    {
        setSize(width, height);

    }

    public function setSize (newW, newH) {
        w = newW;
        h = newH;
    }

    public function getArea ( ) {
        return w * h;
    }
}

public class Square extends Rectange
{
    public function Square(side)
    {
        super(side, side);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;防止被继承或重写&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了防止类被继承，类的实例方法被重写，使用final关键字来修饰。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;final public class A {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A类将不能被其他类继承。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class A {
    final public function m ( ) {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;m()函数不能被子类重写。&lt;/p&gt;

&lt;p&gt;使用final关键字有两个好处：&lt;/p&gt;

&lt;p&gt;某些情况下，final关键字修饰的方法要比没有final修饰的方法执行的更快。&lt;/p&gt;

&lt;p&gt;final能隐藏部分实现细节。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;继承的理论知识&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用继承最大的好处的是代码重用。当对父类进行修改时，所有子类都会自动继承它新的特性，减少了代码修改量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多态和动态绑定&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;多态是所有面向对象语言的一个重要特性。每一个类的实例都可以被看成是它自己或其所有父类的一种形态。&lt;/p&gt;

&lt;p&gt;多态典型的例子是画图应用。这个应用定义了Shape类：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class Shape {
    public function draw ( ) {
    // No implementation. In some other languages, draw( ) would be
    // declared with the abstract attribute, which syntactically
    // forces subclasses of Shape to provide an implementation.
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Shape有许多个子类：Circle、Rectangle、Triangle，每一个子类都有自定义的draw()方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class Circle extends Shape {
    override public function draw ( ) {
    // Code to draw a Circle on screen, not shown...
    }
}
public class Rectangle extends Shape {
    override public function draw ( ) {
    // Code to draw a Rectangle on screen, not shown...
    }
}
public class Triangle extends Shape {
    override public function draw ( ) {
    // Code to draw a Triangle on screen, not shown...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了将图形添加到屏幕上，我们传递Circle、Rectangle、Triangle实例给addShape()方法，在主类中添加该方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    public function addShape(newShape){
        newShape.draw();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;addShape()方法调用shape的draw()方法，这是关键点，newShape可能是Circle、Rectangle、Triangle中的任何一种类型。这个过程叫做动态绑定。&lt;/p&gt;

&lt;p&gt;继承关系被叫做Is-A，就好像说狗是动物，猫是动物。而组合被叫做Has-A，表示A中有一个B。&lt;/p&gt;

&lt;p&gt;继承和组合的选择：&lt;/p&gt;

&lt;p&gt;*如果一个类需要使用其他类的服务，则考虑组合。&lt;/p&gt;

&lt;p&gt;*如果类的行为很像已经存在的类，则使用继承。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;抽象不被支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;许多面向对象的设计会使用抽象类。抽象类定义了抽象方法(没有方法体的方法)。所有继承它的类都要实现这些抽象方法。但ActionScript不支持抽象类和抽象方法。变相的处理时，父类的方法体为空。&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/09/04/inheritance</link>
                <guid>http://alonepig.github.io/actionscript/2014/09/04/inheritance</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Garbage Collection</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/garbage-collection</link>
                <guid>http://alonepig.github.io/2014/09/04/garbage-collection</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Essential Actionscript3.0 读书笔记(四、函数)</title>
                <description>&lt;h4&gt;第四章、函数&lt;/h4&gt;

&lt;p&gt;ActionScript3.0种有两类函数：方法和函数闭包。将函数成为方法还是函数闭包取决于函数的上下文。如果在类定义的一部分或将它附加到对象的实例，则称方法。如果以其他方式定义函数(方法内部、包定义内部、包定义外部)，则称函数闭包。函数的定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;function funName(param1, param2,...):void
{
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用关键字function定义，funName为函数的名字，后面接参数，函数可以有返回值，如果没有返回值则使用void。函数的调用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;funName(param1Value, parame2Value, ....);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;包级别函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面的例子定义了一个包级别函数isMac()，编译时会把这个函数单独编译成一个.as文件，名字为isMac.as：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package utilities {
    import flash.system.*;

    internal function isMac ( ) {
        return Capabilities.os == &amp;quot;MacOS&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要全局使用，则用public修饰该函数。&lt;/p&gt;

&lt;p&gt;调用这个函数的时候需要导入该函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package setup {
    // Import isMac( ) so it can be used within this package body
    import utilities.isMac;
        public class Welcome {
        public function Welcome ( ) {
            // Use isMac( )
            if (isMac( )) {
                // Do something Macintosh-specific
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;嵌套函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在函数内部声明的函数叫嵌套函数。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// Define method a( )
    public function a ( ) {
        // Invoke nested function b( )
        b( );
    // Define nested function b( )
    function b ( ) {
        // Function body would be inserted here
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嵌套函数的定义的可以写在函数内部的任意位置，可以在最前面调用该函数，这种方式被称为向前引用。嵌套函数不能使用修饰符。函数的定义有两种方式：函数语句和函数表达式。上面的例子中就是函数表达式，函数语句的写法如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Example
{
    var methodExpression = function() {}
    function methodStatement() {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;源文件级别函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当函数定义在包定义的外部时，被称作源文件级别函数。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package {
    // Ok to use f( ) here
    class A {
    // Ok to use f( ) here
        public function A ( ) {
        // Ok to use f( ) here
        }
    }
}

// Ok to use f( ) here
function f ( ) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数还能作为函数的参数来传递，如setInterval(fun, intervalTime)函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package {
    import flash.utils.setInterval;
    public class Clock {
        public function Clock ( ) {
            // Execute the function literal once per second
            setInterval(function ( ) {
                trace(&amp;quot;Tick!&amp;quot;);
            }, 1000);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package {
    import flash.utils.setInterval;
    public class Clock {
        public function Clock ( ) {
        // Execute tick( ) once per second
            setInterval(tick, 1000);
            function tick ( ):void {
                trace(&amp;quot;Tick!&amp;quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;递归函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;function trouble ( ) {
    trouble( );
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归函数在解决某些问题的时候非常有用，详细的用法请google之。&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/09/04/functions</link>
                <guid>http://alonepig.github.io/actionscript/2014/09/04/functions</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Flash Player Security Restrictions</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/flash-player-security-restrictions</link>
                <guid>http://alonepig.github.io/2014/09/04/flash-player-security-restrictions</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Exceptions and Error Handling</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/exceptions-and-error-handling</link>
                <guid>http://alonepig.github.io/2014/09/04/exceptions-and-error-handling</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Events and Event Handling</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/events-and-event-handling</link>
                <guid>http://alonepig.github.io/2014/09/04/events-and-event-handling</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Dynamic ActionScript</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/dynamic-actionscript</link>
                <guid>http://alonepig.github.io/2014/09/04/dynamic-actionscript</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Datatypes and Type Checking</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/datatypes-and-type-checking</link>
                <guid>http://alonepig.github.io/2014/09/04/datatypes-and-type-checking</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Compliling andRunning a Program</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/compliling-andrunning-a-program</link>
                <guid>http://alonepig.github.io/2014/09/04/compliling-andrunning-a-program</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Arrays</title>
                <description></description>
                <link>http://alonepig.github.io/2014/09/04/arrays</link>
                <guid>http://alonepig.github.io/2014/09/04/arrays</guid>
                <pubDate>2014-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>股票入门之术语学习</title>
                <description>&lt;p&gt;前天，入手600023后，从此算踏上了股市这条路。不过，自己真的什么都不懂。为了督促自己努力学习各种股票知识，并实现&amp;quot;单车变摩托&amp;quot;的美梦，从此后，此博客也将开始记录自己的股海生涯。&lt;/p&gt;

&lt;p&gt;首先，要明白一些基本的术语。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;股票&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;股票是一种有价证券，它由相应股份公司发行，是证明股东所持股份的凭证，它表明股票的持有者对股份公司的部分资本拥有所有权。在股市中，投资者买卖的对象即为代表着不同上市公司的股票，投资者既可以通过业绩优良上市公司的年终分红，获取高于银行利率的回报，也可以通过股票价格在二级市场的涨跌变化获取差价收益。&lt;/p&gt;

&lt;p&gt;上面是书里面的讲法，但我还是有很多地方不明白。比如，如果股票都涨了，那所有的股民不都赚钱了吗？那这些钱从哪里来的呢？好吧，作为初学者，现在暂时不要纠结这些了，以后会慢慢明白的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;股票市场&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简称为股市，股票市场是股票发行和交易的场所，根据市场的功能划分，可分为发行市场和流通市场，其中，发行市场也就是我们所说的一级市场，流通市场则是二级市场。&lt;/p&gt;

&lt;p&gt;股票交易的场所还好理解，就是证券所嘛！不过现在都可以用不同的软件进行交易，也就不用去证券所了。什么叫发行市场什么叫流通市场我也不太关心，见过面就好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A股、B股、H股&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个很好理解，前面的字母代表不同的股票市场。&lt;/p&gt;

&lt;p&gt;A 股是由我国境内的公司发行，供境内机构、组织或个人（不含台、港、澳投资者）以人民币认购和交易的普通股股票，A 股也就是我们国内普通投资者所参与的股票市场，国内的A 股分为上证A股与深证A 股，上证A 股包括全体在上海证券交易所上市的股票，上证A 股所形成的股票市场也常被称为“沪市”，深证A则包括全体在深圳证券交易所上市的股票，深证A 股所形成的股票市场也常被称为“深市”。&lt;/p&gt;

&lt;p&gt;B 股的正式名称为人民币特种股票。它是以人民币标明面值，以外币认购和买卖，在境 内（上海、深圳）证券交易所上市交易的。B 股公司的注册地和上市地都在境内，起初，B 股的投资者仅限于境外或在中国香港、澳门及台湾投资者，如：外国的自然人、法人和其他 组织，香港、澳门、台湾地区的自然人、法人和其他组织等，后来B 股也对国内投资者开 放，现国内投资者只要有美元就可以开户投资。相对来说，B 股并不是面向国内的广大普通 投资者的。&lt;/p&gt;

&lt;p&gt;H 股，即注册地在内地、上市地在香港的外资股，也称国企股。香港的英文是Hong Kong ，取其字首，在香港上市外资股就叫做H 股。&lt;/p&gt;

&lt;p&gt;所以，作为一个刚入股海的菜鸟，目前还是安心炒A股就好了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;投资者&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;投资者是指持有上市公司股票的自然人或机构投资者，机构投资者主要包括券商、基金、 投资公司、保险公司、及金融财团等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IPO&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;initial public offerings：首次公开发行股票的简称，是一家企业通过证券交易所第一次将它的股份向公众出售，IPO过程对应于一级市场，多有券商来承销发行，所谓承销发行是指：企业通过向券商支付一定的酬 劳，由券商代理帮助其实现股票发行，并由大众申购，若大众申购数量不足，则余下的股票 份额由券商买账。&lt;/p&gt;

&lt;p&gt;加入，某个企业的股票卖不出去，那券商会有那么多钱么？是我太单纯了么...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“手”是股票交易时的最小买入单位，既投资者所买的股票数量应是100 的整数倍。我们常说买入10 手股票，即是指买入1000 股。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;quot;T+1&amp;quot;制度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;T 是Trade 的首字母。目前沪市与深市均实行T+1 制度，即：当天买进的股票只能在第 二天卖出，但当天卖出的股票确认成交后所返回的资金则可以当天再次买股，T+1 制度使得 投资者最短的一次买卖操作也要经历两个交易日才能完成，可以在一定程度上起到抑制投机的作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;股票代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每一只股票在股市中都有唯一的代码，将好像你数据库里保存的记录一般都会有一个主键一样，用来起标识作用。国内的A股市场中，沪市的股票代码以&amp;quot;600&amp;quot;或&amp;quot;601&amp;quot;打头，深市则以&amp;quot;000&amp;quot;打头。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;新股上市&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;成功了完成了 IPO 过程的企业会在随后进入股票二级市场进行交易，这就是所说的新 股上市交易，此时，那些在一级市场中成功申购到此股的投资者就可以进行卖出操作，新股 上市首日会在其股票名称前加一个字母“N”，N 为NEW 的简写。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;低吸高抛&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个就是赚钱的门道，在低价位买入，高价位卖出。也叫&amp;quot;做多机制&amp;quot;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;股价&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;股价即是指股票在二级市场中的交易价格，它随着的买方与卖方的持续交易而发生变 化，当买方力量更强时，股价会在买方的推动下而出现上涨，反之，当卖方力量的打压下而 出现下跌，股价的变化直接决定着投资者是亏损还是盈利，因而它也是投资者最为关注的对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多头和空头&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;quot;多&amp;quot;表示上涨，&amp;quot;空&amp;quot;表示下跌。多头是指那些认为股价将要上涨，而积极买入并持股的投资者，空头则是指那些认为股价将 要下跌会卖出股票、或持币观望等待下跌的投资者。多头与空头是股市中的两类投资者，多 头投资者构成了多方阵营，空头则构成了空方阵营，它们对价格的上涨或下跌起着决定作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;涨跌幅限制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;涨跌幅限制是国内股市中的一种交易规则，它限制了股价的当日波动范围，其出现点是 为了防止股价的暴涨暴跌并抑制过度投机现象的发生，上海、深圳两交易所自1996 年12 月26 日起，分别对上市交易的股票（含A、B 股）、基金类证券的交易实行价格涨跌幅限制， 即在一个交易日内，上述证券的交易价格相对上一交易日收市价格的涨跌幅度不得超过10 %，超过涨跌限价的委托为无效委托。不受涨跌幅限制的股票主要包括以下几中：一是，新 股上市首日；二是，增发股票上市当天；三是，某些重大资产重组股票比如合并之类的复牌当天。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;涨停板和跌停板&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;涨停板与跌停板是涨跌幅限制制度下的股价的一种特殊走势，当买盘过于强劲促使股价当日达到涨幅限制时，若买盘力量没有减弱，则交易就会在这一涨幅上限处进行交易，由此 形成涨停板；当卖盘过于强劲促使股价当日达到跌幅限制时，若卖盘力量没有减弱，则交易 就会在这一跌幅下限处进行交易，由此形成跌停板；它们是股价的极端走势，往往蕴含着机 会或风险，是投资者应关注的对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;大盘指数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指数是依据一定的计算方法经过编制并用以反映相应股票市场整体走势情况的指标，不 同的股票市场都有反映其运行情况的相应指数，如：对于国内的上证A 股与深证A 股，分 别有上证指数与深圳成分指数，平常我们所说的大盘指数是一个俗语，它是指上证综合指数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;仓位、空仓、满仓&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;仓位指出了投资者股票账户中的现金数量与股票市值的关系，当全部的现金都买入股票 后，则为全仓，反之，若账户中没有股票、只有现金，则为空仓；在股票交易中，仓位的控 制极为重要，这属于资金管理的范畴。&lt;/p&gt;

&lt;p&gt;了解了这个，以后跟其他股民聊天就会显得稍微专业一点了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;集合竞价&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;集合竞价是指个股在当日开盘交易前，投资者基于昨日个股的收盘价及当日个股的预期 走势进行申报买入或卖出的行为，对于沪、深A 股来说，每个交易日的 9：15 到9：25 这 段时间内为集合竞价时间，期间投资者可以申报买入或卖出，其中，9：15 至9：20 这段时 间还可以对所委托的申报给予撤销，而9：20 至开盘前则不可以进行撤单操作。在9 点30 分正式开盘的一瞬间，沪深证交所的电脑主机开始撮合成交，以每个股票最大成交量的价格来确定个股的开盘价格。&lt;/p&gt;

&lt;p&gt;开盘价原来是这么确定的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开盘价、收盘价、最高价、最低价&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开盘价是由集合竞价产生的，基于当日开盘价与上一交易日收盘价的对比情况，我们可 以把开盘情况分为高开（当日开盘价高于昨日收盘价）、低开、平开三种。最高价、最低价 则表明了个股当天交投过程中的最高成交价格及最低成交价格；至于收盘价，沪市与深市的 计算方法略有不同，沪市以每个交易日最后一分钟内的所有交易的加权平均价计算得出，而 深市的收盘价则是通过最后三分钟内的竞价方式产生。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;K线图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;K 线图是反映价格在某一时间周期内波动情况的图表，它由开盘价、收盘价、最高价、 最低价四个要素构成，若当日收盘价高于开盘价，这表明价格处于上涨状态，此时K 线图 多用红色表示；若当日收盘价低于开盘价，这表明价格处于下跌状态，此时K 线图多用黑 色或绿色表示；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cainiaoxiaoxiao.u.qiniudn.com/stock1.png&quot; alt=&quot;k线图&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;休市&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;休市是指股市停止交易，国内股市每周六、周日会休市，此外，在五一、十一、春节等 节假日也会休市。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;停牌、复牌&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;停牌即是指个股暂停交易，复牌则是指停牌后的个股又继续恢复交易。可以开始交易了。 对上市公司的股票进行停牌，是为了维护广大投资者的利益及市场信息披露公平、公正以及对上市公司行为进行监管约束而采取的必要措施。一般来说，以下几种情况可能出现停牌： 一是，个股走势出现明显的异常时，二是，当上市公司有重大事项将要公布时，三是，上市 公司召开例行的股东大会时。此外，一些意外的因素也可能导致上市公司股票停牌。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;委买盘和委卖盘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在股票行情软件中，我们可以看到“买盘”与“卖盘”窗口（也可称之为委买盘与委卖 盘窗口），买盘与卖盘各包含五档信息，每一档的信息包括这一档的价位及其委托单数量（以 “手”为单位），指代了已委托而未成交的股票数量，因而，买盘与卖盘窗口是反映投资者 申报委托情况的窗口。（我们平常所说的“买盘”与“卖盘”是指已买入的股票数量及已卖 出的股票数量，与这里的反映委托单情况的买卖盘窗口含义不同）。&lt;/p&gt;

&lt;p&gt;这样看来，可以从里面看出买方和卖方的差别，那是不是能说如果委买盘的数量最大，则股票上涨的可能性越大呢？记录这个，以后看行情图的时候也要留意这个了。&lt;/p&gt;

&lt;p&gt;好了，今天就到这了。欲速则不达！&lt;/p&gt;

&lt;p&gt;600023今天涨了3.5%，还是蛮开心的，虽然是别人推荐的，不过好歹是自己人生第一次买的第一只股哈！！！&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/stock/2014/09/03/stock1</link>
                <guid>http://alonepig.github.io/stock/2014/09/03/stock1</guid>
                <pubDate>2014-09-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Essential Actionscript3.0 读书笔记(二、条件语句和循环)</title>
                <description>&lt;h4&gt;第二章：条件语句和循环&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;条件语句&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActionScript提供两种类型的条件语句：if语句和switch语句。还提供了条件操作符 &amp;quot; ? :&amp;quot;。&lt;/p&gt;

&lt;p&gt;if语句的写法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;if (testExpression) {
    codeBlock1
} else {
    codeBlock2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果testExpression的值为真，则执行codeBlock1语句块，如果为假则执行codeBlock2语句块。&lt;/p&gt;

&lt;p&gt;switch语句的写法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;switch (testExpression) {
    case expression1:
        codeBlock1
        break;
    case expression2:
        codeBlock2
        break;
    default:
        codeBlock3
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果testExpression的值等于expression1，则执行codeBlock1，依此类推。如果break表示跳出该层逻辑，如果没有break;则会一直按顺序执行下去。如果表达式不等于case中的值，则会执行default后面的语句块。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;循环&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActionScript提供了5种循环：while、do-while、for、for-in、for-each-in。&lt;/p&gt;

&lt;p&gt;while语句的写法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;while(testExpression) {
    codeBlock
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了表达式为false来结束循环外，可以使用break来结束。例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var i = 0;
while(i&amp;lt;10){
    trace(i++);
    if(i == 5)
        break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;do-while语句的写法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;do {
    codeBlock
} while (testExpression);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语句块codeBlock会先执行一次，然后在判断testExpression表达式的值是否为真。&lt;/p&gt;

&lt;p&gt;for语句的写法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;for (initialization; testExpression; update) {
    codeBlock
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;initialization语句进行初始化操作，如果表达式testExpression为真，则执行codeBlock语句块，然后执行update语句，再判断testExpression表达式是否为真，为真继续执行codeBlock语句块...。例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var total = 2;
for(var i = 0; i&amp;lt;2; i++){
    total = total*2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;布尔逻辑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通常使用：||(逻辑或)和&amp;amp;&amp;amp;(逻辑与)，逻辑非(!)&lt;/p&gt;

&lt;p&gt;逻辑或(||)的用法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;expression1 || expression2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果表达式expression1或expression2两个中有一个是真的，则表达式的结果为真。这里需要注意的是，如果expression1已经为真了，则表达式expression2就不会进行计算了。&lt;/p&gt;

&lt;p&gt;逻辑与(&amp;amp;&amp;amp;)的用法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;expression1 &amp;amp;&amp;amp; expression2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果表达式expression1和expression2的值都为真，结果才为真。&lt;/p&gt;

&lt;p&gt;逻辑非(!)的用法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;！expression
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取表达式expression的反，如果表达式为真，则结果为假。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可变长参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果参数的个数是未知的话，可以使用... 来表示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;function methodName(... argumentsArray){
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;methodName表示方法的名字，argumentsArray是一个长度可变的数组。可以通过argumentsArray[index]来获取index位置的值。这个跟java中的main方法的参数是一样的。可以联系起来思考。有时候，可能某些参数是固定的，某些不是固定的，可以使用以下的方式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public function initializeUser (name, ...hobbies) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可变长参数在实际编程中用的并不多，用的多的是带默认值的参数，比如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;function setCircle(width:int=100, height:int=100)
{
}

setCircle();
setCircle(200,200);
setCircle(200)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上三种调用方式都是正确的，没有复制的参数会使用默认值。&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/09/01/conditionals-and-loops</link>
                <guid>http://alonepig.github.io/actionscript/2014/09/01/conditionals-and-loops</guid>
                <pubDate>2014-09-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Simple Chat With P2P NetGroup In FP 10.1</title>
                <description>&lt;p&gt;翻译自：http://tomkrcha.com/?p=1266&lt;/p&gt;

&lt;p&gt;这篇文章介绍了最简单的P2P用法，介绍了GroupSpecifier、NetGroup的用法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤一：创建一个ActionSript项目&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用Flash Player10.1或以上的版本&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤二：连接FMS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先我们需要用NetConnection连接服务器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private const SERVER:String = &amp;quot;rtmfp://p2p.rtmfp.net/&amp;quot;;
private const DEVKEY:String = &amp;quot;YOUR-DEVELOPER-KEY&amp;quot;;
private var nc:NetConnection;

private function connect():void{
nc = new NetConnection();
nc.addEventListener(NetStatusEvent.NET_STATUS,netStatus);
nc.connect(SERVER+DEVKEY);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;步骤三：创建NetGroup&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们需要创建P2P组然后连接它。首先，新建GroupSpecifier，构造函数中传入组的名称。然后打开服务器通道，指定为NetGroup启动发布流。groupspecWithAuthorizations和groupspecWithoutAuthorizations的区别在于前者可以发送和接收，后者只能接收。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private function setupGroup():void{
    var groupspec:GroupSpecifier = new GroupSpecifier(&amp;quot;myGroup/g1&amp;quot;);
    groupspec.serverChannelEnabled = true;
    groupspec.postingEnabled = true;

    netGroup = new NetGroup(nc,groupspec.groupspecWithAuthorizations());
    netGroup.addEventListener(NetStatusEvent.NET_STATUS,netStatus);


    user = &amp;quot;user&amp;quot;+Math.round(Math.random()*10000);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;步骤四：监听NetStatusEvent&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private function netStatus(event:NetStatusEvent):void{
    trace(event.info.code);

    switch(event.info.code){
        case &amp;quot;NetConnection.Connect.Success&amp;quot;://连接成功
            setupGroup();
            break;

        case &amp;quot;NetGroup.Connect.Success&amp;quot;://组连接成功
            connected = true;

            break;

        case &amp;quot;NetGroup.Posting.Notify&amp;quot;://消息接收
            receiveMessage(event.info.message);
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;步骤五：发送和接收消息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private var seq:int = 0;
private function sendMessage():void{
    var message:Object = new Object();
    message.sender = netGroup.convertPeerIDToGroupAddress(nc.nearID);
    message.user = txtUser.text;
    message.text = txtMessage.text;
    message.sequence = seq++; // *to keep unique


    netGroup.post(message);
    receiveMessage(message);

    txtMessage.text = &amp;quot;&amp;quot;;
}

private function receiveMessage(message:Object):void{
    write(message.user+&amp;quot;: &amp;quot;+message.text);
}

private function write(txt:String):void{
    txtHistory.text += txt+&amp;quot;n&amp;quot;;
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;步骤六：创建UI&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;s:TextArea left=&amp;quot;10&amp;quot; right=&amp;quot;10&amp;quot; top=&amp;quot;10&amp;quot; bottom=&amp;quot;40&amp;quot; id=&amp;quot;txtHistory&amp;quot;/&amp;gt;
&amp;lt;s:TextInput x=&amp;quot;10&amp;quot; id=&amp;quot;txtUser&amp;quot; text=&amp;quot;{user}&amp;quot; bottom=&amp;quot;10&amp;quot;/&amp;gt;
&amp;lt;s:TextInput left=&amp;quot;145&amp;quot; right=&amp;quot;88&amp;quot; id=&amp;quot;txtMessage&amp;quot; bottom=&amp;quot;10&amp;quot; enter=&amp;quot;sendMessage()&amp;quot;/&amp;gt;
&amp;lt;s:Button label=&amp;quot;Send&amp;quot; click=&amp;quot;sendMessage()&amp;quot; enabled=&amp;quot;{connected}&amp;quot; bottom=&amp;quot;10&amp;quot; right=&amp;quot;10&amp;quot;/&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;**&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/08/29/simple-chat-with-p2p-netgroup-in-fp-101</link>
                <guid>http://alonepig.github.io/fms/2014/08/29/simple-chat-with-p2p-netgroup-in-fp-101</guid>
                <pubDate>2014-08-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Essential Actionscript3.0 读书笔记(一、核心概念)</title>
                <description>&lt;h4&gt;第一章：核心概念&lt;/h4&gt;

&lt;p&gt;什么是程序？程序是由一组可被计算机编译并执行的指令。大家能够看懂的程序中的文本叫做源代码。写这个代码的人叫程序猿，高级一点的叫法叫软件工程师。不同的程序由不同的语言实现，就像有人讲英语有人讲法语。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;写ActionScript代码的工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可以使用任何一种文本编辑器来写，也可以使用Flash Builder或Flash Professional等IDE来写，甚至可以使用VIM编辑器来写，看个人喜好啦！但个人建议刚开始学时可以用纯文本的形式+命令行编译，这样能够更深刻的了解运行原理，后面开始做项目了推荐使用Flash Builder等大型IDE，里面集成的工具方便你调试和更快的开发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Flash客户端运行时环境&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActionScript代码可以被三种不同的应用软件执行：Flash Player、Adobe AIR、Flash Lite。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了能让Flash运行时环境能够执行ActionScript代码，需要对其进行编译，将其转换成ActionScript字节码，并包装到swf文件中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实时编译&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一种利用在运行时将字节码(Bytecode)翻译为机器码(Machine code)，并保存在内存中, 在后续的运行中直接调用机器码, 从而改善字节码编译语言性能的技术。这个技术比较高深，特别是在研究指令集的时候会碰到。需要深入学习的话，请查阅相关资料。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类和对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;试想一下，如果让你造一架飞机，你会怎么做？嗯，应该先画一张图纸，然后制造图纸上不同的零件然后组装起来。在程序世界中，也是这样，先有不同的类，类可以表示有形或无形的东西，比如可以表示数字，可以表示可点击的按钮，可以表示图片模糊的效果。类的实例的集合就构成一个应用程序啦！&lt;/p&gt;

&lt;p&gt;在ActionScript中定义了以下基本类型：&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;类&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;字符串，表示文本数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Boolean&lt;/td&gt;
        &lt;td&gt;布尔值，表示逻辑状态真或假&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;浮点型数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;int&lt;/td&gt;
        &lt;td&gt;整型数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;uint&lt;/td&gt;
        &lt;td&gt;正数整型数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Array&lt;/td&gt;
        &lt;td&gt;数组，有序集合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Error&lt;/td&gt;
        &lt;td&gt;程序错误的类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Date&lt;/td&gt;
        &lt;td&gt;时间类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Math&lt;/td&gt;
        &lt;td&gt;数学运算类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;RegExp&lt;/td&gt;
        &lt;td&gt;正则表达式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Function&lt;/td&gt;
        &lt;td&gt;可执行、可重用的指令集和&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Object&lt;/td&gt;
        &lt;td&gt;所有ActionScript类的基类&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;创建一个程序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个应用程序由多个类文件构成，类文件包含类名、多个Function，由一个主类文件作为整个程序的入口。ActionScript类文件都是以扩展名为.as结尾的文本文件。这里我们新建一个名叫virtualzoo的程序，目录结构如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;virtualzoo
    |- src
        |- VirtualZoo.as
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;包&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为什么要有包的概念？可以想像，如果所有的类文件都放到同一个目录下，那同名了肿么办？因此，你可以创建复杂的包结构，将不同类型的类放在不同的包中。基本的写法如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package packageName {
    public ClassA(){}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的packageName表示包的权限定名，就是说，如果你的类文件在A文件夹的B文件夹中，则packageName为A.B。(文件夹之间以.号隔开)package是ActionScript的关键字。什么叫关键字呢，最简单的理解就是有关键作用的字，哈哈！现在你要记住的就是它是关键字，关键字不能作为类名、方法名来用。package告诉ActionScript要创建一个叫packageName的包，包后面的花括号里定义了很多语句块。&lt;/p&gt;

&lt;p&gt;下面我们将VirtualZoo文件放到包zoo中，目录结构为下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;virtualzoo
    |- src
        |- zoo
            |- VirtualZoo.as    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;定义类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了定义类，我们要使用class关键字：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Identifier {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类定义以class关键字开始，后面跟着类名(是不是跟包的定义很类似)。类的名字也有要求，不能以数字开头，只能包含下划线、字母、数字、美元符号$。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类访问控制修饰符&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况下，一个类只能被同一个包下的其他类访问。但可以通过访问修饰符来改变访问权限。在ActionScript中，类有以下访问权限：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public:全局可以访问
internal(或不写)：当前包下访问
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;构造函数是类初始化的入口，写法如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class SomeClass{
    function SomeClass(){
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造函数的名字和类名是一样的！funciton关键字表示函数，函数名后面的小括号包含了传递进来的参数。花括号里为函数体。如果类没有定义构造函数，则ActionScript会提供一个默认的不带参数的构造函数。
从ActionScript3.0开始，构造函数的默认访问修饰符都是public，所以上面的写法跟下面的写法效果是一样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class SomeClass{
    public function SomeClass(){
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;创建对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了创建一个类的对象(实例化)，我们使用new关键字。例如，我们要创建一个VirtualPet实例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;new VirtualPet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同一个类可以创建多个实例。例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;new VirtualPet
new VirtualPet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Literal语法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于ActionScript内建类型，有一些类型有更简便的实例化方法。比如，我们创建一个Number值为25.4的变量，可以直接用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;25.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义一个字符串使用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义布尔值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Literal 语法也可以用在Object、Function、RegExp和XML类上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对象创建实例：向动物园添加一个动物&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在我们知道如何创建对象，我们可以向动物园添加一个动物了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package zoo {
    public class VirtualZoo {
        public function VirtualZoo() {
            new VirtualPet
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里要注意访问权限的问题，在zoo包下的类默认情况下只能访问该包内的其他类，如果要访问外部包的公共类，需要用import关键字引用该类，如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package zoo {

    import flash.media.Sound;

    public class VirtualZoo {
        public function VirtualZoo() {
            new Sound
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;变量和值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;变量和值是一种对应关系，每个变量都会有一个值，但在ActionScript中还有两种特殊情况，null和undefined，分别表示没有值和未定义。变量是关联到一个值的标识符。比如，一个变量可能是标识符submitBtn，它关联到一个设置按钮。&lt;/p&gt;

&lt;p&gt;变量可以分为不同的种类：局部变量、实例变量、动态实例变量和静态变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;局部变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在函数内定义的变量叫布局变量。定义变量用关键字var，以;结束，&amp;quot;;&amp;quot;表示语句的结束。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class SomeClass {
    public function SomeClass ( ) {
        var identifier = value;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;identifier表示变量的名字，value表示变量的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实例变量直接在类定义的里面定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class SomeClass {
    var identifier = value;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以通过类的实例加&amp;quot;.&amp;quot;来访问某个非私有实例变量，如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;someClass.identifier
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实例变量与布局变量的区别在于它们的生命周期不同。&lt;/p&gt;

&lt;p&gt;变量的访问修饰符有：public、internal、protected、private。public修饰的实例变量可以被包内和包外所有的类访问，internal修饰的实例变量只能被包内的类访问。protected修饰的实例变量只能被类本身或其子类访问。private修饰的实例变量只能在类内部访问。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造函数参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;构造函数参数是一个特殊的局部变量，但又不像局部变量那样需要用var关键字来定义。定义格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class SomeClass {
    funciton SomeClass(identifier = value){
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实例化SomeClass的方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;new SomeClass(value)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果构造函数参数有默认值，则表示该参数是可选的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表达式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;new Date()
2.5
4 * 2.5

var quality = 100;
var price = 50;
var total = quality*price;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上都为表达式，通过不同操作符连接起来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实例方法定义了对象可以做的事情。比如Sound类定义了实例方法play来播放声音。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class SomeClass {
    function identifier ( ) {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>http://alonepig.github.io/actionscript/2014/08/28/essential-actionscript30-reading-note</link>
                <guid>http://alonepig.github.io/actionscript/2014/08/28/essential-actionscript30-reading-note</guid>
                <pubDate>2014-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>windows下的VIM 编辑markdown语法高亮</title>
                <description>&lt;p&gt;Windows使用VIM编辑markdown的语法高亮设置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装git&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装curl&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;在git的安装目录的cmd件夹下的cmd件夹下新建curl.cmd件，复制以下内容：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@rem Do not use &amp;quot;echo off&amp;quot; to not affect any child calls.
@setlocal

@rem Get the abolute path to the parent directory, which is assumed to be the
@rem Git installation root.
@for /F &amp;quot;delims=&amp;quot; %%I in (&amp;quot;%~dp0..&amp;quot;) do @set git_install_root=%%~fI
@set PATH=%git_install_root%\bin;%git_install_root%\mingw\bin;%PATH%

@if not exist &amp;quot;%HOME%&amp;quot; @set HOME=%HOMEDRIVE%%HOMEPATH%
@if not exist &amp;quot;%HOME%&amp;quot; @set HOME=%USERPROFILE%

@curl.exe %*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在命令行中输入curl --version检查是否正确。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装Vundle&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;命令行进入用户目录，(一定要选择用户目录，win7下在C:/Users/xxx/，自己在其他地方clone后不能正确安装，配置文件中rtp和path设置绝对路径貌似没有效果，囧~)，克隆Vundle：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git clone https://github.com/gmarik/Vundle.vim.git 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编辑vim安装目录下的vimrc的配置文件，将以下内容添加到文件的最前面：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;set nocompatible              &amp;quot; be iMproved, required
filetype off                  &amp;quot; required

set rtp+=~/vimfiles/bundle/Vundle.vim/
let path=&amp;#39;~/vimfiles/bundle&amp;#39;
call vundle#begin(path)

&amp;quot; let Vundle manage Vundle, required
Plugin &amp;#39;gmarik/Vundle.vim&amp;#39;

Plugin &amp;#39;godlygeek/tabular&amp;#39;
Plugin &amp;#39;plasticboy/vim-markdown&amp;#39;

call vundle#end()            &amp;quot; required
filetype plugin indent on    &amp;quot; required
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的rtp和path要对应Vundle的目录，不然会找不到后面的命令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装插件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进入vim命令行状态，输入PluginInstall 安装vim-markdown插件&lt;/p&gt;

&lt;p&gt;除此之外还有以下命令可以使用：&lt;/p&gt;

&lt;p&gt;PluginList   查看插件列表&lt;/p&gt;

&lt;p&gt;PluginSearch foo 查询foo插件&lt;/p&gt;

&lt;p&gt;PluginClean     移除不需要的插件&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;https://github.com/gmarik/Vundle.vim&lt;/p&gt;

&lt;p&gt;https://github.com/gmarik/Vundle.vim/wiki/Vundle-for-Windows&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/tools/2014/08/07/vim-markdown-highlight</link>
                <guid>http://alonepig.github.io/tools/2014/08/07/vim-markdown-highlight</guid>
                <pubDate>2014-08-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>bitmapdata</title>
                <description>&lt;p&gt;BitmapData使用过程过的总结：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造函数 BitmapData(width, height, transparent, fillColor)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建一个具有指定的宽度和高度的 BitmapData 对象。如果为 fillColor 参数指定一个值，则位图中的每个像素都将设置为该颜色。&lt;/p&gt;

&lt;p&gt;默认情况下，将位图创建为透明位图，除非您为 transparent 参数传递值 false。创建了不透明位图后，将无法将其更改为透明位图。不透明位图中的每个像素仅使用 24 位的颜色通道信息。如果将位图定义为透明，则每个像素将使用 32 位的颜色通道信息，其中包括 Alpha 透明度通道。&lt;/p&gt;

&lt;p&gt;在 AIR 1.5 和 Flash Player 10 中，BitmapData 对象的最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果 BitmapData 对象的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。如果指定的宽度值或高度值大于 2880，则不会创建新实例。&lt;/p&gt;

&lt;p&gt;这是帮助文档上的解释，在用的时候要注意最后两个参数，比如如果你在截图的时候需要保留透明通道，则需将transparent设置为true，然后根据需求来设置最后一个参数，比如如果要透明，则将其Alpha值设置为0，这时候后面的颜色值就没有效果了；如果需要设置一个背景色，则设置Alpha为FF，再设置后6位的颜色值即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;//不使用透明通道，保存一个背景色为0xF3EBDD的位图
var bmd:BitmapData = new BitmapData(loader.rawContent.width, loader.rawContent.height, false, 0xF3EBDD); 

//保存一个有透明度的位图，背景没有颜色，因为Alpha被设置为0了
var bmd:BitmapData = new BitmapData(loader.rawContent.width, loader.rawContent.height, true, 0x00000000); 

//保存一个有透明度的位图，且背景色为红色
var bmd:BitmapData = new BitmapData(loader.rawContent.width, loader.rawContent.height, true, 0xFFFF0000); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;public function draw(source:IBitmapDrawable, matrix:Matrix = null, colorTransform:flash.geom:ColorTransform = null, blendMode:String = null, clipRect:Rectangle = null, smoothing:Boolean = false):void&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 Flash 运行时矢量渲染器在位图图像上绘制 source 显示对象。可以指定 matrix、colorTransform、blendMode 和目标 clipRect 参数来控制呈现的执行方式。您可以根据需要指定是否应在缩放时对位图进行平滑处理（这只适用于源对象是 BitmapData 对象的情况）。 &lt;/p&gt;

&lt;p&gt;注意：drawWithQuality() 方法与 draw() 方法非常相似，但不使用 Stage.quality 属性确定矢量呈现的品质，您需要为 drawWithQuality() 方法指定 quality 参数。&lt;/p&gt;

&lt;p&gt;此方法与如何在创作工具界面中使用对象的标准矢量渲染器来绘制对像直接对应。&lt;/p&gt;

&lt;p&gt;源显示对象不对此调用使用其任何已应用的转换。它会被视为存在于库或文件中，没有矩阵转换、没有颜色转换，也没有混合模式。要使用对象自己的 transform 属性来绘制显示对象（如影片剪辑），可以将其 transform 属性对象复制到使用 BitmapData 对象的 Bitmap 对象的 transform 属性。&lt;/p&gt;

&lt;p&gt;在 Flash Player 9.0.115.0 及更高版本和 Adobe AIR 中，通过 RTMP 支持此方法。在 Flash Media Server 上，可以在服务器端脚本中控制对流的访问。有关详细信息，请参阅 Server-Side ActionScript Language Reference for Adobe Flash Media Server《Adobe Flash Media Server 服务器端 ActionScript 语言参考》）中的 Client.audioSampleAccess 和 Client.videoSampleAccess。&lt;/p&gt;

&lt;p&gt;如果 source 对象和其所有子对象（如果是 Sprite 或 MovieClip 对象）与调用方不来自同一个域，或者不在调用方可通过调用 Security.allowDomain() 方法访问的内容中，则调用 draw() 将引发 SecurityError 异常。此限制不适用于应用程序安全沙箱中的 AIR 内容。&lt;/p&gt;

&lt;p&gt;对于使用所加载的位图图像作为 source 也有一些限制。如果所加载的图像来自与调用方相同的域，则调用 draw() 方法成功。此外，图像服务器上的跨域策略文件可以向调用 draw() 方法的 SWF 内容的域授予权限。在这种情况下，必须设置 LoaderContext 对象的 checkPolicyFile 属性，并在调用用于加载图像的 Loader 对象的 load() 方法时使用 LoaderContext 对象作为 context 参数。这些限制不适用于应用程序安全沙箱中的 AIR 内容。&lt;/p&gt;

&lt;p&gt;在 Windows 中，draw() 方法无法在 Adobe AIR 的 HTMLLoader 对象中捕获嵌入 HTML 页的 SWF 内容。&lt;/p&gt;

&lt;p&gt;draw() 方法无法捕获 Adobe AIR 中的 PDF 内容。也无法捕获 Adobe AIR 中 wmode 属性设置为“window”的 HTML 中嵌入的 SWF 内容。&lt;/p&gt;

&lt;p&gt;参数
    source:IBitmapDrawable — 要绘制到 BitmapData 对象的显示对象或 BitmapData 对象。（DisplayObject 和 BitmapData 类实现 IBitmapDrawable 接口。）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;matrix:Matrix (default = null) — 一个 Matrix 对象，用于缩放、旋转位图或转换位图的坐标。如果不想将矩阵转换应用于图像，请将此参数设置为恒等矩阵（使用默认 new Matrix() 构造函数创建），或传递 null 值。

colorTransform:flash.geom:ColorTransform (default = null) — 一个 ColorTransform 对象，用于调整位图的颜色值。如果没有提供任何对象，则不会转换位图图像的颜色。如果必须传递此参数但又不想转换图像，请将此参数设置为使用默认 new ColorTransform() 构造函数创建的 ColorTransform 对象。

blendMode:String (default = null) — 来自 flash.display.BlendMode 类的一个字符串值，指定要应用于所生成位图的混合模式。

clipRect:Rectangle (default = null) — 一个 Rectangle 对象，定义要绘制的源对象的区域。 如果不提供此值，则不会进行剪裁，并且将绘制整个源对象。

smoothing:Boolean (default = false) — 一个布尔值，用于确定因在 matrix 参数中指定缩放或旋转而对 BitmapData 对象进行缩放或旋转以后，是否对该对象进行平滑处理。smoothing 参数只有在 source 参数是 BitmapData 对象时才适用。在将 smoothing 设置为 false 的情况下，经过旋转或缩放的 BitmapData 图像可能会显得像素化或带有锯齿。例如，下面两个图像的 source 参数使用同一个 BitmapData 对象，但对左侧的图像，smoothing 参数设置为 true，对右侧的图像，该参数设置为 false：
在将 smoothing 设置为 true 的情况下绘制位图要比在将 smoothing 设置为 false 的情况下执行相同操作更为缓慢。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;应用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;部分剪切：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var bmd:BitmapData = new BitmapData(200, 200);
var m: Matrix = Matrix();
m.tx = -100;
m.ty = -100;
bmd.draw(bmp, m);
var bmp2 = new Bitmap(bmd);
addChild(bmp2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行，是复制的BitmapData的定义，其中200,200是复制出来的内容的宽和高；
第2～3行，是定义要复制的部分的起始坐标，-100，-100，意思就是从要复制的对象的注册点开始算，x:100，y:100坐标开始复制
第4行是复制，其中bmp就是复制的源（也就是一个显示对象），m就是刚才那个Matrix。
第5行是复制，6～7行是把复制的内容显示出来。
因为第一行定义了要复制的区域大小，2，3行定义了从哪个位置复制，这样就实现了按要求区域复制的功能了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public function copyPixels(sourceBitmapData:BitmapData, sourceRect:Rectangle, destPoint:Point, alphaBitmapData:BitmapData = null, alphaPoint:Point = null, mergeAlpha:Boolean = false):void&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为没有拉伸、旋转或色彩效果的图像之间的像素处理提供一个快速例程。此方法在目标 BitmapData 对象的目标点将源图像的矩形区域复制为同样大小的矩形区域。
如果包括 alphaBitmap 参数和 alphaPoint 参数，则可以将另一个图像用作源图像的 Alpha 源。如果源图像具有 Alpha 数据，则这两组 Alpha 数据都用于将源图像中的像素组合到目标图像中。alphaPoint 参数是 Alpha 图像中与源矩形左上角对应的点。源图像和 Alpha 图像交叉区域之外的任何像素都不会被复制到目标图像。
mergeAlpha 属性控制在将透明图像复制到另一透明图像时是否使用 Alpha 通道。若要复制含有 Alpha 通道数据的像素，请将 mergeAlpha 属性设置为 true。默认情况下，mergeAlpha 属性为 false。&lt;/p&gt;

&lt;p&gt;参数
    sourceBitmapData:BitmapData — 要从中复制像素的输入位图图像。源图像可以是另一个 BitmapData 实例，也可以指当前 BitmapData 实例。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sourceRect:Rectangle — 定义要用作输入的源图像区域的矩形。

destPoint:Point — 目标点，它表示将在其中放置新像素的矩形区域的左上角。

alphaBitmapData:BitmapData (default = null) — 第二个 Alpha BitmapData 对象源。

alphaPoint:Point (default = null) — Alpha BitmapData 对象源中与 sourceRect 参数的左上角对应的点。

mergeAlpha:Boolean (default = false) — 要使用 Alpha 通道，请将该值设置为 true。要复制不含 Alpha 通道的像素，请将该值设置为 false。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;应用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下例演示如何将一个 BitmapData 对象中 20 x 20 像素的区域内的像素复制到另一个 BitmapData 对象：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;flexinonroids.wordpress.com/2009/06/17/flex-3-bitmapdata-draw-with-transparency/&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/2014/08/06/bitmapdata</link>
                <guid>http://alonepig.github.io/2014/08/06/bitmapdata</guid>
                <pubDate>2014-08-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>swf文件格式</title>
                <description>&lt;p&gt;关于swf的文件格式，除了官方的文档，也有许多的资料可以参考。在这里只是做一个总结，具体内容请参阅最后给出的链接。&lt;/p&gt;

&lt;p&gt;学习swf的格式，首先你要了解swf的组成，它是有许多的标签按照一定的规则构成。它有自己定义的单位，就像int、number一样。可以查阅官方的文档或http://www.the-labs.com/MacromediaFlash/SWF-Spec/SWFfilereference.html来了解基本的数据类型和标签类型。&lt;/p&gt;

&lt;p&gt;到最新的版本，已有的标签如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Tag-value     Tag-name
0            End
1         ShowFrame
2         DefineShape
4         PlaceObject
5         RemoveObject
6         DefineBits
7         DefineButton
8         JPEGTables
9         SetBackgroundColor
10     DefineFont
11     DefineText
12     DoAction
13     DefineFontInfo
14     DefineSound
15     StartSound
17     DefineButtonSound
18     SoundStreamHead
19     SoundStreamBlock
20     DefineBitsLossless
21     DefineBitsJPEG2
22     DefineShape2
23     DefineButtonCxform
24     Protect
26     PlaceObject2
28     RemoveObject2
32     DefineShape3
33     DefineText2
34     DefineButton2
35     DefineBitsJPEG3
36     DefineBitsLossless2
37     DefineEditText
39     DefineSprite
43     FrameLabel
45     SoundStreamHead2
46     DefineMorphShape
48     DefineFont2
56     ExportAssets
57     ImportAssets
58     EnableDebugger
59     DoInitAction
60     DefineVideoStream
61     VideoFrame
62     DefineFontInfo2
64     EnableDebugger2
65     ScriptLimits
66     SetTabIndex
69     FileAttributes
70     PlaceObject3
71     ImportAssets2
73     DefineFontAlignZones
74     CSMTextSettings
75     DefineFont3
76     SymbolClass
77     Metadata
78     DefineScalingGrid
82     DoABC
83     DefineShape4
84     DefineMorphShape2
86     DefineSceneAndFrameLabelData
87     DefineBinaryData
88     DefineFontName
89     StartSound2
90     DefineBitsJPEG4
91     DefineFont4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，你需要弄明白这个规则。swf是由头和身体两部分组成。&lt;/p&gt;

&lt;p&gt;参考(A simple .swf file and it’s below the line representation)[http://blog.csdn.net/qdlgx/article/details/2868504]，你将明白头是怎么构成的，标签又是按照什么顺序排列的。&lt;/p&gt;

&lt;p&gt;再然后，就是指令集了。AVM虚拟机有自己的指令集。详情参考http://www.adobe.com/content/dam/Adobe/en/devnet/actionscript/articles/avm2overview.pdf&lt;/p&gt;

&lt;p&gt;下面总结出的ABC文件结构：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;abcFile
{
+ minor_version: u16    最低swf版本
+ major_version: u16    最高swf版本
+ method_count: u30     方法数量
+ metadata_count: u30   元数据数量
+ class_count: u30          类数量
+ script_count: u30         脚本数量
+ method_body_count: u30      方法体数量
+ constant_pool: cpool_info      常量池
+ method: method_info (Array)      方法集合
+ metadata: metadata_info (Array)      元数据集合
+ instance: instance_info (Array)      实例集合
+ class: class_info (Array)      类集合
+ script: script_info (Array)      脚本集合
+ method_body: method_body_info (Array)      方法体集合
}



cpool_info
{
+ int_count: u30      整形数量
+ uint_count: u30      无符号整形数量
+ double_count: u30      双精度型数量     
+ string_count: u30      字符串数量
+ namespace_count: u30      命名空间数量
+ ns_set_count: u30      命名空间集合数量
+ multiname_count: u30      复合名字数量
+ string: string_info (Array)      字符串集合
+ namespace: namespace_info (Array)      命名空间集合
+ ns_set: ns_set_info (Array)      命名空间的集合关系
+ multiname: multiname_info (Array)      复合名字集合
}

namespace_info
{
+ CONSTANT_Namespace: u8 = 0x08
+ CONSTANT_PackageNamespace: u8 = 0x16
+ CONSTANT_PackageInternalNs: u8 = 0x17
+ CONSTANT_ProtectedNamespace: u8 = 0x18
+ CONSTANT_ExplicitNamespace: u8 = 0x19
+ CONSTANT_StaticProtectedNs: u8 = 0x1A
+ CONSTANT_PrivateNs: u8 = 0x05
+ kind: u8      类型，有6种常量类型
+ name：u30      string集合的下标，为0的话则是空字符串
}

ns_set_info
{
+ count: u30      数量
+ ns: u30 (Array)      each ns is an integer that indexes into the namespace array of the constant pool
}

multiname_info
{
+ kind: u8      类型
+ CONSTANT_QName: u8 = 0x07
+ CONSTANT_QNameA: u8 = 0x0D
+ CONSTANT_RTQName: u8 = 0x0F
+ CONSTANT_RTQNameA: u8 = 0x10
+ CONSTANT_RTQNameL: u8 = 0x11
+ CONSTANT_RTQNameLA: u8 = 0x12
+ CONSTANT_Multiname: u8 = 0x09
+ CONSTANT_MultinameA: u8 = 0x0E
+ CONSTANT_MultinameL: u8 = 0x1B
+ CONSTANT_MultinameLA: u8 = 0x1C
+ data: u8 (Array)      可变长数据(根据不同类型得到不同的数据)
}

multiname_kind_QName
{
+ ns: u30      namespace集合的索引
+ name: u30      string集合的索引
}

multiname_kind_RTQName
{
+ name: u30      string集合的索引
}

multiname_kind_RTQNameL
{
}

multiname_kind_Multiname
{
+ u30 name      string集合的索引
+ u30 ns_set      ns_set集合的索引
}

multiname_kind_MultinameL
{
+ u30 ns_set      ns_set集合的索引
}


method_info
{
+ u30 param_count      参数的数量
+ u30 return_type      指向multiname索引
+ u30 param_type[param_count]      每一个条目指向multiname集合的索引
+ u30 name      string集合的索引
+ u8 flags      为以下常量类型，提供关于方法的额外信息
+ option_info options      只有在flag为HAS_OPTIONAL时才会出现
+ param_info param_names      只有在flag为HAS_PARAM_NAMES才会出现
+ NEED_ARGUMENTS: u8 = 0x01      Suggests to the run-time that an “arguments” object (as specified by the ActionScript 3.0 Language Reference) be created. Must not be used together with NEED_REST
+ NEED_ACTIVATION: u8 = 0x02      Must be set if this method uses the newactivation opcode
+ NEED_REST: u8 = 0x04      This flag creates an ActionScript 3.0 rest arguments array. Must not be used with NEED_ARGUMENTS
+ HAS_OPTIONAL: u8 = 0x08      Must be set if this method has optional parameters and the options field is present in this method_info structure
+ SET_DXNS: u8 = 0x40      Must be set if this method has optional parameters and the options field is present in this method_info structure
+ HAS_PARAM_NAMES: u8 = 0x80      Must be set when the param_names field is present in this method_info structure
}

option_info
{
+ u30 option_count
+ option_detail option[option_count]
}

option_detail
{
+ u30 val      有kind类型来指向常量池中不同类型集合的索引，如0x03表示整形集合的索引
+ u8 kind      类型，对应kind_constants
}

kind_constants
{
+ CONSTANT_Int: u8 = 0x03
+ CONSTANT_UInt: u8 = 0x04
+ CONSTANT_Double: u8 = 0x06
+ CONSTANT_Utf8: u8 = 0x01
+ CONSTANT_True: u8 = 0x0B
+ CONSTANT_False: u8 = 0x0A
+ CONSTANT_Null: u8 = 0x0C
+ CONSTANT_Undefined: u8 = 0x00
+ CONSTANT_Namespace: u8 = 0x08
+ CONSTANT_PackageNamespace: u8 = 0x16
+ CONSTANT_PackageInternalNs: u8 = 0x17
+ CONSTANT_ProtectedNamespace: u8 = 0x18
+ CONSTANT_ExplicitNamespace: u8 = 0x19
+ CONSTANT_StaticProtectedNs: u8 = 0x1A
+ CONSTANT_PrivateNs: u8 = 0x05
}


metadata_info
{
+ u30 name      string集合的索引
+ u30 item_count      items条目的数量
+ item_info items[item_count]      
}

item_info
{
+ u30 key
+ u30 value
}
The item_info entry consists of item_count elements that are interpreted as key/value pairs of indices into the string table of the constant pool


instance_info
{
+ CONSTANT_ClassSealed: u8 = 0x01      The class is sealed: properties can not be dynamically added to instances of the class
+ CONSTANT_ClassFinal: u8 = 0x02      The class is final: it cannot be a base class for any other class
+ CONSTANT_ClassInterface: u8 = 0x04      The class is an interface
+ CONSTANT_ClassProtectedNs: u8 = 0x08      The class uses its protected namespace and the protectedNs field is present in the interface_info structure
+ u30 name      multiname索引，类名
+ u30 super_name      基类的名字，multiname索引
+ u8 flags      常量类型
+ u30 protectedNs      flags为CONSTANT_ClassProtectedNs时才出现， namespace索引
+ u30 intrf_count      interface长度
+ u30 interface[intrf_count]      interface的条目包含multiname索引
+ u30 iinit      abcFile中method的索引
+ u30 trait_count      trait长度
+ traits_info trait[trait_count]      
}

traits_info
{
+ Trait_Slot: u8 = 0
+ Trait_Method: u8 = 1
+ Trait_Getter: u8 = 2
+ Trait_Setter: u8 = 3
+ Trait_Class: u8 = 4
+ Trait_Function: u8 = 5
+ Trait_Const: u8 = 6
+ ATTR_Final: u8 = 0x1
+ ATTR_Override: u8 = 0x2
+ ATTR_Metadata: u8 = 0x4
+ name: u30      multiname索引，不能为0
+ kind: u8      两个四位字段，低四位决定trait的类型，高四位构成trait的属性(有点不明白)
+ data: u8 (Array)      有trait的类型决定
+ metadata_count: u30      metadata长度
+ metadata: u30 (Array)      
}

trait_slot
{
+ u30 slot_id
+ u30 type_name      multiname索引
+ u30 vindex      
+ u8 vkind      kind_constant索引，当vindex不为0时存在
}
Trait_Slot或Trait_Const类型为trait_slot


trait_class
{
+ u30 slot_id      确定trait的位置
+ u30 classi      abcFile的class集合索引
}
Trait_Class类型为trait_class

trait_function
{
+ u30 slot_id
+ u30 function      abcFile中method索引
}
Trait_Function类型为trait_function

trait_method
{
+ u30 disp_id
+ u30 method      abcFile中method索引
}
Trait_Method、Trait_Getter、Trait_Setter类型为trai_method


class_info
{
+ u30 cinit      method索引
+ u30 trait_count
+ traits_info traits[trait_count]
}

script_info
{
+ u30 init      method索引
+ u30 trait_count
+ traits_info trait[trait_count]
}


method_body_info
{
+ method: u30      abcFile中method索引
+ max_stack: u30
+ local_count: u30      最大本地寄存器索引+1
+ init_scope_depth: u30
+ max_scope_depth: u30
+ code_length: u30
+ code: u8      保存AVM2指令
+ exception_count: u30
+ exception: exception_info (Array)
+ trait_count: u30
+ trait: traits_info (Array)
}

exception_info
{
+ u30 from      代码范围
+ u30 to
+ u30 target      跳转目标
+ u30 exc_type      错误类型, 常量表中 string 索引, 0=所有错误
+ u30 var_name      异常的变量名, 常量表中 string 索引
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;授之以鱼不如授之以渔，由于自己的水平有限，也没有完成弄懂里面的所有东西。在此，只是记录自己的学习过程。除了下面参考的资料，个人觉得最好的学习方法还是找到一个比较好的解析swf开源项目，通过阅读源码来理解(可参考swfinvestigator、as3crypto、JPEXS等)。有任何问题，欢迎跟我探讨。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.the-labs.com/MacromediaFlash/SWF-Spec/SWFfilereference.html&quot;&gt;SWF File Reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.the-labs.com/MacromediaFlash/SWF-Spec/SWFfileformat.html&quot;&gt;SWF File Format Specification&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.adobe.com/content/dam/Adobe/en/devnet/actionscript/articles/avm2overview.pdf&quot;&gt;AVM指令集概要&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qdlgx/article/details/2868504&quot;&gt;一个例子分析swf格式&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/07/30/swf-file-format</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/30/swf-file-format</guid>
                <pubDate>2014-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>mm.cfg</title>
                <description>&lt;p&gt;对于AS程序猿，mm.cfg一定不陌生。因为它真的很强大。&lt;/p&gt;

&lt;p&gt;根据官方文档介绍，你可以使用mm.cfg文件来配置调试版Flash Player的版本。能够将trace语句输出到日志文件中。如果系统中没有这个文件，在相应目录创建一个就好了。&lt;/p&gt;

&lt;p&gt;下面的表格显示了不同系统中mm.cfg的位置。&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;操作系统&lt;/td&gt;
        &lt;td&gt;位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Macintosh OS X&lt;/td&gt;
        &lt;td&gt;Flash Player首先会检查用户根目录(~)。如果没有发现，则检查/Library/Application Support/Macromedia&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Windows 2000/XP&lt;/td&gt;
        &lt;td&gt;
            %HOMEDRIVE%\%HOMEPATH%
            默认路径是c:\Documents and settings\username
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Windows Vista Windows 7&lt;/td&gt;
        &lt;td&gt;
            %HOMEDRIVE%\%HOMEPATH%
            默认路径是c:\Users\username
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Linux&lt;/td&gt;
        &lt;td&gt;/home/username&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;mm.cfg其实就是包含若干键值对的文本文件。&lt;/p&gt;

&lt;p&gt;下面的表格介绍了一些重要的属性：&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;属性&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;ErrorReportingEnable&lt;/td&gt;
        &lt;td&gt;能够输出错误消息。设置为1表示在调试版本的Flash Player的错误信息可以输出到日志文件中。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;TraceOutputFileEnable&lt;/td&gt;
        &lt;td&gt;是否可以输出trace的内容，如果设置为1，则日志文件中会显示所有trace的内容。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;PreloadSWF&lt;/td&gt;
        &lt;td&gt;预加载的swf路径，这个非常有用，下面详细介绍&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;除了以上简单介绍的，还有许多其他的参数可以配置。请参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jpauclair.net/2010/02/10/mmcfg-treasure/&quot;&gt;http://jpauclair.net/2010/02/10/mmcfg-treasure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在来详细谈谈PreloadSWF的作用，再看下面的内容之前可以先看看这篇文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://kanefan.duapp.com/?p=204&quot;&gt;http://kanefan.duapp.com/?p=204&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看完之后就会知道有多强大了。好了，现在总结一下它的作用：&lt;/p&gt;

&lt;p&gt;1.可以预加载到目标swf文件中，这样就可以获取该swf的一些信息了。比如，可以知道这个swf有多大，帧率是多少。更强的地方在于它能直接获取到loaderContentInfo里的ByteArray，是不是想到了什么？！！ 是这样的，直接通过预加载就可以将最终的swf文件导出来，完全不用管它运行前将swf加壳、切分很多块。因为，我们已经直接获取到了最终的文件。&lt;/p&gt;

&lt;p&gt;2.它可以获取到浏览器传过来的flashvars信息，是不是想到了很多页游的一些初始化信息都是从浏览器传过来的。通过增加一些代码，就能获取到这些信息了，是不是非常方便。&lt;/p&gt;

&lt;p&gt;3.还可以跟monsterDebugger、Adobe Scrout等调试工具配合，来看看swf内部运行的数据。&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/07/30/mmcfg</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/30/mmcfg</guid>
                <pubDate>2014-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Flash 游戏破解</title>
                <description>&lt;p&gt;学习编程最好的办法之一就是阅读别人的优秀代码，学习AS最好的方法之一就是阅读别人写的优秀的AS代码。当然，优秀的源码太多，在github一搜就能找到大把的开源项目。但，作为曾经的页游从业者。阅读优秀游戏的源码更是成长速度的方法之一。&lt;/p&gt;

&lt;p&gt;因此，本人也开始了学习破解页游的方法。经过长时间的摸索，自己掌握了一套自己的破解方法。在此，仅供参考。也在此声明，破解只是为了学习优秀的编程思想，对于那种破解之后修改UI后作为自己游戏或转手卖钱的行径，表示鄙视之。&lt;/p&gt;

&lt;p&gt;以下会分为三个部分来介绍破解之道。基础篇介绍需要用到的相关知识，工具篇包含了在破解过程中使用的工具，实战篇将找一款游戏进行实战破解。&lt;/p&gt;

&lt;h4&gt;基础篇&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AS编程基础：这个很重要，如果你连基本的AS语法都不清楚，那就算将源码赤裸裸的摆在您面前，您也看不懂啦！所以，你需要会这个。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;swf格式结构、AVM指令集：adobe是公开了swf的格式的，你需要找到swf&lt;em&gt;file&lt;/em&gt;format&lt;em&gt;spec&lt;/em&gt;v10和avm2overview两份文档，如果您真的读明白了，那读完后自己应该能写出一个解析swf的工具了。
需要了解这个的原因是，大部分的页游都会采用一些加密的方法来保护他们的swf文件，而只要你掌握了这个，那么万变不离其宗啦！请参考(另一篇)[http://alonepig.github.io/posts/2014-07-30-swf-file-format.html]&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mm.cfg：这个文件非常强大，非常有作用。您可以搜索相关的资料了解，也可以查看本人的介绍。关于mm.cfg，请参考(另一篇)[http://alonepig.github.io/posts/2014-07-30-mmcfg.html]：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;工具篇&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;硕思闪客精灵：这个软件最大的优点是能显示出各种资源(Sound、Shape、Image等等)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ActionScript View：这个就是大大有名的ASV了，有很多好用的功能，比如替换常量池的常量，导出swf的资源。相对于硕思闪客，该软件导出的AS源码错误更少一些。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FlashDecompiler：界面跟硕思闪客相似。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AS3 Sorcerer：另一款破解软件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JPEXS：这是一款开源的java项目，强烈推荐。首先，它是开源的(好处太多，自行领会)。再次，功能也很强大。可以显示代码对应的指令集。支持动态修改。有很多结构被修改后的swf文件，我都是通过它来解析成功的。而且，阅读它的源码，你会更加容易理解swf结构和指令集。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Adobe Scrout CC：这是adobe的一款debug软件，可以查看运行中的swf的各种状态。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Monster Debugger：另一款调试工具。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;WinHex：十六进制查看工具。刚您了解了swf结构后，用该工具打开一个swf，就能手动解析里面的数据了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Firefox HttpFox插件： 这个火狐插件是用来找到网页中swf、游戏资源地址的&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fiddler：一款网络监控软件，强大的功能是可以将网络上的文件替换成本地的文件运行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;实战篇&lt;/h4&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/07/29/crack-flash-game</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/29/crack-flash-game</guid>
                <pubDate>2014-07-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>load的缓存</title>
                <description>&lt;p&gt;有时候，在使用URLLoader装载资源的时候，会发现装载不到最新的资源。可以使用以下代码测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;call();

private function call():void
{
    if(urlLoader)
    {
        urlLoader.load(urlRequest); 
        return;
    }
    urlLoader = new URLLoader();                  
    urlRequest = new URLRequest(_url);  

    urlLoader.load(urlRequest);  

    urlLoader.addEventListener(Event.COMPLETE, urlLoaderCompleteHandler);
}

private function urlLoaderCompleteHandler(event:Event):void
{
    setTimeout(call, 2000);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用charles或相关工具监听请求，你会发现，只会发一次请求。这说明第二次就使用了缓存。&lt;/p&gt;

&lt;p&gt;为了解决该问题，只需要在url后添加一个参数，使得URL的地址每次都是唯一的即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;urlRequest = new URLRequest(_url + &amp;quot;?t=&amp;quot; + (new Date()).time);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>http://alonepig.github.io/actionscript/2014/07/25/load-cache</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/25/load-cache</guid>
                <pubDate>2014-07-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Error #2032：流错误</title>
                <description>&lt;p&gt;Error #2032：流错误。 URL:xxx/xxx/xxx 的问题总结：&lt;/p&gt;

&lt;p&gt;使用URLLoader或HttpService装载文件的时候，有时候会出现以上错误。于是开始找寻解决办法，经过搜索，发现很多人都遇到过这个问题，但又是不同的情况。
现整理一份解决办法，希望能帮到后来人。&lt;/p&gt;

&lt;h6&gt;一.由于IE缓存造成的。&lt;/h6&gt;

&lt;p&gt;使用HttpService时，在IE中第一次调用后会缓存资源，下次再使用的时候就会用原来的资源，而出现问题。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;mx:HTTPService id=&amp;quot;accountsRequest&amp;quot;
      method=&amp;quot;POST&amp;quot; url=&amp;quot;accounts.php&amp;quot;
      result=&amp;quot;assignUsersData(event)&amp;quot; fault=&amp;quot;onErrorLoad(event)&amp;quot;&amp;gt;
&amp;lt;/mx:HTTPService&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决办法是在url的地址后面加一个变量：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private function changePage(pageIdValue : Number) : void 
{
      var rnd : Number = Math.round(Math.random()*1000);
      accountsRequest.url = &amp;quot;accounts.php?foo=&amp;quot; + rnd;
      accountsRequest.send();
      pageId = pageIdValue; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;二、可能是IIS造成的，需要设置。进入IIS管理目录，选择MIME类型，然后通过添加菜单，添加一个新的MIME映射，文件拓展名填你需要的，MIME类型填application/octet-stream（可选）。&lt;/h6&gt;

&lt;p&gt;保存设置后，重新启动IIS服务器。&lt;/p&gt;

&lt;h6&gt;三、如果显示的是Error #2032: 流错误。 URL: xxx/xxx/xxx/xxx.swf，则可能需要修改项目设置。&lt;/h6&gt;

&lt;p&gt;修改模块项目的Flex Build Path，取消Use local debug runtime shared libraries when debugging复选框，这样，模块就不会去加载本地的rsls，而是回去加载adobe提供的rsls。&lt;/p&gt;

&lt;p&gt;其他解决办法(仅供参考)：&lt;/p&gt;

&lt;p&gt;1.修改UrlRequest的contentType属性，设置为text/xml。 &lt;/p&gt;

&lt;p&gt;2.修改UrlRequest的method，由POST改成GET。此方法未经验证，因为method原本默认的就是GET。&lt;/p&gt;

&lt;p&gt;如果以上方法都不能解决问题，可以监听HTTPStatusEvent.HTTP&lt;em&gt;STATUS(AIR中卫HTTPStatusEvent.HTTP&lt;/em&gt;RESPONSE_STATUS)事件，可以获得更多的信息来找寻答案。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://jabbypanda.com/blog/2006/11/mxhttpservice-calls-are-cached-in-ie-6-unnecessary/&lt;/p&gt;

&lt;p&gt;http://hydra1983.blog.163.com/blog/static/111750372011020104951205/&lt;/p&gt;

&lt;p&gt;http://www.judahfrangipane.com/blog/2007/02/15/error-2032-stream-error/&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/actionscript/2014/07/23/stream-error-2032</link>
                <guid>http://alonepig.github.io/actionscript/2014/07/23/stream-error-2032</guid>
                <pubDate>2014-07-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>about h264 setting</title>
                <description>&lt;p&gt;&lt;strong&gt;什么是H264&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;H.264，或称MPEG-4第十部分（AVC,Advanced Video Coding），是由国际电信标准化部门ITU-T和国际标准化组织ISO/IEC于2003年共同推出的最新一代的视频压缩标准。
与就标准相比，它能够在更低带宽下提供优质视频。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;H264和Flash Player&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Flash Player9 就支持了H264回播。Flash Player应该播放 .mp4, .m4v, .m4a, .mov, .3gp文件。H264使用.flv扩展名，也使用新的扩展名。&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;文件扩展名&lt;/td&gt;
        &lt;td&gt;FTYP&lt;/td&gt;
        &lt;td&gt;MIME 类型&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;.4v&lt;/td&gt;
        &lt;td&gt;&#39;F4V&#39;&lt;/td&gt;
        &lt;td&gt;video/mp4&lt;/td&gt;
        &lt;td&gt;视频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;.f4p&lt;/td&gt;
        &lt;td&gt;&#39;F4P&#39;&lt;/td&gt;
        &lt;td&gt;video/mp4&lt;/td&gt;
        &lt;td&gt;受保护的媒体&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;.f4a&lt;/td&gt;
        &lt;td&gt;&#39;F4A&#39;&lt;/td&gt;
        &lt;td&gt;audio/mp4&lt;/td&gt;
        &lt;td&gt;Flash Player音频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;.f4b&lt;/td&gt;
        &lt;td&gt;&#39;F4B&#39;&lt;/td&gt;
        &lt;td&gt;audio/mp4&lt;/td&gt;
        &lt;td&gt;Flash Player有声读物&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;H264编码参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Profile：对视频压缩特性的描述，表示不同的画质级别。目前有21种标准，但AS中只支持2种选择。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cainiaoxiaoxiao.u.qiniudn.com/1279272306301.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Level：对视频本身特性的描述(码率、分辨率、fps)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cainiaoxiaoxiao.u.qiniudn.com/2222.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;在直播中使用H264编码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var cam:camera = Camera.getCamera();
var ns:netStream = new NetStream(nc);
ns.client = this;
ns.addEventListener(NetStatusEvent.NET_STATUS, onNetStatus); 

var h264Settings:H264VideoStreamSettings = new H264VideoStreamSettings();
h264Settings.setProfileLevel(H264Profile.MAIN, H264Level.LEVEL_3_1);
// 以下方法暂无效，不知道adobe什么时候才实现，用Camera对应的API代替
//h264Settings.setQuality(0,90);
//h264Settings.setKeyFrameInterval(15);
//h264Settings.setMode(width, height, fps);

ns.videoStreamSettings = h264Settings;
ns.attachCamera(cam);
ns.publish(&amp;quot;mp4:mplivestream.f4v&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;setProfileLevel(profile:String, level:String)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;H264Profile 类是用于设置 H264VideoStreamSettings 类的配置文件的常数值的枚举。(目前只支持两种)&lt;/p&gt;

&lt;p&gt;public static const BASELINE:String = &amp;quot;baseline&amp;quot;&lt;/p&gt;

&lt;p&gt;用于H.264/AVC基线配置文件的常数。这是 H264VideoStreamSettings 类的默认值。
支持I/P帧，只支持无交错(Progressive)和CAVLC，一般用于低阶或需要额外容错的应用，比如视频通话、手机视频等；&lt;/p&gt;

&lt;p&gt;public static const MAIN:String = &amp;quot;main&amp;quot;&lt;/p&gt;

&lt;p&gt;用于 H.264/AVC 主配置文件的常数。 
提高I/P/B帧，支持无交错(Progressive)和交错(interlaced)，同样提供对于CAVLC和CABAC的支持&lt;/p&gt;

&lt;p&gt;H264Level 类是用于设置 H264VideoStreamSettings 类的级别的常数值的枚举。 &lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://en.wikipedia.org/wiki/H264&lt;/p&gt;

&lt;p&gt;http://www.adobe.com/devnet/adobe-media-server/articles/h264_encoding.html&lt;/p&gt;

&lt;p&gt;http://www.adobe.com/devnet/adobe-media-server/articles/encoding-live-video-h264.html&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/2014/07/18/about-h264-setting</link>
                <guid>http://alonepig.github.io/2014/07/18/about-h264-setting</guid>
                <pubDate>2014-07-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>params on live</title>
                <description>&lt;h4&gt;直播过程中NetStream、Camera、Microphone的参数设置&lt;/h4&gt;

&lt;p&gt;在直播过程中，参数的设置非常重要，它关乎着使用了多少带宽，画面的流畅度等。自己在使用的过程中总结了一些经验，若有不对之处，望看官能指出。&lt;/p&gt;

&lt;h6&gt;关于bufferTime&lt;/h6&gt;

&lt;p&gt;bufferTime是NetStream的属性，表示缓冲的时间，默认值为0.1秒。在直播中如果设置为0则会出现卡顿的现象，要是设置的值较大，则等待的时间较长。
有一个比较好的办法，在开始连接的时候设置一个较小的值(如0.1)，等到缓冲区填满时(&amp;quot;NetStream.Buffer.Full&amp;quot;)，再设置大点(3秒或4秒)。接收到
&amp;quot;NetStream.Buffer.Empty&amp;quot;时再设置回初始值。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private function onNetStreamStatusHandler(event:NetStatusEvent):void
{
    switch(event.info.code)
    {
        case &amp;quot;NetStream.Buffer.Full&amp;quot;:
            _ns.bufferTime = 3;
            break;
        case &amp;quot;NetStream.Buffer.Empty&amp;quot;:
            _ns.bufferTime = 0.1;
            break;
    }
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;关于Camera.setQuality(bandwidth:int, quality:int)方法&lt;/h5&gt;

&lt;p&gt;帮助文档中说的很轻快，这个方法是用来设置每秒的最大带宽或当前输出视频输入信号所需的画面质量。&lt;/p&gt;

&lt;p&gt;使用此方法可以指定输出视频输入信号的哪一方面对于您的应用程序更重要：是带宽使用率还是图片品质。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;要表示带宽使用率更为重要，请将一个值传递给 bandwidth 并将 0 传递给 quality。运行时将在指定的带宽内以可能的最高质量传输视频。如有必要，运行时将降低画面质量以避免超出指定的带宽。通常，随着运动的增加，质量将降低。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要表示品质更为重要，请将 0 传递给 bandwidth 并将一个数值传递给 quality。运行时使用所需数量的带宽来保持指定的质量。如有必要，运行时将降低帧速率以保持画面质量。通常，随着运动的增加，带宽的使用率也将增加。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要指定带宽和品质同等重要，请为这两个参数都传递数值。运行时将传输达到指定质量并且不超过指定带宽的视频。如有必要，运行时将降低帧速率以保持画面质量，而不会超出指定的带宽。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里对于带宽bandwidth要重点理解。这里以每秒字节数(bps)为单位。但我们日常生活中常用到的是Kb/s、Mb/s，表示每秒传输多少兆、多少千字节。它们的转换关系是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;8 bit = 1 Byte = 1/1024 k = 1/1024/1024 M
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，2Mb的带宽最多只有200多K的下载速度就是这样得来的。&lt;/p&gt;

&lt;p&gt;在调试过程中，可以将bandwidth值设置为0，看看当前设置需要多少的带宽才能保持品质。&lt;/p&gt;

&lt;h5&gt;关于Camera.setMode(width:int, height:int, fps:Number, favorArea:Boolean = true)&lt;/h5&gt;

&lt;p&gt;将摄像头的捕获模式设置为最符合指定要求的本机模式。如果摄像头没有与您传递的所有参数相匹配的本机模式，运行时将选择与所请求的模式最接近的合成捕获模式。此操作可能涉及裁切图像和删除帧。&lt;/p&gt;

&lt;p&gt;默认情况下，运行时根据需要删除一些帧以保持图像大小。要将删除的帧数降至最低（即使这意味着减小图像大小），请为 favorArea 参数传递 false。&lt;/p&gt;

&lt;p&gt;在选择本机模式时，运行时将设法尽量保持所请求的高宽比。例如，如果发出 myCam.setMode(400, 400, 30) 命令，并且摄像头上可用的最大宽度和高度值分别为 320 和 288，则运行时将宽度和高度都设置为 288；通过将这些属性设置为相同的值，运行时可以保持所请求的 1:1 高宽比。&lt;/p&gt;

&lt;p&gt;要确定在运行时选择与所请求的值最匹配的模式后分配给这些属性的值，请使用 width、height 和 fps 属性。&lt;/p&gt;

&lt;p&gt;网络上流传一些关于setMode的设置，说带宽的大致算法是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;视频宽度 x 视频高度 x 播放速率 (fps) = 总的带宽( bits/sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后给出了一组推荐的参数设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;1 : //如果使用的是1M以上的宽度的话，可以选用如下设置：
2 : Camera.setMode(320,240,15);
3 : Camera.setQuality(144,000,85 );
4 : Microphone.setRate(22);
5 : //总的消耗带宽：1,196 kbps = 144kbyte

1 : //786 kbps宽带：
2 : Camera.setMode(240,180,12);
3 : Camera.setQuality(64,800,85 );
4 : Microphone.setRate(22);
5 : //总的消耗带宽：562 kbps = 70kbyte

1 : //384 kbps宽带：
2 : Camera.setMode(192,144,7);
3 : Camera.setQuality(24,192,85 );
4 : Microphone.setRate(11);
5 : //总的消耗带宽：216 kbps = 27kbyte

1 : //56 kbps 拨号：
2 : Camera.setMode(80,60,8);
3 : Camera.setQuality(4,800,85 );
4 : Microphone.setRate(8);
5 : //总的消耗带宽：54 kbps = 7kbyte
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;setLoopback(compress:Boolean=false)&lt;/h5&gt;

&lt;p&gt;指定在本地查看摄像头时是否使用压缩视频流。此方法仅在使用 Flash Media Server 传输视频时适用；如果将 compress 设置为 true，则可以更精确地看到在用户实时查看视频时向用户呈现视频的方式。&lt;/p&gt;

&lt;p&gt;虽然压缩流在用于测试（如预览视频品质设置）时很有用，但对它进行处理要花很大的代价，因为对本地视图并不只是进行压缩处理；就像通过实时连接进行传输那样，需要对视频进行压缩和编辑以进行传输，然后要对其进行解压缩处理以供本地查看。&lt;/p&gt;

&lt;p&gt;这个方法的作用感觉就是让用户感受最终传输的流的效果。应根据需求来决定是否需要设置。&lt;/p&gt;

&lt;h5&gt;setKeyFrameInterval(keyFrameInterval:int)&lt;/h5&gt;

&lt;p&gt;指定进行完整传输而不由视频压缩算法进行插值处理的视频帧（称为关键帧）。此方法仅在使用 Flash Media Server 传输视频时适用。&lt;/p&gt;

&lt;p&gt;Flash 视频压缩算法通过只传输自视频的上一帧以来的更改内容来压缩视频；这些部分被视为插补帧。可以根据前一帧的内容插补视频帧。但是，关键帧是完整的视频帧；它并不是根据前面的帧插补的。&lt;/p&gt;

&lt;p&gt;要确定如何设置 keyFrameInterval 参数的值，请考虑带宽使用率和视频播放辅助功能。例如，为 keyFrameInterval 指定较高的值（以较低的频率发送关键帧）可降低带宽使用率。但是，这可能会增加在视频某一特定点上定位播放头所需的时间量；可能需要插补更多以前的视频帧才能继续播放视频。&lt;/p&gt;

&lt;p&gt;反之，为 keyFrameInterval 指定较低的值（以较高的频率发送关键帧）会提高带宽使用率（因为会更频繁地传输所有的视频帧），但可能会减少在已录制视频内搜索特定视频帧所需的时间量。&lt;/p&gt;

&lt;p&gt;这个方法,如果不需要录播视频，那么可以把值设置的高一点来节省带宽。&lt;/p&gt;

&lt;h5&gt;setUseEchoSuppression(useEchoSuppression:Boolean)&lt;/h5&gt;

&lt;p&gt;指定是否使用音频编解码器的回音抑制功能。除非用户已经在 Flash Player 的“麦克风设置”面板中选择了“降低回音”，否则默认值为 false。&lt;/p&gt;

&lt;p&gt;回音抑制是指降低音频回馈效果，当扬声器发出的声音由同一系统上的麦克风拾取时，将导致音频回馈。（这不同于回音消除，后者会完全移除反馈。在调用 getEnhancedMicrophone() 方法以使用回音消除功能时，将忽略 setUseEchoSuppression() 方法。）&lt;/p&gt;

&lt;p&gt;通常情况下，当通过扬声器（而不是耳机）播放所捕获的声音时，建议使用回音抑制。如果您的 SWF 文件允许用户指定声音输出设备，则当他们指定使用扬声器并且还将使用麦克风时，您可能需要调用 Microphone.setUseEchoSuppression(true)。&lt;/p&gt;

&lt;p&gt;用户也可以在 Flash Player 的“麦克风设置”面板中调整这些设置。&lt;/p&gt;

&lt;h5&gt;setLoopBack(state:Boolean=true)&lt;/h5&gt;

&lt;p&gt;将麦克风捕获的音频传送到本地扬声器。如果将本地麦克风的声音传递到本地扬声器，则会存在创建音频回馈循环的风险，这可能导致非常大的振鸣声，并且可能会损坏声音硬件。使用参数值true调用Microphone.setUseEchoSuppression()方法可降低发生音频回馈的风险，但不会完全消除该风险。建议始终在调用Mecrophone.setLoopback(true)之前调用Microphone.setUseEchoSuppression(true)，除非确信用户使用耳机来播放声音，或者使用除扬声器外的设备。在FMS直播中需设置false，不然会有吵杂声。&lt;/p&gt;

&lt;h5&gt;setSilenceLevel(silenceLevel:Number, timeout:int=-1)&lt;/h5&gt;

&lt;p&gt;设置可认定为有声的最低音量输入水平，以及实际静音前需经历的无声时间长度(可选)。此方法用于优化带宽。
     * 要完全禁止麦克风检测声音，请为selenceLevel传递值1000；这样就对不会调度activity事件了。
     * 要确定麦克风当前所检测的音量，请使用Microphone.activityLevel。
Speex具有语音活动检测功能(VAD)，在未检测到语音时将自动减少带宽。使用Speex编码器时，建议将静音级别设置为0.&lt;/p&gt;

&lt;p&gt;第一个参数： 激活麦克风并调度activity事件所需的音量。可接收值的范围为0到100。
第二个参数： 在没有活动的情况下经历过的毫秒数，必须经历这么长的时间，Flash Player才会认为声音已停止并调度dispatch事件。&lt;/p&gt;

&lt;h5&gt;framesPerPacket&lt;/h5&gt;

&lt;p&gt;在一个包（消息）中传输的 Speex 语音帧的数目。每帧长 20 ms。默认值为每个包两帧。&lt;/p&gt;

&lt;p&gt;消息中包含的 Speex 帧越多，需要的带宽就越小，但发送消息延迟的时间就越长。Speex 帧越少，需要的带宽就越大，而延迟的时间就会越短。&lt;/p&gt;

&lt;h5&gt;gain&lt;/h5&gt;

&lt;p&gt;麦克风放大信号的程度。有效值0到100。默认值为50。&lt;/p&gt;

&lt;h5&gt;codec&lt;/h5&gt;

&lt;p&gt;用于压缩音频的编解码器。可用编解码器为 Nellymoser（默认值）和 Speex。枚举类 SoundCodec 包含各种对 codec 属性有效的值。&lt;/p&gt;

&lt;p&gt;如果使用 Nellymoser 编解码器，可使用 Microphone.rate() 设置采样率。如果使用 Speex 编解码器，则采样率会设置为 16 kHz。&lt;/p&gt;

&lt;p&gt;Speex 具有语音活动检测功能 (VAD)，在未检测到语音时将自动减小带宽。使用 Speex 编解码器时，Adobe 建议将静音级别设置为 0。要设置静音级别，请使用 Microphone.setSilenceLevel() 方法。&lt;/p&gt;

&lt;h5&gt;rate&lt;/h5&gt;

&lt;p&gt;麦克风捕获声音时使用的速率，单位是 kHz。可接受的值为 5、8、11、22 和 44。如果您的声音捕获设备支持 8 kHz，则默认值为 8 kHz。否则，默认值是您的声音捕获设备支持的高于 8 kHz 的下一个可用捕获级别，通常为 11 kHz。 &lt;/p&gt;

&lt;p&gt;注意：实际速率与下表中注明的 rate 值稍有不同：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rate 值    实际频率
44  44,100 Hz
22  22,050 Hz
11  11,025 Hz
8   8,000 Hz
5   5,512 Hz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;encodeQuality&lt;/h5&gt;

&lt;p&gt;使用 Speex 编解码器时的编码语音品质。可能值为从 0 到 10 的值。默认值为 6。数字越大，表示品质越高，但需要更多的带宽，如下表所示。列出的比特率值表示净比特率，并不包括信息分包开销。&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;品质值&lt;/td&gt;
        &lt;td&gt;所需的比特率(KB/秒)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;0&lt;/td&gt;
        &lt;td&gt;3.95&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1&lt;/td&gt;
        &lt;td&gt;5.57&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;2&lt;/td&gt;
        &lt;td&gt;7.75&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;3&lt;/td&gt;
        &lt;td&gt;9.80&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;4&lt;/td&gt;
        &lt;td&gt;12.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;5&lt;/td&gt;
        &lt;td&gt;16.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;6&lt;/td&gt;
        &lt;td&gt;20.6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;7&lt;/td&gt;
        &lt;td&gt;23.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;8&lt;/td&gt;
        &lt;td&gt;27.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;9&lt;/td&gt;
        &lt;td&gt;34.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;10&lt;/td&gt;
        &lt;td&gt;42.2&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h5&gt;noiseSuppressionLevel&lt;/h5&gt;

&lt;p&gt;Speex 编码器使用的最大噪音衰减分贝数（负数）。如果启用，则在从 Microphone 捕获的声音进行 Speex 压缩之前应用噪音抑制。设置为 0 以禁用噪音抑制。默认启用噪音抑制，最大衰减为 -30 dB。选择 Nellymoser 编解码器时被忽略。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://www.adobe.com/cn/devnet/flashplayer/articles/acoustic-echo-cancellation.html&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/17/params-on-live</link>
                <guid>http://alonepig.github.io/fms/2014/07/17/params-on-live</guid>
                <pubDate>2014-07-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>air develop ios app</title>
                <description>&lt;p&gt;记录使用AIR开发IOS应用中的点点滴滴&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h4&gt;准备证书、供给配置文件&lt;/h4&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;首先，你得弄明白以下几个概念：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;证书签名请求文件&lt;/strong&gt;：包含用于生成开发证书的个人信息的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Certificates&lt;/strong&gt;：开发证书，用于标识以开发应用程序为目的的开发人员。由证书签名文件上传到apple站点后生成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;p112证书文件&lt;/strong&gt;：用来构建iphone应用。用于windows平台。由从apple站点下载的cer文件转换成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;供给配置文件(Provisioning)&lt;/strong&gt;：一个允许测试或分发iphone应用程序的文件。有几种类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开发供给配置文件：用于开发和测试。满足条件的设备可以安装&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分发供给配置文件：用于提交App Store。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;应用程序 ID&lt;/strong&gt;：标识由特定开发人员开发的 iPhone 应用程序（或多个应用程序）的唯一字符串。应在 iPhone 开发人员中心站点创建应用程序 ID。每个供给配置文件都具有一个关联的应用程序 ID 或应用程序 ID 模式。当开发应用程序时应使用此应用程序 ID（或模式）。应在 Flash Professional CS5 的“iPhone 设置” 对话框中或在应用程序描述符文件中使用应用程序 ID。&lt;/p&gt;

&lt;p&gt;iPhone 开发人员中心的应用程序 ID 包含一个绑定种子 ID （后面带有绑定标识符）。绑定种子 ID 是 Apple 分配给应用程序ID 的一个字符串，例如 5RM86Z4DJM。绑定标识符包含一个您选择的反向域名字符串。绑定标识符可能以星号 (*) 结尾，表示通配符应用程序 ID。例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;5RM86Z4DJM.com.example.helloWorld&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;96LPVWEASL.com.example.* （通配符应用程序 ID）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;iPhone 开发人员中心提供了两种应用程序 ID：&lt;/p&gt;

&lt;p&gt;• 通配符应用程序 ID — 在 iPhone 开发人员中心，这些应用程序 ID 以星号 (&lt;em&gt;) 结尾，例如96LPVWEASL.com.myDomain.&lt;/em&gt; 或 96LPVWEASL.&lt;em&gt;。借助使用这种应用程序 ID 的供给配置文件，您可以生成测试应用程序，并且这些应用程序使用的应用程序 ID 与该模式匹配。对于应用程序的应用程序 ID，您可以将星号替换为任何有效字符字符串。例如，如果 iPhone 开发人员中心站点将 96LPVWEASL.com.example.&lt;/em&gt; 指定为应用程序 ID，则您可以将 com.example.foo 或 com.example.bar 用作应用程序的应用程序 ID。&lt;/p&gt;

&lt;p&gt;• 特定应用程序 ID — 它们定义在应用程序中使用的唯一应用程序 ID。在 iPhone 开发人员中心，这些应用程序 ID 不以星号结尾。例如：96LPVWEASL.com.myDomain.myApp。借助使用这种应用程序 ID 的供给配置文件，应用程序必须与该应用程序 ID 完全匹配。例如，如果 iPhone 开发人员中心站点将 96LPVWEASL.com.example.helloWorld 指定为应用程序 ID，您必须将 com.example.foo 用作应用程序的应用程序 ID。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Devices&lt;/strong&gt;：可以安装应用程序的设备。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;App IDs&lt;/strong&gt;：应用程序ID。创建供给配置文件后，该供给配置文件会绑定到应用程序ID。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;在开发之前，你必须做的事情：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;成为apple开发人员&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生成证书请求文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.Mac OS中，打开钥匙串访问。选择&amp;quot;首选项&amp;quot;--&amp;gt;&amp;quot;证书助手&amp;quot;--&amp;gt;&amp;quot;从证书颁发机构请求证书&amp;quot;。&lt;/p&gt;

&lt;p&gt;2 填写相关资料，输入iPhone开发人员账户ID匹配的电子邮件地址。不要输入CA电子邮件地址。&lt;/p&gt;

&lt;p&gt;3.保存此文件(CertificateSigningRequest.certSingingRequest)。&lt;/p&gt;

&lt;p&gt;4.将此文件上传到https://developer.apple.com/account/ios/certificate/certificateList.action的证书列表中，审核通过后，下载对应的cer文件。如果是在windows下开发，还需要将其转换成p12文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开发人员证书转换为p12文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.打开钥匙串访问应用程序。&lt;/p&gt;

&lt;p&gt;2.将下载下来的证书添加到钥匙串，选择&amp;quot;文件&amp;quot;--&amp;gt;&amp;quot;导入&amp;quot;。&lt;/p&gt;

&lt;p&gt;3.选择密钥类别，选择与iPhone开发证书相关联的私钥，导出项目。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h4&gt;开发中遇到的问题&lt;/h4&gt;

&lt;p&gt;1.在iphone5或iphone中上下出现黑边。解决办法是在跟描述文件同目录下添加一个命名为Default-568@2x.png的空白图片，图片大小为1136*640。参考：&lt;/p&gt;

&lt;p&gt;http://blogs.adobe.com/airodynamics/2012/11/07/deploying-air-apps-on-iphone-5/&lt;/p&gt;

&lt;p&gt;http://zengrong.net/post/1752.htm/comment-page-1#comment-16642&lt;/p&gt;

&lt;p&gt;2.不同的版本需要添加不同的Icon。不然在上传ipa文件时会有警告或直接报错。&lt;/p&gt;

&lt;p&gt;ERROR ITMS-9000: &amp;quot;Missing required icon file. The bundle does not contain an app icon for iPhone / iPod touch of exactly &amp;#39;57x57&amp;#39; pixels, in .png fomat for iOS versions &amp;lt; 7.0.&amp;quot;&lt;/p&gt;

&lt;p&gt;这时候，你应该根据提示来添加不同尺寸的icon。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h4&gt;上传到AppStore&lt;/h4&gt;

&lt;p&gt;1.打开https://itunesconnect.apple.com，选择&amp;quot;Manage Your Applications&amp;quot;，点击&amp;quot;Add New App&amp;quot;，填写相关资料。需要注意的是Bundle ID属性，这个属性是可选择的，必须和你申请证书的appid保持一致。&lt;/p&gt;

&lt;p&gt;2.通过Mac OS中的application uploader工具上传ipa文件。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/akun1103/article/details/8632651&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://help.adobe.com/zh_CN/air/build/air_buildingapps.pdf&quot;&gt;air_deviphoneapps.pdf&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/air/2014/07/16/air-develop-ios-app</link>
                <guid>http://alonepig.github.io/air/2014/07/16/air-develop-ios-app</guid>
                <pubDate>2014-07-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>working with live video</title>
                <description>&lt;h4&gt;使用实时视频&lt;/h4&gt;

&lt;h5&gt;捕获实时流&lt;/h5&gt;

&lt;h6&gt;使用Flash Media Live Encoder捕获视频&lt;/h6&gt;

&lt;h6&gt;实例：自定义视频捕获应用&lt;/h6&gt;

&lt;h5&gt;添加DVR特征&lt;/h5&gt;

&lt;h5&gt;添加元数据&lt;/h5&gt;

&lt;h6&gt;关于元数据&lt;/h6&gt;

&lt;p&gt;元数据流媒体让用户有机会获得他们正在查看的信息媒体。元数据可以包含关于视频的信息,例如标题、版权信息、视频的时间,或创建日期。客户端可以使用元数据来设置宽度和高度的视频播放器&lt;/p&gt;

&lt;h6&gt;向实时流发送元数据&lt;/h6&gt;

&lt;p&gt;客户端中使用send发送元数据&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NetStream.send(@setDataFrame, onMetaData [, metadata]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onMetaData参数指定回调函数。你可以使用多个数据关键帧，每个数据关键帧必须使用唯一的监听器(如onMetaData1..)&lt;/p&gt;

&lt;p&gt;metadata参数可以是Object或Array类型。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var metaData:Object = new Object();
metaData.title = &amp;quot;myStream&amp;quot;;
metaData.width = 400;
metaData.height = 200;
ns.send(&amp;quot;@setDataFrame&amp;quot;, &amp;quot;onMetaData&amp;quot;, metaData);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;清空元数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ns.send(&amp;quot;@clearDataFrame&amp;quot;, &amp;quot;onMetaData&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了在服务器端添加元数据，使用以下代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;s = Stream.get(&amp;quot;myStream&amp;quot;);
metaData = new Object();
metaData.title = &amp;quot;myStream&amp;quot;;
metaData.width = 400;
metaData.height = 200;
s.send(&amp;quot;@setDataFrame&amp;quot;, &amp;quot;onMetaData&amp;quot;, metaData);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器端情况元数据:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.send(&amp;quot;@clearDataFrame&amp;quot;, &amp;quot;onMetaData&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;检索元数据&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;netstream.client = this;

function onMetaData(info:Object):void {
    var key:String;
    for (key in info) {
        trace(key + &amp;quot;: &amp;quot; + info[key]);
    }
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;实例：向实时视频添加元数据&lt;/h6&gt;

&lt;p&gt;这个客户端应用有以下功能：&lt;/p&gt;

&lt;p&gt;· 捕获和编码视频&lt;/p&gt;

&lt;p&gt;· 显示捕获的视频&lt;/p&gt;

&lt;p&gt;· 流从客户端到服务器端&lt;/p&gt;

&lt;p&gt;· 发送元数据到服务器，客户端播放流时服务器发送元数据到客户端&lt;/p&gt;

&lt;p&gt;· 显示来自服务器的流&lt;/p&gt;

&lt;p&gt;· 显示元数据&lt;/p&gt;

&lt;p&gt;参考 nstall/documentation/smaples/metadata&lt;/p&gt;

&lt;h6&gt;Flash Media Live Encoder 元数据属性&lt;/h6&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;元数据属性名&lt;/td&gt;
        &lt;td&gt;数据类型&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;lastkeyframetimestamp&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;width&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;height&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;videodatarate&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;audiodatarate&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;framerate&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;creationdate&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;createdby&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;audiocodecid&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;videocodecid&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;audiodelay&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h6&gt;被录制的实时流的元数据属性&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ns.publish(&amp;quot;myCamera&amp;quot;, &amp;quot;record&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你录制流，AMS会添加如下表格中的元数据：&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;元数据属性名&lt;/td&gt;
        &lt;td&gt;数据类型&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;audiocodecid&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;canSeekToEnd&lt;/td&gt;
        &lt;td&gt;Boolean&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;createdby&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;duration&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;creationdate&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;videocodecid&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    
&lt;/table&gt;

&lt;h5&gt;捕获来自Flash Media Live Encoder的时间码&lt;/h5&gt;

&lt;h5&gt;以RAW格式发布实时流&lt;/h5&gt;

&lt;h5&gt;不同服务器间的多点发布&lt;/h5&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/07/working-with-live-video</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/working-with-live-video</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>securing applications</title>
                <description>&lt;h4&gt;应用安全&lt;/h4&gt;

&lt;h5&gt;资源访问权限&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;关于访问控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当用户访问服务器的时候，默认情况下能访问所有的流和共享对象。你可以使用服务端的ActionScript创建动态访问控制列表。&lt;/p&gt;

&lt;p&gt;当一个客户端连接服务器，服务器脚本会传递一个Client对象。每个Client对象有readAccess和writeAccess属性。你可以使用这些属性来控制访问权限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现动态访问控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;clent.readAccess和client.writeAccess属性为字符串类型，值包含了用分号隔开的字符串。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;client.readAccess = &amp;quot;appStreams;/appSO/&amp;quot;;
client.writeAccess = &amp;quot;appStreams/public/;appSO/public/&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认值为&amp;quot;/&amp;quot;，表示可以访问所有的流和共享对象。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;允许访问流&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在main.asc中，添加onConnect()函数来指定目录文件夹：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function(client, name) {
    // give this new client the same name as passed in
    client.name = name;
    // give write access
    client.writeAccess = &amp;quot;appStreams/public/&amp;quot;;
    // accept the new client&amp;#39;s connection
    application.acceptConnection(client);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;拒绝访问流&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function(client, name) {
    ...
    // deny write access to the server
    client.writeAccess = &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;指定访问共享对象&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;指定共享对象的名字&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function(client, name) {
    ...
    client.writeAccess = &amp;quot;appSO/public/&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;客户端权限&lt;/h5&gt;

&lt;h6&gt;使用Client对象属性&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;检查客户端IP地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;client.ip，如果需要，可以拒绝客户端连接：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;if (client.ip.indexOf(&amp;quot;60.120&amp;quot;) !=0) {
    application.rejectConnection(client, {&amp;quot;Access Denied&amp;quot;} );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;检查原始URL&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;在main.asc中，client.referrer表示拒绝访问的URL列表。确保连接的客户端是来自你期望的地方。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;referrerList = {};
referrerList[&amp;quot;http://www.example.com&amp;quot;] = true;
referrerList[&amp;quot;http://www.abc.com&amp;quot;] = true;

if (!referrerList[client.referrer]) {
    application.rejectConnection(client, {&amp;quot;Access Denied&amp;quot;} );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用唯一的key&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.客户端中，创建一个唯一的key：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var keyDate = String(new Date().getTime());
var keyNum = String(Math.random());
var uniqueKey = keyDate + keyNum;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.发送到服务器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;nc.connect(&amp;quot;rtmp://www.example.com/someApplication&amp;quot;, uniqueKey);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.下面的代码在所有的连接中寻找唯一的key。如果key丢失或者已经存在，则拒绝连接。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function( pClient, uniqueKey ) {
    if ( uniqueKey != undefined ) { 
    // require a unique key with connection request
        if ( clientKeyList[uniqueKey] == undefined ) {
        // first time -- allow connection
            pClient.uniqueKey = uniqueKey;
            clientKeyList[uniqueKey] = pClient;
            this.acceptConnection(pClient);
        } else {
            trace( &amp;quot;Connection rejected&amp;quot; );
            this.rejectConnection(pClient);
        }
    }
}
application.onDisconnect = function( pClient ) {
    delete clientKeyList[pClient.uniqueKey];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用访问插件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Flash Player版本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有两种方法访问这个值：&lt;/p&gt;

&lt;p&gt;虚拟的key： 配置服务器重新映射基于Flash播放器客户端的流&lt;/p&gt;

&lt;p&gt;Client.agent 服务器端代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function( pClient ) {
    var platform = pClient.agent.split(&amp;quot; &amp;quot;);
    var versionMajor = platform[1].split(&amp;quot;,&amp;quot;)[0];
    var versionMinor = platform[1].split(&amp;quot;,&amp;quot;)[1];
    var versionBuild = platform[1].split(&amp;quot;,&amp;quot;)[2];
}

// output example
// Client.agent: WIN 9,0,45,0
// platform[0]: &amp;quot;WIN&amp;quot;
// versionMajor: 9
// versionMinor: 0
// versionBuild: 45
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;验证连接的swf文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在swf文件连接应用之前，你可以配置服务器来验证客户端swf的权限。验证swf的作用是为了防止有人自己创建swf来访问你的资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指定域时，允许或拒绝连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你知道合法客户端来自的域，则可以使用一个白名单。相反的，你也可以使用黑名单。&lt;/p&gt;

&lt;p&gt;在Adaptor.xml文件添加域列表。&lt;/p&gt;

&lt;p&gt;也可以在服务器端代码中保存。下面的例子中，文件bannedIPList.txt包含了不需要的IP地址：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// bannedIPList.txt file contents:
// 192.168.0.1
// 128.493.33.0

function getBannedIPList() {
    var bannedIPFile = new File (&amp;quot;bannedIPList.txt&amp;quot;) ;
    bannedIPFile.open(&amp;quot;text&amp;quot;,&amp;quot;read&amp;quot;);
    application.bannedIPList = bannedIPFile.readAll();
    bannedIPFile.close();
    delete bannedIPFile;
}

application.onConnect = function(pClient) {
    var isIPOK = true;
    getBannedIPList();
    for (var index=0; index&amp;lt;this.bannedIPList.length; index++) {
        var currentIP = this.bannedIPList[index];
        if (pClient.ip == currentIP) {
            isIPOK = false;
            trace(&amp;quot;ip was rejected&amp;quot;);
            break;
        }
    }

    if (isIPOK) {
        this.acceptConnection(pClient);
    } else {
        this.rejectConnection(pClient);
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此外，你也能检查来自特殊域的请求来的太快：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.VERIFY_TIMEOUT_VALUE = 2000;
Client.prototype.verifyTimeOut = function() {
    trace (&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Closing Connection&amp;quot;)
    clearInterval(this.$verifyTimeOut);
    application.disconnect(this);
}

function VerifyClientHandler(pClient) {
    this.onResult = function (pClientRet) {
        // if the client returns the correct key, then clear timer
        if (pClientRet.key == pClient.verifyKey.key) {
            trace(&amp;quot;Connection Passed&amp;quot;);
            clearInterval(pClient.$verifyTimeOut);
        }
    }
}

application.onConnect = function(pClient) {
    this.acceptConnection(pClient);
    // create a random key and package within an Object
    pClient.verifyKey = ({key: Math.random()});

    // send the key to the client
    pClient.call(&amp;quot;verifyClient&amp;quot;,
        new VerifyClientHandler(pClient),
        pClient.verifyKey);

    // set a wait timer
    pClient.$verifyTimeOut = setInterval(pClient,
        $verifyTimeOut,
        this.VERIFY_TIMEOUT_VALUE,
        pClient);
}

application.onDisconnect = function(pClient) {
    clearInterval(pClient.$verifyTimeOut);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;用户权限&lt;/h5&gt;

&lt;h6&gt;使用额外资源的权限&lt;/h6&gt;

&lt;p&gt;对于有限的观众来说，这是他们使用数据库等资源的有效的凭证(登录和密码)。&lt;/p&gt;

&lt;p&gt;1.swf向连接请求提供要给用户认证。&lt;/p&gt;

&lt;p&gt;客户端一般提供账号和密码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var sUsername = &amp;quot;someUsername&amp;quot;;
var sPassword = &amp;quot;somePassword&amp;quot;;
nc.connect(&amp;quot;rtmp://server/secure1/&amp;quot;, sUsername, sPassword);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.AMS验证凭证。&lt;/p&gt;

&lt;p&gt;你可以使用WebService、LoadVars、XML、NetServices等技术来做验证。&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/07/securing-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/securing-applications</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>developing streaming media applications</title>
                <description>&lt;h4&gt;开发流媒体应用&lt;/h4&gt;

&lt;h5&gt;连接服务器&lt;/h5&gt;

&lt;h5&gt;管理连接&lt;/h5&gt;

&lt;h5&gt;流媒体文件&lt;/h5&gt;

&lt;h5&gt;检查视频文件&lt;/h5&gt;

&lt;h5&gt;处理错误&lt;/h5&gt;

&lt;h5&gt;使用播放列表&lt;/h5&gt;

&lt;h5&gt;动态流&lt;/h5&gt;

&lt;h5&gt;当连接断掉时重连流&lt;/h5&gt;

&lt;h6&gt;重连ActionScript API&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NetStream.attach(connection:NetConnection)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetStreamPlayTransitions.RESUME&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetStreamPlayTransitions.APPEND&lt;em&gt;AND&lt;/em&gt;WAIT&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetConnection.Connect.Closed&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用这个事件来重连流&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NetConnection.Connect.NetworkChange&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通知客户端网络连接改变了。&lt;/p&gt;

&lt;h6&gt;使用ActionScript API重连流&lt;/h6&gt;

&lt;p&gt;当NetConnection由于网络改变关闭，流会使用存在的缓存播放一会。同时，客户端代码重连服务器来恢复播放流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重连单一流&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用NetConnection.call()连接服务器A&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个NetStream。设置NetStream.bufferTime使得其有足够的数据在连接断开后播放一会儿。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用NetStream.play2()，使用NetStreamPlayTransitions.RESET来播放&amp;quot;myStream&amp;quot;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监听NetConnection的&amp;quot;NetConnection.Connect.Closed&amp;quot;事件，如果流断掉了则重连服务器。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用NetStream.attach(connection:NetConnection)函数使NetStream附加到新的连接上。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用NetStream.play2()，使用NetStreamPlayTransitions.RESUME来播放&amp;quot;myStream&amp;quot;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你想重连的话，不要调用NetConnection.close()或NetStream.close()。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;重连播放列表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务器负载均衡&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用NetStream.attch(connection:NetConnection)来连接其他的服务器&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;成功连接后，调用以前连接上的NetConnection.close()，防止数据泄露。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用 NetStream.play2() 并设置 NetStreamPlayOptions.transition 的值以执行恢复。将其余的 NetStreamPlayOptions 属性设置为最初调用 NetStream.play() 或 NetStream.play2() 时使用的值以启动流。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;监控网络接口改变&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;监控移动设备上的连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;监控RTMPS或RTMPT连接&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;授权插件事件和属性&lt;/h6&gt;

&lt;h6&gt;服务器日志&lt;/h6&gt;

&lt;p&gt;下面的事件在流重连时会写入AMS日志文件中：
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;事件&lt;/td&gt;
        &lt;td&gt;目录&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;connect&lt;/td&gt;
        &lt;td&gt;session&lt;/td&gt;
        &lt;td&gt;重新建立连接后&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;play&lt;/td&gt;
        &lt;td&gt;stream&lt;/td&gt;
        &lt;td&gt;流恢复播放&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;stop&lt;/td&gt;
        &lt;td&gt;stream&lt;/td&gt;
        &lt;td&gt;流停止播放&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h5&gt;快速切换流&lt;/h5&gt;

&lt;h5&gt;快速搜索&lt;/h5&gt;

&lt;h5&gt;检测带宽&lt;/h5&gt;

&lt;h6&gt;ActionScript3.0 本地带宽检测&lt;/h6&gt;

&lt;p&gt;NetConnect.call(&amp;quot;checkBandWidth&amp;quot;, null);&lt;/p&gt;

&lt;p&gt;Application.xml允许带宽检测&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;BandwidthDetection enabled=&amp;quot;true&amp;quot;&amp;gt;
&amp;lt;MaxRate&amp;gt;-1&amp;lt;/MaxRate&amp;gt;
&amp;lt;DataSize&amp;gt;16384&amp;lt;/DataSize&amp;gt;
&amp;lt;MaxWait&amp;gt;2&amp;lt;/MaxWait&amp;gt;
&amp;lt;/BandwidthDetection&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;监听事件，必须实现onBWCheck和onBWDone两个函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Client {
    public function onBWCheck(... rest):Number {
        return 0;
    }
    public function onBWDone(... rest):void {
        var bandwidthTotal:Number;
        if (rest.length &amp;gt; 0){
            bandwidthTotal = rest[0];
            // This code runs
            // when the bandwidth check is complete.
            trace(&amp;quot;bandwidth = &amp;quot; + bandwidthTotal + &amp;quot; Kbps.&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onBWCheck()函数是必须的。该函数返回一个值，即使是0，也表明告诉服务器客户端接收到了数据，你可以调用onBWCheck()了。&lt;/p&gt;

&lt;p&gt;服务器会在检测带宽之后调用onBWDone()函数。它有四个参数。第一个表示带宽(Kbps)。第二个、第三个还没用到，第四个表示延迟&lt;/p&gt;

&lt;h6&gt;服务器端初始化带宽检测&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function (clientObj){
    this.acceptConnection(clientObj);
    clientObj.checkBandwidth();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不需要在客户端手动调用checkBandwidth()函数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在应用级别禁用带宽检测&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;修改配置文件rootinstall/applications/applicationname/Application.xml&lt;/p&gt;

&lt;p&gt;&lt;Application&gt;
    &lt;Client&gt;
        &lt;BandwidthDetection enabled=&quot;false&quot;&gt;
        &lt;/BandwidthDetection&gt;
    &lt;/Client&gt;
&lt;/Application&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改rootinstall/conf/&lt;em&gt;defaultRoot/&lt;/em&gt;defaultVHost/Application.xml&lt;/p&gt;

&lt;p&gt;&lt;Application&gt;
    ...
    &lt;Client&gt;
        ...
        &lt;BandwidthDetection enabled=&quot;false&quot;&gt;
        &lt;/BandwidthDetection&gt;
        ...
    &lt;/Client&gt;
    ...
&lt;/Application&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;检测流长度&lt;/h5&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/07/developing-streaming-media-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/developing-streaming-media-applications</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>developing social applications</title>
                <description></description>
                <link>http://alonepig.github.io/fms/2014/07/07/developing-social-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/developing-social-applications</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>building peer assisted networking applications</title>
                <description>&lt;h4&gt;构建对等的网络应用&lt;/h4&gt;

&lt;h5&gt;RTMFP&lt;/h5&gt;

&lt;p&gt;Flash Player10和AIR1.5支持实时媒体流协议(RTMFP)。RTMFP是建立在UDP协议上的。RTMP是建立在TCP协议上的。UDP提供了更低的延迟。
它能够在两个客户端之间直接传输。&lt;/p&gt;

&lt;p&gt;RTMFP提供了以下特征：NAT/firewall traversal, congestion control 和 prioritization， IP地址， mobility， partial reliability。&lt;/p&gt;

&lt;p&gt;RTMFP使用了128位加密传输。为了播放RTMFP的流，客户端必须知道发布者的节点ID。节点ID是一个256位的发布者标识符。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.adobe.com/devnet/adobe-media-server/articles/real-time-collaboration.html&quot;&gt;Best practices for real-time collaboration using Adobe Media Server&lt;/a&gt;&lt;/p&gt;

&lt;h6&gt;关于节点ID&lt;/h6&gt;

&lt;p&gt;每个客户端都有一个节点ID。&lt;/p&gt;

&lt;p&gt;NetConnection.nearID为客户端节点ID，NetConnection.farID为服务器节点ID。&lt;/p&gt;

&lt;p&gt;同理在服务器中，client.nearID为服务器节点ID，client.farID为客户端节点ID。&lt;/p&gt;

&lt;p&gt;NetConnection.nearID和client.farID值一样，NetConnection.farID和client.nearID值一样。&lt;/p&gt;

&lt;p&gt;服务器端还有NetConnection.nearID和NetConnection.farID属性，包含了RTMFP连接的所有节点ID。&lt;/p&gt;

&lt;h6&gt;RTMFP上的单一传播，广播，多点发布&lt;/h6&gt;

&lt;p&gt;虽然RTMFP经常在对等网络应用中使用，你也可以使用RTMFP在单一传播、广播、多点发布上。简单的替换RTMP协议即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;netconnection.connect(&amp;quot;rtmfp://fms.exmaple.com/vod&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了在多点发布中使用RTMFP，创建一个服务器端的NetConnection，使用RTMFP URL连接目标服务器。&lt;/p&gt;

&lt;h5&gt;RTMFP 组&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;Peer&lt;/strong&gt; 节点，组的成员，也叫&amp;quot;node&amp;quot;。一个节点就是一个Flash Player或AIR客户端。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Group&lt;/strong&gt; 1个或多个RTMFP节点组成的集合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bootstrapping&lt;/strong&gt; 为了加入组，连接至少一个组成员。你可以写应用逻辑来使得要给客户端加入一个组，或者可以请求AMS自动引导客户端。&lt;/p&gt;

&lt;p&gt;组里的节点可以不经过服务器进行数据传输。节点可以共享数据。&lt;/p&gt;

&lt;p&gt;使用ActionScript3 GroupSpecifier类来定义组的&amp;quot;groupspec&amp;quot;。传递给NetGroup和NetStream的构造函数。使用NetGroup类管理组和发送ActionScript对象。使用
NetStream类来多播音频和视频。&lt;/p&gt;

&lt;p&gt;Groupspecs字符串以&amp;quot;G:&amp;quot;开头，后面接着一串十六进制的数字。&lt;/p&gt;

&lt;h6&gt;创建一个组&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;连接AMS
NetConnection.connect(&amp;quot;rtmfp://fms.exmaple.com/p2pexample/test1&amp;quot;);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：如果Adaptor.xml文件将RTMFP禁用了，客户端会接收&amp;quot;NetConnection.Connect.Failed&amp;quot;状态。   &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在&amp;quot;NetConnection.Connect.Success&amp;quot;中，使用GroupSpecifier类来额创建一个groupspec&lt;/p&gt;

&lt;p&gt;// Called in the &amp;quot;NetConnection.Connect.Success&amp;quot; case in the NetStatusEvent handler.
private function OnConnect():void{
    connected = true;
    // Create a GroupSpecifier object to pass to the NetGroup constructor.
    // The GroupSpecifier determines the properties of the group
    var groupSpecifier:GroupSpecifier;
    groupSpecifier = new GroupSpecifier(&amp;quot;com.example.p2papp&amp;quot;);
    groupSpecifier.postingEnabled = true;
    groupSpecifier.multicastEnabled = true;
    // The serverChannel lets the server do auto-bootstrapping
    groupSpecifier.serverChannelEnabled = true;
    netGroup = new NetGroup(netConnection, groupSpecifier.groupspecWithAuthorizations());
    netGroup.addEventListener(NetStatusEvent.NET_STATUS, NetStatusHandler);
}&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&amp;quot;NetGroup.Connect.Success&amp;quot;中，你可以手动或自动引导节点。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6&gt;向组里引导一个节点&lt;/h6&gt;

&lt;p&gt;连接到服务器后，一个节点必须被加入到一个组里，这个技术叫做&amp;quot;bootstrapping&amp;quot;。Bootstrapping允许同一个组的成员互相可见。&lt;/p&gt;

&lt;p&gt;为了加入一个组，客户端必须知道组定义的GroupSpecifier。如果两个客户端使用相同的GroupSpecifier，但从不联系，则他们在不同的组。如果两个组有联系，
那他们会合并为一个大组。&lt;/p&gt;

&lt;p&gt;每一个客户端都有一个节点ID。客户端和服务器端都可以访问节点ID。&lt;/p&gt;

&lt;p&gt;RTMFP中的节点可以使用以下的方法进行引导：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务器自动引导。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当客户端进行RTMFP连接时，服务器使用相同的NetGroup引导他们。客户端需要设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;GroupSpecifier.serverChannelEnabled为true。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;手动引导&lt;/p&gt;

&lt;p&gt;调用NetGroup.addNeighbor()方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LAN节点发现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用GroupSpecifier类可以激活局域网节点发现。局域网节点发现允许ERMFP NetConnection和NetStream、NetGroup对象自动定位节点和加入组的子组。
下面的代码展示了如果激活LAN节点发现：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var nc = new NetConnection();
// Protocol must be RTMFP
nc.connect(&amp;quot;rtmfp://fms.example.com/appname/appinstance&amp;quot;);
var gs = new GroupSpecifier(&amp;quot;com.example.discovery-test&amp;quot;);
// Must be enabled for LAN peer discovery to work
gs.ipMulticastMemberUpdatesEnabled = true;
// Multicast address over which to exchange peer discovery.
gs.addIPMulticastAddress(&amp;quot;224.0.0.255:30000&amp;quot;);
// Additional GroupSpecifier configuration...
var ns = new NetStream(nc, gs.toString());  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;服务端的RTMFP组&lt;/h6&gt;

&lt;p&gt;使用服务器端的ActionScript来创建一个RTMFP连接。一个服务器端的netConnection是一个虚拟的Flash客户端。它有自己的RTMFP栈。&lt;/p&gt;

&lt;p&gt;注意：服务器端的ActionScript不支持直接在节点之间创建连接。&lt;/p&gt;

&lt;h6&gt;Flash Player 对等节点网络应用安全对话框&lt;/h6&gt;

&lt;p&gt;当groupsec传递给了NetStream或NetGroup。Flash Player会显示一个&amp;quot;对等互助网络&amp;quot;对话框。该对话框询问用户是否可以使用它们的连接在节点之间共享数据。&lt;/p&gt;

&lt;p&gt;如果用户点击允许，对话框就不会在出现。如果用户不允许，所有节点特征将不能使用。你可以使用RTMFP订阅一个纯净的本地IP多播流，这种情况下，对话框不会出现。&lt;/p&gt;

&lt;p&gt;当使用IP多播时(没有对等网络的功能)，你可以禁用安全对话框，设置GroupSpecifier.peerToPeerDisabled属性为true。默认为false。&lt;/p&gt;

&lt;h6&gt;关于RRMFP组的ActionScript类&lt;/h6&gt;

&lt;p&gt;使用下面的ActionScript类和服务器端ActionScript类来创建RTMFP应用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NetConnection&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GroupSpecifier&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup：管理RTMFP组。该类属性提供了组成员的信息&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroupInfo：指定传输质量。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetStream：&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetStreamMulticastInfo：NetStream.multicastinfo 返回当前Qos状态的NetStreamMulticastInfo对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;向组里发送一个消息&lt;/h6&gt;

&lt;p&gt;调用NetGroup.post()方法广播一个ActionScript消息。使用&amp;quot;NetGroup.Posting.Notify&amp;quot;接收。&lt;/p&gt;

&lt;p&gt;这个方法类似于服务器端的Application.broadcastMsg()。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GroupSpecifier.postingEnabled属性必须为true。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接收NetGroup.Neighbor.Connect事件早于你调用post()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息使用AMF序列化。一个消息可以是任何形式的AMF对象。不能是MovieClip。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息传输是无序的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;post()方法返回一个消息ID或null或error。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;post()方法发送一个NetStatusEvent事件&amp;quot;NetGroup.Posting.Notify&amp;quot;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private function OnConnect():void{
    StatusMessage(&amp;quot;Connected\n&amp;quot;);
    connected = true;
    // Create a GroupSpecifier object to pass to the NetGroup constructor.
    // The GroupSpecifier determines the properties of the group
    var groupSpecifier:GroupSpecifier;
    groupSpecifier = new GroupSpecifier(&amp;quot;com.aslrexample/&amp;quot; + groupNameText.text);
    groupSpecifier.postingEnabled = true;
    groupSpecifier.serverChannelEnabled = true;
    netGroup = new NetGroup(netConnection, groupSpecifier.groupspecWithAuthorizations());
    netGroup.addEventListener(NetStatusEvent.NET_STATUS, NetStatusHandler);
    StatusMessage(&amp;quot;Join \&amp;quot;&amp;quot; + groupSpecifier.groupspecWithAuthorizations() + &amp;quot;\&amp;quot;\n&amp;quot;);
}
// Called when you the chatText field has focus and you press Enter.
private function DoPost(e:ComponentEvent):void{
    if(joinedGroup){
        // Build the message to post.
        var message:Object = new Object;
        message.user = userNameText.text;
        message.text = chatText.text;
        message.sequence = sequenceNumber++;
        message.sender = netConnection.nearID;
        // Post the message to the group.
        netGroup.post(message);
        StatusMessage(&amp;quot;==&amp;gt; &amp;quot; + chatText.text + &amp;quot;\n&amp;quot;)
    } else {
        StatusMessage(&amp;quot;Click Connect before sending a chat message&amp;quot;);
    }
    ClearChatText();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;直接向某个节点发送消息&lt;/h6&gt;

&lt;p&gt;客户端能直接向组里的一个节点发送消息而不经过服务器。这个特征叫做directed routing。&lt;/p&gt;

&lt;p&gt;下面是服务器端directed routing API：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Netgroup.sendToAllNeighbors()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToNearest()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToNeighbor()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToAllNeighbors()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToNearest()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.sendToNeighbor()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;在组里复制一个对象&lt;/h6&gt;

&lt;p&gt;客户端可以在组里发送ActionScript对象。这个特征叫做object replication(对象复制)。使用该特征可以复制工作空间，创建白板，传输文件，同步节点操作等。&lt;/p&gt;

&lt;p&gt;使用以下客户端API：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NetGroup.addHaveObjects()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.addWantObjects()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.denyRequestedObject()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.removeHaveObjects()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.removeWantObjects()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetGroup.writeRequestedObject()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用以下服务器端API：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ByteArray 类&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;File.readBytes()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;File.writeBytes()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;多播&lt;/h6&gt;

&lt;p&gt;多播是向一个组里的多用户分配视频和音频。服务器不向客户端发送数据。多播允许部分发布者发送大量的数据。为了多播媒体，向NetStream构造器传递groupspec。对多播数据调用NetStream.publish()
或NetStream.play()。&lt;/p&gt;

&lt;p&gt;AMS支持应用级别的多播和IP多播。你可以对一个流同时使用应用多播和IP多播，这种情况叫做multicast fusion(多播融合)。&lt;/p&gt;

&lt;p&gt;关于多播，需要理解的地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;任何数量的流都可以在组内被发布。However, this practice is not recommended because each group member consumes and relays all streams, even if the streams aren’t playing at that specific client&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同名的流可以在组内被发布。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发布者可以调用NetStream.send()来向组里注入数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When a client is in an RTMFP group in which a live multicast stream is playing, the client may act as a relay point for that stream to some number of direct neighbors. To control this number, use the
NetStream.multicastPushNeighborLimit
property. The default value is to 4. All the peers within a group work
co-operatively to get the stream to each other. Each client is not pulling the stream from the server independently. For this reason, consider the expected average client uplink capacity when selecting the bitrate for the multicast stream you publish. Choosing a bitrate that&amp;#39;s too high may result in peers not being able to relay the stream smoothly.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;应用级别多播&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;By default, the peer-to-peer mesh distributes streams published into an RTMFP group&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP 多播&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IP多播使用路由器发送数据到指定的IP地址。&lt;/p&gt;

&lt;p&gt;为了发布流到IP多播地址，在发布前调用服务器端方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NetStream.setIPMulticastPublishAddress()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的订阅节点必须添加IP多播地址。GroupSpecifier.addIPMulticastAddress()&lt;/p&gt;

&lt;p&gt;默认情况下，应用级别多播和IP多播是并行的。这个技术叫做&amp;quot;fusion multicast&amp;quot;。为了运行IP多播而不用应用级别多播，设置以下属性：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;GroupSpecifier.peerToPeerDisabled=true

//关闭点对点多播
GroupSpecifier.multicastEnabled=true 

调用GroupSpecifier.addIPMulticastAddress()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Source-specific IP multicast&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建客户端无服务器的RTMFP连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;融合多播&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;检查多播服务的质量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent the server from unloading an application&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ingest, convert, and record a multicast stream&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;对等网络应用实例&lt;/h6&gt;

&lt;h5&gt;Distribute peer introductions across servers&lt;/h5&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/07/building-peer-assisted-networking-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/07/building-peer-assisted-networking-applications</guid>
                <pubDate>2014-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>getting started developing applications</title>
                <description>&lt;h4&gt;开始开发应用&lt;/h4&gt;

&lt;h5&gt;应用结构&lt;/h5&gt;

&lt;p&gt;典型的AMS应用有以下部分：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Client&lt;/strong&gt; 客户端显示用户界面，如控制视频的播放、停止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Client-side ActionScript&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Video or audio files&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Camera or Microphone&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Server-Side ActionScript&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;设置开发环境&lt;/h5&gt;

&lt;p&gt;你可以使用任何版本的AMS来开发和测试应用。为了写客户端代码，可以使用Flash Professional，Flash Builder等。
任何文本编辑器写服务器端代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设置开发环境:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、安装AMS&lt;/p&gt;

&lt;p&gt;2、验证是否安装成功&lt;/p&gt;

&lt;p&gt;3、安装Flash Professional或Flash Builder或Flex SDK&lt;/p&gt;

&lt;p&gt;4、捕获和编码视频&lt;/p&gt;

&lt;p&gt;a 连接一个摄像头或麦克风&lt;/p&gt;

&lt;p&gt;b 下载和安装Adobe Media Live Encoder&lt;/p&gt;

&lt;h5&gt;实例：Hello World应用&lt;/h5&gt;

&lt;h6&gt;概要&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 以下内容不能在Adobe Media Streaming Server中使用，因为你不能在这个版本上写服务器端代码&lt;/p&gt;

&lt;p&gt;这个例子展示了客户端的简单通讯。实例文件在rootinstall/documentation/samples/Hello World文件夹。&lt;/p&gt;

&lt;h6&gt;写用户接口&lt;/h6&gt;

&lt;h6&gt;写客户端脚本&lt;/h6&gt;

&lt;p&gt;package {
import flash.display.MovieClip;
import flash.net.Responder;
import flash.net.NetConnection;
import flash.events.NetStatusEvent;
import flash.events.MouseEvent;
public class HelloWorld extends MovieClip {&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public function HelloWorld() {
    textLbl.text = &amp;quot;&amp;quot;;
    connectBtn.label = &amp;quot;Connect&amp;quot;;
    connectBtn.addEventListener(MouseEvent.CLICK, connectHandler);
}

public function connectHandler(event:MouseEvent):void {
    if (connectBtn.label == &amp;quot;Connect&amp;quot;) {
        trace(&amp;quot;Connecting...&amp;quot;);
        nc = new NetConnection();
        // Connect to the server.
        nc.connect(&amp;quot;rtmp://localhost/HelloWorld&amp;quot;);
        // Call the server&amp;#39;s client function serverHelloMsg, in HelloWorld.asc.
        nc.call(&amp;quot;serverHelloMsg&amp;quot;, myResponder, &amp;quot;World&amp;quot;);
        connectBtn.label = &amp;quot;Disconnect&amp;quot;;
    } else {
        trace(&amp;quot;Disconnecting...&amp;quot;);
        // Close the connection.
        nc.close();
        connectBtn.label = &amp;quot;Connect&amp;quot;;
        textLbl.text = &amp;quot;&amp;quot;;
    }
}

private function onReply(result:Object):void {
    trace(&amp;quot;onReply received value: &amp;quot; + result);
    textLbl.text = String(result);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;}
}&lt;/p&gt;

&lt;h6&gt;写服务器端脚本&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function( client ) {
    client.serverHelloMsg = function( helloStr ) {
    return &amp;quot;Hello, &amp;quot; + helloStr + &amp;quot;!&amp;quot;;
}
application.acceptConnection( client );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;编译和运行应用&lt;/h6&gt;

&lt;p&gt;1、运行服务器&lt;/p&gt;

&lt;p&gt;2、编译客户端文件&lt;/p&gt;

&lt;p&gt;3、测试。&lt;/p&gt;

&lt;h5&gt;创建应用的概要&lt;/h5&gt;

&lt;h6&gt;客户端代码&lt;/h6&gt;

&lt;h6&gt;服务器端代码&lt;/h6&gt;

&lt;p&gt;一般来说，有如下需求的时候服务器端需要写代码：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Authenticate clients&lt;/strong&gt; 权限验证&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Implement connection logic&lt;/strong&gt; 实现连接的逻辑&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update clients&lt;/strong&gt; 通过调用远程方法来更新客户端的共享数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Connect to other server&lt;/strong&gt;  向某个应用或数据库调用web service或socket&lt;/p&gt;

&lt;p&gt;服务器端的代码入口为main.asc或yourApplicationName.asc。&lt;/p&gt;

&lt;p&gt;该文件应在应用的主目录中，或scripts子目录中。&lt;/p&gt;

&lt;p&gt;rootinstall/applications/appName&lt;/p&gt;

&lt;p&gt;rootinstall/applications/appName/scripts&lt;/p&gt;

&lt;p&gt;默认情况下，应用文件夹在安装目录的的applications文件中，也可以在fms.ini或Vhost.xml文件中设置VHOST.APPSDIR。
在Vhost.xml文件中，编辑AppsDir。&lt;/p&gt;

&lt;h5&gt;测试应用&lt;/h5&gt;

&lt;h6&gt;测试和调试客户端脚本&lt;/h6&gt;

&lt;h6&gt;测试和调试服务器端脚本&lt;/h6&gt;

&lt;p&gt;使用trace()，输出相关数据。日志信息也会保存在rootinstall/logs/&lt;em&gt;defaultVHost&lt;/em&gt;/yourApplicationName/yourInstanceName/application.xx.log文件中&lt;/p&gt;

&lt;p&gt;使用管理员控制台。修改.asc文件之后，需要重启应用才会生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用管理员控制台调试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可调式行和可调试会话数由Application.xml配置文件的AllowDebugDefault和MaxPendingDebugConnections决定。默认情况下，是不可调试的。
也可以使用服务器端代码开启调试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.allowDebug = true;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;部署应用&lt;/h5&gt;

&lt;h6&gt;注册应用&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;myNetConnection.connect(&amp;quot;rtmp://fms.examples.com/myApplication&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;复制服务器端脚本文件到服务器&lt;/h6&gt;

&lt;h6&gt;复制多媒体文件&lt;/h6&gt;

&lt;h6&gt;复制客户端文件到web服务器&lt;/h6&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/04/getting-started-developing-applications</link>
                <guid>http://alonepig.github.io/fms/2014/07/04/getting-started-developing-applications</guid>
                <pubDate>2014-07-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>communication between client and server</title>
                <description>&lt;h4&gt;一、客户端呼叫服务器&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;服务器main.asc代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Client.prototype.serverFun1 = function(value)
{
    return &amp;quot;value=&amp;quot; +value;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;客户端代码：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&lt;mx:Application xmlns:mx=&quot;http://www.adobe.com/2006/mxml&quot; layout=&quot;absolute&quot; 
    fontSize=&quot;12&quot; creationComplete=&quot;init()&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;mx:Script&amp;gt;
    &amp;lt;![CDATA[    
    import mx.controls.Alert;

    private var netConnection:NetConnection;
    private var responder:Responder;
    private var appServer:String=&amp;quot;rtmp://127.0.0.1/TestCode1&amp;quot;;

    private function init():void
    {
        netConnection = new NetConnection();
        netConnection.connect(appServer);
        netConnection.client=this;
    }

    private function onClick(evt:MouseEvent):void
    {
        responder = new Responder(OkFun,ErrorFun);
        netConnection.call(&amp;quot;serverFun1&amp;quot;,responder,&amp;quot;va&amp;quot;);
    }

    private function OkFun(re:String):void
    {
        Alert.show(re);
    }

    private function ErrorFun(info:Object):void
    {
        Alert.show( &amp;quot;error: &amp;quot; + info.description );
        Alert.show( &amp;quot;error: &amp;quot; + info.code );
    }

    ]]&amp;gt;
&amp;lt;/mx:Script&amp;gt;
&amp;lt;mx:Button x=&amp;quot;43&amp;quot; y=&amp;quot;65&amp;quot; label=&amp;quot;调用服务器&amp;quot; id=&amp;quot;btn&amp;quot; click=&amp;quot;onClick(event)&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;/mx:Application&quot;&gt;/mx:Application&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Responder 类提供了一个对象，该对象是NetConnection.call()中回调函数。&lt;/p&gt;

&lt;p&gt;NetConnection.call的参数分别表示：服务器端方法名、处理服务器的返回值函数(可选对象)、传递给服务器的参数&lt;/p&gt;

&lt;h4&gt;二、服务器端呼叫指定的客户端&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;服务器main.asc代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var handlerObject = function() {};

handlerObject.prototype.onResult = function( result )
{
    trace( result );
};

handlerObject.prototype.onStatus = function( info )
{
    trace( &amp;quot;error: &amp;quot; + info.description );
    trace( &amp;quot;error: &amp;quot; + info.code );
};

application.onConnect = function( client )
{
    this.acceptConnection( client );
    var msg = &amp;quot;Hello client, your IP is: &amp;quot; + client.ip;
    client.call( &amp;quot;asyncServerCall&amp;quot;, new handlerObject, msg );
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;客户端代码：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&lt;mx:Application xmlns:mx=&quot;http://www.adobe.com/2006/mxml&quot; layout=&quot;absolute&quot; 
    fontSize=&quot;12&quot; creationComplete=&quot;init()&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;mx:Script&quot;&gt;mx:Script&lt;/a&gt;
    &amp;lt;![CDATA[
        import mx.controls.Alert;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    private var netConnection:NetConnection;
    private var appServer:String=&amp;quot;rtmp://192.168.0.249/TestCode1&amp;quot;;

    private function init():void
    {
        netConnection = new NetConnection();
        netConnection.connect(appServer);
        netConnection.client=this;
    }

    public function asyncServerCall( msg:String ) : String 
       {
           Alert.show( msg );
           return &amp;quot;I got your message Thanks Server!&amp;quot;;
       }

]]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;/mx:Script&quot;&gt;/mx:Script&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/mx:Application&quot;&gt;/mx:Application&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Client.call(methodName, [resultObj, [p1, ..., pN]]) 在Flash客户机上异步的执行一个方法，并把值从Flash客户机返回到服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;resultObj：客户端的方法名&lt;/p&gt;

&lt;p&gt;[resultObj, [p1, ..., pN]]： 当发送者期待一个来自客户机的返回值时需要这个参数。如果参数被传递但没有返回值被期待的话，则传递值null。结果对象可以是你定义的任何对象，并且，为了有用起见，这个结果对象应该有两个方法-onResult和onStatus，这些方法会在结果到达时被调用。如果远端方法的调用是成功的，则resultObj.onResult会被调用；否则，resultObj.onStatus被触发。&lt;/p&gt;

&lt;h4&gt;三、服务端呼叫所有客户端(广播)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;服务器main.asc代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;application.onConnect = function(currentClient)
{
    application.acceptConnection(currentClient);
    application.broadcastMsg(&amp;quot;showServerMsg&amp;quot;,application.clients.length );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;客户端代码：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&lt;mx:Application xmlns:mx=&quot;http://www.adobe.com/2006/mxml&quot; layout=&quot;absolute&quot;
 fontSize=&quot;12&quot; creationComplete=&quot;init()&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;mx:Script&amp;gt;
    &amp;lt;![CDATA[

    import mx.controls.Alert;

    private var netConnection:NetConnection;
    private var appServer:String=&amp;quot;rtmp://192.168.0.249/TestCode1&amp;quot;;

    private function init():void
    {
        netConnection = new NetConnection();
        netConnection.connect(appServer);
        netConnection.client=this;
    }

    public function showServerMsg( n:Number ) :void
       {
           var msg:String =&amp;quot;已经有&amp;quot;+n.toString()+&amp;quot;位用户连接&amp;quot;;
           Alert.show( msg );
       }

    ]]&amp;gt;
&amp;lt;/mx:Script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;/mx:Application&quot;&gt;/mx:Application&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Application.broadcastMsg()：把一条消息广播到所有连接的客户机，给每个客户机广播。
这个方法相当于遍历Application.clients数组并在每一个独立的客户机上调用Client.call()，但这个方法的效率更高。唯一不同的是当你调用broadcastMsg()时你不能指定一个响应对象。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; //遍历客户端列表，分别call他们
for(var i=0;i&amp;lt;application.clients.length;i++) {
 application.clients[i].call(&amp;quot;showServerMsg&amp;quot;，application.clients.length);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;四、服务器端呼叫服务器端&lt;/h4&gt;

&lt;p&gt;NetConnection.call(methodName, [resultObj, p1, ..., pN])&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/04/communication-between-client-and-server</link>
                <guid>http://alonepig.github.io/fms/2014/07/04/communication-between-client-and-server</guid>
                <pubDate>2014-07-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ams_config_admin_guide</title>
                <description>&lt;h4&gt;Adobe Media Server Configuration and Administration Guide&lt;/h4&gt;

&lt;h5&gt;第一章、部署服务器&lt;/h5&gt;

&lt;h6&gt;配置端口&lt;/h6&gt;

&lt;p&gt;Adobe Media Server默认端口为1935和80.Adobe Media 管理员服务器端口为1111。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;端口要求&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;端口号&lt;/td&gt;
        &lt;td&gt;协议&lt;/td&gt;
        &lt;td&gt;传输&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1935&lt;/td&gt;
        &lt;td&gt;TRMP/E&lt;/td&gt;
        &lt;td&gt;TCP&lt;/td&gt;
        &lt;td&gt;默认&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1935&lt;/td&gt;
        &lt;td&gt;RTMFP&lt;/td&gt;
        &lt;td&gt;UDP&lt;/td&gt;
        &lt;td&gt;默认&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;80&lt;/td&gt;
        &lt;td&gt;RTMP/E,RTMTP,HTTP&lt;/td&gt;
        &lt;td&gt;TCP&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;19350-65535&lt;/td&gt;
        &lt;td&gt;RTMFP&lt;/td&gt;
        &lt;td&gt;UDP&lt;/td&gt;
        &lt;td&gt;
        默认情况，客户端使用RTMFP协议，在1935和19350-65535端口上连接AMS。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;8134&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;HTTP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;TCP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;1111&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;RTMP,HTTP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;TCP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;默认情况下，Flash Player，HTML客户端连接AMS管理员服务器的端口。&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;443&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;RTMPS&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;TCP&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置IP地址和端口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开rootinstall/conf/ams.ini。&lt;/p&gt;

&lt;p&gt;2、编辑ADAPTOR.HOSTPORT参数，默认值为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ADAPTOR.HOSTPORT = :1935, 80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、保存文件重启服务器。&lt;/p&gt;

&lt;p&gt;Adaptor.xml配置文件中Adaptor/HostPortList/HostPort标签中使用ADAPTOR.HOSTPORT参数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;HostPort name=&amp;quot;edge1&amp;quot; ctl_channel=&amp;quot;localhost:19350&amp;quot;
rtmfp=&amp;quot;${ADAPTOR.HOSTPORT}&amp;quot;&amp;gt;${ADAPTOR.HOSTPORT}&amp;lt;/HostPort&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;为RTMFP配置IP地址和端口&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;RTMFP连接流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、RTMFP客户端在1935端口上连接AMS服务器进行UDP传输。&lt;/p&gt;

&lt;p&gt;重要：RTMFP和RTMP/E 客户端使用同样的端口连接AMS。但，RTMFP使用UDP，RTMP/E使用TCP。&lt;/p&gt;

&lt;p&gt;2、The amsedge process redirects the connection to an amscore process listening on a UDP port in the range 19350-65535&lt;/p&gt;

&lt;p&gt;每一个amscore进程有自己的RTMFP监听器。每一个RTMFP监听器绑定一个UDP端口。当amscore进程开始时，监听器绑定一下可用的UDP端口(Adaptor.xml中Adaptor/RTMFP/Core?hostPortList/HostPort标签指定)。
使用的端口的数量取决于amscore进程使用的数量。amscore进程使用的数量取决于应用程序实例是如何分布的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置RTMFP重定向端口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开rootinstall/conf/&lt;em&gt;defaultRoot&lt;/em&gt;/Adaptor.xml文件&lt;/p&gt;

&lt;p&gt;2、编辑HostPort标签，默认情况为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;Adaptor&amp;gt;
    ...
    &amp;lt;RTMFP&amp;gt;
    ...
        &amp;lt;Core&amp;gt;
            &amp;lt;HostPortList&amp;gt;
                &amp;lt;HostPort&amp;gt;:19350-65535&amp;lt;/HostPort&amp;gt;
            &amp;lt;/HostPortList&amp;gt;
        &amp;lt;/Core&amp;gt;
    &amp;lt;/RTMFP&amp;gt;
&amp;lt;/Adaptor&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、If the RTMFP adaptor is behind a NAT, specify the in-front-of-NAT IP address that clients connect to in the public attribute of the HostPort element. The following example uses 12.34.56.78 for the in-front-of-NAT IP address:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;HostPort public=&amp;quot;12.34.56.78:19350-65535&amp;quot;&amp;gt;:19350-65535&amp;lt;/HostPort&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、保存文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于HostPort&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HostPort标签的值为以下格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;value-of-HostPort&amp;gt; := [&amp;lt;host-port-range&amp;gt; [; &amp;lt;host-port-range&amp;gt; [; ... ] ] ]
&amp;lt;host-port-range&amp;gt; := [&amp;lt;host&amp;gt;][:&amp;lt;port-range&amp;gt;[, &amp;lt;port-range&amp;gt; ] ]
&amp;lt;port-range&amp;gt; := &amp;lt;start-port&amp;gt;[ - &amp;lt;end-port&amp;gt; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的例子中，每一个监听器有两个端口集合：一个端口来自host1:2000-2010或host2:3000-3010，一个来自host2:5000或host2:2010-4000。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置服务器在NAT后的公共的IP地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果RTMFP适配器在NAT之后，指定客户端连接的HostPort标签public属性来设置in-front-of-NAT IP地址。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;HostPort public=&amp;quot;&amp;lt;in-front-of-NAT-server-IP&amp;gt;:19350-65535&amp;quot;&amp;gt;:19350-65535&amp;lt;/HostPort&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你不指定public属性，服务器不会知道in-front-of-NAT 地址。amdedge进程会重定向客户端到正确的端口，但它会告诉客户端behind-NAT地址，这个地址客户端不能接触。&lt;/p&gt;

&lt;p&gt;Each HostPort element can specify a public address that corresponds to the specified port. This is the address that is advertised to clients for the given HostPort. To advertise an address, specify a value for the public attribute of the HostPort element. The public attribute has the same format as the HostPort element. The number of ports specified by the public attribute must equal the number of ports specified by the HostPort element. If the core listens on the n-th port of the HostPort value, the n-th port of the public attribute is advertised as its value.&lt;/p&gt;

&lt;p&gt;例子中HostPortList使用public属性，如果核心监听器在host1:1005，它的公共广告地址在host2:4005。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NAT和防火墙穿越&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;NAT(网络地址转换)和防火墙过滤可以阻止点对点的连接。在内部网应用程序中,您为了对整个网络进行控制,执行以下操作以确保客户可以创建点对点连接:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;允许在任何防火墙进行UDP通讯&lt;/li&gt;
&lt;li&gt;使用IFTF BEHAVE工作组推荐的NAT或防火墙&lt;/li&gt;
&lt;li&gt;Use the TURN proxy support in Flash Player to send traffic to a proxy in a DMZ that can comply with the previous recommendations. 
See &lt;a href=&quot;http://www.adobe.com/devnet/adobe-media-server/articles/real-time-collaboration.html&quot;&gt;Best practices for real-time collaboration using Adobe Media Server.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In an Internet application, the application developer must choose how to handle cases in which a firewall or NAT blocks a direct peer-to-peer connection. To create an application that works for connections that aren’t peer-to-peer, create a protocol fallback to client-server RTMP and/or RTMPT. To create an application that never relays media through the server (even though some clients may not see the media), don’t create a protocol fallback&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理解NAT的类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cone&lt;/strong&gt;    当想所有节点说话时重用同样的地址和端口&lt;/p&gt;

&lt;p&gt;多 IP地址，对称的    向一个新节点说话时，使用新地址和端口&lt;/p&gt;

&lt;p&gt;单一 IP地址，对称的 向一个新节点说话时，使用相同的地址和端口&lt;/p&gt;

&lt;p&gt;理解NAT和防火墙的过滤行为很重要：&lt;/p&gt;

&lt;p&gt;None    没有过滤功能的叫&amp;quot;full cone&amp;quot;&lt;/p&gt;

&lt;p&gt;Address-restricted  节点限制在已经使用过的地址&lt;/p&gt;

&lt;p&gt;Address and port-restricted 节点限制在已经使用过的地址和端口&lt;/p&gt;

&lt;p&gt;In addition, some NAT and firewall behaviors aren&amp;#39;t easily defined. For example, a NAT could act as a symmetric NAT that preserves port numbers. When it runs out of resources, it could switch and act as a cone NAT.&lt;/p&gt;

&lt;p&gt;In another example, a NAT could act as one type of NAT for the first client that connected to a server. It could act as a different type of NAT for the second client that tried to connect to the same server. In this case, a simple analysis can fail to predict whether a client can make a peer-to-peer connection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RTMFP连接检查&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RTMFP发明家马修·考夫曼主持一个名为RTMFP连通性检查程序的网站http://cc.rtmfp.net/。使用这个网站,尝试确定一个客户机在一个特定的网络可以创建一个点对点连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为HTTP流配置端口&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;负载平衡&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;部署服务器集群的工作流&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;strong&gt;点对点网络应用的负载均衡&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;部署边缘服务器&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;部署边缘服务器的工作流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设置边缘服务器的缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;连接到一个边缘服务器&lt;/strong&gt;&lt;/p&gt;

&lt;h6&gt;部署64位服务器&lt;/h6&gt;

&lt;h5&gt;第二章、配置服务器&lt;/h5&gt;

&lt;h6&gt;配置服务器虚拟映射&lt;/h6&gt;

&lt;h6&gt;使用配置文件&lt;/h6&gt;

&lt;h6&gt;配置性能特性&lt;/h6&gt;

&lt;h6&gt;配置安全特性&lt;/h6&gt;

&lt;h6&gt;执行常规配置任务&lt;/h6&gt;

&lt;h6&gt;配置内容存储&lt;/h6&gt;

&lt;h6&gt;配置Apache HTTP服务器&lt;/h6&gt;

&lt;h6&gt;为Adobe HTTP动态流和Apple HTTP 实时流配置Apache&lt;/h6&gt;

&lt;h6&gt;配置HTTP流失效备援&lt;/h6&gt;

&lt;h6&gt;使用第三方的web服务器&lt;/h6&gt;

&lt;h6&gt;配置差分服务(DiffServ)&lt;/h6&gt;

&lt;h5&gt;第三章、使用管理员控制台&lt;/h5&gt;

&lt;h6&gt;连接管理员控制台&lt;/h6&gt;

&lt;h6&gt;检查应用&lt;/h6&gt;

&lt;h6&gt;管理管理员&lt;/h6&gt;

&lt;h6&gt;管理服务器&lt;/h6&gt;

&lt;h5&gt;第四章、监控和管理日志文件&lt;/h5&gt;

&lt;h6&gt;使用日志文件&lt;/h6&gt;

&lt;h6&gt;访问日志&lt;/h6&gt;

&lt;h6&gt;应用日志&lt;/h6&gt;

&lt;h6&gt;诊断日志&lt;/h6&gt;

&lt;h5&gt;第五章、管理服务器&lt;/h5&gt;

&lt;h6&gt;开始和停止服务器&lt;/h6&gt;

&lt;h6&gt;检查服务器状态&lt;/h6&gt;

&lt;h6&gt;检查视频文件&lt;/h6&gt;

&lt;h6&gt;在Linux上管理服务器&lt;/h6&gt;

&lt;h6&gt;Scramble tool&lt;/h6&gt;

&lt;h5&gt;第六章、使用管理员API&lt;/h5&gt;

&lt;h6&gt;使用管理员API工作&lt;/h6&gt;

&lt;h5&gt;第七章、XML配置文件参考&lt;/h5&gt;

&lt;h6&gt;配置文件的版本从4.5到5.0.1发生的改变&lt;/h6&gt;

&lt;h6&gt;配置文件的版本从4.0到4.5发生的改变&lt;/h6&gt;

&lt;h6&gt;Adaptor.xml文件&lt;/h6&gt;

&lt;h6&gt;Application.xml文件&lt;/h6&gt;

&lt;h6&gt;Logger.xml文件&lt;/h6&gt;

&lt;h6&gt;Server.xml文件&lt;/h6&gt;

&lt;h6&gt;Users.xml文件&lt;/h6&gt;

&lt;h6&gt;VHost.xml文件&lt;/h6&gt;

&lt;h5&gt;第八章、诊断日志消息&lt;/h5&gt;

&lt;h6&gt;诊断日志的消息ID&lt;/h6&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/03/ams_config_admin_guide</link>
                <guid>http://alonepig.github.io/fms/2014/07/03/ams_config_admin_guide</guid>
                <pubDate>2014-07-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>server side actionscript language reference</title>
                <description>&lt;h4&gt;服务器端ActionScript语言参考手册&lt;/h4&gt;

&lt;h5&gt;Adobe媒体服务器服务端的APIs&lt;/h5&gt;

&lt;h5&gt;全局函数&lt;/h5&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;函数名&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;clearInterval()&lt;/td&gt;
        &lt;td&gt;停止调用setInterval()&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;getGlobal()&lt;/td&gt;
        &lt;td&gt;当secure.asc文件装载好后提供全局对象的访问&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;load()&lt;/td&gt;
        &lt;td&gt;装载服务器的asc文件到main.asc文件中，方便管理，不然可能会造成main.asc过大&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;protectedObject()&lt;/td&gt;
        &lt;td&gt;保护一个对象的方法&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;setAttribute()&lt;/td&gt;
        &lt;td&gt;防止某些方法和属性被枚举、修改和删除&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;setInterval()&lt;/td&gt;
        &lt;td&gt;指定一个时间间隔调用某方法，直到调用clearInterval()&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;trace()&lt;/td&gt;
        &lt;td&gt;计算表达式并显示结果&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;clearInterval()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;停止调用setInterval()方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;intervalID：setInterval()方法返回的标识符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;function callback(){trace(&amp;quot;interval called&amp;quot;);}
var intervalID;
intervalID = setInterval(callback, 1000);
//sometime later
clearInterval(intervalID);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;getGlobal()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当secure.asc文件装载好后提供全局对象的访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Adobe Media Server有两个脚本执行模式：安全和普通。在安全模式下，只有secure.asc文件被装载和执行(没有其他脚本被装载)。
getGlobal()和protectedObject()函数都只适用于安全模式。这些函数非常强大，因为它们能够完全的访问脚本环境和创建系统对象。
一旦secure.asc被装载，服务器切换到普通脚本执行状态直到应用被卸载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;var global = getGlobal();&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;load()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;装载服务器端asc或js文件到main.asc文件。被装载的文件在main.asc文件成功装载后，application.onAppStart()调用之前编译运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;filename：文件名&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;load(&amp;quot;myLoadfile.asc&amp;quot;);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;protectObject()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;保护一个对象的方法。只能在main.asc中使用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;object：保护的对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var sysobj = {};
sysobj._load = load; // Hide the load function
load = null; // Make it unavailable unpriviliged code.
sysobj.load = function(fname){
// User-defined code to validate/modify fname
return this._load(fname);
}
// Grab the global object.
var global = getGlobal();
// Now protect sysobj and make it available as
// &amp;quot;system&amp;quot; globally. Also, set its attributes
// so that it is read-only and not deletable.
global[&amp;quot;system&amp;quot;] = protectObject(sysobj);
setAttributes(global, &amp;quot;system&amp;quot;, false, true, true);
// Now add a global load() function for compatibility.
// Make it read-only and nondeletable.
global[&amp;quot;load&amp;quot;] = function(path){
return system.load(path);
}
setAttributes(global, &amp;quot;load&amp;quot;, false, true, true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;setAttributes(object, propName, enumerable, readonly, permanent)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;object：一个对象&lt;/p&gt;

&lt;p&gt;propName:&lt;/p&gt;

&lt;p&gt;enumerable:&lt;/p&gt;

&lt;p&gt;readonly:&lt;/p&gt;

&lt;p&gt;permanent:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;setInterval(function, interval [, p1, ..., pN])&lt;/strong&gt;
&lt;strong&gt;setInterval(object.method, interval [, p1, ..., pN])&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;function：一个对象&lt;/p&gt;

&lt;p&gt;object.method:&lt;/p&gt;

&lt;p&gt;[, p1, ..., pN] &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;返回结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;trace()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;
expression:&lt;/p&gt;

&lt;h6&gt;Application&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;属性摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;属性&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.allowDebug&lt;/td&gt;
        &lt;td&gt;一个布尔值，是否允许管理员使用管理员API approveDebugSession()方法访问应用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.clients&lt;/td&gt;
        &lt;td&gt;只读，所有客户端列表&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.config&lt;/td&gt;
        &lt;td&gt;提供访问Application.xml配置文件的ApplicationObject元素&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.hostname&lt;/td&gt;
        &lt;td&gt;只读，主机名&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.name&lt;/td&gt;
        &lt;td&gt;只读，应用实例的名称&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.server&lt;/td&gt;
        &lt;td&gt;只读，服务器的平台和版本&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;函数&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.acceptConnection()&lt;/td&gt;
        &lt;td&gt;接收连接&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.broadcastMsg()&lt;/td&gt;
        &lt;td&gt;广播&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.clearSharedObjects()&lt;/td&gt;
        &lt;td&gt;删除共享对象&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.clearStream()&lt;/td&gt;
        &lt;td&gt;清空录制的流文件&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.denyPeerLookup()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.disconnect()&lt;/td&gt;
        &lt;td&gt;终止客户端连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.gc()&lt;/td&gt;
        &lt;td&gt;垃圾回收&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.getStats()&lt;/td&gt;
        &lt;td&gt;返回一个应用的状态&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.redirectConnection()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.registerClass()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.registerProxy()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.rejectConnection()&lt;/td&gt;
        &lt;td&gt;拒绝连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.sendPeerRedirect()&lt;/td&gt;
        &lt;td&gt;当一个节点查找一个对象节点，这个函数发送一个地址数组给对象节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.shutdown()&lt;/td&gt;
        &lt;td&gt;卸载应用实例&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件监听摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;事件监听器&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.onAppStart()&lt;/td&gt;
        &lt;td&gt;应用装载时调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onAppStop()&lt;/td&gt;
        &lt;td&gt;应用卸载时调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onConnect()&lt;/td&gt;
        &lt;td&gt;客户端调用NetConnection.connect()时被调用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.onConnectAccept()&lt;/td&gt;
        &lt;td&gt;连接成功后被调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onConnectReject()&lt;/td&gt;
        &lt;td&gt;连接被拒绝时调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onDisconnect()&lt;/td&gt;
        &lt;td&gt;客户端断开连接时被调用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;application.onPeerLookup()&lt;/td&gt;
        &lt;td&gt;服务器接收查找请求是被调用&lt;/td&gt;
    &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;application.onPublish()&lt;/td&gt;
        &lt;td&gt;发布流时被调用&lt;/td&gt;
    &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;application.onStatus()&lt;/td&gt;
        &lt;td&gt;服务器处理消息出现错误的时候被调用&lt;/td&gt;
    &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;application.onUnpublish()&lt;/td&gt;
        &lt;td&gt;当一个客户端停止发布流的时候被调用&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h6&gt;ByteArray&lt;/h6&gt;

&lt;p&gt;服务器端的ByteArray类等于客户端的ByteArray，除了一下几种情况：&lt;/p&gt;

&lt;p&gt;下面两个方法在服务器端没有被实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ByteArray.inflate()&lt;/li&gt;
&lt;li&gt;ByteArray.deflate()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ActionScript3.0 ByteArray使用int或uint数据类型时，服务器端使用Number数据类型。&lt;/p&gt;

&lt;h6&gt;Client&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;属性摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;属性&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.agent&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.audioSampleAccess&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.farAddress&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.farID&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.farNonce&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.id&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.ip&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.nearAddress&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.nearID&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.nearNonce&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.pageUrl&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.potentialNearAddresses&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.protocol&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.protocolVersion&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.readAccess&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.referrer&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.reportedAddresses&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.secure&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.uri&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.videoSampleAccess&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.virtualKey&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.writeAccess&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.call()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.checkBandwidth()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.getbandwidthLimit()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.getStats()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.introducePeer()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.ping()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.remoteMethod()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.__resolve()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.setBandwidthLimit()&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;函数&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.onFarAddressChange()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.onGroupLeave&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.onGroupJoin&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Client.onReportedAddressChange()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h6&gt;File&lt;/h6&gt;

&lt;h6&gt;GroupSpecifier&lt;/h6&gt;

&lt;h6&gt;GroupControl&lt;/h6&gt;

&lt;h6&gt;LoadVars&lt;/h6&gt;

&lt;h6&gt;Log&lt;/h6&gt;

&lt;p&gt;日志类允许您创建一个日志对象,可以作为一个可选的参数传递给WebService类的构造函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件监听摘要&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;事件监听器&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Log.onLog()&lt;/td&gt;
        &lt;td&gt;当日志消息发送时被调用&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Log 构造器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;new Log([logLevel] [, logName])&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;logLevel： 有以下几种值
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;值&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Log.BRIEF&lt;/td&gt;
        &lt;td&gt;基本的生命周期事件，接收错误错误消息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Log.VERBOSE&lt;/td&gt;
        &lt;td&gt;所有的生命周期事件，接收错误错误消息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Log.DEBUG&lt;/td&gt;
        &lt;td&gt;Metrics and fine-grained events and errors are received&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;logName&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可选参数，用于区分多个日志。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;newLog = new Log();&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Log.onLog()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;发送消息时调用&lt;/p&gt;

&lt;h6&gt;MulticastStreamInfo&lt;/h6&gt;

&lt;h6&gt;MulticastStreamIngest&lt;/h6&gt;

&lt;h6&gt;NetConnection&lt;/h6&gt;

&lt;h6&gt;NetGroup&lt;/h6&gt;

&lt;h6&gt;NetGroupInfo&lt;/h6&gt;

&lt;h6&gt;NetGroupReceiveMode&lt;/h6&gt;

&lt;h6&gt;NetGroupReplicationStrategy&lt;/h6&gt;

&lt;h6&gt;NetGroupSendMode&lt;/h6&gt;

&lt;h6&gt;NetGroupSendResult&lt;/h6&gt;

&lt;h6&gt;NetStream&lt;/h6&gt;

&lt;h6&gt;ProxyStream&lt;/h6&gt;

&lt;h6&gt;SharedObject&lt;/h6&gt;

&lt;p&gt;SharedObject类让你在服务器和多个客户端之间共享储存数据。共享对象可以是临时的，也可以在应用关闭后持久化。
你可以把他看作实时的数据传输设备。&lt;/p&gt;

&lt;p&gt;下面的条目描述了在服务器端使用共享对象的方法：&lt;/p&gt;

&lt;p&gt;1 保存和共享数据。一个共享对象可以在服务器和其他客户端之间检索。比如，你可以打开一个远程共享对象，比如一个电话列表，它在
服务器上持久化了。无论哪个客户端作出改变，修改后的数据都可以同步到服务器和其他连接的客户端。&lt;/p&gt;

&lt;p&gt;2 实时共享数据。&lt;/p&gt;

&lt;p&gt;对于理解服务器端共享对象，下面的信息很重要：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务器端函数SharedObject.get()创建远程共享对象，没有创建本地共享对象的方法。本地共享对象保存在内存中，
除非他们是持久的，这种情况才能保存到.sol文件中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保存在服务器端的远程共享对象的文件扩展名为.fso，它们保存在应用的子目录中。客户端的远程共享对象扩展名为.sor也保存在应用的子目录中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器共享对象可以是无持久化的(存在于应用实例的时间中)，或持久化(应用关闭后也能储存)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了创建持久化共享对象，设置SharedObject.get()的persistence参数为true。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3 每一个远程共享对象都被唯一的名字所标识，包含一组名字-值的键值对。就像其他的ActionScript对象。名字必须是唯一的字符串，值可以为任意的ActionScript数据类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SharedObject.getProperty()获取服务器端远程共享对象的属性。SharedObject.setProperty()设置属性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SharedObject.clear()清除共享对象；application.clearSharedObjects()删除多个共享对象。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器端共享对象可以属于当前应用程序实例或另一个应用程序实例。另一个应用程序实例可以在同一台服务器上或在一个不同的服务器上。
属于不同的应用程序实例的共享对象引用被称为代理共享对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SharedObject.lock()可以防止其他客户端修改共享对象。SharedObject.mark()发送change事件。&lt;/p&gt;

&lt;p&gt;当你得到一个引用代理共享对象,对象的任何更改发送到拥有对象的实例。成功或失败的任何变化是由使用SharedObject.onSync()事件处理程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;属性摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;属性&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.autoCommit&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.isDirty&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.name&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.resyncDepth&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.version&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;函数&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.clear()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.close()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.commit()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.flush()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.get()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.getProperty()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.getPropertyNames()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.lock()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.mark()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.purge()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.send()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.setProperty()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.size()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.unlock()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件监听摘要&lt;/strong&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;事件监听器&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.handlerName()&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.onStatus&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SharedObject.onSync&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h6&gt;SHA256&lt;/h6&gt;

&lt;h6&gt;SOAPCall&lt;/h6&gt;

&lt;h6&gt;SOAPFault&lt;/h6&gt;

&lt;h6&gt;Stream&lt;/h6&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/01/server-side-actionscript-language-reference</link>
                <guid>http://alonepig.github.io/fms/2014/07/01/server-side-actionscript-language-reference</guid>
                <pubDate>2014-07-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>getting_started_streaming_media</title>
                <description>&lt;h3&gt;目录&lt;/h3&gt;

&lt;p&gt;一、支持的客户端，编码器，解码器和文件格式&lt;/p&gt;

&lt;p&gt;二、预构建的媒体播放器&lt;/p&gt;

&lt;p&gt;三、实时流媒体(HTTP)&lt;/p&gt;

&lt;p&gt;四、实时流媒体(RTMP)&lt;/p&gt;

&lt;p&gt;五、点播流媒体(HTTP)&lt;/p&gt;

&lt;p&gt;六、点播流媒体(RTMP)&lt;/p&gt;

&lt;p&gt;七、受保护的点播流媒体(pRTMP)&lt;/p&gt;

&lt;p&gt;八、多播媒体(RTMFP)&lt;/p&gt;

&lt;p&gt;九、Configure closed captioning&lt;/p&gt;

&lt;p&gt;十、配置可交换的音频&lt;/p&gt;

&lt;p&gt;十一、配置保护内容&lt;/p&gt;

&lt;p&gt;十二、配置HTTP动态流和HTTP实时流&lt;/p&gt;

&lt;p&gt;十三、HTTP流配置文件参考&lt;/p&gt;

&lt;p&gt;十四、建立自定义媒体播放器&lt;/p&gt;

&lt;p&gt;十五、Offline packaging&lt;/p&gt;

&lt;p&gt;十六、流媒体问题的一些解决办法&lt;/p&gt;

&lt;hr&gt;

&lt;h5&gt;一、支持的客户端，编码器，解码器和文件格式&lt;/h5&gt;

&lt;h6&gt;流服务支持的客户端和服务器&lt;/h6&gt;

&lt;h5&gt;二、预构建的媒体播放器&lt;/h5&gt;

&lt;h5&gt;三、实时流媒体(HTTP)&lt;/h5&gt;

&lt;h5&gt;四、实时流媒体(RTMP)&lt;/h5&gt;

&lt;h5&gt;五、点播流媒体(HTTP)&lt;/h5&gt;

&lt;h5&gt;六、点播流媒体(RTMP)&lt;/h5&gt;

&lt;h5&gt;七、受保护的点播流媒体(pRTMP)&lt;/h5&gt;

&lt;h5&gt;八、多播媒体(RTMFP)&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;关于多播服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要：&lt;/strong&gt; 多播服务(rootinstall/applications/multicast)不能运行在AMS标准版中。&lt;/p&gt;

&lt;p&gt;多播服务是AMS多播解决方案的一部分。多播解决方案包括以下组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多播配置工具(rootinstall/tools/multicast/configurator)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Flash Media Live Encoder&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;捕获、编码和发布实时视频&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多播服务(rootinstall/applications/multicast)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多播播放器(rootinstall/tools/multicast/multicastplayer)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;配置多播事件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开rootinstall/tools/multicast/configurator/configurator.html。&lt;/p&gt;

&lt;p&gt;2、选择多播类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Fusion(simultaneous, cooperative IP and P2P multicast)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IP Multicast&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Peer to Peer&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Peer to Peer with Peer Discovery&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、对于Fusion和Peer to Peer，输入服务器名称(或IP地址)和多播应用的全路径，比如:rtmfp://ams.example.com/multicast。
如果服务器配置的端口大于1935，需指定端口，比如：rtmfp://ams.example.com:1940/multicast。&lt;/p&gt;

&lt;p&gt;4、输入流名字，比如，CorpAllHandsQ2_2010或livestream。&lt;/p&gt;

&lt;p&gt;5、输入发布密码。&lt;/p&gt;

&lt;p&gt;发布密码指定只有多播服务器才能在组内发布多播流，其他节点只能播放。&lt;/p&gt;

&lt;p&gt;6、输入组名字。名字需要唯一。&lt;/p&gt;

&lt;p&gt;7、对于IP Multicast 和Fusion，输入IP多播地址和端口。&lt;/p&gt;

&lt;p&gt;8、(可选的)如果托管AMS的服务器有一个以上的网络接口卡(NIC)，在地址文本框中为一个NIC输入IP地址。AMS使用这个IP地址来决定发布时访问的接口。&lt;/p&gt;

&lt;p&gt;9、(可选的)为了使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Source-specific_multicast&quot;&gt;source-specific multicast&lt;/a&gt;，在对应的输入框输入IP地址和端口。&lt;/p&gt;

&lt;p&gt;10、点击生成。多播配置工具产生以下内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实时流的名字。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;F4M文件。为了观看此文件，点击观看Manifest文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;11、为了使用多播播放器，按照下面的步骤：&lt;/p&gt;

&lt;p&gt;a 点击保存Manifest文件。&lt;/p&gt;

&lt;p&gt;b 保存manifest.f4m文件到multicastplayer.html同目录。默认情况，在rootinstall/tools/multicast/multicastplayer。&lt;/p&gt;

&lt;p&gt;12、为了使用Strobe Media Playback，打开配置器。在设置完成后，你将返回到配置并保存f4m文件到相同的文件夹下的作为Strobe Media Playback。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Flash Media Live Encoder 发布流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开Flash Media Live Encoder3.1或更高版本&lt;/p&gt;

&lt;p&gt;2、从预设菜单中，选择一个单一的流。多播解决方案不支持multi-bitrate流。&lt;/p&gt;

&lt;p&gt;3、对于AMS URL，输入多播服务的URL。如果你在同一台电脑测试，输入：rtmp://localhost/multicast&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;Flash Media Live Encoder 连接AMS是通过RTMP协议传输的，不使用RTMFP。&lt;/p&gt;

&lt;p&gt;4、将在多播配置工具中复制的发布流的名字粘贴。&lt;/p&gt;

&lt;p&gt;5、点击开始。&lt;/p&gt;

&lt;p&gt;6、打开管理员控制台，点击观看Applications&amp;gt;Clients。The RTMP client is the connection from FMLE to the server. The RTMFP client is a server-side peer established by the multicast service to republish the live stream into the target RTMFP Group&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;播放多播流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、开打rootinstall/tools/multicast/multicastplayer/multicastplayer.html&lt;/p&gt;

&lt;p&gt;2、为了在本地系统中运行Flash Player，右键屏幕，选择全局设置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在Flash Player帮助页，选择全局安全设置面板。点击Edit locations &amp;gt; Add location &amp;gt;Browse for folder。选择multicastplayer.swf文件所在目录。
点击添加。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Flash Player设置管理器，选择高级点击Trusted Location Setting。点击添加，选择multicastplayer.swf文件所在目录。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、重新装载multicastplayer.html。点击运行点对点连接。&lt;/p&gt;

&lt;p&gt;4、打开管理员控制台看客户端连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用AMS样例播放器播放流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、打开rootinstall/samples/videoPlayer/videoplayer.html&lt;/p&gt;

&lt;p&gt;2、从rootinstall/tools/multicast/configurator复制t.f4m文件到rootinstall/smaples/videoPlayer文件夹。&lt;/p&gt;

&lt;p&gt;3、在样例播放器中，在URL流文本框中输入manifest.f4m， 点击播放。&lt;/p&gt;

&lt;p&gt;4、管理员控制台查看信息。&lt;/p&gt;

&lt;h5&gt;九、Configure closed captioning&lt;/h5&gt;

&lt;h5&gt;十、配置可交换的音频&lt;/h5&gt;

&lt;h5&gt;十一、配置保护内容&lt;/h5&gt;

&lt;h5&gt;十二、配置HTTP动态流和HTTP实时流&lt;/h5&gt;

&lt;h5&gt;十三、HTTP流配置文件参考&lt;/h5&gt;

&lt;h5&gt;十四、建立自定义媒体播放器&lt;/h5&gt;

&lt;h6&gt;为实时或点播服务构建媒体播放器&lt;/h6&gt;

&lt;p&gt;OSMF 播放器是基于Flash平台的开源播放器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;连接流服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;跟所有AMS应用一样，通过NetConnection.connect()来连接，URI参数格式如下：&lt;/p&gt;

&lt;p&gt;rtmp://ams-ip-or-dns/serviceName/[formatType:][instanceName/]fileOrStreamName&lt;/p&gt;

&lt;p&gt;hostName AMS域名&lt;/p&gt;

&lt;p&gt;serviceName 直播或点播&lt;/p&gt;

&lt;p&gt;instanceName 如果客户端连接默认的实例，你可以省略或使用&lt;em&gt;definst&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;fotmatType mp3文件则用mp3:,对mp4/f4v文件，则用mp4:，flv文件不做要求。&lt;/p&gt;

&lt;p&gt;fileOrStreamName 文件名或路径，如my&lt;em&gt;video.mp4或subdir/subdir2/my&lt;/em&gt;video.mp4。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不支持的ActionScript API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于实时和点播服务，客户端不能使用 SharedObject.getRemote()&lt;/p&gt;

&lt;p&gt;你不能编辑服务端的代码。但可以通过NetConnection.call()来调用服务器端的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;允许从指定的域连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况，可以从任何域连接。&lt;/p&gt;

&lt;p&gt;rootinstall/applications/live 或 rootinstall/applications/vod 文件夹：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加一个swf客户端的域，编辑allowedSWFdomains.txt文件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加一个HTML客户端的域，编辑allowedHTMLdomains.txt文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;访问音频和视频的原始数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActionScript中通过BitmapData.draw()和SoundMixer.computeSpectrum()方法访问数据。&lt;/p&gt;

&lt;p&gt;默认情况下，AMS阻止你访问流。为了访问，需要做以下事情：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将rootinstall/smaple/applications/live 或 rootinstall/smaple/applications/vod的main.far和main.asc文件复制到rootinstall/applications/live 或 rootinstall/applications/vod&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;去掉下面两行的注释：&lt;/p&gt;

&lt;p&gt;//p&lt;em&gt;client.audioSampleAccess = &amp;quot;/&amp;quot;;
//p&lt;/em&gt;client.videoSampleAccess = &amp;quot;/&amp;quot;;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;流服务API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;getStreamLength(streamObj)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返回流的长度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nc.call(&amp;quot;getStreamLength&amp;quot;, returnObj, &amp;quot;sample_video&amp;quot;);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;getPageUrl()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返回客户端Swf的URL&lt;/p&gt;

&lt;p&gt;//嵌套在html中
getPageUrl 返回： http://www.example.com/trace.html&lt;/p&gt;

&lt;p&gt;//没有嵌套在html中
getPageUrl 返回： http://www.example.com/trace.swf&lt;/p&gt;

&lt;p&gt;这个值必须是http地址。由于安全原因，本地地址不会显示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nc.call(&amp;quot;getPageUrl&amp;quot;, returnObj);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;getReferrer()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返回SWF文件的URL或服务器连接源自哪里&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;myNetConnection.call(&amp;quot;getReferrer&amp;quot;, returnObj);&lt;/p&gt;

&lt;h6&gt;构建动态的HTTP流媒体播放器&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;使用OSMF&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理解HTTP动态流的应用结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流媒体使用Adobe HDS需要Adobe媒体Manifest文件(.f4m)。&lt;/p&gt;

&lt;p&gt;manifest文件包含的信息媒体资源或多播流中的每个流的事件的信息。这些信息包括媒体的位置、DRM额外头数据,媒体引导信息,自适应流比特率等。&lt;/p&gt;

&lt;p&gt;为了产生文件，HTTP模块会执行以下步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;结合请求URL和HttpStreamingLiveEventPath指令来定位实时事件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从Event.xml和multi-lvevel manifest文件总检索元数据&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了流录制文件(.stream)扫描事件目录&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;检索每一个流文件对应的内容。每一个.stream文件都来自manifest文件的&lt;media&gt;标签&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从.meta文件检索元数据&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为引导信息和DRM额外头数据创建链接(如果内容是安全的)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回生成manifest文档&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在rootinstall/applications/livepkgr/streams/&lt;em&gt;definst&lt;/em&gt;文件夹，实时打包器以流的名字创建文件夹：livestream1，livestream2。实时打包器
在每个文件夹中创建了以下文件：&lt;/p&gt;

&lt;p&gt;· livestream#.bootstrap&lt;/p&gt;

&lt;p&gt;· livestream#.control&lt;/p&gt;

&lt;p&gt;· livestream#.meta&lt;/p&gt;

&lt;p&gt;· livestream#.Seg#.f4f&lt;/p&gt;

&lt;p&gt;· livestream#.Seg#.f4x&lt;/p&gt;

&lt;p&gt;下表描述了每个文件类型：
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;文件&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#Seg#.f4f&lt;/td&gt;
        &lt;td&gt;A segment. The Live Packager outputs one or more F4F files. Each file contains a segment of the source file. Each segment contains the fragmented (and optionally protected) content.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#Seg#.f4x&lt;/td&gt;
        &lt;td&gt;An index file listing the fragment offsets in each .f4f file. The Live Packager outputs one or more F4X files. The HTTP Origin Module uses this file to deliver fragments.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#.meta&lt;/td&gt;
        &lt;td&gt;Contains the stream metadata (bitrate, screen size, and so on).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#.bootstrap&lt;/td&gt;
        &lt;td&gt;Contains the bootstrap information for the stream.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#.control&lt;/td&gt;
        &lt;td&gt;Contains internal metadata that the Live Packager uses to manage stream state.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;livestream#.drmmeta&lt;/td&gt;
        &lt;td&gt;Contains additional header information when a stream is encrypted for use with Adobe Access.&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;以下是Apache配置HTTP动态流的时候这些文件的URL请求格式：
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;请求格式&lt;/td&gt;
        &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Fragment&lt;/td&gt;
        &lt;td&gt;http://&lt;host&gt;/&lt;location-tag-alias&gt;/streams/&lt;app-name&gt;/streams/&lt;app-instance&gt;/&lt;stream name&gt;Seg&lt;segment #&gt;-Frag&lt;fragment #&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Bootstrap(.bootstrap)&lt;/td&gt;
        &lt;td&gt;http://&lt;host&gt;/&lt;location-tag-alias&gt;/streams/&lt;app-name&gt;/streams/&lt;app-instance&gt;/&lt;stream name&gt;.bootstrap&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流录制文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流记录文件(.stream)是一个XML文档,其中包含的物理位置。服务器创建流记录文件时传入流与实时事件相关联。服务器创建的文件的名称在以下位置进行编码&lt;/p&gt;

&lt;p&gt;applications/appname/events/appinstancename/eventname/MTg1ODAyNigwNg=.stream&lt;/p&gt;

&lt;p&gt;.stream文件格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;stream xmlns=&amp;quot;http://www.adobe.com/liveevent/1.0&amp;quot;&amp;gt;
    &amp;lt;type&amp;gt;
        f4f
    &amp;lt;/type&amp;gt;
    &amp;lt;name&amp;gt;
        livestream
    &amp;lt;/name&amp;gt;
    &amp;lt;path&amp;gt;
        C:\Program Files\Adobe\Adobe Media Server 5\applications\myapp\streams\_definst_\livestream
    &amp;lt;/path&amp;gt;
&amp;lt;/stream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;.f4m manifest文件实例&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;十五、Offline packaging&lt;/h5&gt;

&lt;h5&gt;十六、流媒体问题的一些解决办法&lt;/h5&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/07/01/getting_started_streaming_media</link>
                <guid>http://alonepig.github.io/fms/2014/07/01/getting_started_streaming_media</guid>
                <pubDate>2014-07-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Learning AMS</title>
                <description>&lt;h3&gt;Adobe Media Server开发笔记&lt;/h3&gt;

&lt;p&gt;一、[adobemediaserver&lt;em&gt;5.0.3&lt;/em&gt;install 总结]&lt;/p&gt;

&lt;p&gt;二、[dev_guide使用手册：开始使用流媒体]&lt;/p&gt;

&lt;p&gt;三、[dev_guide使用手册：内容保护]&lt;/p&gt;

&lt;p&gt;四、[dev_guide使用手册：开始开发应用]&lt;/p&gt;

&lt;p&gt;五、[dev_guide使用手册：开发流媒体应用]&lt;/p&gt;

&lt;p&gt;六、&lt;a href=&quot;http://alonepig.tk/fms/2014/07/07/working-with-live-video/&quot;&gt;dev_guide使用手册：使用实时流&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;七、[dev_guide使用手册：构建点对点的网络应用]&lt;/p&gt;

&lt;p&gt;八、[dev_guide使用手册：开发社交应用]&lt;/p&gt;

&lt;p&gt;九、[dev_guide使用手册：应用安全]&lt;/p&gt;

&lt;p&gt;十、[dev_guide使用手册：开发插件]&lt;/p&gt;

&lt;p&gt;十一、[客户端和服务器端通讯的方法]&lt;/p&gt;

&lt;p&gt;十二、[administrationapi介绍]&lt;/p&gt;

&lt;p&gt;十三、&lt;a href=&quot;&quot;&gt;ams&lt;em&gt;config&lt;/em&gt;admin 手册&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;十四、Server-Side ActionScript语言参考 &lt;/p&gt;

&lt;p&gt;十五、H264编码的使用&lt;/p&gt;

&lt;p&gt;十六、(优化参数(画质、延迟、带宽等))[]&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/06/24/learning-ams</link>
                <guid>http://alonepig.github.io/fms/2014/06/24/learning-ams</guid>
                <pubDate>2014-06-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>adobemediaserver_5.0.3_install 总结</title>
                <description>&lt;h3&gt;一、安装服务&lt;/h3&gt;

&lt;h6&gt;准备安装Adobe媒体服务器&lt;/h6&gt;

&lt;p&gt;1、部署情况：可以部署到单一的电脑上，也可以是复杂的集群边缘服务器。&lt;/p&gt;

&lt;p&gt;2、选择是否安装Apache Http服务，默认是安装的。&lt;/p&gt;

&lt;p&gt;3、安装之前确认序列号。&lt;/p&gt;

&lt;h6&gt;准备升级Adobe媒体服务器&lt;/h6&gt;

&lt;p&gt;1、备份数据&lt;/p&gt;

&lt;p&gt;复制下面的文件夹：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;applications/
conf/
licenses/
modules/
webroot/
Apache2.2/conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、卸载原来的AMS&lt;/p&gt;

&lt;p&gt;3、安装新的AMS&lt;/p&gt;

&lt;h3&gt;二、验证安装&lt;/h3&gt;

&lt;p&gt;http://localhost 进入测试页面&lt;/p&gt;

&lt;p&gt;http://localhost/ams_adminConsole.htm  管理后台&lt;/p&gt;
</description>
                <link>http://alonepig.github.io/fms/2014/06/24/adobemediaserver_503_install-</link>
                <guid>http://alonepig.github.io/fms/2014/06/24/adobemediaserver_503_install-</guid>
                <pubDate>2014-06-24T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
