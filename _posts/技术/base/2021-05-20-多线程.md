---
layout: post
title: 多线程
category: 技术
tags: 技术
keywords: 
description:
---

## 线程的来源



## 线程的状态



- 新建状态:

线程对象已经创建，还没有在其上调用start()方法。

- 可运行状态:

当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。

- 运行状态:

就绪状态的线程获取了CPU，执行程序代码。

- 阻塞状态:

阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入可运行状态，才有机会转到运行状态。

阻塞的情况分三种：

    等待阻塞:运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒. (注意:当调用wait()后，线程会释放掉它所占有的'锁'，所以线程只有在持有'锁'才能进入可运行状态.)

    同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。

    其他阻塞:运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

- 死亡状态:

线程执行完了或者因异常退出了run()时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。



## 线程间通讯
