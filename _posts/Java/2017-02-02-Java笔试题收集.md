---
layout: post
title: Java笔试题收集
category: Java
tags: Java
keywords:
description:
---

##### 弱引用、强引用

弱引用：不会影响其引用对象的释放。如果对象只存在弱引用，那么在下一次垃圾回收时必然被清理掉。



##### TCP、UDP区别

1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的,UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4. TCP首部开销20字节;UDP的首部开销小，只有8个字节
5. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

##### 三次握手、四次挥手

**三次握手**

![](/public/img/java/tcp_1.png)

第一次握手：客户端想跟服务器进行连接，所以状态变为**主动打开**，同时发送一个连接请求报文给服务器端SYN=1，并且会携带x个字节过去。发送完请求连接报文后，客户端的状态就变为**SYN_SENT**,这个状态等待发送确认。

第二次握手：服务端接收到连接请求报文后，从**LISTEN**状态变为**被动打开**状态，然后给客户端返回一个报文。这个报文有两层意思，一是确认报文，二是可以达到告诉客户端，我也打开连接了。发送完毕后，变为**SYN_RCVD**状态。

第三次握手：客户端得到服务端的确认和知道服务端已经准备好连接后，还会发一个确认报文到服务端，发送完后客户端进入**ESTABLISHED**状态，当服务端接收后，状态也变为**ESTABLISHED**。

**四次挥手**

![](/public/img/java/tcp_2.png)

第一次挥手：从**ESTABLISHED**变为**主动关闭**状态，客户端主动发送释放连接请求给服务器端，FIN=1。发送完之后就变为**FIN_WAIT_1**状态，这个状态可以说是等待确认状态。

第二次挥手：服务器接收到客户端发来的释放连接请求后，状态变为**CLOSE_WAIT**，然后发送确认报文给客户端，告诉他我接收到了你的请求。为什么变为CLOSE_WAIT，原因是客户端发送的释放连接请求，可能自己这端还有数据没有发送完呢，所以这个时候整个TCP连接的状态就变为了半关闭状态。服务器端还能发送数据，并且客户端也能接收数据，但是客户端不能在发送数据了，只能够发送确认报文。客户端接到服务器的确认报文后，就进入了**FIN_WAIT_2**状态。也可以说这是等待服务器释放连接状态。

第三次挥手：服务器端所有的数据度发送完了，认为可以关闭连接了，状态变为**被动关闭**，所以向客户端发送释放连接报文，发完之后自己变为**LAST_WAIT**状态，也就是等待客户端确认状态。

第四次挥手：客户端接到释放连接报文后，发送一个确认报文，然后自己变为**TIME_WAIT**,而不是立马关闭，因为客户端发送的确认报文可能会丢失，丢失的话服务器就会重传一个FIN，也就是释放连接报文，这个时候客户端必须还没关闭。 当服务器接受到确认报文后，服务器就进入**CLOSE**状态，也就是关闭了。但是由于上面说的这个原因，客户端必须等待一定的时间才能够进入**CLOSE**状态。



## volatile

执行控制：目的是控制代码执行（顺序）及是否可以并行执行。

内存可见：线程执行结果在内存中对其他线程的可见性。

1. volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3. volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
4. volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
5. volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
