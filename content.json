{"pages":[{"title":"About","date":"2016-10-24T02:24:00.000Z","path":"about/index.html","text":"介绍一个一直以来比较菜的程序员!什么都懂一点，但貌似没一样精通的！o(╯□╰)o 关注IT技术，分享学到的知识，分享生活的乐趣。 此博客内容因博主见识、表达措辞、查阅资料有限、资料时效性变化等因素，内容不能保证完全正确或适合读者使用！！！ 此博客乃学习笔记，主要目的是方便自己检阅、巩固学习时的知识整理，其中错漏残缺不可避免，如果读者有任何新发现烦请留言，互勉学习而进步。 关于程序员的自我修养要想成为一名还行的程序员，需要学的东西真的不少。技术更新迭代的速度非常之快，怎么才能不在信息浪潮中落伍，我觉得还是要注重基础，下盘劳了，学什么都不费劲。而基础有哪些呢？ 计算机组成原理 操作系统原理 数据结构 算法 设计模式 网络原理 底层原理性的东西的变化速度是远远慢于应用层的技术迭代的，而应用层的技术很多都是依赖于这些底层技术的。所以，大家还是把这些东西都牢记于心吧！ 关于此博客的搭建我对自己写博客的需求： 使用方便，查阅方便； 容易构建、发布、分享； 博客展示能支持树状结构，方便知识体系的归类； 文章支持显示目录； 支持评论、统计等功能 最终选择使用hexo构建，主题来源于https://github.com/zthxxx/hexo-theme-Wikitten。这套主题基本满足了我的需求，在此感谢作者。 一些小东西 ActionScript3版本的Flappy Bird Alfred股票小助手 ： 用于快速查询实时股价 精选的Alfred的workflow Java设计模式代码整理 你可以在这里找到我： 豆瓣 Github 知乎 stackoverflow 力扣"},{"title":"Categories","date":"2022-03-08T02:25:29.755Z","path":"categories/index.html","text":""},{"title":"","date":"2022-03-08T02:25:29.614Z","path":"/404.html","text":"Error 404 Not Found 您所访问的地址无法找到或者已经被删除了， 如果您是从搜索结果点击进来看到的 404，可以先尝试使用页面 右上方的搜索文章。 来都来了，就先逛逛嘛~~ 您可以访问 本站主页 ，或者联系我，吐槽下问题的详细情况， 也可以通过页面上方的 分类 或 标签 来查看本站已有的一些 tags。"},{"title":"Tags","date":"2022-03-08T02:25:29.756Z","path":"tags/index.html","text":""}],"posts":[{"title":"集成到现有Android应用","date":"2024-03-09T09:31:38.330Z","path":"wiki/JavaScript/ReactNative/集成到现有Android应用/","text":"不同版本的RN可能配置不一样，这里使用0.62版本 1. 创建一个空目录用于存放React Native项目，然后在其中创建一个&#x2F;android子目录，把现有的Android项目拷贝到该目录2. 安装JavaScript依赖包在项目根目录创建package.json空文件，填入以下内容； 12345678&#123; &quot;name&quot;: &quot;MyReactNativeApp&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;yarn react-native start&quot; &#125;&#125; 然后运行：yarn add &#x72;&#101;&#97;&#99;&#116;&#45;&#110;&#x61;&#116;&#x69;&#118;&#101;&#64;&#48;&#x2e;&#54;&#50;&#46;&#x31;，如果不写版本号会默认安装最新版本的React Native，同时会出现类似以下的警告信息： 1warning &quot;react-native@0.52.2&quot; has unmet peer dependency &quot;react@16.2.0&quot;. 只需要再次安装对应版本即可：yarn add &#x72;&#x65;&#97;&#x63;&#116;&#x40;&#49;&#54;&#46;&#50;&#46;&#48; 这里其实也可以不用手动创建package.json文件，命令添加react-native后会自动生成这个文件。Android项目会依赖node_modules中react-native中的aar 3. 修改Android项目，添加React Native3.1 根目录build.gradle文件配置仓库地址12345678910111213141516171819202122232425def REACT_NATIVE_VERSION = new File([&#x27;node&#x27;, &#x27;--print&#x27;,&quot;JSON.parse(require(&#x27;fs&#x27;).readFileSync(require.resolve(&#x27;react-native/package.json&#x27;), &#x27;utf-8&#x27;)).version&quot;].execute(null, rootDir).text.trim())allprojects &#123; repositories &#123; maven &#123; // All of React Native (JS, Android binaries) is installed from npm url &quot;$rootDir/../node_modules/react-native/android&quot; &#125; maven &#123; // Android JSC is installed from npm url(&quot;$rootDir/../node_modules/jsc-android/dist&quot;) &#125; ... &#125; //这里会强制项目的版本号跟node_modules中的一致 configurations.all &#123; resolutionStrategy &#123; // Remove this override in 0.65+, as a proper fix is included in react-native itself. force &quot;com.facebook.react:react-native:&quot; + REACT_NATIVE_VERSION &#125; &#125; ...&#125; 3.2 配置依赖123456dependencies &#123; implementation &quot;com.android.support:appcompat-v7:27.1.1&quot; ... implementation &quot;com.facebook.react:react-native:+&quot; // +表示使用本地的仓库依赖 implementation &quot;org.webkit:android-jsc:+&quot;&#125; 注意：Android项目和RN项目要保持统一的依赖版本，有些文章说找不到库使用固定版本号也是一种方式，但建议统一版本号 3.3 启动原生模块的自动链接1234567//settings.gradle文件配置apply from: file(&quot;../node_modules/@react-native-community/cli-platform-android/native_modules.gradle&quot;); applyNativeModulesSettingsGradle(settings)//app/build.gradle中配置apply from: file(&quot;../../node_modules/@react-native-community/cli-platform-android/native_modules.gradle&quot;); applyNativeModulesAppBuildGradle(project) 3.4 配置权限1234567891011121314151617//AndroidManifest.xml配置&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;application标签添加android:networkSecurityConfig=&quot;@xml/network_security_config&quot;//开发者菜单配置&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;//允许http接口（从 Android 9 (API level 28)开始，默认情况下明文传输（http 接口）是禁用的，只能访问 https 接口。这将阻止应用程序连接到Metro bundler）&lt;!-- ... --&gt;&lt;application android:usesCleartextTraffic=&quot;true&quot; tools:targetApi=&quot;28&quot; &gt; &lt;!-- ... --&gt;&lt;/application&gt; network_security_config.xml文件内容： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;debug-overrides cleartextTrafficPermitted=&quot;true&quot;&gt; &lt;trust-anchors&gt; &lt;certificates src=&quot;user&quot;/&gt; &lt;certificates src=&quot;system&quot;/&gt; &lt;/trust-anchors&gt; &lt;/debug-overrides&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt; 4. 代码集成4.1 创建自定义ReactActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package com.lqd.androidpractice.rn;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.provider.Settings;import android.util.Log;import android.view.KeyEvent;import androidx.annotation.Nullable;import com.facebook.react.PackageList;import com.facebook.react.ReactInstanceManager;import com.facebook.react.ReactPackage;import com.facebook.react.ReactRootView;import com.facebook.react.common.LifecycleState;import com.facebook.react.devsupport.RedBoxHandler;import com.facebook.react.devsupport.interfaces.StackFrame;import com.facebook.react.modules.core.DefaultHardwareBackBtnHandler;import com.facebook.soloader.SoLoader;import com.lqd.androidpractice.BuildConfig;import java.util.List;public class MyReactActivity extends Activity implements DefaultHardwareBackBtnHandler &#123; private ReactRootView mReactRootView; private ReactInstanceManager mReactInstanceManager; private final int OVERLAY_PERMISSION_REQ_CODE = 1; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.w(&quot;MyReactActivity&quot;, &quot;onCreate&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); //获取权限 if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if(!Settings.canDrawOverlays(this)) &#123; Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(&quot;package:&quot; + getPackageName())); startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE); &#125; &#125; SoLoader.init(this, false); mReactRootView = new ReactRootView(this); List&lt;ReactPackage&gt; packages = new PackageList(getApplication()).getPackages();// packages.add(new MyReactNativePackage()); packages.add(new IndexPackage());//自定义的Package mReactInstanceManager = ReactInstanceManager.builder() //设置上下文 .setApplication(getApplication()) .setCurrentActivity(this) //设置js产物的名字 .setBundleAssetName(&quot;index.android.bundle&quot;) //JS bundle主入口的文件名，js文件的名字 .setJSMainModulePath(&quot;index&quot;) .addPackages(packages)//注册自定义的Package .setUseDeveloperSupport(BuildConfig.DEBUG) //设置创建时机 .setInitialLifecycleState(LifecycleState.RESUMED) //JS异常回调 .setRedBoxHandler(new MyRedBoxHandler()) .build(); //这里的名字与AppRegistry.registerComponent对应 mReactRootView.startReactApplication(mReactInstanceManager, &quot;MyReactNativeApp&quot;, null); setContentView(mReactRootView); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if(resultCode == OVERLAY_PERMISSION_REQ_CODE) &#123; if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if(!Settings.canDrawOverlays(this)) &#123; &#125; &#125; &#125; mReactInstanceManager.onActivityResult(this, requestCode, resultCode, data); &#125; @Override public boolean onKeyUp(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; mReactInstanceManager != null) &#123; mReactInstanceManager.showDevOptionsDialog(); return true; &#125; return super.onKeyUp(keyCode, event); &#125; @Override public void invokeDefaultOnBackPressed() &#123; super.onBackPressed(); &#125; @Override public void onBackPressed() &#123; if (mReactInstanceManager != null) &#123; mReactInstanceManager.onBackPressed(); &#125; else &#123; super.onBackPressed(); &#125; &#125; //生命周期回调同步 @Override protected void onPause() &#123; super.onPause(); if (mReactInstanceManager != null) &#123; mReactInstanceManager.onHostPause(this); &#125; &#125; @Override protected void onResume() &#123; super.onResume(); if (mReactInstanceManager != null) &#123; mReactInstanceManager.onHostResume(this, this); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mReactInstanceManager != null) &#123; mReactInstanceManager.onHostDestroy(this); &#125; if (mReactRootView != null) &#123; mReactRootView.unmountReactApplication(); &#125; &#125;&#125;/** * 异常信息的回调 */class MyRedBoxHandler implements RedBoxHandler &#123; @Override public void handleRedbox(@Nullable String title, StackFrame[] stack, ErrorType errorType) &#123; for(StackFrame stackFrame : stack) &#123; Log.w(&quot;MyReactActivity&quot;, &quot;=====handleRedbox &quot; + stackFrame.getMethod() + &quot; &quot; + stackFrame.getFileName() + &quot; &quot; + stackFrame.getLine() + &quot; &quot; + stackFrame.getColumn() + &quot; &quot;); &#125; //JS异常 Log.w(&quot;MyReactActivity&quot;, &quot;&gt;&gt;handleRedbox &quot; + title + &quot;---------------- &quot; + errorType + &quot; &quot;); &#125; @Override public boolean isReportEnabled() &#123; return true; &#125; @Override public void reportRedbox(Context context, String title, StackFrame[] stack, String sourceUrl, ReportCompletedListener reportCompletedListener) &#123; Log.w(&quot;MyReactActivity&quot;, &quot;-----handleRedbox &quot; + title + &quot; sourceUrl:&quot; + sourceUrl + &quot; &quot;); &#125;&#125; 4.2 创建自定义PackageIndexPackage.java文件 1234567891011121314151617181920212223242526272829303132333435package com.lqd.androidpractice.rn;import androidx.annotation.NonNull;import com.facebook.react.ReactPackage;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.uimanager.ViewManager;import java.util.ArrayList;import java.util.Collections;import java.util.List;//Package用于将原生模块和视图管理器添加到RN中public class IndexPackage implements ReactPackage &#123; //返回原生模块列表 @NonNull @Override public List&lt;NativeModule&gt; createNativeModules(@NonNull ReactApplicationContext reactContext) &#123; List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;(); modules.add(new IndexModule(reactContext)); return modules; &#125;//返回包含原生视图管理器的列表 @NonNull @Override public List&lt;ViewManager&gt; createViewManagers(@NonNull ReactApplicationContext reactContext) &#123; return Collections.emptyList(); &#125;&#125; IndexModule.java文件 12345678910111213141516171819202122232425package com.lqd.androidpractice.rn;import androidx.annotation.NonNull;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.bridge.ReactContextBaseJavaModule;public class IndexModule extends ReactContextBaseJavaModule &#123; public IndexModule(@NonNull ReactApplicationContext reactContext) &#123; super(reactContext); &#125; @NonNull @Override public String getName() &#123; return &quot;index&quot;;//跟index.js对应 &#125; @Override public void onCatalystInstanceDestroy() &#123; super.onCatalystInstanceDestroy(); &#125;&#125; 4.3 创建index.js文件1234567891011121314151617181920212223import React from &#x27;react&#x27;;import &#123; AppRegistry, Button, Style, Text, View&#125; from &#x27;react-native&#x27;;//import ToastExample from &#x27;./ToastExample&#x27;;class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text&gt;Hello, World&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent(&#x27;MyReactNativeApp&#x27;, () =&gt; HelloWorld); React Native也封装了一个ReactActivity，直接继承它更方便 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class RNActivity1 extends ReactActivity implements PermissionAwareActivity, DefaultHardwareBackBtnHandler &#123; protected String getMainComponentName() &#123; return &quot;index&quot;; &#125; @Override protected ReactActivityDelegate createReactActivityDelegate() &#123; return new ReactActivityDelegate(this, getMainComponentName()) &#123; @Nullable @Override public String getMainComponentName() &#123; return &quot;index&quot;; &#125; &#125;; &#125;&#125;//使用这种方式Application需要实现ReactApplication，实现getReactNativeHost方法，将对应的Package进行注册public class LQDApplication extends Application implements ReactApplication &#123; @Override public ReactNativeHost getReactNativeHost() &#123; return new ReactNativeHost(this) &#123; @Override public boolean getUseDeveloperSupport() &#123; return false; &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; List&lt;ReactPackage&gt; packages = new PackageList(getApplication()).getPackages(); packages.add(new IndexPackage()); packages.add(new ImagePickerPackage()); return packages; &#125; &#125;; &#125; &#125; 4.4 编译bundle12npx react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res 5. 运行Android端123456789101112131415#开发环境时调试#1.先启动Metro服务器#如果自定义端口，则需要在开发者菜单中配置对应的ip:portnpm run start --verbose -- --port 8088 #或yarn start#2.运行程序yarn react-native run-android#3.打开开发者工具，配置ip:port#生产环境#通过codepush进行热更新或者编译bundle到assets目录下 问题总结找不到PackageList这个文件是生成的，删除build文件夹，执行以下yarn react-native run-android 参考 集成到现有原生应用","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"项目结构","date":"2024-03-09T09:31:38.330Z","path":"wiki/JavaScript/ReactNative/项目结构/","text":"android：#Android 项目 ios： node_modules： 项目依赖 app.json： 描述app信息 index.js： 入口文件 package.json: 依赖信息和版本信息 metro.config.js:Metro打包器的配置文件，以配置 Metro 的行为，例如设置转换器（transformer）、指定资源扩展名、设置服务器端口等。 babel.config.js: Babel的配置文件。Babel 是一个 JavaScript 编译器，用于将 ES6+ 代码转换为向后兼容的 JavaScript 版本，以便在当前和旧版本的浏览器或其他环境中运行。 tsconfig.json：指定编译TypeScript代码所需的根文件和编译器选项，一个项目中可能会有多个tsconfig.json文件，用于不同的环境。tsc -p tsconfig_xxx.json指定不同的配置文件 jsconfig.json：定义JS项目的行为，主要改善编辑器的代码智能感知功能 jest.config.js：Jest的配置文件。Jest 是一个 JavaScript 测试框架，用于编写和运行测试。 .eslintrc.js或.eslintrc.json：ESLint的配置文件。ESLint 是一个用于识别和报告 ECMAScript&#x2F;JavaScript 代码中的模式的工具，以确保代码的一致性和避免错误。 .prettierrc.js或.prettierrc.json：Prettier的配置文件。Prettier 是一个代码格式化工具，用于格式化代码以确保代码的一致性。 tsconfig.json1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123; &quot;compilerOptions&quot;: &#123; /* Basic Options */ &quot;target&quot;: &quot;es6&quot;, /* 设置ECMAScript目标版本 Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;,&#x27;ES2018&#x27; or &#x27;ESNEXT&#x27;. */ &quot;module&quot;: &quot;commonjs&quot;, /* 指定生成哪个模块系统 Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, or &#x27;ESNext&#x27;. */ // &quot;lib&quot;: [], /* Specify library files to be included in the compilation. */ &quot;allowJs&quot;: true, /* Allow javascript files to be compiled. */ // &quot;checkJs&quot;: true, /* Report errors in .js files. */ &quot;jsx&quot;: &quot;react&quot;, /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;. */ // &quot;declaration&quot;: true, /* Generates corresponding &#x27;.d.ts&#x27; file. */ // &quot;declarationMap&quot;: true, /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */ // &quot;sourceMap&quot;: true, /* Generates corresponding &#x27;.map&#x27; file. */ // &quot;outFile&quot;: &quot;./&quot;, /* Concatenate and emit output to single file. */ // &quot;outDir&quot;: &quot;./&quot;, /* Redirect output structure to the directory. */ // &quot;rootDir&quot;: &quot;./&quot;, /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */ // &quot;composite&quot;: true, /* Enable project compilation */ // &quot;removeComments&quot;: true, /* Do not emit comments to output. */ // &quot;noEmit&quot;: true, /* Do not emit outputs. */ // &quot;importHelpers&quot;: true, /* Import emit helpers from &#x27;tslib&#x27;. */ // &quot;downlevelIteration&quot;: true, /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */ // &quot;isolatedModules&quot;: true, /* Transpile each file as a separate module (similar to &#x27;ts.transpileModule&#x27;). */ /* Strict Type-Checking Options */ &quot;strict&quot;: true, /* 严格类型检查选项 Enable all strict type-checking options. */ &quot;noImplicitAny&quot;: false, /* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */ // &quot;strictNullChecks&quot;: true, /* Enable strict null checks. */ // &quot;strictFunctionTypes&quot;: true, /* Enable strict checking of function types. */ // &quot;strictBindCallApply&quot;: true, /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */ // &quot;strictPropertyInitialization&quot;: true, /* Enable strict checking of property initialization in classes. */ // &quot;noImplicitThis&quot;: true, /* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */ // &quot;alwaysStrict&quot;: true, /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */ /* Additional Checks */ // &quot;noUnusedLocals&quot;: true, /* Report errors on unused locals. */ // &quot;noUnusedParameters&quot;: true, /* Report errors on unused parameters. */ // &quot;noImplicitReturns&quot;: true, /* Report error when not all code paths in function return a value. */ // &quot;noFallthroughCasesInSwitch&quot;: true, /* Report errors for fallthrough cases in switch statement. */ /* Module Resolution Options */ // &quot;moduleResolution&quot;: &quot;node&quot;, /* Specify module resolution strategy: &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6). */ &quot;baseUrl&quot;: &quot;./&quot;, /* Base directory to resolve non-absolute module names. */ &quot;paths&quot;: &#123; /* 设置模块名到文件路径的映射 */ &quot;@app&quot;: [&quot;./&quot;], &quot;@app/*&quot;: [&quot;./*&quot;], &quot;@common&quot;: [&quot;module_xxx/lib&quot;], &quot;@common/*&quot;: [&quot;module_xxx/lib/*&quot;] &#125;, /* A series of entries which re-map imports to lookup locations relative to the &#x27;baseUrl&#x27;. */ // &quot;rootDirs&quot;: [], /* List of root folders whose combined content represents the structure of the project at runtime. */ // &quot;typeRoots&quot;: [], /* List of folders to include type definitions from. */ // &quot;types&quot;: [], /* Type declaration files to be included in compilation. */ &quot;allowSyntheticDefaultImports&quot;: true, /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */ &quot;esModuleInterop&quot;: true, /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */ // &quot;preserveSymlinks&quot;: true, /* Do not resolve the real path of symlinks. */ /* Source Map Options */ // &quot;sourceRoot&quot;: &quot;&quot;, /* Specify the location where debugger should locate TypeScript files instead of source locations. */ // &quot;mapRoot&quot;: &quot;&quot;, /* Specify the location where debugger should locate map files instead of generated locations. */ // &quot;inlineSourceMap&quot;: true, /* Emit a single file with source maps instead of having a separate file. */ // &quot;inlineSources&quot;: true, /* Emit the source alongside the sourcemaps within a single file; requires &#x27;--inlineSourceMap&#x27; or &#x27;--sourceMap&#x27; to be set. */ /* Experimental Options */ // &quot;experimentalDecorators&quot;: true, /* Enables experimental support for ES7 decorators. */ // &quot;emitDecoratorMetadata&quot;: true, /* Enables experimental support for emitting type metadata for decorators. */ &quot;lib&quot;: [&quot;es2015&quot;, &quot;es2017&quot;, &quot;es2018.promise&quot;] &#125;, &quot;exclude&quot;: [ &quot;node_modules&quot; ]&#125; jsconfig.json1234567891011121314151617181920212223242526&#123; &quot;compilerOptions&quot;: &#123; /* 控制编译过程 */ &quot;target&quot;: &quot;es6&quot;, /* 指定ECMAScript目标版本 */ &quot;module&quot;: &quot;commonjs&quot;, /* 指定生成哪个模块系统 */ &quot;sourceMap&quot;: true, &quot;strict&quot;: true, &quot;noImplicitAny&quot;: false, &quot;allowSyntheticDefaultImports&quot;: true, /* 允许从没有默认导出的模块进行默认导入。这不影响代码输出，只是类型检查。 */ &quot;esModuleInterop&quot;: true, /* 启用CommonJS和ES模块之间的互操作性。这个选项会隐含地设置 allowSyntheticDefaultImports 为 true。 */ &quot;baseUrl&quot;: &quot;.&quot;, &quot;jsx&quot;: &quot;react-native&quot;, &quot;paths&quot;: &#123; &quot;@app&quot;: [&quot;./&quot;], &quot;@app/*&quot;: [&quot;./*&quot;] &#125; &#125;, &quot;include&quot;: [ /* 指定哪些文件被包含在项目中 */ &quot;src/**/*&quot; ], &quot;exclude&quot;: [ /* 排除哪些文件 */ &quot;node_modules&quot;, &quot;babel.config.js&quot;, &quot;metro.config.js&quot; ]&#125; babel.config.js用于将ES6+代码转换为向后兼容的JS版本，在 babel.config.js 文件中，你可以指定一系列的插件和预设，以控制 Babel 的转换过程。例如，你可以使用 @babel&#x2F;preset-env 预设来自动转换 ES6+ 代码，或者使用 @babel&#x2F;plugin-transform-runtime 插件来自动优化你的代码。 1234567891011121314151617181920module.exports = api =&gt; &#123; api.cache.forever() const plugins = [ [&quot;module-resolver&quot;, &#123; root: [&quot;.&quot;], extensions: [&#x27;.ios.js&#x27;, &#x27;.android.js&#x27;, &#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.tsx&#x27;, &#x27;.json&#x27;], alias: &#123; &quot;@app&quot;: [&quot;./&quot;], &quot;@app/*&quot;: [&quot;./*&quot;] &#125; &#125;] ] return &#123; presets: [&#x27;@babel/preset-env&#x27;, &#x27;module:metro-react-native-babel-preset&#x27;], //指定定义好的插件集合 plugins: plugins //指定一组插件 &#125;&#125;; metro.config.js1234567891011121314151617181920module.exports = &#123; resolver: &#123; // assetExts: [&#x27;bmp&#x27;, &#x27;gif&#x27;, &#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;png&#x27;, &#x27;svg&#x27;], //指定应该被视为资源的文件扩展名 sourceExts: [&#x27;js&#x27;, &#x27;json&#x27;, &#x27;ts&#x27;, &#x27;tsx&#x27;, &#x27;jsx&#x27;], //指定应该被视为源代码的文件扩展名 &#125;, server: &#123; port: 8081, //配置服务端口 &#125;, watchFolders: [&#x27;/path/to/folder&#x27;], //监视额外的文件夹 transformer: &#123; //指定转换器 getTransformOptions: async () =&gt; (&#123; transform: &#123; experimentalImportSupport: false, //禁用实验性的import支持 inlineRequires: true, &#125;, &#125;), &#125;,&#125;;","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"Git使用笔记","date":"2024-03-09T09:31:38.330Z","path":"wiki/技术开发/Git/Git使用笔记/","text":"基本概念 Working Space&#x2F;Working Directory：工作区&#x2F;工作目录，平时存放项目代码的地方 Index&#x2F;Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Local Repository：本地仓库 Stash：用于保存工作区的临时状态，方便后续恢复 Remote Repository：远程仓库 基本命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192git init # 输出 Initialized empty Git repository in .git/ 建立空仓库git add . #添加到仓库 把所有修改提交到暂存区(Stage)git commit -m &quot;提交注释&quot; #提交到仓库 把暂存区的所有修改提交到分支git push remote_branch local_branch #将本地库提交到远程库git status #查看修改状态git log #显示从最近到最远的提交日志git log -2： #查看最近几条记录git clone git@github.com:xxx/gitskills.git #克隆仓库#checkout 检查工作目录代码与本地仓库中的代码的差异git checkout -b dev #创建并切换分支，相当于下面的两句git branch experimental #创建分支git checkout experimental #切换到分支git fetch -u origin master #拉取远程仓库名为origin的master分支代码到本地仓库，并不修改本地工作目录的代码，如果要修改，则进行git merge变更合并#merge 将远程仓库的变更，更新到本地工作目录中git merge 分支名 #合并分支到当前分支上#git pull相当于git fetch + git merge#git pull --rebase 相当于 git fetch + git rebase#remote 用于管理远程仓库git remote -v #查看现有的远程仓库#添加一个远程仓库git remote add &lt;仓库名字&gt; &lt;仓库的URL&gt;git remote add pb git://github.com/paulboone/ticgit.git #添加一个远程仓库 并用pb命名。git remote rm paul #删除远程仓库git remote rename pb paul #重名远程仓库 本地也会跟着修改git remote set-url origin xxx.git # 修改远程仓库#git push -u &lt;远程仓库名字&gt; &lt;远程仓库的某一分支名字&gt;git push -u test mater #将本地仓库的变更推送远程仓库的master分支git push origin 标签名 #推送标签到远程仓库git push origin --tags #推送所有标签到远程仓库git push origin :refs/tags/标签名 #从远程仓库中删除标签git push origin --delete &lt;branchname&gt; #删除远程分支git push origin :&lt;branchName&gt; #删除远程分支#暂存操作：git stash 暂存当前修改git stash apply 恢复最近的一次暂存git stash pop 恢复暂存并删除暂存记录git stash list 查看暂存列表git stash drop 暂存名(例：stash@&#123;0&#125;) 移除某次暂存git stash clear 清除暂存#回退操作：#Git服务有一个叫HEAD的版本指针，当用户申请还原数据时，其实就是将HEAD指针指向到某个特定的提交版本。#git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。#虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！#为了撤销更改并分享给别人，我们需要使用 git revert。新提交记录 C2&#x27; 引入了更改 —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2&#x27; 的状态与 C1 是相同的。git reset --hard HEAD^ #回退到上一个版本git reset --hard ahdhs1(commit_id) #回退到某个版本，撤销git commit，撤销git add，删除编辑器改动代码git reset --soft (commit id) #撤销git commit，不撤销git add，保留编辑器改动代码git reset --mixed (commit id) #撤销git commit，撤销git add，保留编辑器改动代码git checkout -- file #撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)git reset HEAD file #撤回暂存区的文件修改到工作区git revert HEAD#标签操作：#tag的作用是方便用户回滚操作，只需要记住tag的名字就能迅速回滚git tag #列出所有标签列表，可以按照标签进行checkoutgit tag 标签名 #添加标签(默认对当前版本)git tag 标签名 commit_id #对某一提交记录打标签git tag -a 标签名 -m &#x27;描述&#x27; #创建新标签并增加备注git show 标签名 #查看标签信息git tag -d 标签名 #删除本地标签#git rm提交删除文件的变更到暂存区git diff test.txt 本地工作目录中到文件与本地仓库中的文件对比# 时光机，查看提交记录git reflog # 取消xxx的修改内容git restore xxx Git分支管理master分支一般用于发布新版本，dev分支用于开发，每个人从dev分支创建自己的个人分支，开发完合并到dev分支，最后合并到master分支。 123456789101112git branch 查看所有已存在的分支git branch -a 查看远程分支git branch -v 查看所有分支的最后一次操作git branch -vv 查看当前分支git brabch -b 分支名 origin/分支名 //创建远程分支到本地git branch --merged //查看别的分支和当前分支合并过的分支git branch --no-merged //查看未与当前分支合并的分支git branch -d xxx 删除本地分支git branch -D crazy-idea 强制删除分支git merge 功能1 #合并功能1分支到当前分支git branch -d 功能1 # 删除功能1分支（当前不能在功能1分支、删除的是本地分支） gitignore文件用来存储不需要进行版本管理的文件 文件匹配规则12345*.log # 表示忽略项目中所有以.log结尾的文件123?.log # 忽略所有以123加任意一个字符，且以.log结尾的文件/error.log # 忽略根目录下的error.log文件**/java/ # 忽略所有java目录下的所有文件!/error.log # 表示在前面的匹配规则中，被忽略了的文件，你不想它被忽略，那么就可以在文件前面加叹号 拉取体积很大的仓库12345678910111213141516git clone --depth 1 仓库地址git fetch --unshallow#以上方式只有主分支#拉取所有分支git fetch -all#拉取某一个分支git branch -agit remote set-branches origin &#x27;远程分支名称’git fetch --depth 1 origin 远程分支名称git checkout ‘远程分支名称’ 仓库之间的迁移整个仓库迁移123git clone --bare 旧仓库地址git push --mirror 新仓库地址 迁移一个分支12git remote add 本地分支 新仓库地址 //关联远程分支git push 远程分支 本地分支 //提交分支 SourceTreeCould not read from remote repository解决办法12345cd ~/.ssh# 确认将公钥添加到服务器# 验证ssh -T git@github.comssh-add id-rsa Sourcetree使用Permission denied错误1234567git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. Mac每次重启之后就无法在Sourcetree连接服务器了，原因是私钥没有添加到钥匙链中，需要执行以下命令： 12345678910111213141516#ssh-add参数-D：删除ssh-agent中的所有密钥.-d：从ssh-agent中的删除密钥-e pkcs11：删除PKCS#11共享库pkcs1提供的钥匙。-s pkcs11：添加PKCS#11共享库pkcs1提供的钥匙。-L：显示ssh-agent中的公钥-l：显示ssh-agent中的密钥-t life：对加载的密钥设置超时时间，超时ssh-agent将自动卸载密钥-X：对ssh-agent进行解锁-x：对ssh-agent进行加锁ssh-add -K !/.ssh/id_rsa#查看ssh-agent中的密钥ssh-add -l 移动HEAD12345678# 切换到指定idgit checkout commit_id# 指定提交git branch -f branch_name HEAD~1# 上一个提交git branch -f branch_name HEAD^","tags":[{"name":"Git","slug":"Git","permalink":"http://airshu.github.io/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Git","slug":"技术开发/Git","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Git/"}]},{"title":"package.json说明","date":"2024-03-09T09:31:38.329Z","path":"wiki/JavaScript/ReactNative/package.json/","text":"12345678910111213141516171819202122232425262728293031323334353637383940&#123; &quot;name&quot;: &quot;app_name&quot;,//应用名 &quot;version&quot;: &quot;1.1.1&quot;,//版本，用于展示 &quot;versionCode&quot;: 99,//版本号 &quot;private&quot;: true, &quot;scripts&quot;: &#123; //常用的命令封装 &quot;start&quot;: &quot;&quot;, &quot;clear&quot;: &quot;&quot;, &quot;publish&quot;: &quot;&quot;, &quot;android&quot;: &quot;&quot;, &quot;ios&quot;: &quot;&quot; &#125;, &quot;engines&quot;: &#123;&#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;&quot; &#125;, &quot;keywords&quot;: &#123;&#125;, &quot;author&quot;: &#123; &quot;name&quot;: &quot;&quot;, &quot;email&quot;: &quot;&quot; &#125;, &quot;license&quot;: &quot;&quot;, &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;&quot; &#125;, &quot;homepage&quot;: &#123;&#125;, &quot;dependencies&quot;: &#123;//项目的依赖 &quot;react&quot;: &quot;18.2.0&quot;, &quot;react-native&quot;: &quot;0.71.7&quot; &#125;, &quot;resolutions&quot;:&#123; /* 强制依赖， 只在yarn中有效，npm不支持此字段 */ &quot;@types/react&quot;: &quot;^17&quot; &#125;, &quot;devDependencies&quot;: &#123;//开发的时候依赖 &#125;&#125;","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"基础知识","date":"2024-03-09T09:31:38.329Z","path":"wiki/JavaScript/ReactNative/基础知识/","text":"facebook先开源了React，然后基于React，开源了可以在App上用的React Native。先了解一下ReactReact 入门实例教程 React是一个JavaScript库，用于简单的创建用户界面；React Native则可以用于手机Android、iOS应用。 开发React需要引入： react.js：核心库 react-dom.js：与DOM相关 browser.min.js：将JSX转为JavaScript语法 原生组件和核心组件React Native允许用户为Android和iOS构建自己的Native Components（原生组件），RN自己也包括一组基本的，随时可用的原生组件（核心组件） 核心组件 View Text Image ScrollView TextInput 函数式组件与Class组件优先使用函数式组件 123456789101112131415161718192021222324252627const HelloWorldApp = () =&gt; &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: &#x27;center&#x27;, alignItems: &#x27;center&#x27; &#125;&#125;&gt; &lt;Text&gt;Hello, world!&lt;/Text&gt; &lt;/View&gt; );&#125;class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; &#125;&#125;&gt; &lt;Text&gt;Hello, world!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 组件的生命周期 mounting:已插入真实DOM updating:正在被重新渲染 unmounting:已移出真实DOM React为每个状态提供了两种处理函数，will函数载进入状态之前调用，did函数在进入状态之后调用 123456789componentWillMount()componentDidMount()componentWillUpdate(object nextProps, object nextState)componentDidUpdate(object prevProps, object prevState)componentWillUnmount()//特殊状态的处理函数componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 专有名词JSXJSX 仅仅只是 React.createElement(component, props, …children) 函数的语法糖. https://zh-hans.legacy.reactjs.org/docs/jsx-in-depth.html#gatsby-focus-wrapper React：纯JS框架，用 JS 实现了 Virtual Dom, 实现了数据驱动编程的模式, 而且 React 还提出了独特的 JSX 语法, 实现了在 JS 就可以写 HTML 和 CSS 代码, 配合虚拟 DOM 就实现了基于 MVC 的前端框架 Babel:Babel 是一个高度可配置的编译器，它允许我们使用较新的 JavaScript 语言功能（以及扩展，如 JSX），将“向下”编译为更广泛的引擎支持的较旧版本的 JavaScript React Native：JavaScript Core + React.js + Bridges JavaScriptCore：JS引擎，用来解释和执行JavaScript代码。在React Native中，负责bundle产出的JS代码的解析和执行 JS Engine：React Native需要一个JS运行环境，RN会把应用的JS代码编译成一个JS文件（x.x.bundle），RN框架的目标就是解释运行这个JS脚本文件，如果是Native扩展的API，则直接通过bridge调用Native方法，最基础的比如绘制UI界面，映射Virtual DOM到真实的UI组件中。 Hermes Engine：新一代JavaScript引擎，相对于JavaScriptCore和V8引擎，各方面性能显著提升。 Bridge： RCTRootView： RCTBridge： 加载和初始化专用类, 用于前期 JS 的初始化和原生代码的加载 负责加载各个 Bridge 模块供 JS 调用 找到并注册实现了 RCTBridgeModule protocol 的类 创建持有 RCTBatchedBridge RCTBatchedBridge：负责 Native 和 JS 之间的相互调用, 也就是信息通信 RCTJavaScriptLoader：实现远程代码的核心, 热更新, 开发环境代码加载. 静态 jsbundle 加载 RCTContextExecutor：封装了 JS 和 Native 代码的互相调用逻辑 RCTModuleData：加载管理所有与 JS 交互的原生代码, 把交互代码封装成 JS 模块 RCTModuleMethod： 记录所有原生代码的导出函数地址, 同时生成对应的字符串映射到改函数地址 翻译所有 J2N call MessageQueue： metro：facebook官方推出的打包工具，构建代码和资源 JSI：JavaScript Interface，JSI 是一个轻量级的通用的 API 框架，可以应用于任意的 JavaScript virtual machine fabric：UI Manager新名称，整个框架中新UI层 codepush：用于热更新 JS Thread：读取和编译所有JavaScript代码 UI Thread：原生渲染和调用 Shadow Thread：通过Yoga引擎计算布局，将结果发送给Native UI 常用的API ReactContext：继承于ContextWrapper，是React Native应用的上下文，管理着CatalystInstance以及三大线程（UIThread、NativeModulesThread、JSThread） ReactApplicationContext: ReactContext的子类，提供RN应用的上下文 管理原生模块和视图 包含一个CatalystInstance，负责JS的执行 用于在JS和原生代码之间的事件传递 ReactInstanceManager：总的管理类，管理ReactPackage、ReactContext、ReactRootView，同时还可以设置JavaScript引擎 控制生命周期 创建和销毁ReactContext 加载React应用，可以从服务器、本地文件、assets中加载JS bundle 负责原生模块和视图，负责处理Android的生命周期事件 ReactRootView：React Native渲染的原生容器，继承于FrameLayout 承载React应用的UI，所有React组件都会在这个View中渲染 启动React应用，通过调用startReactApplication方法启动一个RN应用 处理Android的触摸事件，将其转换为React事件 CatalystInstance：代表JS执行环境。Java层、C++层、JavaScript层通信的总管理类，管理着Java层、JavaScript层Module映射表与回调，是三端通信的桥梁。实现类为CatalystInstanceImpl，支持向JavaScript注入全局变量、动态加载脚本文件、获取NativeModules &amp; JSModules runJSBundle：执行JS代码 包含一个NativeModuleRegistry，用于管理RN的原生模块。当JS调用一个原生模块方法时，CatalystInstance会将这个调用转发给对应的原生模块 callFunction：调用JS函数 ReactBridge：通信桥，三端通信的桥梁 执行JS代码 调用原生模块 调用JS函数 传递事件 JavaScriptModule：JS Module，负责JavaScript到Java的映射调用格式生命，由CatalystInstance统一管理 NativeModule：Java Module，负责Java到JavaScript的映射调用格式声明，由CatalystInstance统一管理 JavaScriptModuleRegistry:JavaScriptModule注册表，负责管理与查找JavaScriptModule JSCExecutor.cpp: 脚本引擎，封装了Webkit的JavaScriptCore UIManager：处理UI的渲染，JavaScript层通过C++层把创建的View的请求发送给Java层的UIManagerModule Android常用API： ReactPackage: 用于注册原生模块和视图管理器。注册到ReactInstanceManager createNativeModules：返回一个原生模块列表，并将她们添加到NativeModuleRegistry createViewManagers：返回视图管理器列表，RN会调用这个方法来获取你的视图管理器，并将它们添加到UIManagerModule TurboReactPackage：允许原生模块在需要时才被初始化 MainReactPackage: 包含默认支持的package，对应modules文件夹，比如toast、storeage等等，可以直接在js端使用 常用Modules： AppearanceModule： CameraRollManager：允许JS访问相机和摄像头 ClipboardModule：剪切板操作 DatePickerDialogModule：原生日期选择 DeviceInfoModule：设备信息 DialogModule：显示原生弹窗 NetworkingModule：网络访问 PermissionsModule：权限管理 ShareModule：系统分享 StatusBarModule：状态栏设置 AsyncStorageModule：存储键值对 AndroidInfoModule：获取Android的一些常量信息，比如厂商、版本信息等 ToastModule：原生toast ReactContextBaseJavaModule: 一个package对应一个module，里面会实现native的方法给js用 ReactNativeHost：对js数据的包装，负责创建ReactInstanceManager，方便用户使用，一般要实现getPackages方法返回所有bundle getPackages：返回包含所有React包的列表 管理生命周期，在应用生命周期发生变化时通知ReactInstanceManager getJSMainModuleName：返回JS主模块的名称，是NR的入口点。默认情况下，返回”index“，则意味着加载index.js的文件作为应用的入口点 getBundleAssetName：返回JS bundle的asset名称，默认情况下返回“index.android.bundle” getUseDeveloperSupport：返回是否使用开发者支持，默认情况下返回true getRedBoxHandler：返回RN应用中的红屏错误，可以重写这个方法进行监听 getJSBundleFile：返回JS bundle的文件路径，如果返回null，则会使用getBundleAssetName返回的asset文件 ReactActivity：封装好的Activity，方便使用 ReactFragment： ReactActivityDelegate：委托类，可以实现各种回调 ReactDelegate：ReactActivityDelegate的成员变量 ReactApplication：如果使用ReactActivity，则Application需要实现这个接口，将package进行注册 常用命令 npm npx yarn ES6特性class module export import Named imports and exports Import from modules 参考 React Native 原理与实践 https://github.com/sucese/react-native https://www.reactnative.express/","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"环境搭建","date":"2024-03-09T09:31:38.329Z","path":"wiki/JavaScript/ReactNative/环境搭建/","text":"Mac 环境搭建12345678910111213141516171819# 安装nodebrew install node# 安装文件监控，方便开发brew install watchman# 使用nrm工具切换淘宝源npx nrm use taobao# 如果之后需要切换回官方源可使用npx nrm use npm# Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载npm install -g yarn# 安装java环境# 安装Android开发环境 Hello World12345678910111213# 新建项目npx react-native init AwesomeProject# 启动Metronpm start yarn start# 运行Android端npm run androidyarn androidnpm run iosyarn ios 端口配置12345678# 启动metro修改端口，建议使用这种方式npm run start --verbose -- --port 8082# 默认会监听8081端口# 配置环境变量指定端口，未验证是否有效export RCT_METRO_PORT=9091npx react-native start --port 9091 nvm推荐使用nvm来做node多版本管理 123456789101112131415# 查看已安装的node版本nvm list# 安装指定版本nvm install v12.18.3# 卸载指定版本nvm uninstall v12.18.3# 当前项目指定node版本nvm use v12.18.3# 设置全局默认版本nvm alias default v12.18.3 参考 https://github.com/crazycodeboy/RNStudyNotes","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"状态管理","date":"2024-03-09T09:31:38.329Z","path":"wiki/JavaScript/ReactNative/状态管理/","text":"","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"RN常用的开源库","date":"2024-03-09T09:31:38.329Z","path":"wiki/JavaScript/ReactNative/开源库/RN常用的开源库/","text":"antd-mobile-rn https://rn.mobile.ant.design/ antd-mobile-rn是一个基于React Native的UI组件库，由蚂蚁金服团队开发和维护。包含了许多常用的UI组件，如按钮、列表、输入框、导航栏、轮播图、对话框等。这些组件都遵循了Ant Design的设计规范，具有一致的视觉样式和交互行为。 async-retryasync-retry是一个用于在异步操作失败时进行重试的JavaScript库。它提供了一个简单的API，你可以使用它来包装一个异步函数，当这个函数抛出错误时，async-retry会自动重试这个函数。 12345678910111213const retry = require(&#x27;async-retry&#x27;)async function fetchData() &#123; // 这里是你的异步操作&#125;retry(fetchData, &#123; retries: 5, // 重试次数 factor: 2, // 每次重试之间的时间间隔将乘以这个因子 minTimeout: 1000, // 两次重试之间的最小时间间隔 maxTimeout: Infinity, // 两次重试之间的最大时间间隔 onRetry: error =&gt; &#123; console.log(error) &#125; // 在每次重试前调用&#125;) axios https://www.axios-http.cn/docs/intro 网络请求库 babel-jestbabel-jest是一个Jest插件，用于使用Babel转换你的JavaScript代码。当你在Jest测试中使用ES6或其他需要转换的JavaScript语法时，你需要使用babel-jest。 Jest https://jestjs.io/ Jest是一个流行的JavaScript测试框架，由Facebook开发并开源。它被设计为提供完整的测试解决方案，包括单元测试、集成测试和快照测试。 Metro https://facebook.github.io/metro/ Metro是Facebook开发的一个JavaScript模块打包器，用于React Native应用。它负责将你的JavaScript代码和依赖项打包成一个单一的文件，这个文件可以在React Native应用中运行。 Metro的主要功能包括： 代码转换：Metro使用Babel将你的JavaScript代码转换为可以在React Native环境中运行的代码。 模块打包：Metro将你的所有JavaScript模块打包成一个单一的bundle文件。 资源管理：Metro可以处理图片和其他静态资源，将它们包含在bundle中。 热更新：Metro支持热更新，这意味着你可以在不重新打包整个应用的情况下，更新你的JavaScript代码。 源码映射：Metro可以生成源码映射，这对于调试和错误跟踪非常有用。 react-hook-form https://react-hook-form.com/ react-hook-form是一个用于在React应用中处理表单的库。它使用React的钩子（Hooks）API，提供了一种简单、高效的方式来验证和收集表单数据。 redux状态管理框架 rematchRematch是一个基于Redux的状态管理库，它提供了一种更简单的方式来使用Redux。它有以下插件： @rematch&#x2F;core：它提供了Rematch的主要功能，包括定义models、创建store等。 @rematch&#x2F;select：它提供了一种简单的方式来创建和使用selectors。Selectors可以帮助你从store中选择和计算派生数据。 @rematch&#x2F;loading：它自动跟踪你的异步action的加载状态。这可以帮助你在UI中显示加载指示器。 @rematch&#x2F;updated：它提供了一种方式来跟踪你的state的更新状态。 @rematch&#x2F;persist：它提供了一种方式来持久化和恢复你的state。这可以帮助你在页面刷新或重新加载时保持用户的状态。 @rematch&#x2F;immer：它让你可以在reducers中使用Immer库来更简单地处理不可变状态。 react-native https://reactnative.dev/ React Native是一个由Facebook开发的开源框架，用于构建跨平台的移动应用。它允许你使用JavaScript和React来编写本地移动应用，而无需学习Swift或Java。 react-native-code-pushreact-native-code-push是一个用于React Native应用的开源库，它允许开发者通过Microsoft的CodePush服务直接向用户的设备推送代码更新。 react-native-fast-image它提供了比React Native内置的Image组件更高效的图片加载。 react-native-get-random-values它提供了一个实现了Web Crypto API的getRandomValues方法。这个方法可以生成一个包含随机数的类型化数组。在Web浏览器中，getRandomValues方法是Web Crypto API的一部分，用于生成加密安全的随机数。但在React Native中，Web Crypto API并不可用，因此我们需要react-native-get-random-values这个库来提供类似的功能。 react-native-gesture-handler它提供了一种在JavaScript中处理触摸手势的方式。这个库的目标是提供一个更强大、更灵活的手势系统，以替代React Native内置的手势系统。 react-native-highlight-words它可以在文本中高亮显示指定的单词或短语。 react-native-drag-sort提供了一个可以拖动排序的列表组件 react-native-image-crop-picker图片的选择和裁剪 react-native-linear-gradient线性渐变背景的功能 react-native-modal模态窗口组件 react-native-ratings评分组件 react-native-reanimated提供了一个更强大和灵活的方式来创建动画，有以下特点： 性能优化：react-native-reanimated在原生线程上执行动画，避免了JavaScript线程的阻塞，从而提高了动画的性能。 灵活的API：react-native-reanimated提供了一套低级API，你可以使用这些API来创建复杂的动画和交互。 与手势库集成：react-native-reanimated可以与react-native-gesture-handler库集成，使你可以创建与手势交互的动画。 react-native-safe-area-context提供一个安全区域的上下文，可以帮助你避免在设备的刘海、圆角、虚拟家庭指示器等特殊区域内放置内容。 react-native-safe-area-view视图组件，可以帮助你的应用适应设备的安全区域。 react-native-screens提供原生的屏幕组件 react-native-size-matters提供一个简单的API，可以帮助你在不同的设备上适配不同的尺寸。 react-native-soundreact-native-svgreact-native-swiper轮播图组件 react-native-videoreact-native-view-shot可以捕获某个视图的截图 react-native-vector-icons使用矢量图标 react-native-collapsible可折叠组件 react-navigation导航组件 react-navigation-transitions自定义屏幕之间的转场动画 rneReact Native Elements是一个用于React Native应用的UI组件库，它提供了一套丰富的UI组件，包括按钮、图标、输入框、列表、卡片、轮播图等。这些组件都遵循了Material Design的设计规范，具有一致的视觉样式和交互行为。 @rneui&#x2F;base@rneui&#x2F;envinfo#rneui&#x2F;themed@rneui&#x2F;layout@rneui&#x2F;kit#rneui&#x2F;template","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"},{"name":"开源库","slug":"JavaScript/ReactNative/开源库","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"flutter Android端编译流程","date":"2024-03-09T09:31:38.328Z","path":"wiki/Flutter/源码分析/flutter Android端编译流程/","text":"Android编译源码流程 settings.gradle配置 123456789101112131415161718// 当前 app moduleinclude &#x27;:app&#x27;/** * 1、读取android/local.properties文件内容 * 2、获取flutter.sdk的值，也就是你本地flutter SDK安装目录 * 3、gradle 脚本常规操作 apply flutter SDK路径下/packages/flutter_tools/gradle/app_plugin_loader.gradle文件 */def localPropertiesFile = new File(rootProject.projectDir, &quot;local.properties&quot;)def properties = new Properties()assert localPropertiesFile.exists()localPropertiesFile.withReader(&quot;UTF-8&quot;) &#123; reader -&gt; properties.load(reader) &#125;def flutterSdkPath = properties.getProperty(&quot;flutter.sdk&quot;)assert flutterSdkPath != null, &quot;flutter.sdk not set in local.properties&quot;apply from: &quot;$flutterSdkPath/packages/flutter_tools/gradle/app_plugin_loader.gradle&quot; 查看app_plugin_loader.gradle文件 1234567891011121314151617181920212223242526272829import groovy.json.JsonSlurper//得到自己新建的 flutter 项目的根路径，因为已经被自己新建的 project apply，所以这里是项目根路径哦def flutterProjectRoot = rootProject.projectDir.parentFile//获取自己项目根路径下的.flutter-plugins-dependencies json配置文件// Note: if this logic is changed, also change the logic in module_plugin_loader.gradle.def pluginsFile = new File(flutterProjectRoot, &#x27;.flutter-plugins-dependencies&#x27;)if (!pluginsFile.exists()) &#123; return&#125;/** * 1、通过groovy的JsonSlurper解析json文件内容。 * 2、简单校验json内容字段的类型合法性。 * 3、把安卓平台依赖的Flutter plugins全部自动include进来 */def object = new JsonSlurper().parseText(pluginsFile.text)assert object instanceof Mapassert object.plugins instanceof Mapassert object.plugins.android instanceof List// Includes the Flutter plugins that support the Android platform.object.plugins.android.each &#123; androidPlugin -&gt; assert androidPlugin.name instanceof String assert androidPlugin.path instanceof String def pluginDirectory = new File(androidPlugin.path, &#x27;android&#x27;) assert pluginDirectory.exists() include &quot;:$&#123;androidPlugin.name&#125;&quot; project(&quot;:$&#123;androidPlugin.name&#125;&quot;).projectDir = pluginDirectory&#125; 我们在flutter项目中配置不同的plugin、package，会在项目根目录生成.flutter-plugins-dependencies，app_plugin_loader.gradle会将其中的Android部分库添加进来，用Android Studio打开android文件夹，会自动加载这些库。 在android文件夹下的build.gradle中: 12345678//......省略无关紧要的常见配置// 看到了吧，他将所有 android 依赖的构建产物挪到了根目录下的 build 中，所有产物都在那儿rootProject.buildDir = &#x27;../build&#x27;subprojects &#123; project.buildDir = &quot;$&#123;rootProject.buildDir&#125;/$&#123;project.name&#125;&quot; project.evaluationDependsOn(&#x27;:app&#x27;) //运行其他配置之前，先运行app依赖&#125; 然后看app模块下的build.gradle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 1、读取local.properties配置信息。 * 2、获取flutter.sdk路径。 * 3、获取flutter.versionCode值，此值在编译时自动从pubspec.yaml中读取赋值，所以修改版本号请修改yaml。 * 4、获取flutter.versionName值，此值在编译时自动从pubspec.yaml中读取赋值，所以修改版本号请修改yaml。 */def localProperties = new Properties()def localPropertiesFile = rootProject.file(&#x27;local.properties&#x27;)if (localPropertiesFile.exists()) &#123; localPropertiesFile.withReader(&#x27;UTF-8&#x27;) &#123; reader -&gt; localProperties.load(reader) &#125;&#125;def flutterRoot = localProperties.getProperty(&#x27;flutter.sdk&#x27;)if (flutterRoot == null) &#123; throw new GradleException(&quot;Flutter SDK not found. Define location with flutter.sdk in the local.properties file.&quot;)&#125;def flutterVersionCode = localProperties.getProperty(&#x27;flutter.versionCode&#x27;)if (flutterVersionCode == null) &#123; flutterVersionCode = &#x27;1&#x27;&#125;def flutterVersionName = localProperties.getProperty(&#x27;flutter.versionName&#x27;)if (flutterVersionName == null) &#123; flutterVersionName = &#x27;1.0&#x27;&#125;//常规操作，不解释apply plugin: &#x27;com.android.application&#x27;apply plugin: &#x27;kotlin-android&#x27;//重点1：apply 了 flutter SDK 下面的packages/flutter_tools/gradle/flutter.gradle脚本文件apply from: &quot;$flutterRoot/packages/flutter_tools/gradle/flutter.gradle&quot;android &#123; compileSdkVersion 30 sourceSets &#123; main.java.srcDirs += &#x27;src/main/kotlin&#x27; &#125; defaultConfig &#123; applicationId &quot;cn.yan.f1&quot; minSdkVersion 21 targetSdkVersion 30 versionCode flutterVersionCode.toInteger() //赋值为yaml中读取的值 versionName flutterVersionName //赋值为yaml中读取的值 &#125; //......省略常规操作，不解释&#125;//重点2：一个拓展配置，指定source路径为当前的两级父级，也就是项目根目录flutter &#123; source &#x27;../..&#x27;&#125;//......省略常规操作，不解释 看看重点1flutter.gradle文件，它实际上运行了flutter.groovy这个文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//......省略一堆import头文件/** * 常规脚本配置：脚本依赖仓库及依赖的 AGP 版本 * 如果你自己没有全局配国内maven镜像，修改这里repositories也可以。 * 如果你项目对于AGP这个版本不兼容，自己修改这里然后兼容也可以。 */buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:4.1.0&#x27; &#125;&#125;//java8编译配置android &#123; compileOptions &#123; sourceCompatibility 1.8 targetCompatibility 1.8 &#125;&#125;//又 apply 了一个插件，只是这个插件源码直接定义在下方apply plugin: FlutterPlugin//FlutterPlugin插件实现源码，参考标准插件写法一样，基本语法不解释，这里重点看逻辑。class FlutterPlugin implements Plugin&lt;Project&gt; &#123; //...... //重点入口！！！！！！ @Override void apply(Project project) &#123; this.project = project //1、配置maven仓库地址，环境变量有配置FLUTTER_STORAGE_BASE_URL就优先用，没就缺省 String hostedRepository = System.env.FLUTTER_STORAGE_BASE_URL ?: DEFAULT_MAVEN_HOST String repository = useLocalEngine() ? project.property(&#x27;local-engine-repo&#x27;) : &quot;$hostedRepository/download.flutter.io&quot; project.rootProject.allprojects &#123; repositories &#123; maven &#123; url repository &#125; &#125; &#125; //2、创建app模块中配置的flutter&#123; source: &#x27;../../&#x27;&#125;闭包extensions project.extensions.create(&quot;flutter&quot;, FlutterExtension) //3、添加flutter构建相关的各种task this.addFlutterTasks(project) //4、判断编译命令flutter build apk --split-per-abi是否添加--split-per-abi参数，有的话就拆分成多个abi包。 if (shouldSplitPerAbi()) &#123; project.android &#123; splits &#123; abi &#123; // Enables building multiple APKs per ABI. enable true // Resets the list of ABIs that Gradle should create APKs for to none. reset() // Specifies that we do not want to also generate a universal APK that includes all ABIs. universalApk false &#125; &#125; &#125; &#125; //5、判断编译命令是否添加deferred-component-names参数，有就配置android dynamicFeatures bundle特性。 if (project.hasProperty(&#x27;deferred-component-names&#x27;)) &#123; String[] componentNames = project.property(&#x27;deferred-component-names&#x27;).split(&#x27;,&#x27;).collect &#123;&quot;:$&#123;it&#125;&quot;&#125; project.android &#123; dynamicFeatures = componentNames &#125; &#125; //6、判断编译命令是否添加--target-platform=xxxABI参数，没有就用缺省，有就看这个ABI是否flutter支持的，支持就配置，否则抛出异常。 getTargetPlatforms().each &#123; targetArch -&gt; String abiValue = PLATFORM_ARCH_MAP[targetArch] project.android &#123; if (shouldSplitPerAbi()) &#123; splits &#123; abi &#123; include abiValue &#125; &#125; &#125; &#125; &#125; //7、通过属性配置获取flutter.sdk，或者通过环境变量FLUTTER_ROOT获取，都没有就抛出环境异常。 String flutterRootPath = resolveProperty(&quot;flutter.sdk&quot;, System.env.FLUTTER_ROOT) if (flutterRootPath == null) &#123; throw new GradleException(&quot;Flutter SDK not found. Define location with flutter.sdk in the local.properties file or with a FLUTTER_ROOT environment variable.&quot;) &#125; flutterRoot = project.file(flutterRootPath) if (!flutterRoot.isDirectory()) &#123; throw new GradleException(&quot;flutter.sdk must point to the Flutter SDK directory&quot;) &#125; //8、获取Flutter Engine的版本号，如果通过local-engine-repo参数使用本地自己编译的Engine则版本为+，否则读取SDK目录下bin\\internal\\engine.version文件值，一串类似MD5的值。 engineVersion = useLocalEngine() ? &quot;+&quot; // Match any version since there&#x27;s only one. : &quot;1.0.0-&quot; + Paths.get(flutterRoot.absolutePath, &quot;bin&quot;, &quot;internal&quot;, &quot;engine.version&quot;).toFile().text.trim() //9、依据平台获取对应flutter命令脚本，都位于SDK目录下bin\\中，名字为flutter String flutterExecutableName = Os.isFamily(Os.FAMILY_WINDOWS) ? &quot;flutter.bat&quot; : &quot;flutter&quot; flutterExecutable = Paths.get(flutterRoot.absolutePath, &quot;bin&quot;, flutterExecutableName).toFile(); //10、获取flutter混淆配置清单，位于SDK路径下packages\\flutter_tools\\gradle\\flutter_proguard_rules.pro。 //里面配置只有 -dontwarn io.flutter.plugin.** 和 -dontwarn android.** String flutterProguardRules = Paths.get(flutterRoot.absolutePath, &quot;packages&quot;, &quot;flutter_tools&quot;, &quot;gradle&quot;, &quot;flutter_proguard_rules.pro&quot;) project.android.buildTypes &#123; //11、新增profile构建类型，在当前project下的android.buildTypes中进行配置 profile &#123; initWith debug //initWith操作复制所有debug里面的属性 if (it.hasProperty(&quot;matchingFallbacks&quot;)) &#123; matchingFallbacks = [&quot;debug&quot;, &quot;release&quot;] &#125; &#125; //...... &#125; //...... //12、给所有buildTypes添加依赖，addFlutterDependencies project.android.buildTypes.all this.&amp;addFlutterDependencies &#125; //......&#125;//flutter&#123;&#125;闭包Extension定义class FlutterExtension &#123; String source String target&#125;//...... 接下来看看addFluterTasks方法，这是整个编译的重点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private void addFlutterTasks(Project project) &#123; //gradle项目配置评估失败则返回，常规操作，忽略 if (project.state.failure) &#123; return &#125; //1、一堆属性获取与赋值操作 String[] fileSystemRootsValue = null if (project.hasProperty(&#x27;filesystem-roots&#x27;)) &#123; fileSystemRootsValue = project.property(&#x27;filesystem-roots&#x27;).split(&#x27;\\\\|&#x27;) &#125; String fileSystemSchemeValue = null if (project.hasProperty(&#x27;filesystem-scheme&#x27;)) &#123; fileSystemSchemeValue = project.property(&#x27;filesystem-scheme&#x27;) &#125; Boolean trackWidgetCreationValue = true if (project.hasProperty(&#x27;track-widget-creation&#x27;)) &#123; trackWidgetCreationValue = project.property(&#x27;track-widget-creation&#x27;).toBoolean() &#125; String extraFrontEndOptionsValue = null if (project.hasProperty(&#x27;extra-front-end-options&#x27;)) &#123; extraFrontEndOptionsValue = project.property(&#x27;extra-front-end-options&#x27;) &#125; String extraGenSnapshotOptionsValue = null if (project.hasProperty(&#x27;extra-gen-snapshot-options&#x27;)) &#123; extraGenSnapshotOptionsValue = project.property(&#x27;extra-gen-snapshot-options&#x27;) &#125; String splitDebugInfoValue = null if (project.hasProperty(&#x27;split-debug-info&#x27;)) &#123; splitDebugInfoValue = project.property(&#x27;split-debug-info&#x27;) &#125; Boolean dartObfuscationValue = false if (project.hasProperty(&#x27;dart-obfuscation&#x27;)) &#123; dartObfuscationValue = project.property(&#x27;dart-obfuscation&#x27;).toBoolean(); &#125; Boolean treeShakeIconsOptionsValue = false if (project.hasProperty(&#x27;tree-shake-icons&#x27;)) &#123; treeShakeIconsOptionsValue = project.property(&#x27;tree-shake-icons&#x27;).toBoolean() &#125; String dartDefinesValue = null if (project.hasProperty(&#x27;dart-defines&#x27;)) &#123; dartDefinesValue = project.property(&#x27;dart-defines&#x27;) &#125; String bundleSkSLPathValue; if (project.hasProperty(&#x27;bundle-sksl-path&#x27;)) &#123; bundleSkSLPathValue = project.property(&#x27;bundle-sksl-path&#x27;) &#125; String performanceMeasurementFileValue; if (project.hasProperty(&#x27;performance-measurement-file&#x27;)) &#123; performanceMeasurementFileValue = project.property(&#x27;performance-measurement-file&#x27;) &#125; String codeSizeDirectoryValue; if (project.hasProperty(&#x27;code-size-directory&#x27;)) &#123; codeSizeDirectoryValue = project.property(&#x27;code-size-directory&#x27;) &#125; Boolean deferredComponentsValue = false if (project.hasProperty(&#x27;deferred-components&#x27;)) &#123; deferredComponentsValue = project.property(&#x27;deferred-components&#x27;).toBoolean() &#125; Boolean validateDeferredComponentsValue = true if (project.hasProperty(&#x27;validate-deferred-components&#x27;)) &#123; validateDeferredComponentsValue = project.property(&#x27;validate-deferred-components&#x27;).toBoolean() &#125; def targetPlatforms = getTargetPlatforms() ......&#125; 可以看到，addFlutterTasks 方法的第一部分比较简单，基本都是从 Project 中读取各自配置属性供后续步骤使用。所以我们接着继续看 addFlutterTasks 这个方法步骤 1 之后的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135private void addFlutterTasks(Project project) &#123; //一堆属性获取与赋值操作 //...... //1、定义 addFlutterDeps 箭头函数，参数variant为标准构建对应的构建类型 def addFlutterDeps = &#123; variant -&gt; if (shouldSplitPerAbi()) &#123; //2、常规操作：如果是构建多个变体apk模式就处理vc问题 variant.outputs.each &#123; output -&gt; //由于GP商店不允许同一个应用的多个APK全都具有相同的版本信息，因此在上传到Play商店之前，您需要确保每个APK都有自己唯一的versionCode，这里就是做这个事情的。 //具体可以看官方文档 https://developer.android.com/studio/build/configure-apk-splits def abiVersionCode = ABI_VERSION.get(output.getFilter(OutputFile.ABI)) if (abiVersionCode != null) &#123; output.versionCodeOverride = abiVersionCode * 1000 + variant.versionCode &#125; &#125; &#125; //3、获取编译类型，variantBuildMode值为debug、profile、release之一 String variantBuildMode = buildModeFor(variant.buildType) //4、依据参数生成一个task名字，譬如这里的compileFlutterBuildDebug、compileFlutterBuildProfile、compileFlutterBuildRelease String taskName = toCammelCase([&quot;compile&quot;, FLUTTER_BUILD_PREFIX, variant.name]) //5、给当前project创建compileFlutterBuildDebug、compileFlutterBuildProfile、compileFlutterBuildRelease Task //实现为FlutterTask，主要用来编译Flutter代码，这个task稍后单独分析 FlutterTask compileTask = project.tasks.create(name: taskName, type: FlutterTask) &#123; //各种task属性赋值操作，基本都来自上面的属性获取或者匹配分析 flutterRoot this.flutterRoot flutterExecutable this.flutterExecutable buildMode variantBuildMode localEngine this.localEngine localEngineSrcPath this.localEngineSrcPath //默认dart入口lib/main.dart、可以通过target属性自定义指向 targetPath getFlutterTarget() verbose isVerbose() fastStart isFastStart() fileSystemRoots fileSystemRootsValue fileSystemScheme fileSystemSchemeValue trackWidgetCreation trackWidgetCreationValue targetPlatformValues = targetPlatforms sourceDir getFlutterSourceDirectory() //学到一个小技能，原来中间API是AndroidProject.FD_INTERMEDIATES，这也是flutter中间产物目录 intermediateDir project.file(&quot;$&#123;project.buildDir&#125;/$&#123;AndroidProject.FD_INTERMEDIATES&#125;/flutter/$&#123;variant.name&#125;/&quot;) extraFrontEndOptions extraFrontEndOptionsValue extraGenSnapshotOptions extraGenSnapshotOptionsValue splitDebugInfo splitDebugInfoValue treeShakeIcons treeShakeIconsOptionsValue dartObfuscation dartObfuscationValue dartDefines dartDefinesValue bundleSkSLPath bundleSkSLPathValue performanceMeasurementFile performanceMeasurementFileValue codeSizeDirectory codeSizeDirectoryValue deferredComponents deferredComponentsValue validateDeferredComponents validateDeferredComponentsValue //最后做一波权限相关处理 doLast &#123; project.exec &#123; if (Os.isFamily(Os.FAMILY_WINDOWS)) &#123; commandLine(&#x27;cmd&#x27;, &#x27;/c&#x27;, &quot;attrib -r $&#123;assetsDirectory&#125;/* /s&quot;) &#125; else &#123; commandLine(&#x27;chmod&#x27;, &#x27;-R&#x27;, &#x27;u+w&#x27;, assetsDirectory) &#125; &#125; &#125; &#125; //项目构建中间产物的文件，也就是根目录下build/intermediates/flutter/debug/libs.jar文件 File libJar = project.file(&quot;$&#123;project.buildDir&#125;/$&#123;AndroidProject.FD_INTERMEDIATES&#125;/flutter/$&#123;variant.name&#125;/libs.jar&quot;) //6、创建packLibsFlutterBuildProfile、packLibsFlutterBuildDebug、packLibsFlutterBuildRelease任务，主要是产物的复制挪位置操作，Jar 类型的 task //作用就是把build/intermediates/flutter/debug/下依据abi生成的app.so通过jar命令打包成build/intermediates/flutter/debug/libs.jar Task packFlutterAppAotTask = project.tasks.create(name: &quot;packLibs$&#123;FLUTTER_BUILD_PREFIX&#125;$&#123;variant.name.capitalize()&#125;&quot;, type: Jar) &#123; //目标路径为build/intermediates/flutter/debug目录 destinationDir libJar.parentFile //文件名为libs.jar archiveName libJar.name //依赖前面步骤5定义的compileFlutterBuildDebug，也就是说，这个task基本作用是产物处理 dependsOn compileTask //targetPlatforms取值为android-arm、android-arm64、android-x86、android-x64 targetPlatforms.each &#123; targetPlatform -&gt; //abi取值为armeabi-v7a、arm64-v8a、x86、x86_64 String abi = PLATFORM_ARCH_MAP[targetPlatform] //数据来源来自步骤5的compileFlutterBuildDebug任务中间产物目录 //即把build/intermediates/flutter/debug/下依据abi生成的app.so通过jar命令打包成一个build/intermediates/flutter/debug/libs.jar文件 from(&quot;$&#123;compileTask.intermediateDir&#125;/$&#123;abi&#125;&quot;) &#123; include &quot;*.so&quot; // Move `app.so` to `lib/&lt;abi&gt;/libapp.so` rename &#123; String filename -&gt; return &quot;lib/$&#123;abi&#125;/lib$&#123;filename&#125;&quot; &#125; &#125; &#125; &#125; //前面有介绍过addApiDependencies作用，把 packFlutterAppAotTask 产物加到依赖项里面参与编译 //类似implementation files(&#x27;libs.jar&#x27;)，然后里面的so会在项目执行标准mergeDebugNativeLibs task时打包进标准lib目录 addApiDependencies(project, variant.name, project.files &#123; packFlutterAppAotTask &#125;) // 当构建有is-plugin属性时则编译aar boolean isBuildingAar = project.hasProperty(&#x27;is-plugin&#x27;) //7、当是Flutter Module方式，即Flutter以aar作为已存在native安卓项目依赖时才有这些:flutter:模块依赖，否则没有这些task //可以参见新建的FlutterModule中.android/include_flutter.groovy中gradle.project(&quot;:flutter&quot;).projectDir实现 Task packageAssets = project.tasks.findByPath(&quot;:flutter:package$&#123;variant.name.capitalize()&#125;Assets&quot;) Task cleanPackageAssets = project.tasks.findByPath(&quot;:flutter:cleanPackage$&#123;variant.name.capitalize()&#125;Assets&quot;) //判断是否为FlutterModule依赖 boolean isUsedAsSubproject = packageAssets &amp;&amp; cleanPackageAssets &amp;&amp; !isBuildingAar //8、新建copyFlutterAssetsDebug task，目的就是copy产物，也就是assets归档 //常规merge中间产物类似，不再过多解释，就是把步骤5 task产物的assets目录在mergeAssets时复制到主包中间产物目录 Task copyFlutterAssetsTask = project.tasks.create( name: &quot;copyFlutterAssets$&#123;variant.name.capitalize()&#125;&quot;, type: Copy, ) &#123; dependsOn compileTask with compileTask.assets if (isUsedAsSubproject) &#123; dependsOn packageAssets dependsOn cleanPackageAssets into packageAssets.outputDir return &#125; // `variant.mergeAssets` will be removed at the end of 2019. def mergeAssets = variant.hasProperty(&quot;mergeAssetsProvider&quot;) ? variant.mergeAssetsProvider.get() : variant.mergeAssets dependsOn mergeAssets dependsOn &quot;clean$&#123;mergeAssets.name.capitalize()&#125;&quot; mergeAssets.mustRunAfter(&quot;clean$&#123;mergeAssets.name.capitalize()&#125;&quot;) into mergeAssets.outputDir &#125; if (!isUsedAsSubproject) &#123; def variantOutput = variant.outputs.first() def processResources = variantOutput.hasProperty(&quot;processResourcesProvider&quot;) ? variantOutput.processResourcesProvider.get() : variantOutput.processResources processResources.dependsOn(copyFlutterAssetsTask) &#125; return copyFlutterAssetsTask &#125; // end def addFlutterDeps ......&#125; 以上大部分代码只是为了执行以下脚本时准备配置参数 123456789101112flutter assemble --no-version-check \\--depfile build/app/intermediates/flutter/release/flutter_build.d \\--output build/app/intermediates/flutter/release/ \\-dTargetFile=lib/main.dart \\-dTargetPlatform=android \\-dBuildMode=release \\-dDartObfuscation=true \\android_aot_bundle_release_android-arm \\android_aot_bundle_release_android-arm64 \\android_aot_bundle_release_android-x86 \\android_aot_bundle_release_android-x64 Flutter SDK下bin&#x2F;flutter编译命令分析flutter脚本如下： 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env bash#1、该命令之后出现的代码，一旦出现了返回值非零，整个脚本就会立即退出，那么就可以避免一些脚本的危险操作。set -e#2、清空CDPATH变量值unset CDPATH# 在Mac上，readlink -f不起作用，因此follow_links一次遍历一个链接的路径，然后遍历cd进入链接目的地并找出它。# 返回的文件系统路径必须是Dart的URI解析器可用的格式，因为Dart命令行工具将其参数视为文件URI，而不是文件名。# 例如，多个连续的斜杠应该减少为一个斜杠，因为双斜杠表示URI的authority。function follow_links() ( cd -P &quot;$(dirname -- &quot;$1&quot;)&quot; file=&quot;$PWD/$(basename -- &quot;$1&quot;)&quot; while [[ -h &quot;$file&quot; ]]; do cd -P &quot;$(dirname -- &quot;$file&quot;)&quot; file=&quot;$(readlink -- &quot;$file&quot;)&quot; cd -P &quot;$(dirname -- &quot;$file&quot;)&quot; file=&quot;$PWD/$(basename -- &quot;$file&quot;)&quot; done echo &quot;$file&quot;)# 这个变量的值就是Flutter SDK根目录下的bin/flutterPROG_NAME=&quot;$(follow_links &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)&quot;BIN_DIR=&quot;$(cd &quot;$&#123;PROG_NAME%/*&#125;&quot; ; pwd -P)&quot;OS=&quot;$(uname -s)&quot;# 平台兼容if [[ $OS =~ MINGW.* || $OS =~ CYGWIN.* ]]; then exec &quot;$&#123;BIN_DIR&#125;/flutter.bat&quot; &quot;$@&quot;fi#3、source导入这个shell脚本后执行其内部的shared::execute方法source &quot;$BIN_DIR/internal/shared.sh&quot;shared::execute &quot;$@&quot; 关注shared.sh文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#......function shared::execute() &#123; #1、默认FLUTTER_ROOT值为FlutterSDK根路径 export FLUTTER_ROOT=&quot;$(cd &quot;$&#123;BIN_DIR&#125;/..&quot; ; pwd -P)&quot; #2、如果存在就先执行bootstrap脚本，默认SDK下面是没有这个文件的，我猜是预留给我们自定义初始化挂载用的。 BOOTSTRAP_PATH=&quot;$FLUTTER_ROOT/bin/internal/bootstrap.sh&quot; if [ -f &quot;$BOOTSTRAP_PATH&quot; ]; then source &quot;$BOOTSTRAP_PATH&quot; fi #3、一堆基于FlutterSDK路径的位置定义 FLUTTER_TOOLS_DIR=&quot;$FLUTTER_ROOT/packages/flutter_tools&quot; SNAPSHOT_PATH=&quot;$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot&quot; STAMP_PATH=&quot;$FLUTTER_ROOT/bin/cache/flutter_tools.stamp&quot; SCRIPT_PATH=&quot;$FLUTTER_TOOLS_DIR/bin/flutter_tools.dart&quot; DART_SDK_PATH=&quot;$FLUTTER_ROOT/bin/cache/dart-sdk&quot; DART=&quot;$DART_SDK_PATH/bin/dart&quot; PUB=&quot;$DART_SDK_PATH/bin/pub&quot; #4、路径文件平台兼容，常规操作，忽略 case &quot;$(uname -s)&quot; in MINGW*) DART=&quot;$DART.exe&quot; PUB=&quot;$PUB.bat&quot; ;; esac #5、测试运行脚本的账号是否为超级账号，是的话警告提示，Docker和CI环境不警告。 if [[ &quot;$EUID&quot; == &quot;0&quot; &amp;&amp; ! -f /.dockerenv &amp;&amp; &quot;$CI&quot; != &quot;true&quot; &amp;&amp; &quot;$BOT&quot; != &quot;true&quot; &amp;&amp; &quot;$CONTINUOUS_INTEGRATION&quot; != &quot;true&quot; ]]; then &gt;&amp;2 echo &quot; Woah! You appear to be trying to run flutter as root.&quot; &gt;&amp;2 echo &quot; We strongly recommend running the flutter tool without superuser privileges.&quot; &gt;&amp;2 echo &quot; /&quot; &gt;&amp;2 echo &quot;📎&quot; fi #6、测试git命令行环境配置是否正常，不正常就抛出错误。 if ! hash git 2&gt;/dev/null; then &gt;&amp;2 echo &quot;Error: Unable to find git in your PATH.&quot; exit 1 fi #7、FlutterSDK是否来自clone等测试。 if [[ ! -e &quot;$FLUTTER_ROOT/.git&quot; ]]; then &gt;&amp;2 echo &quot;Error: The Flutter directory is not a clone of the GitHub project.&quot; &gt;&amp;2 echo &quot; The flutter tool requires Git in order to operate properly;&quot; &gt;&amp;2 echo &quot; to install Flutter, see the instructions at:&quot; &gt;&amp;2 echo &quot; https://flutter.dev/get-started&quot; exit 1 fi # To debug the tool, you can uncomment the following lines to enable checked # mode and set an observatory port: # FLUTTER_TOOL_ARGS=&quot;--enable-asserts $FLUTTER_TOOL_ARGS&quot; # FLUTTER_TOOL_ARGS=&quot;$FLUTTER_TOOL_ARGS --observe=65432&quot; #7、日常编译遇到命令lock文件锁住问题就是他，本质该方法就是创建/bin/cache目录并维持锁状态等事情，不是我们关心的重点。 upgrade_flutter 7&lt; &quot;$PROG_NAME&quot; #8、相关参数值，别问我怎么知道的，问就是自己在源码对应位置echo输出打印的 # BIN_NAME=flutter、PROG_NAME=FLUTTER_SDK_DIR/bin/flutter # DART=FLUTTER_SDK_DIR/bin/cache/dart-sdk/bin/dart # FLUTTER_TOOLS_DIR=FLUTTER_SDK_DIR/packages/flutter_tools # FLUTTER_TOOL_ARGS=空 # SNAPSHOT_PATH=FLUTTER_SDK_DIR/bin/cache/flutter_tools.snapshot # @=build apk BIN_NAME=&quot;$(basename &quot;$PROG_NAME&quot;)&quot; case &quot;$BIN_NAME&quot; in flutter*) # FLUTTER_TOOL_ARGS aren&#x27;t quoted below, because it is meant to be # considered as separate space-separated args. &quot;$DART&quot; --disable-dart-dev --packages=&quot;$FLUTTER_TOOLS_DIR/.packages&quot; $FLUTTER_TOOL_ARGS &quot;$SNAPSHOT_PATH&quot; &quot;$@&quot; ;; dart*) &quot;$DART&quot; &quot;$@&quot; ;; *) &gt;&amp;2 echo &quot;Error! Executable name $BIN_NAME not recognized!&quot; exit 1 ;; esac&#125; 可以看到，由于 Flutter SDK 内部内置了 Dart，所以当配置环境变量后 flutter、dart 命令都可以使用了。而我们安装 Flutter SDK 后首先做的事情就是把 SDK 的 bin 目录配置到了环境变量，所以执行的 flutter build apk、flutter upgrade、flutter pub xxx 等命令本质都是走进了上面这些脚本，且 flutter 命令只是对 dart 命令的一个包装，所以执行flutter pub get其实等价于dart pub get。所以假设我们执行flutter build apk命令，本质走到上面脚本最终执行的命令如下： 12345FLUTTER_SDK_DIR/bin/cache/dart-sdk/bin/dart \\--disable-dart-dev --packages=FLUTTER_SDK_DIR/packages/flutter_tools/.packages \\FLUTTER_SDK_DIR/bin/cache/flutter_tools.snapshot \\build apk 上面命令行中 FLUTTER_SDK_DIR 代表的就是 Flutter SDK 的根目录，–packages可以理解成是一堆 SDK 相关依赖，FLUTTER_SDK_DIR&#x2F;bin&#x2F;cache&#x2F;flutter_tools.snapshot就是FLUTTER_SDK_DIR&#x2F;packages&#x2F;flutter_tools的编译产物。所以，上面其实通过 dart 命令执行flutter_tools.snapshot文件也就是等价于执行flutter_tools.dart的main()方法。因此上面命令继续简化大致如下: 123dart --disable-dart-dev --packages=xxx flutter_tools.dart build apk 也就是说，我们执行的任何 flutter 命令，本质都是把参数传递到了FLUTTER_SDK_DIR&#x2F;packages&#x2F;flutter_tools&#x2F;bin&#x2F;flutter_tools.dart源码的 main 方法中 flutter_tools会执行flutter_tools&#x2F;lib文件夹中的代码，不同的参数对应commands中不同的文件，比如build对应lib&#x2F;src&#x2F;commands&#x2F;build.dart 参考 Flutter Android 工程结构及应用层编译源码深入分析","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"sentry_flutter","date":"2024-03-09T09:31:38.327Z","path":"wiki/Flutter/开源库/sentry_flutter/","text":"Sentry是一款多平台支持的异常信息收集解决方案。sentry_flutter可以在Flutter项目中收集异常信息。 https://docs.sentry.io/platforms/flutter/可以查阅其Flutter项目的集成文档。 sentry_dart_plugin可以自动上传mapping.txt文件和debug的动态库，方便后续直接在sentry后台查看异常信息。 基本用法 pubspec.yaml配置，sentry_dart_plugin配置参数参考https://github.com/getsentry/sentry-dart-plugin/blob/main/README.md 123456789101112131415161718dependencies: sentry_flutter: ^7.16.0sentry: upload_debug_symbols: true upload_source_maps: false # flutter_web使用 upload_sources: false project: ... org: ... auth_token: ... url: ... wait_for_processing: false log_level: error # possible values: trace, debug, info, warn, error release: ... dist: ... web_build_path: ... commits: auto ignore_missing: true 代码中初始化相关配置 1234567891011121314import &#x27;package:flutter/widgets.dart&#x27;;import &#x27;package:sentry_flutter/sentry_flutter.dart&#x27;;Future&lt;void&gt; main() async &#123; // sentry支持面包屑配置，可以在重要的场景添加相关信息 await SentryFlutter.init( (options) &#123; options.dsn = &#x27;https://example@sentry.io/add-your-dsn-here&#x27;; &#125;, // Init your App. appRunner: () =&gt; runApp(MyApp()), );&#125; 打包脚本中配置上传mapping.txt文件和debug的动态库 1flutter packages pub run sentry_dart_plugin","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"单元测试","date":"2024-03-09T09:31:38.326Z","path":"wiki/Flutter/单元测试/单元测试/","text":"单元测试的作用？ 保证代码质量，当一个方法在某个版本进行了调整，如果对应的单元测试无法通过，说明这个方法的改动有问题。单元测试中也能包含很多边界条件，甚至可以把测试用例的场景都包含，这样就相当于做了一遍测试的工作，而且可以复用检查，下次迭代时再运行一遍，说不定能发现新问题 单元测试阶段发现bug的处理时间相对后期测试发现反馈给研发，处理的时间要短很多，提高效率 单元测试做的好不好，在于测试用例的有效性 测试的评价指标： 通过率 覆盖率：覆盖足够多的代码，覆盖足够多的场景 有测试用例 测试方法 Code Review 静态代码扫描 单元测试用例编写：综合运用黑盒测试、白盒测试方法来进行测试用例设计 测试用例规范单元测试的最佳实践 模块化代码：将代码分解为小的、可重复使用的模块，每个模块只负责一个特定的功能。这样可以更容易地针对单个模块编写测试用例。 避免依赖：代码中应避免使用全局变量、静态方法或其他硬编码的依赖项，因为这些会增加测试的复杂性。相反，应使用依赖注入或其他技术来模拟依赖项。 方法、函数的测试测试网络请求测试UI测试Bloc集成测试Flutter如何进行单元测试 单元测试ー单元测试对单个函数、方法或类执行测试。我们使用单元测试来测试您想要测试的非常小的代码或函数。 widget 测试ー widget 测试(在其他 UI 框架中称为组件测试)测试单个 widget 。 集成测试ーー集成测试测试一个完整的应用程序或应用程序的很大一部分，这些应用程序将许多事情和测试结合在一起，比如创建一个流。 Flutter单元测试库123456789101112dev_dependencies: test: # 纯dart测试框架 flutter_test: # 基于test的flutter测试框架 sdk: flutter flutter_driver: sdk: flutter mockito: http_mock_adapter: bloc_test: test_api: # dart测试框架 integration_test: # 集成测试 flutter_test基于dart的test库，用于Flutter项目的测试库，跟其他语言类似，提供了一些测试的方法，如expect、group、test、testWidgets、setUp、tearDown等。 https://api.flutter.dev/flutter/flutter_test&#x2F;flutter_test-library.html 基本用法12345678910111213141516171819202122232425262728293031@Skip(&#x27;跳过当前测试用例&#x27;)@Timeout(Duration(seconds: 10)) //设置超时时间import &#x27;package:flutter_test/flutter_test.dart&#x27;;void main() &#123; setUp(() &#123; //在每个测试用例执行前执行 &#125;); tearDown(() &#123; //在每个测试用例执行后执行 &#125;); test(&#x27;描述测试内容&#x27;, () async &#123; //支持异步测试 expect(1+1, 2); &#125;); group(&#x27;描述分组&#x27;, () &#123; test(&#x27;描述测试内容&#x27;, () async &#123; &#125;); &#125;, skip: &#x27;跳过当前分组&#x27;, timeout: Timeout(Duration(seconds: 10)) //设置超时时间 );&#125; 方法介绍 expect：断言，判断是否符合预期 group：分组，可以把一些相关的测试用例放在一起 test：单个测试用例 testWidgets：测试UI pumpWidget()：创建并渲染widget pump(): 触发widget重建，仅重建已更改的 widget pumpAndSettle():在给定期间内不断重复调用 pump() 直到完成所有绘制帧，一般需要等到所有动画全部完成 setUp：在每个测试用例执行前执行 tearDown：在每个测试用例执行后执行 交互类API enterText(): 模拟输入 tap(): 模拟点击 drag(): 模拟拖拽 longPress():模拟长按 scrollUntilVisible(): 模拟滚动到可见位置 scrollIntoView(): 模拟滚动到可见位置 scroll(): 模拟滚动 fling(): 模拟拖拽 flingFrom(): 模拟拖拽 flingFromEdge(): 模拟拖拽 flingFromCenter(): 模拟拖拽 使用Finder定位Widget text(String text): 查找特定文本的Text widget byWidget(Widget widget, {bool skipOffstage &#x3D; true}): 通过widget查找widget byKey(Key key): 通过key查找widget byType(Type type): 通过类型查找widget byWidget(Widget widget): byElementType(Type type, { bool skipOffstage &#x3D; true }): matchers findsOneWidget： 找到一个widget findsWidgets：找到一个或多个 findsNothing：没有找到 findsNWidgets：找到指定数量的widget TestPointer：测试手势，按下、滑动、抬起等 TestTextInput：测试输入框 AutomatedTestWidgetsFlutterBinding：会模拟用户操作并控制应用程序的状态。它可以处理异步操作、动画和定时器等，以确保测试代码在正确的上下文中运行。通常与 flutter_driver 或其他自动化测试框架一起使用，用于执行集成测试或端到端测试 AnimationSheetBuilder：用于测试动画 mockito https://pub.dev/packages/mockito 文档中文翻译 mockito库用来模拟数据。 使用Mockito产生的mock类，需要添加build_runner依赖。有以下主要用途： 可通过标注或Fake的方式来生成mock类 可通过when().thenReturn()来模拟方法的返回值 可通过argThat()来模拟方法的参数 可通过verify()来验证方法的调用 verifyInOrder可校验顺序 可通过verifyNoMoreInteractions()来验证没有更多的调用 可通过reset()来重置mock 可通过verifyZeroInteractions()来验证没有调用 可通过verifyNever()来验证没有调用 可通过verifyInOrder()来验证顺序 可通过verifyStream()来验证Stream 可通过verifyStreamEvent()来验证Stream的事件 called能校验调用次数 captured存储调用时的参数 thenReturn、thenAnswer thenReturn会返回Future或Stream，可能抛出ArgumentError thenAnswer只会返回Future或Stream http_mock_adapterbloc_test https://pub.dev/packages/bloc_test 12345678910111213141516void blocTest&lt;B extends BlocBase&lt;State&gt;, State&gt;( String description, &#123; //测试的描述 required B Function() build, //创建bloc FutureOr&lt;void&gt; Function()? setUp, //在每个测试用例执行前执行 State Function()? seed, dynamic Function(B bloc)? act, //执行的动作 Duration? wait, int skip = 0, dynamic Function()? expect, //期望的结果 dynamic Function(B bloc)? verify, dynamic Function()? errors, FutureOr&lt;void&gt; Function()? tearDown, //在每个测试用例执行后执行 dynamic tags,&#125;) flutter_driver集成测试框架 参考 5个关键问题让单元测试的价值最大化 单元测试介绍 如何写出有效的单元测试 Flutter如何Mock MethodChannel进行单元测试","tags":[{"name":"Flutter 单元测试","slug":"Flutter-单元测试","permalink":"http://airshu.github.io/tags/Flutter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"单元测试","slug":"Flutter/单元测试","permalink":"http://airshu.github.io/categories/Flutter/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"Flutter项目良好的编码tips","date":"2024-03-09T09:31:38.326Z","path":"wiki/Flutter/Flutter项目良好的编码tips/","text":"Flutter项目结构 代码规范 良好的编码tips 首先，代码编写需要满足一定的规范，统一团队内的代码风格。参考Flutter代码规范。除此之外，为了提升质量，还可以设置以下规范和技巧 如果明确视图不会发生变化，尽量使用StatelessWidget 如果变量明确不会改变，则使用final修饰 如果变量明确是常量，则使用const修饰 注意输入框类型，如果是数字或者邮箱则设置默认键盘类型 监听器的使用，注意不要在调用多次方法中使用（比如didChangeDependencies），记得不需要时移除监听 尽量不用print，使用封装的Log工具，设置合适的level。release版本统一去掉print catch(e, s)的异常，上报详细信息用于分析具体原因 异步使用setState前需要判断mounted 1234if(mounted) &#123; setState(()&#123;&#125;);&#125; scrollcontroller要记得释放资源，一个controller只能对应一个list 1234void dispose() &#123; controller?.dispose();&#125; 按钮请求接口注意添加防重复点击 建议使用bloc等方式进行精细化刷新UI；处理业务逻辑时尽量控制刷新的最小粒度 尽量复用代码，继承base class、mixin，复用通用组件 代码健壮性：是否可能出现异常的代码有catch？能否保障在异常情况下流程还能顺利完成 可空语法的一些写法 12345678910111213//对于获取List中的元素，为了安全建议使用List list = [];User? item = list?.elementAtSafe(1); //elementAtSafew为扩展函数，如果index对应的元素不存在则返回null，保证空安全User item = list?.elementAtSafe(1) ?? User(); //使用?语法，只有当其不为空时才执行后面的代码，elementAtSafe为扩展函数，如果index对应的元素不存在则返回null，保证空安全。第二个参数则设置在没有值的情况下返回一个默认值//对于后端数据的解析Map result = await getxxx();double points = (resutl[&#x27;name&#x27;]? as num?)?.toDouble() ?? 2.1; 注意代码分层，不要把UI和业务逻辑全部堆叠在一个文件中，使用状态管理框架，将业务逻辑和UI分离 dispose方法中注意会不会出现因为代码异常造成后面释放资源的代码不执行而造成内存泄漏","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"pull_to_refresh","date":"2024-03-09T09:31:38.326Z","path":"wiki/Flutter/开源库/pull_to_refresh/","text":"上拉加载和下拉刷新的组件 pull_to_refresh特性 提供上拉加载和下拉刷新 几乎适合所有部件 提供全局设置默认指示器和属性 提供多种比较常用的指示器 支持Android和iOS默认滑动引擎,可限制越界距离,打造自定义弹性动画,速度,阻尼等。 支持水平和垂直刷新,同时支持翻转列表(四个方向) 提供多种刷新指示器风格:跟随,不跟随,位于背部,位于前部, 提供多种加载更多风格 提供二楼刷新,可实现类似淘宝二楼,微信二楼,携程二楼 允许关联指示器存放在Viewport外部,即朋友圈刷新效果 通过自定义scroll_physics，监听滚动事件，下拉的过程中进行状态的切换。当完成数据请求后需要手动更新组件的状态。 基本使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283List&lt;String&gt; items = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;]; RefreshController _refreshController = RefreshController(initialRefresh: false); void _onRefresh() async&#123; // monitor network fetch await Future.delayed(Duration(milliseconds: 1000)); // if failed,use refreshFailed() _refreshController.refreshCompleted(); &#125; void _onLoading() async&#123; // monitor network fetch await Future.delayed(Duration(milliseconds: 1000)); // if failed,use loadFailed(),if no data return,use LoadNodata() items.add((items.length+1).toString()); if(mounted) setState(() &#123; &#125;); _refreshController.loadComplete(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: SmartRefresher( enablePullDown: true, enablePullUp: true, header: WaterDropHeader(), footer: CustomFooter( builder: (BuildContext context,LoadStatus mode)&#123; Widget body ; if(mode==LoadStatus.idle)&#123; body = Text(&quot;pull up load&quot;); &#125; else if(mode==LoadStatus.loading)&#123; body = CupertinoActivityIndicator(); &#125; else if(mode == LoadStatus.failed)&#123; body = Text(&quot;Load Failed!Click retry!&quot;); &#125; else if(mode == LoadStatus.canLoading)&#123; body = Text(&quot;release to load more&quot;); &#125; else&#123; body = Text(&quot;No more Data&quot;); &#125; return Container( height: 55.0, child: Center(child:body), ); &#125;, ), controller: _refreshController, onRefresh: _onRefresh, onLoading: _onLoading, child: ListView.builder( itemBuilder: (c, i) =&gt; Card(child: Center(child: Text(items[i]))), itemExtent: 100.0, itemCount: items.length, ), ), ); &#125;// 全局配置子树下的SmartRefresher,下面列举几个特别重要的属性RefreshConfiguration( headerBuilder: () =&gt; WaterDropHeader(), // 配置默认头部指示器,假如你每个页面的头部指示器都一样的话,你需要设置这个 footerBuilder: () =&gt; ClassicFooter(), // 配置默认底部指示器 headerTriggerDistance: 80.0, // 头部触发刷新的越界距离 springDescription:SpringDescription(stiffness: 170, damping: 16, mass: 1.9), // 自定义回弹动画,三个属性值意义请查询flutter api maxOverScrollExtent :100, //头部最大可以拖动的范围,如果发生冲出视图范围区域,请设置这个属性 maxUnderScrollExtent:0, // 底部最大可以拖动的范围 enableScrollWhenRefreshCompleted: true, //这个属性不兼容PageView和TabBarView,如果你特别需要TabBarView左右滑动,你需要把它设置为true enableLoadingWhenFailed : true, //在加载失败的状态下,用户仍然可以通过手势上拉来触发加载更多 hideFooterWhenNotFull: false, // Viewport不满一屏时,禁用上拉加载更多功能 enableBallisticLoad: true, // 可以通过惯性滑动触发加载更多 child: MaterialApp( ........ )); easy_refresh由于pull_to_refresh已经很久不更新了，新的Flutter SDK使用easy_refresh替代，支持Flutter SDK 3.x 特性 支持所有的滚动组件 滚动物理作用域，精确匹配滚动组件 集成多个炫酷的 Header 和 Footer 支持自定义样式，实现各种动画效果 支持下拉刷新、上拉加载(可使用控制器触发和结束) 支持指示器位置设定，结合监听器也放置在任何位置 支持页面启动时刷新，并自定义视图 支持安全区域，不再有遮挡 自定义滚动参数，让列表具有不同的滚动反馈和惯性 基本使用1234567891011121314151617181920212223242526EasyRefresh( //顶部指示器 header: Header( position: IndicatorPosition.locator, ), footer: Footer( position: IndicatorPosition.locator, ), //刷新 onRefresh: () async &#123; .... &#125;, //翻页 onLoad: () async &#123; .... return IndicatorResult.noMore; &#125;, child: CustomScrollView( slivers: [ SliverAppBar(), const HeaderLocator.sliver(), ... const FooterLocator.sliver(), ], ),) 参考 https://github.com/peng8350/flutter_pulltorefresh https://pub.dev/packages/easy_refresh","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"form_bloc","date":"2024-03-09T09:31:38.326Z","path":"wiki/Flutter/开源库/form_bloc/","text":"form_bloc是结合bloc的表单库，运用bloc的特性实现UI和逻辑的分离，使得表单的逻辑更加清晰，代码更加简洁。 基本用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_form_bloc/flutter_form_bloc.dart&#x27;;void main() =&gt; runApp(const App());class App extends StatelessWidget &#123; const App(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return const MaterialApp( debugShowCheckedModeBanner: false, home: LoginForm(), ); &#125;&#125;class LoginFormBloc extends FormBloc&lt;String, String&gt; &#123; // 不同的表单项对应不同的FieldBloc final email = TextFieldBloc( validators: [ FieldBlocValidators.required, FieldBlocValidators.email, ], ); final password = TextFieldBloc( validators: [ FieldBlocValidators.required, ], ); final showSuccessResponse = BooleanFieldBloc(); LoginFormBloc() &#123; //添加表单项 addFieldBlocs( fieldBlocs: [ email, password, showSuccessResponse, ], ); &#125; /// 表单提交方法 @override void onSubmitting() async &#123; debugPrint(email.value); debugPrint(password.value); debugPrint(showSuccessResponse.value.toString()); await Future&lt;void&gt;.delayed(const Duration(seconds: 1)); // 提交进度变化 emitSubmitting(progress: 0.2); await Future&lt;void&gt;.delayed(Duration(milliseconds: 400)); emitSubmitting(progress: 0.6); await Future&lt;void&gt;.delayed(Duration(milliseconds: 400)); emitSubmitting(progress: 1.0); //取消提交 //emitSubmissionCancelled(); if (showSuccessResponse.value) &#123; emitSuccess(); //提交成功，发送成功消息，触发UI更新 &#125; else &#123; emitFailure(failureResponse: &#x27;This is an awesome error!&#x27;); //提交失败，发送失败消息，触发UI更新 &#125; &#125; @override Future&lt;void&gt; close() &#123; // 释放所有表单项 email.close(); password.close(); showSuccessResponse.close(); return super.close(); &#125;&#125;class LoginForm extends StatelessWidget &#123; const LoginForm(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return BlocProvider( create: (context) =&gt; LoginFormBloc(), child: Builder( builder: (context) &#123; final loginFormBloc = context.read&lt;LoginFormBloc&gt;(); return Scaffold( resizeToAvoidBottomInset: false, appBar: AppBar(title: const Text(&#x27;Login&#x27;)), body: FormBlocListener&lt;LoginFormBloc, String, String&gt;( onSubmitting: (context, state) &#123; LoadingDialog.show(context); &#125;, onSubmissionFailed: (context, state) &#123; LoadingDialog.hide(context); &#125;, onSuccess: (context, state) &#123; LoadingDialog.hide(context); Navigator.of(context).pushReplacement( MaterialPageRoute(builder: (_) =&gt; const SuccessScreen())); &#125;, onFailure: (context, state) &#123; LoadingDialog.hide(context); ScaffoldMessenger.of(context).showSnackBar( SnackBar(content: Text(state.failureResponse!))); &#125;, child: SingleChildScrollView( physics: const ClampingScrollPhysics(), child: AutofillGroup( child: Column( children: &lt;Widget&gt;[ TextFieldBlocBuilder( textFieldBloc: loginFormBloc.email, keyboardType: TextInputType.emailAddress, autofillHints: const [ AutofillHints.username, ], decoration: const InputDecoration( labelText: &#x27;Email&#x27;, prefixIcon: Icon(Icons.email), ), ), TextFieldBlocBuilder( textFieldBloc: loginFormBloc.password, suffixButton: SuffixButton.obscureText, autofillHints: const [AutofillHints.password], decoration: const InputDecoration( labelText: &#x27;Password&#x27;, prefixIcon: Icon(Icons.lock), ), ), SizedBox( width: 250, child: CheckboxFieldBlocBuilder( booleanFieldBloc: loginFormBloc.showSuccessResponse, body: Container( alignment: Alignment.centerLeft, child: const Text(&#x27;Show success response&#x27;), ), ), ), ElevatedButton( onPressed: loginFormBloc.submit, child: const Text(&#x27;LOGIN&#x27;), ), ], ), ), ), ), ); &#125;, ), ); &#125;&#125;class LoadingDialog extends StatelessWidget &#123; static void show(BuildContext context, &#123;Key? key&#125;) =&gt; showDialog&lt;void&gt;( context: context, useRootNavigator: false, barrierDismissible: false, builder: (_) =&gt; LoadingDialog(key: key), ).then((_) =&gt; FocusScope.of(context).requestFocus(FocusNode())); static void hide(BuildContext context) =&gt; Navigator.pop(context); const LoadingDialog(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return WillPopScope( onWillPop: () async =&gt; false, child: Center( child: Card( child: Container( width: 80, height: 80, padding: const EdgeInsets.all(12.0), child: const CircularProgressIndicator(), ), ), ), ); &#125;&#125;class SuccessScreen extends StatelessWidget &#123; const SuccessScreen(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ const Icon(Icons.tag_faces, size: 100), const SizedBox(height: 10), const Text( &#x27;Success&#x27;, style: TextStyle(fontSize: 54, color: Colors.black), textAlign: TextAlign.center, ), const SizedBox(height: 10), ElevatedButton.icon( onPressed: () =&gt; Navigator.of(context).pushReplacement( MaterialPageRoute(builder: (_) =&gt; const LoginForm())), icon: const Icon(Icons.replay), label: const Text(&#x27;AGAIN&#x27;), ), ], ), ), ); &#125;&#125; 表单项类型 SingleFieldBloc TextFieldBloc SelectFieldBloc InputFieldBloc MultiFieldBloc BooleanFieldBloc MultiSelectFieldBloc GroupFieldBloc：一组表单项 ListFieldBloc 1234567891011121314/// 更新数据void updateValue(Value value) &#123;&#125;/// 监听数据变化StreamSubscription&lt;dynamic&gt; onValueChanges&lt;R&gt;(&#123; Duration debounceTime = const Duration(), void Function(State previous, State current)? onStart, required Stream&lt;R&gt; Function(State previous, State current) onData, void Function(State previous, State current, R result)? onFinish, &#125;)&#123;&#125;/// 手动校验表单项Future&lt;bool&gt; validate() &#123;&#125; FieldBloc的用法表单的属性都通过FieldBloc来管理，比如是否必填、默认选项、校验规则等。 FormBlocListenerFormBlocListener监听一个FormBloc的状态，并根据状态的变化来执行一些操作。它接受三个参数：一个FormBloc，一个在表单提交成功时执行的回调函数，和一个在表单提交失败时执行的回调函数。 1234567891011121314FormBlocListener&lt;MyFormBloc, String, String&gt;( onSubmitting: (context, state) &#123; // Show a loading indicator &#125;, onSuccess: (context, state) &#123; // Navigate to another screen &#125;, onFailure: (context, state) &#123; // Show an error message &#125;, child: ...,) BlocBuilder用于连接FieldBloc和任何Widget，有以下类型： TextFieldBlocBuilder DropdownFieldBlocBuilder RadioButtonGroupFieldBlocBuilder CheckboxFieldBlocBuilder SwitchFieldBlocBuilder CheckboxGroupFieldBlocBuilder DateTimeFieldBlocBuilder TimeFieldBlocBuilder 123456789TextFieldBlocBuilder( textFieldBloc: loginFormBloc.email,//关联bloc autofillHints: [AutofillHints.username,AutofillHints.email], keyboardType: TextInputType.emailAddress, decoration: InputDecoration( labelText: &#x27;Email&#x27;, prefixIcon: Icon(Icons.email), ),), 展示表单项的错误提示123xxx.addFieldError(&#x27;That username is taken. Try another.&#x27;); 加载初始数据1. FormBloc构造函数的isLoading设置为true2. 实现onLoading方法，使用updateInitialValue（updateItems）方法更新数据。完成数据赋值后，发送emitLoaded消息123456789101112131415161718192021222324252627var _throwException = true;@overridevoid onLoading() async &#123; try &#123; await Future&lt;void&gt;.delayed(Duration(milliseconds: 1500)); if (_throwException) &#123; // Simulate network error throw Exception(&#x27;Network request failed. Please try again later.&#x27;); &#125; text.updateInitialValue(&#x27;I am prefilled&#x27;); select ..updateItems([&#x27;Option A&#x27;, &#x27;Option B&#x27;, &#x27;Option C&#x27;]) ..updateInitialValue(&#x27;Option B&#x27;); emitLoaded(); &#125; catch (e) &#123; _throwException = false; emitLoadFailed(); &#125;&#125; 3. UI层处理1234567891011121314151617child: BlocBuilder&lt;LoadingFormBloc, FormBlocState&gt;( condition: (previous, current) &#123; //优化刷新频率 return previous.runtimeType != current.runtimeType; &#125;, builder: (context, state) &#123; //根据不同状态显示不同的UI if (state is FormBlocLoading) &#123; return LoadingWidget(); &#125; else if (state is FormBlocLoadFailed) &#123; return LoadFailedWidget(); &#125; else &#123; return LoadedWidget(); &#125; &#125;,), 表单项关联校验123456789101112131415161718192021222324252627282930313233343536373839class MyFormBloc extends FormBloc&lt;String, String&gt; &#123; final password = TextFieldBloc( validators: [FieldBlocValidators.required], ); final confirmPassword = TextFieldBloc( validators: [FieldBlocValidators.required], ); Validator&lt;String&gt; _confirmPassword( TextFieldBloc passwordTextFieldBloc, ) &#123; return (String confirmPassword) &#123; if (confirmPassword == passwordTextFieldBloc.value) &#123; return null; &#125; return &#x27;Must be equal to password&#x27;; &#125;; &#125; MyFormBloc() &#123; addFieldBlocs( fieldBlocs: [password, confirmPassword], ); confirmPassword ..addValidators([_confirmPassword(password)]) ..subscribeToFieldBlocs([password]); // Or you can use built-in confirm password validator // confirmPassword // ..addValidators([FieldBlocValidators.confirmPassword(password)]) // ..subscribeToFieldBlocs([password]); &#125;&#125; 动态添加或删除表单项使用addFieldBlocs和removeFieldBlocs方法 自定义表单项1. 自定义FieldBloc123456789101112131415161718class CustomFieldBloc extends SingleFieldBloc&lt;String, String, CustomState&lt;T&gt;, T?&gt; &#123; CustomFieldBloc(&#123; String? initialValue, required String Function(String value) validator, &#125;) : super( initialValue: initialValue, //初始值 validator: validator, //校验器 asyncValidators: [], //异步校验器 asyncValidatorDebounceTime: Duration.zero, //异步校验器的防抖时间 initialState: CustomState(), ); @override String toString() &#123; return &#x27;CustomFieldBloc&#x27;; &#125;&#125; 2. 自定义Widget，关联FieldBloc12345678910111213141516171819202122232425262728class CustomFieldBlocBuilder extends StatelessWidget &#123; final CustomFieldBloc fieldBloc; const CustomFieldBlocBuilder(&#123; Key? key, required this.fieldBloc, &#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return BlocBuilder&lt;CustomFieldBloc, CustomState&gt;( bloc: fieldBloc, builder: (context, state) &#123; return TextField( onChanged: (value) &#123; fieldBloc.updateValue(value); &#125;, decoration: InputDecoration( labelText: &#x27;Custom&#x27;, errorText: state.error, ), ); &#125;, ); &#125;&#125; 参考 https://pub.dev/packages/form_bloc https://giancarlocode.github.io/form_bloc&#x2F;#&#x2F;","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"Flutter项目Android端构建流程","date":"2024-03-09T09:31:38.325Z","path":"wiki/Flutter/Android端/Flutter项目Android端构建流程/","text":"","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Android端","slug":"Flutter/Android端","permalink":"http://airshu.github.io/categories/Flutter/Android%E7%AB%AF/"}]},{"title":"ReactiveX","date":"2024-02-12T02:23:36.670Z","path":"wiki/技术开发/杂项/ReactiveX/","text":"Observables概述ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持大部分主流语言。 使用这种方法的优点是，当你有一大堆的任务是不相互依赖，你就可以同时执行他们，而不是等待每一个类启动下一个前完成，这样你的整个任务包只需要花最长的任务时间。 在ReactiveX中，一个观察者(Observer)订阅一个可观察对象(Observable)。观察者对Observable发射的数据或数据序列作出响应。这种模式可以极大地简化并发操作，因为它创建了一个处于待命状态的观察者哨兵，在未来某个时刻响应Observable的通知，不需要阻塞等待Observable发射数据。 背景知识在很多软件编程任务中，或多或少你都会期望你写的代码能按照编写的顺序，一次一个的顺序执行和完成。但是在ReactiveX中，很多指令可能是并行执行的，之后他们的执行结果才会被观察者捕获，顺序是不确定的。为达到这个目的，你定义一种获取和变换数据的机制，而不是调用一个方法。在这种机制下，存在一个可观察对象(Observable)，观察者(Observer)订阅(Subscribe)它，当数据就绪时，之前定义的机制就会分发数据给一直处于等待状态的观察者哨兵。 这种方法的优点是，如果你有大量的任务要处理，它们互相之间没有依赖关系。你可以同时开始执行它们，不用等待一个完成再开始下一个（用这种方式，你的整个任务队列能耗费的最长时间，不会超过任务里最耗时的那个）。 有很多术语可用于描述这种异步编程和设计模式，在本文里我们使用这些术语：一个观察者订阅一个可观察对象 (An observer subscribes to an Observable)。通过调用观察者的方法，Observable发射数据或通知给它的观察者。 在其它的文档和场景里，有时我们也将Observer叫做Subscriber、Watcher、Reactor。这个模型通常被称作Reactor模式。 创建观察者关于Observers的创建 同步方式： 调用一个方法 用一个变量存储方法返回值 使用这个变量作为一个新的值做其他事情 123//写一个回调returnVal = someMethod(paramters);//做新的事情 异步方式： 定义一个方法，此方法是做一些事情并带有来之于异步调用的返回值；这个方法也是observer的一部分 定义异步调用自身作为一个Observable 通过订阅的方式连接observer到Observable 执行你的业务 123def myOnNext = &#123;it-&gt;do something useful with it&#125;;def myObservable = someOvservable(itsParamters);myObservable.subscribe(myOnNext); onNext，onCompleted，onError回调 onNext：每当Observable广播数据时将会调用该方法，这个方法将会被作为Observable的一个广播项目参数被发送 onError：表示内部已经发生异常 onCompleted：成功调用onNext 123456def myOnNext = &#123; item -&gt; /* 任务执行 */ &#125;;def myError = &#123; throwable -&gt; /* 失败时的响应 */ &#125;;def myComplete = &#123; /* 成功后的响应 */ &#125;;def myObservable = someMethod(itsParameters);myObservable.subscribe(myOnNext, myError, myComplete);// 继续执行相应的业务逻辑 取消订阅（Ubsubscribing）在一些ReactiveX实现中，有一个特殊的观察者接口Subscriber，它有一个unsubscribe方法。调用这个方法表示你不关心当前订阅的Observable了，因此Observable可以选择停止发射新的数据项（如果没有其它观察者订阅）。 取消订阅的结果会传递给这个Observable的操作符链，而且会导致这个链条上的每个环节都停止发射数据项。这些并不保证会立即发生，然而，对一个Observable来说，即使没有观察者了，它也可以在一个while循环中继续生成并尝试发射数据项。 关于命名约定ReactiveX的每种特定语言的实现都有自己的命名偏好，虽然不同的实现之间有很多共同点，但并不存在一个统一的命名标准。 而且，在某些场景中，一些名字有不同的隐含意义，或者在某些语言看来比较怪异。 例如，有一个onEvent命名模式(onNext, onCompleted, onError)，在一些场景中，这些名字可能意味着事件处理器已经注册。然而在ReactiveX里，他们是事件处理器的名字。 Observables的”热”和”冷”Observable什么时候开始发射数据序列？这取决于Observable的实现，一个”热”的Observable可能一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。 在一些ReactiveX实现里，还存在一种被称作Connectable的Observable，不管有没有观察者订阅它，这种Observable都不会开始发射数据，除非Connect方法被调用。 用操作符组合Ovservable创建新的Observables的操作符： Create Defer Empty&#x2F;Never&#x2F;Throw From Interval Just Range Repeat Start Timer 转换被一个Observable发送的项目的操作符 Buffer FlatMap：进行一对多或多对多转换 GroupBy Map:进行一对一转换 Scan Window 过滤被Observable发送的项目的操作符 Debounce Distinct ElementAt Filter First IgnoreElements Last Sample Skip SkipLast Take TakeLast 将多个Observable合并成单个Observable的操作符 And&#x2F;Then&#x2F;When CombineLatest Join Merge StartWith Switch Zip 错误处理操作符 Catch Retry 实用工具操作符 Delay Do Materialize&#x2F;Dematerialize ObserveOn Serialize Subscribe SubscribeOn TimeInterval Timeout Timestamp Using 条件和布尔运算操作符 All Amb Contains DefaultIfEmpty SequenceEqual SkipUntil SkipWhile TakeUntil TakeWhile 算术和集合操作符 Average Concat Count Max Min Reduce Sum 转换操作符 To 可连接Obervable的操作符 Connect Publish RefCount Replay SingleRxJava（以及它派生出来的RxGroovy和RxScala）中有一个名为Single的Observable变种。 Single类似于Observable，不同的是，它总是只发射一个值，或者一个错误通知，而不是发射一系列的值。 因此，不同于Observable需要三个方法onNext, onError, onCompleted，订阅Single只需要两个方法： onSuccess - Single发射单个的值到这个方法 onError - 如果无法发射需要的值，Single发射一个Throwable对象到这个方法 Single只会调用这两个方法中的一个，而且只会调用一次，调用了任何一个方法之后，订阅关系终止。 Single操作符 操作符 返回值 说明 compose Single 创建一个自定义的操作符 concat and concatWith Observable 连接多个Single和Observable发射的数据 create Single 调用观察者的create方法创建一个Single error Single 返回一个立即给订阅者发射错误通知的Single flatMap Single 返回一个Single，它发射对原Single的数据执行flatMap操作后的结果 flatMapObservable Observable 返回一个Observable，它发射对原Single的数据执行flatMap操作后的结果 from Single 将Future转换成Single just Single 返回一个发射一个指定值的Single map Single 返回一个Single，它发射对原Single的数据执行map操作后的结果 merge Single 将一个Single(它发射的数据是另一个Single，假设为B)转换成另一个Single(它发射来自另一个Single(B)的数据) merge and mergeWith Observable 合并发射来自多个Single的数据 observeOn Single 指示Single在指定的调度程序上调用订阅者的方法 onErrorReturn Single 将一个发射错误通知的Single转换成一个发射指定数据项的Single subscribeOn Single 指示Single在指定的调度程序上执行操作 timeout Single 它给原有的Single添加超时控制，如果超时了就发射一个错误通知 toSingle Single 将一个发射单个值的Observable转换为一个Single zip and zipWith Single 将多个Single转换为一个，后者发射的数据是对前者应用一个函数后的结果 SubjectSubject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。 由于一个Subject订阅一个Observable，它可以触发这个Observable开始发射数据（如果那个Observable是”冷”的–就是说，它等待有订阅才开始发射数据）。因此有这样的效果，Subject可以把原来那个”冷”的Observable变成”热”的。 Subject种类AsyncSubjectBehaviorSubject每一个新添加的监听，接收到的第一个数据都是上一个数据 PublishSubjectReplaySubject监听能接收所有数据 Scheduler如果你想给Observable操作符链添加多线程功能，你可以指定操作符（或者特定的Observable）在特定的调度器(Scheduler)上执行。 某些ReactiveX的Observable操作符有一些变体，它们可以接受一个Scheduler参数。这个参数指定操作符将它们的部分或全部任务放在一个特定的调度器上执行。 默认情况下，可观察对象和观察者的订阅方法是在同一个线程中运行的。使用ObserveOn和SubscribeOn操作符，你可以让Observable在一个特定的调度器上执行，ObserveOn指示一个Observable在一个特定的调度器上调用观察者的onNext, onError和onCompleted方法，SubscribeOn更进一步，它指示Observable将全部的处理过程（包括发射数据和通知）放在特定的调度器上执行。 RxJava示例调度器的种类下表展示了RxJava中可用的调度器种类： 调度器类型 效果 Schedulers.computation( ) 用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量 Schedulers.from(executor) 使用指定的Executor作为调度器 Schedulers.immediate( ) 在当前线程立即开始执行任务 Schedulers.io( ) 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器 Schedulers.newThread( ) 为每个任务创建一个新线程 Schedulers.trampoline( ) 当其它排队的任务完成后，在当前线程排队开始执行 默认调度器在RxJava中，某些Observable操作符的变体允许你设置用于操作执行的调度器，其它的则不在任何特定的调度器上执行，或者在一个指定的默认调度器上执行。下面的表格个列出了一些操作符的默认调度器： 操作符 调度器 buffer(timespan) computation buffer(timespan, count) computation buffer(timespan, timeshift) computation debounce(timeout, unit) computation delay(delay, unit) computation delaySubscription(delay, unit) computation interval computation repeat trampoline replay(time, unit) computation replay(buffersize, time, unit) computation replay(selector, time, unit) computation replay(selector, buffersize, time, unit) computation retry trampoline sample(period, unit) computation skip(time, unit) computation skipLast(time, unit) computation take(time, unit) computation takeLast(time, unit) computation takeLast(count, time, unit) computation takeLastBuffer(time, unit) computation takeLastBuffer(count, time, unit) computation throttleFirst computation throttleLast computation throttleWithTimeout computation timeInterval immediate timeout(timeoutSelector) immediate timeout(firstTimeoutSelector, timeoutSelector) immediate timeout(timeoutSelector, other) immediate timeout(timeout, timeUnit) computation timeout(firstTimeoutSelector, timeoutSelector, other) immediate timeout(timeout, timeUnit, other) computation timer computation timestamp immediate window(timespan) computation window(timespan, count) computation window(timespan, timeshift) computation 使用调度器除了将这些调度器传递给RxJava的Observable操作符，你也可以用它们调度你自己的任务。下面的示例展示了Scheduler.Worker的用法： 1234567891011worker = Schedulers.newThread().createWorker();worker.schedule(new Action0() &#123; @Override public void call() &#123; yourWork(); &#125;&#125;);// some time later...worker.unsubscribe(); 递归调度器要调度递归的方法调用，你可以使用schedule，然后再用schedule(this)，示例： 12345678910111213worker = Schedulers.newThread().createWorker();worker.schedule(new Action0() &#123; @Override public void call() &#123; yourWork(); // recurse until unsubscribed (schedule will do nothing if unsubscribed) worker.schedule(this); &#125;&#125;);// some time later...worker.unsubscribe(); 检查或设置取消订阅状态Worker类的对象实现了Subscription接口，使用它的isUnsubscribed和unsubscribe方法，所以你可以在订阅取消时停止任务，或者从正在调度的任务内部取消订阅，示例： 123456789101112Worker worker = Schedulers.newThread().createWorker();Subscription mySubscription = worker.schedule(new Action0() &#123; @Override public void call() &#123; while(!worker.isUnsubscribed()) &#123; status = yourWork(); if(QUIT == status) &#123; worker.unsubscribe(); &#125; &#125; &#125;&#125;); 延时和周期调度器你可以使用schedule(action,delayTime,timeUnit)在指定的调度器上延时执行你的任务，下面例子中的任务将在500毫秒之后开始执行： 1someScheduler.schedule(someAction, 500, TimeUnit.MILLISECONDS); 使用另一个版本的schedule，schedulePeriodically(action,initialDelay,period,timeUnit)方法让你可以安排一个定期执行的任务，下面例子的任务将在500毫秒之后执行，然后每250毫秒执行一次： 1someScheduler.schedulePeriodically(someAction, 500, 250, TimeUnit.MILLISECONDS); 测试调度器TestScheduler让你可以对调度器的时钟表现进行手动微调。这对依赖精确时间安排的任务的测试很有用处。这个调度器有三个额外的方法： advanceTimeTo(time,unit) 向前波动调度器的时钟到一个指定的时间点 advanceTimeBy(time,unit) 将调度器的时钟向前拨动一个指定的时间段 triggerActions( ) 开始执行任何计划中的但是未启动的任务，如果它们的计划时间等于或者早于调度器时钟的当前时间 Operators创建操作 just( ) — 将一个或多个对象转换成发射这个或这些对象的一个Observable from( ) — 将一个Iterable, 一个Future, 或者一个数组转换成一个Observable repeat( ) — 创建一个重复发射指定数据或数据序列的Observable repeatWhen( ) — 创建一个重复发射指定数据或数据序列的Observable，它依赖于另一个Observable发射的数据 create( ) — 使用一个函数从头创建一个Observable defer( ) — 只有当订阅者订阅才创建Observable；为每个订阅创建一个新的Observable range( ) — 创建一个发射指定范围的整数序列的Observable interval( ) — 创建一个按照给定的时间间隔发射整数序列的Observable timer( ) — 创建一个在给定的延时之后发射单个数据的Observable empty( ) — 创建一个什么都不做直接通知完成的Observable error( ) — 创建一个什么都不做直接通知错误的Observable never( ) — 创建一个不发射任何数据的Observable 变换操作 map( ) — 对序列的每一项都应用一个函数来变换Observable发射的数据序列 flatMap( ), concatMap( ), and flatMapIterable( ) — 将Observable发射的数据集合变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable switchMap( ) — 将Observable发射的数据集合变换为Observables集合，然后只发射这些Observables最近发射的数据 scan( ) — 对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值 groupBy( ) — 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据 buffer( ) — 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个 window( ) — 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项 cast( ) — 在发射之前强制将Observable发射的所有数据转换为指定类型 过滤操作 filter( ) — 过滤数据 takeLast( ) — 只发射最后的N项数据 last( ) — 只发射最后的一项数据 lastOrDefault( ) — 只发射最后的一项数据，如果Observable为空就发射默认值 takeLastBuffer( ) — 将最后的N项数据当做单个数据发射 skip( ) — 跳过开始的N项数据 skipLast( ) — 跳过最后的N项数据 take( ) — 只发射开始的N项数据 first( ) and takeFirst( ) — 只发射第一项数据，或者满足某种条件的第一项数据 firstOrDefault( ) — 只发射第一项数据，如果Observable为空就发射默认值 elementAt( ) — 发射第N项数据 elementAtOrDefault( ) — 发射第N项数据，如果Observable数据少于N项就发射默认值 sample( ) or throttleLast( ) — 定期发射Observable最近的数据 throttleFirst( ) — 定期发射Observable发射的第一项数据 throttleWithTimeout( ) or debounce( ) — 只有当Observable在指定的时间后还没有发射数据时，才发射一个数据 timeout( ) — 如果在一个指定的时间段后还没发射数据，就发射一个异常 distinct( ) — 过滤掉重复数据 distinctUntilChanged( ) — 过滤掉连续重复的数据 ofType( ) — 只发射指定类型的数据 ignoreElements( ) — 丢弃所有的正常数据，只发射错误或完成通知 结合操作 startWith( ) — 在数据序列的开头增加一项数据 merge( ) — 将多个Observable合并为一个 mergeDelayError( ) — 合并多个Observables，让没有错误的Observable都完成后再发射错误通知 zip( ) — 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果 and( ), then( ), and when( ) — (rxjava-joins) 通过模式和计划组合多个Observables发射的数据集合 combineLatest( ) — 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果 join( ) and groupJoin( ) — 无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射 switchOnNext( ) — 将一个发射Observables的Observable转换成另一个Observable，后者发射这些Observables最近发射的数据 错误操作很多操作符可用于对Observable发射的onError通知做出响应或者从错误中恢复，例如，你可以： 吞掉这个错误，切换到一个备用的Observable继续发射数据 吞掉这个错误然后发射默认值 吞掉这个错误并立即尝试重启这个Observable 吞掉这个错误，在一些回退间隔后重启这个Observable 这是操作符列表： onErrorResumeNext( ) — 指示Observable在遇到错误时发射一个数据序列 onErrorReturn( ) — 指示Observable在遇到错误时发射一个特定的数据 onExceptionResumeNext( ) — instructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)指示Observable遇到错误时继续发射数据 retry( ) — 指示Observable遇到错误时重试 retryWhen( ) — 指示Observable遇到错误时，将错误传递给另一个Observable来决定是否要重新给订阅这个Observable 辅助操作 materialize( ) — 将Observable转换成一个通知列表convert an Observable into a list of Notifications dematerialize( ) — 将上面的结果逆转回一个Observable timestamp( ) — 给Observable发射的每个数据项添加一个时间戳 serialize( ) — 强制Observable按次序发射数据并且要求功能是完好的 cache( ) — 记住Observable发射的数据序列并发射相同的数据序列给后续的订阅者 observeOn( ) — 指定观察者观察Observable的调度器 subscribeOn( ) — 指定Observable执行任务的调度器 doOnEach( ) — 注册一个动作，对Observable发射的每个数据项使用 doOnCompleted( ) — 注册一个动作，对正常完成的Observable使用 doOnError( ) — 注册一个动作，对发生错误的Observable使用 doOnTerminate( ) — 注册一个动作，对完成的Observable使用，无论是否发生错误 doOnSubscribe( ) — 注册一个动作，在观察者订阅时使用 doOnUnsubscribe( ) — 注册一个动作，在观察者取消订阅时使用 finallyDo( ) — 注册一个动作，在Observable完成时使用 delay( ) — 延时发射Observable的结果 delaySubscription( ) — 延时处理订阅请求 timeInterval( ) — 定期发射数据 using( ) — 创建一个只在Observable生命周期存在的资源 single( ) — 强制返回单个数据，否则抛出异常 singleOrDefault( ) — 如果Observable完成时返回了单个数据，就返回它，否则返回默认数据 toFuture( ), toIterable( ), toList( ) — 将Observable转换为其它对象或数据结构 条件和布尔操作条件操作符 amb( ) — 给定多个Observable，只让第一个发射数据的Observable发射全部数据 defaultIfEmpty( ) — 发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据 (rxjava-computation-expressions) doWhile( ) — 发射原始Observable的数据序列，然后重复发射这个序列直到不满足这个条件为止 (rxjava-computation-expressions) ifThen( ) — 只有当某个条件为真时才发射原始Observable的数据序列，否则发射一个空的或默认的序列 skipUntil( ) — 丢弃原始Observable发射的数据，直到第二个Observable发射了一个数据，然后发射原始Observable的剩余数据 skipWhile( ) — 丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始Observable剩余的数据 (rxjava-computation-expressions) switchCase( ) — 基于一个计算结果，发射一个指定Observable的数据序列 takeUntil( ) — 发射来自原始Observable的数据，直到第二个Observable发射了一个数据或一个通知 takeWhile( ) and takeWhileWithIndex( ) — 发射原始Observable的数据，直到一个特定的条件为真，然后跳过剩余的数据 布尔操作符 all( ) — 判断是否所有的数据项都满足某个条件 contains( ) — 判断Observable是否会发射一个指定的值 exists( ) and isEmpty( ) — 判断Observable是否发射了一个值 sequenceEqual( ) — 判断两个Observables发射的序列是否相等 算数和聚合操作rxjava-math 模块的操作符 averageInteger( ) — 求序列平均数并发射 averageLong( ) — 求序列平均数并发射 averageFloat( ) — 求序列平均数并发射 averageDouble( ) — 求序列平均数并发射 max( ) — 求序列最大值并发射 maxBy( ) — 求最大key对应的值并发射 min( ) — 求最小值并发射 minBy( ) — 求最小Key对应的值并发射 sumInteger( ) — 求和并发射 sumLong( ) — 求和并发射 sumFloat( ) — 求和并发射 sumDouble( ) — 求和并发射 其它聚合操作符 concat( ) — 顺序连接多个Observables count( ) and countLong( ) — 计算数据项的个数并发射结果 reduce( ) — 对序列使用reduce()函数并发射最终的结果 collect( ) — 将原始Observable发射的数据放到一个单一的可变的数据结构中，然后返回一个发射这个数据结构的Observable toList( ) — 收集原始Observable发射的所有数据到一个列表，然后返回这个列表 toSortedList( ) — 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表 toMap( ) — 将序列数据转换为一个Map，Map的key是根据一个函数计算的 toMultiMap( ) — 将序列数据转换为一个列表，同时也是一个Map，Map的key是根据一个函数计算的 异步操作下面的这些操作符属于单独的rxjava-async模块，它们用于将同步对象转换为Observable。 start( ) — 创建一个Observable，它发射一个函数的返回值 toAsync( ) or asyncAction( ) or asyncFunc( ) — 将一个函数或者Action转换为已Observable，它执行这个函数并发射函数的返回值 startFuture( ) — 将一个返回Future的函数转换为一个Observable，它发射Future的返回值 deferFuture( ) — 将一个返回Observable的Future转换为一个Observable，但是并不尝试获取这个Future返回的Observable，直到有订阅者订阅它 forEachFuture( ) — 传递Subscriber方法给一个Subscriber，但是同时表现得像一个Future一样阻塞直到它完成 fromAction( ) — 将一个Action转换为Observable，当一个订阅者订阅时，它执行这个action并发射它的返回值 fromCallable( ) — 将一个Callable转换为Observable，当一个订阅者订阅时，它执行这个Callable并发射Callable的返回值，或者发射异常 fromRunnable( ) — convert a Runnable into an Observable that invokes the runable and emits its result when a Subscriber subscribes将一个Runnable转换为Observable，当一个订阅者订阅时，它执行这个Runnable并发射Runnable的返回值 runAsync( ) — 返回一个StoppableObservable，它发射某个Scheduler上指定的Action生成的多个actions 连接操作 ConnectableObservable.connect( ) — 指示一个可连接的Observable开始发射数据 Observable.publish( ) — 将一个Observable转换为一个可连接的Observable Observable.replay( ) — 确保所有的订阅者看到相同的数据序列，即使它们在Observable开始发射数据之后才订阅 ConnectableObservable.refCount( ) — 让一个可连接的Observable表现得像一个普通的Observable 转换操作阻塞操作要将普通的Observable 转换为 BlockingObservable，可以使用 Observable.toBlocking( )) 方法或者BlockingObservable.from( )) 方法。 forEach( ) — 对Observable发射的每一项数据调用一个方法，会阻塞直到Observable完成 first( ) — 阻塞直到Observable发射了一个数据，然后返回第一项数据 firstOrDefault( ) — 阻塞直到Observable发射了一个数据或者终止，返回第一项数据，或者返回默认值 last( ) — 阻塞直到Observable终止，然后返回最后一项数据 lastOrDefault( ) — 阻塞直到Observable终止，然后返回最后一项的数据，或者返回默认值 mostRecent( ) — 返回一个总是返回Observable最近发射的数据的iterable next( ) — 返回一个Iterable，会阻塞直到Observable发射了另一个值，然后返回那个值 latest( ) — 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值 single( ) — 如果Observable终止时只发射了一个值，返回那个值，否则抛出异常 singleOrDefault( ) — 如果Observable终止时只发射了一个值，返回那个值，否则否好默认值 toFuture( ) — 将Observable转换为一个Future toIterable( ) — 将一个发射数据序列的Observable转换为一个Iterable getIterator( ) — 将一个发射数据序列的Observable转换为一个Iterator 字符串操作 byLine( ) — 将一个字符串的Observable转换为一个行序列的Observable，这个Observable将原来的序列当做流处理，然后按换行符分割 decode( ) — 将一个多字节的字符流转换为一个Observable，它按字符边界发射字节数组 encode( ) — 对一个发射字符串的Observable执行变换操作，变换后的Observable发射一个在原始字符串中表示多字节字符边界的字节数组 from( ) — 将一个字符流或者Reader转换为一个发射字节数组或者字符串的Observable join( ) — 将一个发射字符串序列的Observable转换为一个发射单个字符串的Observable，后者用一个指定的字符串连接所有的字符串 split( ) — 将一个发射字符串的Observable转换为另一个发射字符串的Observable，后者使用一个指定的正则表达式边界分割前者发射的所有字符串 stringConcat( ) — 将一个发射字符串序列的Observable转换为一个发射单个字符串的Observable，后者连接前者发射的所有字符串 参考 reactivex.io https://github.com/ReactiveX https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Getting-Started.html","tags":[{"name":"Rx","slug":"Rx","permalink":"http://airshu.github.io/tags/Rx/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"flutter_bloc","date":"2024-02-12T02:23:36.669Z","path":"wiki/Flutter/开源库/flutter_bloc/","text":"基本用法核心概念：将UI和数据分离，数据使用Event、Bloc（Cubit）、State来进行单项流转。 通过BlocProvider提供Bloc供不同地方使用 使用BlocBuilder监听Bloc的状态变化，根据状态变化来刷新UI Bloc中处理业务逻辑 State中保存数据 常用APIBloc.observer全局监听Event事件的变化、bloc的转化、异常回调 BlocProvider、MultiBlocProvider绑定bloc BlocBuilder视图层监听bloc的状态变化，根据状态变化来刷新UI。buildWhen中判断是否需要刷新 12345678BlocBuilder&lt;BlocA, StateA&gt;( builder: (context, state) &#123; return Container(); &#125;, buildWhen: (previous, current) &#123; return previous != current; &#125;,) BlocSelector123456789BlocSelector&lt;BlocA, StateA, StateB&gt;( selector: (state) &#123; //判断是否需要刷新 return state; &#125;, builder: (context, state) &#123; return Container(); &#125;,) BlocListener123456BlocListener&lt;BlocA, StateA&gt;( listener: (context, state) &#123; // do stuff here based on BlocA&#x27;s state &#125;, child: Container(),) ### Bloc&lt;Event,State&gt; Bloc、Cubit的基类，bloc中监听Event，处理业务逻辑，emit State ### Event 实体类，定义成事件类型，区分不同的业务场景 ### State 实体类，存储数据，驱动UI刷新 ## 注意事项 - emit的时候需要重新构造State对象，是否可以优化？ - 为了精细化处理，需要使用多个BlocBuilder，每个Builder都要实现自己的buildWhen，避免不必要的刷新 - 异步操作完后的emit之前需要判断下isClosed ## 参考 - [官方文档](https://bloclibrary.dev)","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"Widget","date":"2024-02-12T02:23:36.669Z","path":"wiki/Flutter/UI/Widget/","text":"WidgetFlutter中的一切都是Widget。关于Flutter的UI绘制原理可以参考纷争再起：Flutter-UI绘制解析。 简要概括就是，我们写各种widget，Flutter框架帮我们解析成element树，最终转换成renderobject树，再通过底层skia绘制。 Component Widget：组合类Widget，这类Widget都继承StatelessWidget或StatefulWidget； Render Widget：渲染类Widget，参与layout、paint流程，有与之对应的Render Object； Proxy Widget：代理类Widget，提供一些附加的功能，比如InheritedWidget用于共享信息，ParentDataWidget用于为其他Widget提供信息； context如果 widget A 拥有子 widget，那么 widget A 的 context 将成为其直接关联子 context 的父 context。 1context.ancestorWidgetOfExactType(Scaffold) =&gt; 通过从 context 得到树结构来返回第一个 Scaffold Widget主要有两种类型： StatelessWidget：只有在创建的时候绘制一次 StatefulWidget：根据状态会发生变化 感觉这样设计还是处于性能考虑，当某些控件不需要改变UI时，使用StatelessWidget就不会重绘。 Widget12345678910111213abstract class Widget extends DiagnosticableTree &#123; final Key? key;//标识 https://medium.com/flutter/keys-what-are-they-good-for-13cb51742e7d Element createElement();//每个Widget对应一个Element /// 是否需要更新，根据runtimeType和key来判断 static bool canUpdate(Widget oldWidget, Widget newWidget) &#123; return oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key; &#125;&#125; 为什么widget都是immutable? @immutable 代表 Widget 是不可变的，这会限制 Widget 中定义的属性（即配置信息）必须是不可变的（final），为什么不允许 Widget 中定义的属性变化呢？这是因为，Flutter 中如果属性发生变化则会重新构建Widget树，即重新创建新的 Widget 实例来替换旧的 Widget 实例，所以允许 Widget 的属性变化是没有意义的，因为一旦 Widget 自己的属性变了自己就会被替换。这也是为什么 Widget 中定义的属性必须是 final 的原因。 StatelessWidget对于StatelessWidget，只需要重写build方法即可。 StatefulWidgetStatefulWidget是通过State来管理状态，State的生命周期也就是State的生命周期。参考：State Key在 Fultter 中，每一个 Widget 都是被唯一标识的。这个唯一标识在 build&#x2F;rendering 阶段由框架定义。该唯一标识对应于可选的 Key 参数。如果省略该参数，Flutter 将会为你生成一个。 参考：key 访问子Widget通过key 12345678910111213...GlobalKey&lt;MyStatefulWidgetState&gt; myWidgetStateKey = new GlobalKey&lt;MyStatefulWidgetState&gt;();...@overrideWidget build(BuildContext context)&#123; return new MyStatefulWidget( key: myWidgetStateKey, color: Colors.blue, );&#125;///访问子StatemyWidgetStateKey.currentState 访问父Widget1234567891011121314151617181920class MyExposingWidgetState extends State&lt;MyExposingWidget&gt;&#123; Color _color; Color get color =&gt; _color; ...&#125;class MyChildWidget extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; // 通过context的方法 final MyExposingWidget widget = context.ancestorWidgetOfExactType(MyExposingWidget); final MyExposingWidgetState state = widget?.myState; return new Container( color: state == null ? Colors.blue : state.color, ); &#125;&#125; StatelessWidget、StatefulWidget选择策略： 优先使用 StatelessWidget 含有大量子 Widget（如根布局、次根布局）慎用 StatefulWidget 尽量在叶子节点使用 StatefulWidget 将会调用到setState((){}) 的代码尽可能的和要更新的视图封装在一个尽可能小的模块里。 如果一个Widget需要reBuild，那么它的子节点、兄弟节点、兄弟节点的子节点应该尽可能少 InheritedWidget允许树中较低层次的widget向上查找，获得祖先widget的引用，以及在祖先改变的时候重建自身。Theme.of()和Navigator.of()都是InheritedWidget的例子。 InheritedWidget 组件的所有子组件都可以直接通过 BuildContext.dependOnInheritedWidgetOfExactType 获取数据。 updateShouldNotify方法来决定是否通知子树中依赖data的Widget。 如果返回true，则子树中依赖(build函数中有调用)本widget的子widget的state.didChangeDependencies会被调用 参考 纷争再起：Flutter-UI绘制解析 数据共享（InheritedWidget） 源码分析系列之InheritedWidget","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"}]},{"title":"资料收集","date":"2024-02-12T02:23:36.669Z","path":"wiki/Flutter/动态化/资料收集/","text":"https://github.com/openkraken/kraken：阿里出品，已经不维护 https://github.com/ymm-tech/thresh：基于JS的Flutter动态化方案，已不维护 https://github.com/mxflutter/mxflutter：腾讯出品，MXFlutter 是一套使用 TypeScript&#x2F;JavaScript 来开发 Flutter 应用的框架。已不维护 https://hydro-sdk.io/：使用JS相关技术的动态化技术，已不维护 https://github.com/ChimeraFlutter/Chimera-Flutter-Code-Push：已不维护，貌似很强大。只需要基于dart https://github.com/openwebf/webf：Kraken替代品 https://github.com/wuba/FairPushy：58同城的开源动态化方案，目前市面上比较完善的开源方案。 Flutter动态化方案 https://alibaba.github.io/LuaViewSDK/index.html UC Flutter技术沙龙分享：Aion - 拥抱 Flutter 生态的动态化方案 美团外卖Flutter动态化实践 Flutter 动态化在最右 App 中的实践 Definitional Interpreters for Higher-Order Programming Languages Dynamic Interpretation for Dynamic Scripting Languages https://hetu.dev/docs/zh-Hans/：河图，专为Flutter打造的轻量型嵌入式脚本语言 https://github.com/peiffer-innovations/json_dynamic_widget：动态加载json文件的UI 带你不到80行代码搞定Flutter热更新原创","tags":[{"name":"Flutter 动态化","slug":"Flutter-动态化","permalink":"http://airshu.github.io/tags/Flutter-%E5%8A%A8%E6%80%81%E5%8C%96/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"动态化","slug":"Flutter/动态化","permalink":"http://airshu.github.io/categories/Flutter/%E5%8A%A8%E6%80%81%E5%8C%96/"}]},{"title":"Flutter事件分发原理","date":"2024-02-12T02:23:36.669Z","path":"wiki/Flutter/源码分析/Flutter事件分发原理/","text":"Flutter中，Android设备上的事件分发流程： Android的事件响应，通过Engine发送到framework层，Flutter侧的GestureBinding负责接收事件。 Flutter侧对设备事件定义了touch、mouse、stylus、invertedStylus、trackpad、unknown几种类型 命中测试：当手指按下时，触发 PointerDownEvent 事件，按照深度优先遍历当前渲染（render object）树，对每一个渲染对象进行“命中测试”（hit test），如果命中测试通过，则该渲染对象会被添加到一个 HitTestResult 列表当中。 事件分发：命中测试完毕后，会遍历 HitTestResult 列表，调用每一个渲染对象的事件处理方法（handleEvent）来处理 PointerDownEvent 事件，该过程称为“事件分发”（event dispatch）。随后当手指移动时，便会分发 PointerMoveEvent 事件。 事件清理：当手指抬（ PointerUpEvent ）起或事件取消时（PointerCancelEvent），会先对相应的事件进行分发，分发完毕后会清空 HitTestResult 列表。 Flutter屏幕触发的事件类型 PointerAddedEvent：接触屏幕 PointerHoverEvent：悬停事件 PointerDownEvent：按下事件 PointerMoveEvent：移动事件 PointerUpEvent：完全离开屏幕事件 PointerCancelEvent：取消事件 PointerRemovedEvent：事件可能已偏离设备的检测范围，或者可能已完全与系统断开连接 事件流程Dart层中手势事件从_dispatchPointerDataPacket开始，之后会执行GestureBinding的_handlePointerEvent方法。 12345678910111213141516171819202122232425262728293031323334353637void handlePointerEvent(PointerEvent event) &#123; if (resamplingEnabled) &#123; _resampler.addOrDispatch(event); _resampler.sample(samplingOffset, _samplingClock); return; &#125; // Stop resampler if resampling is not enabled. This is a no-op if // resampling was never enabled. _resampler.stop(); _handlePointerEventImmediately(event);&#125;void _handlePointerEventImmediately(PointerEvent event) &#123; HitTestResult? hitTestResult; if (event is PointerDownEvent || event is PointerSignalEvent || event is PointerHoverEvent || event is PointerPanZoomStartEvent) &#123; hitTestResult = HitTestResult(); //开始碰撞检测 先调用RenderBinding中的 再调用GestureBinding中的 hitTest(hitTestResult, event.position); if (event is PointerDownEvent || event is PointerPanZoomStartEvent) &#123; _hitTests[event.pointer] = hitTestResult; &#125; &#125; else if (event is PointerUpEvent || event is PointerCancelEvent || event is PointerPanZoomEndEvent) &#123; //复用机制，抬起或取消，不用hitTest，移除 hitTestResult = _hitTests.remove(event.pointer); &#125; else if (event.down || event is PointerPanZoomUpdateEvent) &#123; hitTestResult = _hitTests[event.pointer]; &#125; if (hitTestResult != null || event is PointerAddedEvent || event is PointerRemovedEvent) &#123; //分发事件 dispatchEvent(event, hitTestResult); &#125;&#125; RenderBinding的hitTest1234567891011121314151617181920212223242526272829 void hitTest(HitTestResult result, Offset position) &#123; //RenderView renderView.hitTest(result, position: position); super.hitTest(result, position); &#125;/// RenderView中的hitTest bool hitTest(HitTestResult result, &#123; required Offset position &#125;) &#123; //RenderBox if (child != null) &#123; child!.hitTest(BoxHitTestResult.wrap(result), position: position); &#125; result.add(HitTestEntry(this)); return true; &#125;/// RenderObject中的hitTest bool hitTest(BoxHitTestResult result, &#123; required Offset position &#125;) &#123; if (_size!.contains(position)) &#123; if (hitTestChildren(result, position: position) || hitTestSelf(position)) &#123; result.add(BoxHitTestEntry(this, position)); return true; &#125; &#125; return false; &#125; GestureBinding的hitTest123void hitTest(HitTestResult result, Offset position) &#123; result.add(HitTestEntry(this));&#125; 分发事件dispatchEvent对事件进行分发 123456789101112131415161718192021void dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) &#123; if (hitTestResult == null) &#123; assert(event is PointerAddedEvent || event is PointerRemovedEvent); try &#123; // 没有碰撞检测信息 pointerRouter.route(event); &#125; catch (exception, stack) &#123; &#125; return; &#125; for (final HitTestEntry entry in hitTestResult.path) &#123; try &#123; // 存在碰撞时，每个控件内部调用handleEvent处理，多个控件存在竞争时如何处理？ 使用手势竞技场GestureArenaManager entry.target.handleEvent(event.transformed(entry.transform), entry); &#125; catch (exception, stack) &#123; &#125; &#125;&#125; 手势竞技场GestureArenaManager GestureRecognizer ：手势识别器基类，基本上 RenderPointerListener 中需要处理的手势事件，都会分发到它对应的 GestureRecognizer，并经过它处理和竞技后再分发出去，常见有 ： OneSequenceGestureRecognizer MultiTapGestureRecognizer HorizontalDragGestureRecognizer VerticalDragGestureRecognizer TapGestureRecognizer、 LongPressGestureRecognizer DoubleTapGestureRecognizer PanGestureRecognizer ScaleGestureRecognizer ForcePressGestureRecognizer GestureArenaManager：手势竞技管理，它管理了整个“战争”的过程，原则上竞技胜出的条件是 ：第一个竞技获胜的成员或最后一个不被拒绝的成员。 GestureArenaEntry ：提供手势事件竞技信息的实体，内封装参与事件竞技的成员。 GestureArenaMember：参与竞技的成员抽象对象，内部有 acceptGesture 和 rejectGesture 方法，它代表手势竞技的成员，默认 GestureRecognizer 都实现了它，所有竞技的成员可以理解为就是 GestureRecognizer 之间的竞争。 _GestureArena：GestureArenaManager 内的竞技场，内部持参与竞技的 members 列表，官方对这个竞技场的解释是： 如果一个手势试图在竞技场开放时(isOpen&#x3D;true)获胜，它将成为一个带有“渴望获胜”的属性的对象。当竞技场关闭(isOpen&#x3D;false)时，竞技场将寻找一个“渴望获胜”的对象成为新的参与者，如果这时候刚好只有一个，那这一个参与者将成为这次竞技场胜利的青睐存在。 添加到竞技场 手势识别器是如何添加到竞技场的呢？ 使用GestureDector，在其build方法中会根据不同的场景注册不同的手势识别器，将其传递给RawGestureDetector RawGestureDetector的build方法中创建Listener，并通过_handlePointerDown方法将PointerDownEvent数据添加进来 GestureBinding的handleEvent中竞技场处理数据 1234567891011121314151617void handleEvent(PointerEvent event, HitTestEntry entry) &#123; //使用注册的识别器GestureRecognizer的handleEvent处理 //比如TapGestureRecognizer中，在其父类PrimaryPointerGestureRecognizer的handleEvent中处理 pointerRouter.route(event); if (event is PointerDownEvent || event is PointerPanZoomStartEvent) &#123; //关闭手势竞技场，并尝试解决手势竞技场 gestureArena.close(event.pointer); &#125; else if (event is PointerUpEvent || event is PointerPanZoomEndEvent) &#123; //扫描手势竞技场，并调用第一个手势识别器的 acceptGesture 方法 gestureArena.sweep(event.pointer); &#125; else if (event is PointerSignalEvent) &#123; pointerSignalResolver.resolve(event); &#125;&#125; 竞技场处理GestureArenaManager的作用： 存储所有竞技场及竞技场成员的添加及移除。 竞技场状态的管理。如竞技场的创建、关闭、生命周期的延长等。 每个竞技场中成员竞争的具体实现。 参考 Flutter事件机制 浅谈Flutter核心机制之—事件分发 Flutter分享：Flutter事件分发原理 全面深入触摸和滑动原理 Flutter之竞技场（Arena）原理解析","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"Flutter代码规范","date":"2024-02-12T02:23:36.668Z","path":"wiki/Flutter/Flutter代码规范/","text":"好的代码有一个非常重要的特点就是拥有好的风格。一致的命名、一致的顺序、以及一致的格式让代码看起来是一样的。 Dart代码规范标识符在 Dart 中标识符有三种类型。 UpperCamelCase 每个单词的首字母都大写，包含第一个单词。 lowerCamelCase 除了第一个字母始终是小写（即使是缩略词），每个单词的首字母都大写。 lowercase_with_underscores 只是用小写字母单词，即使是缩略词，并且单词之间使用 _ 连接 UpperCamelCase使用场景 Classes（类名）、 enums（枚举类型）、 typedefs（类型定义）、以及 type parameters（类型参数）应该把每个单词的首字母都大写（包含第一个单词），不使用分隔符。 扩展 12345678910class SliderMenu &#123; ... &#125;class HttpRequest &#123; ... &#125;typedef Predicate&lt;T&gt; = bool Function(T value);extension MyFancyList&lt;T&gt; on List&lt;T&gt; &#123; ... &#125;extension SmartIterable&lt;T&gt; on Iterable&lt;T&gt; &#123; ... &#125; lowercase_with_underscores使用场景 库的名字、package的名字、文件夹名字、文件名、源文件名 123456789101112import &#x27;dart:math&#x27; as math;import &#x27;package:angular_components/angular_components.dart&#x27; as angular_components;import &#x27;package:js/js.dart&#x27; as js;//my_package└─ lib └─ file_system.dart └─ slider_menu.dart lowerCamelCase使用场景 类成员、顶级定义、变量、参数以及命名参数等 除了第一个单词，每个单词首字母都应大写，并且不使用分隔符。 常量 123456789101112131415161718var count = 3;HttpRequest httpRequest;void align(bool clearItems) &#123; // ...&#125;const pi = 3.14;const defaultTimeout = 1000;final urlScheme = RegExp(&#x27;^([a-z]+):&#x27;);class Dice &#123; static final numberGenerator = Random();&#125; 不要使用前缀字母在编译器无法帮助你了解自己代码的时， 匈牙利命名法 和其他方案出现在了 BCPL ，但是因为 Dart 可以提示你声明的类型，范围，可变性和其他属性，所以没有理由在标识符名称中对这些属性进行编码。 12345// gooddefaultTimeout// badkDefaultTimeout 顺序为了使文件前面部分保持整洁，我们规定了关键字出现顺序的规则。每个“部分”应该使用空行分割。 要把”dart:”导入语句放到其他导入语句之前 要把”package:”导入语句放到项目相关导入语句之前 要把导出（export）语句作为一个单独的部分放到所有导入语句之后 按照字母顺序排序 12345678910import &#x27;dart:async&#x27;;import &#x27;dart:html&#x27;;import &#x27;package:bar/bar.dart&#x27;;import &#x27;package:foo/foo.dart&#x27;;import &#x27;util.dart&#x27;;export &#x27;src/error.dart&#x27;; 代码格式化格式化要严格要求，不然不同的提交会产生不必要的冲突。可以通过IDE的插件配置提交前格式化，平时写完代码也可手动格式化 单行宽度以前由于屏幕小，一般要求宽度不能超过80.这里只要团队内统一一个值，大家根据实际情况调整即可。建议设置成140 流控制结构使用花括号统一规范，if后面必须使用花括号。 不推荐使用new在不需要的时候不要使用this项目中配置代码规范参考 Flutter静态代码检测 参考 https://dart.cn/guides/language/effective-dart/style","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"Flutter与Android通信","date":"2024-02-12T02:23:36.667Z","path":"wiki/Flutter/Android端/Flutter与Android通信/","text":"PlatformChannelFlutter可以通过PlatformChannel与原生侧互发消息，有三种类型： MethodChannel：用于传递方法调用 EventChannel：用于传递事件（单向） BasicMessageChannel：用于传递数据，比如可以获取native层的图片数据进行展示 一些概念 BinaryMessenger BinaryMessenger 是 PlatformChannel 与 Flutter 端的通信的工具，其通信使用的消息格式为二进制格式数据，BinaryMessenger 在 Android 中是一个接口，它的实现类为 FlutterNativeView Codec Codec 是消息编解码器，主要用于将二进制格式的数据转化为 Handler 能够识别的数据，Flutter 定义了两种 Codec：MessageCodec 和 MethodCodec。MessageCodec 用于二进制格式数据与基础数据之间的编解码，BasicMessageChannel 所使用的编解码器是 MessageCodec。MethodChannel 和 EventChannel 所使用的编解码均为 MethodCodec Handler Flutter 定义了三种类型的 Handler，它们与 PlatformChannel 类型一一对应，分别是 MessageHandler、MethodHandler、StreamHandler。在使用 PlatformChannel 时，会为它注册一个 Handler，PlatformChannel 会将该二进制数据通过 Codec 解码为转化为 Handler 能够识别的数据，并交给 Handler 处理。当 Handler 处理完消息之后，会通过回调函数返回 result，将 result 通过编解码器编码为二进制格式数据，通过 BinaryMessenger 发送回 Flutter 端 MethodChannelFlutter侧写法123456789101112131415// 构造一个MethodChannel 参数定义一个唯一的通道名static const platform = MethodChannel(&#x27;methodChannelDemo&#x27;);// 调用native的方法，第一个参数为方法名，第二个为参数// 可以设置返回类型// result为native的方法的返回值 final result = await platform.invokeMethod&lt;int&gt;(&#x27;increment&#x27;, &#123;&#x27;count&#x27;: 1&#125;);// 监听底层来的方法回调platform.setMethodCallHandler((MethodCall call)&#123;if(call.method == &#x27;callDart&#x27;) &#123;&#125;&#125;); native侧写法12345678910111213141516171819202122232425262728293031323334353637override fun configureFlutterEngine(flutterEngine: FlutterEngine) &#123; val channel = MethodChannel(flutterEngine.dartExecutor, &quot;methodChannelDemo&quot;) channel.setMethodCallHandler &#123; call, result -&gt; val count: Int? = call.argument&lt;Int&gt;(&quot;count&quot;) if (count == null) &#123; result.error(&quot;INVALID ARGUMENT&quot;, &quot;Value of count cannot be null&quot;, null) &#125; else &#123; when (call.method) &#123; &quot;increment&quot; -&gt; result.success(count + 1) &quot;decrement&quot; -&gt; result.success(count - 1) else -&gt; result.notImplemented() &#125; &#125; &#125; //调用dart侧的方法 参数分别为方法、参数、回调，需要在主线程中调用 channel.invokeMethod(&quot;callDart&quot;, &quot;Hello&quot;, object: MethodChannel.Result &#123; override fun success(result: Any?) &#123; &#125; override fun error(errorCode: String, errorMessage: String?, errorDetails: Any?) &#123; &#125; override fun notImplemented() &#123; &#125; &#125;)&#125; EventChannelFlutter侧写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/// 监听streamStreamBuilder&lt;AccelerometerReadings&gt;( stream: Accelerometer.readings, builder: (context, snapshot) &#123; if (snapshot.hasError) &#123; return Text((snapshot.error as PlatformException).message!); &#125; else if (snapshot.hasData) &#123; return Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text( &#x27;x axis: $&#123;snapshot.data!.x.toStringAsFixed(3)&#125;&#x27;, style: textStyle, ), Text( &#x27;y axis: $&#123;snapshot.data!.y.toStringAsFixed(3)&#125;&#x27;, style: textStyle, ), Text( &#x27;z axis: $&#123;snapshot.data!.z.toStringAsFixed(3)&#125;&#x27;, style: textStyle, ) ], ); &#125; return Text( &#x27;No Data Available&#x27;, style: textStyle, ); &#125;, )class Accelerometer &#123; static const _eventChannel = EventChannel(&#x27;eventChannelDemo&#x27;); /// Method responsible for providing a stream of [AccelerometerReadings] to listen /// to value changes from the Accelerometer sensor. static Stream&lt;AccelerometerReadings&gt; get readings &#123; return _eventChannel.receiveBroadcastStream().map( (dynamic event) =&gt; AccelerometerReadings( event[0] as double, event[1] as double, event[2] as double, ), ); &#125;&#125;class AccelerometerReadings &#123; /// Acceleration force along the x-axis. final double x; /// Acceleration force along the y-axis. final double y; /// Acceleration force along the z-axis. final double z; AccelerometerReadings(this.x, this.y, this.z);&#125; Native侧写法123456789101112131415161718192021222324252627282930313233343536373839val sensorManger: SensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManagerval accelerometerSensor: Sensor = sensorManger.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)// 构造EventChannel 定义唯一标志EventChannel(flutterEngine.dartExecutor, &quot;eventChannelDemo&quot;) .setStreamHandler(AccelerometerStreamHandler(sensorManger, accelerometerSensor))// 继承EventChannel.StreamHandlerclass AccelerometerStreamHandler(sManager: SensorManager, s: Sensor) : EventChannel.StreamHandler, SensorEventListener &#123; private val sensorManager: SensorManager = sManager private val accelerometerSensor: Sensor = s private lateinit var eventSink: EventChannel.EventSink override fun onListen(arguments: Any?, events: EventChannel.EventSink?) &#123; if (events != null) &#123; eventSink = events sensorManager.registerListener(this, accelerometerSensor, SensorManager.SENSOR_DELAY_UI) &#125; &#125; override fun onCancel(arguments: Any?) &#123; sensorManager.unregisterListener(this) &#125; override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) &#123;&#125; override fun onSensorChanged(sensorEvent: SensorEvent?) &#123; if (sensorEvent != null) &#123; val axisValues = listOf(sensorEvent.values[0], sensorEvent.values[1], sensorEvent.values[2]) eventSink.success(axisValues)//向flutter发送数据 &#125; else &#123; eventSink.error(&quot;DATA_UNAVAILABLE&quot;, &quot;Cannot get accelerometer data&quot;, null) &#125; &#125;&#125; BasicMessageChannel可以用来传递如图片等数据，有以下编码格式： StandardMessageCodec BinaryCodec JSONMessageCodec StringCodec Flutter侧写法12345678910111213141516171819202122class PlatformImageFetcher &#123; //有 static const _basicMessageChannel = BasicMessageChannel&lt;dynamic&gt;(&#x27;platformImageDemo&#x27;, StandardMessageCodec()); /// Method responsible for providing the platform image. static Future&lt;Uint8List&gt; getImage() async &#123; //请求数据 final reply = await _basicMessageChannel.send(&#x27;getImage&#x27;) as Uint8List?; if (reply == null) &#123; throw PlatformException( code: &#x27;Error&#x27;, message: &#x27;Failed to load Platform Image&#x27;, details: null, ); &#125; return reply; &#125;&#125; Native侧123456789101112// Registers a MessageHandler for BasicMessageChannel to receive a message from Dart and send// image data in reply.BasicMessageChannel(flutterEngine.dartExecutor, &quot;platformImageDemo&quot;, StandardMessageCodec()) .setMessageHandler &#123; message, reply -&gt; if (message == &quot;getImage&quot;) &#123; val inputStream: InputStream = assets.open(&quot;eat_new_orleans.jpg&quot;) reply.reply(inputStream.readBytes())//回传数据 &#125; &#125; 参考 Flutter与原生通信总结 Flutter 安卓 Platform 与 Dart 端消息通信方式 Channel 源码解析 flutter通信机制-EventChannel","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Android端","slug":"Flutter/Android端","permalink":"http://airshu.github.io/categories/Flutter/Android%E7%AB%AF/"}]},{"title":"Dart虚拟机","date":"2024-02-12T02:23:36.667Z","path":"wiki/Flutter/Dart/Dart虚拟机/","text":"Runtime System Object Model Garbage Collection Snapshots Core libraries native methods Development Experience components accessible via service protocol * Debugging * Profiling * Hot-reload Just-in-Time (JIT) and Ahead-of-Time (AOT) compilation pipelines Interpreter ARM simulators Introduction to Dart VM","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"}]},{"title":"native crash 分析","date":"2024-02-12T02:23:36.667Z","path":"wiki/Android/性能优化/native crash分析/","text":"Crash类型： Framework&#x2F;App Crash：Java层崩溃 Native Crash：C&#x2F;C++层崩溃 Kernel Crash：内核崩溃 tombstone文件的组成部分： Build fingerprint Crashed process and PIDS Terminated signal and fault address CPU registers Call stack Stack content of each call 12345678910111213--logversion:utraceaProcess Name: &#x27;com.feiteng.lieyou&#x27;Thread Name: &#x27;RenderThread&#x27;pid: 25031, tid: 25237 &gt;&gt;&gt; com.feiteng.lieyou &lt;&lt;&lt;killed by pid: 25031, comm: .feiteng.lieyou, uid: 10125.signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------r0 00000000 r1 00006295 r2 00000006 r3 00000008r4 c587c978 r5 00000006 r6 c587c920 r7 0000010cr8 bf249bc8 r9 00000000 10 bf249bbc fp bf249bb8ip 00000004 sp c587c3b0 lr eba21907 pc eba24188 cpsr 20070010d0 0000000000000000 d1 0000000000000000d2 0000000000000000 d3 0000000000000000 signal指定异常类型。如果pid等于tid，则说明程序是在主线程中崩溃。 signal下一行为寄存器快照 backtrace下面为异常调用堆栈 信号类型:软中断信号（signal，又简称为信号）用来通知进程发生了事件。进程之间可以通过调用kill库函数发送软中断信号。Linux内核也可能给进程发送信号，通知进程发生了某个事件（例如内存越界）。 信号只是用来通知某进程发生了什么事件，无法给进程传递任何数据，进程对信号的处理方法有三种： 第一种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。 第二种是设置中断的处理函数，收到信号后，由该函数来处理。 第三种方法是，对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//信号监听sighandler_t signal(int signum, sighandler_t handler);/*参数signum表示信号的编号。参数handler表示信号的处理方式，有三种情况：1）SIG_IGN：忽略参数signum所指的信号。2）一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数。3）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。*///发送信号int kill(pid_t pid, int sig);/*kill函数将参数sig指定的信号给参数pid 指定的进程。参数pid 有几种情况：1）pid&gt;0 将信号传给进程号为pid 的进程。2）pid=0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。3）pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。EINVAL：指定的信号码无效（参数 sig 不合法）。EPERM：权限不够无法传送信号给指定进程。ESRCH：参数 pid 所指定的进程或进程组不存在。*/#define SIGHUP 1 // 终端连接结束时发出(不管正常或非正常)#define SIGINT 2 // 程序终止(例如Ctrl-C)#define SIGQUIT 3 // 程序退出(Ctrl-\\)#define SIGILL 4 // 执行了非法指令，或者试图执行数据段，堆栈溢出#define SIGTRAP 5 // 断点时产生，由debugger使用#define SIGABRT 6 // 调用abort函数生成的信号，表示程序异常#define SIGIOT 6 // 同上，更全，IO异常也会发出#define SIGBUS 7 // 非法地址，包括内存地址对齐出错，比如访问一个4字节的整数, 但其地址不是4的倍数#define SIGFPE 8 // 计算错误，比如除0、溢出#define SIGKILL 9 // 强制结束程序，具有最高优先级，本信号不能被阻塞、处理和忽略#define SIGUSR1 10 // 未使用，保留#define SIGSEGV 11 // 非法内存操作，与SIGBUS不同，他是对合法地址的非法访问，比如访问没有读权限的内存，向没有写权限的地址写数据#define SIGUSR2 12 // 未使用，保留#define SIGPIPE 13 // 管道破裂，通常在进程间通信产生#define SIGALRM 14 // 定时信号,#define SIGTERM 15 // 结束程序，类似温和的SIGKILL，可被阻塞和处理。通常程序如果终止不了，才会尝试SIGKILL#define SIGSTKFLT 16 // 协处理器堆栈错误#define SIGCHLD 17 // 子进程结束时, 父进程会收到这个信号。#define SIGCONT 18 // 让一个停止的进程继续执行#define SIGSTOP 19 // 停止进程,本信号不能被阻塞,处理或忽略#define SIGTSTP 20 // 停止进程,但该信号可以被处理和忽略#define SIGTTIN 21 // 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号#define SIGTTOU 22 // 类似于SIGTTIN, 但在写终端时收到#define SIGURG 23 // 有紧急数据或out-of-band数据到达socket时产生#define SIGXCPU 24 // 超过CPU时间资源限制时发出#define SIGXFSZ 25 // 当进程企图扩大文件以至于超过文件大小资源限制#define SIGVTALRM 26 // 虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.#define SIGPROF 27 // 类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间#define SIGWINCH 28 // 窗口大小改变时发出#define SIGIO 29 // 文件描述符准备就绪, 可以开始进行输入/输出操作#define SIGPOLL SIGIO // 同上，别称#define SIGPWR 30 // 电源异常#define SIGSYS 31 // 非法的系统调用 tombstone 文件位于路径 &#x2F;data&#x2F;tombstones&#x2F;下 调用栈信息调用栈信息是分析程序崩溃的非常重要的一个信息，它主要记录了程序在 Crash 前的函数调用关系以及当前正在执行函数的信息，它对应的是我们tombstone文件中 backtrace 符号开始的信息，上面例子中的 backtrace 的信息如下所示 12345678910backtrace: #00 pc 00006639 /system/lib/libui.so (android::Fence::waitForever(char const*)+41) #01 pc 00034b86 /system/lib/libsurfaceflinger.so #02 pc 0003229e /system/lib/libsurfaceflinger.so #03 pc 0002cb9c /system/lib/libgui.so (android::BufferQueue::ProxyConsumerListener::onFrameAvailable(android::BufferItem const&amp;)+652) #04 pc 000342f4 /system/lib/libgui.so (android::BufferQueueProducer::queueBuffer(int, android::IGraphicBufferProducer::QueueBufferInput const&amp;, android::IGraphicBufferProducer::QueueBufferOutput*)+2580) ##00 等表示函数调用栈中栈帧的编号 pc 后面的16进制数表示当前函数正在执行语句在共享链接库或可执行文件的位置 最后一行表示当前指令在哪个文件 如何定位崩溃位置完整的so文件包含代码和一些debug信息，release版的so文件需要经过一个strip操作，debug信息会被剥离，整个so文件的大小会变小。要定位具体位置，则需要使用debug版本的so文件 常用工具nm12查看动态库的符号表nm -D libName.so addr2line用来分析单个pc地址对应的源码行数 12345678910111213141516171819Usage: /Users/loneqd/Android/sdk/ndk-bundle/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line [option(s)] [addr(s)] Convert addresses into line number/file name pairs. If no addresses are specified on the command line, they will be read from stdin The options are: @&lt;file&gt; Read options from &lt;file&gt; -a --addresses Show addresses -b --target=&lt;bfdname&gt; Set the binary file format -e --exe=&lt;executable&gt; Set the input file name (default is a.out) -i --inlines Unwind inlined functions -j --section=&lt;name&gt; Read section-relative offsets instead of addresses -p --pretty-print Make the output easier to read for humans -s --basenames Strip directory names -f --functions Show function names -C --demangle[=style] Demangle function names -h --help Display this information -v --version Display the program&#x27;s version实例：(需使用带symbol的动态库)addr2line -f -e libui.so 00006639 _ZN7android5Fence11waitForeverE ndk-stack将崩溃时的调用内存地址和C++代码对应起来 123456789101112131415usage: ndk-stack.py [-h] -sym SYMBOL_DIR [-i INPUT]Symbolizes Android crashes.optional arguments: -h, --help show this help message and exit -sym SYMBOL_DIR, --sym SYMBOL_DIR directory containing unstripped .so files -i INPUT, -dump INPUT, --dump INPUT input filenameSee &lt;https://developer.android.com/ndk/guides/ndk-stack&gt;.sym指项目编译成功之后，obj目录dump指崩溃文件 xCrash的使用 https://github.com/iqiyi/xCrash native异常日志文件的格式 12345678910111213日志分为： 头部信息（为应用的基本信息） 异常信号部分。（哪个异常信号导致异常，信号参见Linux信号） backtrace so库的编译信息，build id 堆栈信息 内存信息 内存映射 logcat日志输出部分，包括main,system,event app应用进程打开的文件描述符 内存信息 app应用进程信息 异常回调填充信息 一般根据backtrace，再使用addr2line命令定位具体的错误代码位置。 参考 http://gityuan.com/2016/06/25/android-native-crash/ https://toutiao.io/posts/jflx6c/preview https://source.android.google.cn/devices/tech/debug/native-crash?hl=zh-cn http://www.droidsec.cn/%E5%B8%B8%E8%A7%81android-native%E5%B4%A9%E6%BA%83%E5%8F%8A%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0/ https://github.com/iqiyi/xCrash https://source.android.com/devices/tech/debug xCrash日志文件格式 介绍addr2line调试命令","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"错误报告","date":"2024-02-12T02:23:36.667Z","path":"wiki/Android/性能优化/错误报告/","text":"获取错误报告 通过开启开发者选项，生成错误报告 通过adb命令获取：adb bugreport D:\\Reports 分析错误报告默认情况下，错误报告是 ZIP 文件。ZIP 文件名类似 bugreport-BUILD_ID-DATE.zip，它可能会包含多个文件，但最重要的文件是 bugreport-BUILD_ID-DATE.txt。此文件就是错误报告，它包含系统服务 (dumpsys)、错误日志 (dumpstate) 和系统消息日志 (logcat) 的诊断输出。系统消息包括设备抛出错误时的堆栈轨迹，以及从所有应用中使用 Log 类写入的消息 查看日志展示最近时间段内的日志 1234------ SYSTEM LOG (logcat -v threadtime -v printable -v uid -d *:v) ------------ LOG STATISTICS (logcat -b all -S) ------ ANR和死锁当某个应用在一定时间内没有响应（通常是由于主线程被阻塞或繁忙）时，系统会终止该进程并将堆栈转储到 &#x2F;data&#x2F;anr。要找出 ANR 背后的罪魁祸首，请为二进制事件日志中的 am_anr 执行 grep 命令 VM TRACES AT LAST ANR、VM TRACES JUST NOW部分查找堆栈跟踪。 WATCHDOG KILLING SYSTEM PROCESS 查找死锁 123grep &quot;am_anr&quot; bugreport-xxxx-xx-xx-xx-xx-xx.txt# 日志中搜索ANR关键字grep &quot;ANR&quot; bugreport-xxxx-xx-xx-xx-xx-xx.txt Activity活动 am_focused_activity 关键字搜索聚焦Activity Start proc关键字搜索进程启动事件 am_proc_died 和 am_proc_start 关键字搜索进程启动和终止事件 123456789# 查看处理聚焦的Activitygrep &quot;am_focused_activity&quot; bugreport-xxxx-xx-xx-xx-xx-xx.txt# 查看进程启动事件grep “Start proc” bugreport-xxxx-xx-xx-xx-xx-xx.txt# 要确定设备是否发生系统颠簸，请检查 am_proc_died 和 am_proc_start 前后在短时间内是否出现活动异常增加grep -e &quot;am_proc_died&quot; -e &quot;am_proc_start&quot; bugreport-xxxx-xx-xx-xx-xx-xx.txt 内存异常 内存不足可能会导致系统发生颠簸，这是因为虽然内存不足时系统会终止某些进程来释放内存，但又会继续启动其他进程。要查看内存不足的确凿证据，请检查二进制事件日志中 am_proc_died 和 am_proc_start 条目的密集程度. 关于系统颠簸（分页、直接回收等）的其他指标包括 kswapd、kworker 和 mmcqd 消耗的 CPU 周期。 am_low_memory 表示最后一个缓存的进程已终止 Total PSS by OOM adjustment 列出内存快照 12grep &quot;am_low_memory&quot; bugreport-xxxx-xx-xx-xx-xx-xx.txt 广播 Historical broadcasts summary显示广播的历史记录 ACTIVITY MANAGER BROADCAST STATE 查看广播监听器 进程 DUMP OF SERVICE procstats 部分包含有关进程及相关服务已运行时长的完整统计信息 ACTIVITY MANAGER RUNNING PROCESSES 列出部分正在运行的进程 参考 阅读错误报告","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"RxDart","date":"2024-02-12T02:23:36.667Z","path":"wiki/Flutter/Dart/RxDart/","text":"ReactX的dart实现，React X的原理可参考 Stream相关APICombineLatestStream（combine2，combine3…combine9）&#x2F;Rx.combineLatest2…Rx.combineLatest9 将多个流进行结合，可以定义自己的合并规则。 ConcatStream&#x2F;Rx.concat 按顺序一个个拼接起来 ConcatEagerStream&#x2F;Rx.concatEager与concat的区别 流订阅的顺序： concat：按照提供的顺序依次订阅流。它会等待每个流完成后再订阅下一个流。 concatEager：立即订阅所有的流，而不等待任何流完成。事件的发射顺序基于流的顺序。 流的完成： concat：等待每个流完成后再进行下一个流的订阅。只有当前流完成后，才会订阅下一个流。 concatEager：不等待任何流完成。它立即订阅所有的流，并在每个流的事件到达时进行发射。 事件的发射： concat：从第一个流开始发射事件，直到它完成，然后发射第二个流的事件，依此类推。 concatEager：无论任何流是否完成，都会发射所有流的事件。 总结起来，concat是一个顺序连接的操作符，在移动到下一个流之前等待每个流完成。而concatEager是一个急切连接的操作符，立即订阅所有的流，并在事件到达时发射它们，而不等待任何流完成。 以上是GPT的回答，并给出的具体例子，但结果却跟描述的不一样，不知道是不是dart的实现有问题，😳 12345678910Rx.concat([ Stream.fromFuture(Future.delayed(Duration(seconds: 2), () =&gt; &#x27;Stream 1&#x27;)), Stream.fromFuture(Future.delayed(Duration(seconds: 1), () =&gt; &#x27;Stream 2&#x27;)), ]).listen(print); // 预期输出：Stream 1，Stream 2 Rx.concatEager([ Stream.fromFuture(Future.delayed(Duration(seconds: 2), () =&gt; &#x27;Stream 1&#x27;)), Stream.fromFuture(Future.delayed(Duration(seconds: 1), () =&gt; &#x27;Stream 2&#x27;)), ]).listen(print); // 预期输出：Stream 2，Stream 1 DeferStream&#x2F;Rx.defer在被订阅时才创建和发射源流 123456final deferStream = DeferStream(() =&gt; Stream.fromIterable([1, 2, 3]));// 在这个时候，流还没有被创建print(&#x27;Before subscription&#x27;);deferStream.listen(print); // 输出：1, 2, 3// 当我们订阅流的时候，流才被创建并发射事件print(&#x27;After subscription&#x27;); ForkJoinStream(join2,join3…join9)&#x2F;Rx.forkJoin2…Rx.forkJoin9等待所有的输入流发射完毕，然后将每个输入流的最后一个元素组合成一个列表并发射出去。如果任何一个输入流没有发射元素，那么结果流也不会发射元素。如果任何一个输入流发生错误，那么结果流也会发生错误。 1234final streamA = Stream.fromIterable([1, 2, 3]).delay(Duration(seconds: 2));final streamB = Stream.fromIterable([4, 5, 6]).delay(Duration(seconds: 1));ForkJoinStream.list([streamA, streamB]).listen(print); // 输出：[3, 6] FromCallableStream&#x2F;Rx.fromCallable可以从一个可以调用的函数创建一个流。这个函数在流被订阅的时候调用，并且它的返回值会被发射出去。如果函数抛出一个错误，那么这个错误会被流捕获并发射出去。 12345final callable = () &#123; return &#x27;Hello, World!&#x27;;&#125;;final stream = FromCallableStream(callable);stream.listen(print); // 输出：Hello, World! MergeStream&#x2F;Rx.merge 同时订阅所有的输入流，并将所有流的事件按照它们到达的顺序发射出去 12345final streamA = Stream.fromIterable([1, 2, 3]).delay(Duration(seconds: 2));final streamB = Stream.fromIterable([4, 5, 6]).delay(Duration(seconds: 1));MergeStream([streamA, streamB]).listen(print); // 输出：4, 5, 6, 1, 2, 3 NeverStream&#x2F;Rx.never不会发射数据事件、错误事件或完成事件。它可以用于需要一个永远不会完成的流的场景。 RaceStream&#x2F;Rx.race 会同时订阅所有的输入流，但只会发射第一个发射事件的流的事件。一旦有一个流发射了事件，其他的流就会被忽略 123final streamA = Stream.fromIterable([1, 2, 3]).delay(Duration(seconds: 2));final streamB = Stream.fromIterable([4, 5, 6]).delay(Duration(seconds: 1));RaceStream([streamA, streamB]).listen(print); // 输出：4, 5, 6 RangeStream&#x2F;Rx.rangeRangeStream接受两个参数：范围的开始值和结束值。它会创建一个流，这个流会从开始值开始，一直到结束值结束，每次发射下一个整数。 1RangeStream(1, 3).listen(print); // 输出：1, 2, 3 RepeatStream&#x2F;Rx.repeatRepeatStream接受两个参数：一个返回流的函数和一个重复次数。它会创建一个新的流，这个流会重复发射源流的事件指定的次数。 12final stream = Stream.fromIterable([1, 2, 3]);RepeatStream(() =&gt; stream, 2).listen(print); // 输出：1, 2, 3, 1, 2, 3 RetryStream&#x2F;Rx.retryRetryStream接受两个参数：一个返回流的函数和一个重试次数。如果源流发射了一个错误事件，RetryStream会重新订阅源流，直到达到指定的重试次数。 RetryWhenStream&#x2F;Rx.retryWhenRetryStream接受两个参数：一个返回流的函数和一个重试次数。如果源流发射了一个错误事件，RetryStream会重新订阅源流，直到达到指定的重试次数 1234567891011int attempt = 0;final retryStream = RetryStream(() &#123; attempt++; print(&#x27;==&gt;&gt;$attempt&#x27;); if (attempt &lt; 3) &#123; return Stream&lt;int&gt;.error(Exception(&#x27;Error&#x27;)); &#125; else &#123; return Stream.fromIterable([1, 2, 3]); &#125;&#125;, 3);retryStream.listen(print, onError: (e) =&gt; print(&#x27;###&#x27;+e.toString())); // 输出：1, 2, 3 在这个示例中，我们创建了一个RetryStream，它会在源流发射错误事件时重新订阅源流。源流在前两次都会发射一个错误事件，但在第三次时会发射1, 2, 3。因此，当我们订阅RetryStream时，它会依次发射1, 2, 3。 SequenceEqualStream&#x2F;Rx.sequenceEqual SequenceEqualStream会同时订阅两个输入流，并比较它们发射的事件是否相同。如果两个流的事件完全相同（包括事件的顺序），那么结果流会发射一个true事件。否则，结果流会发射一个false事件 12345final streamA = Stream.fromIterable([1, 2, 3]);final streamB = Stream.fromIterable([1, 2, 3]);SequenceEqualStream(streamA, streamB).listen(print); // 输出：true SwitchLatestStream&#x2F;Rx.switchLatestSwitchLatestStream接受一个发射流的流作为输入，它会始终只订阅最新的流，并发射这个流的事件。当新的流到来时，它会取消订阅旧的流，并开始订阅新的流。 123456789101112final switchLatestStream = SwitchLatestStream&lt;String&gt;( Stream.fromIterable(&lt;Stream&lt;String&gt;&gt;[ Stream.value(&#x27;C&#x27;), Stream.value(&#x27;D&#x27;), Stream.value(&#x27;E&#x27;), Rx.timer(&#x27;A&#x27;, Duration(seconds: 1)), Stream.value(&#x27;F&#x27;), Rx.timer(&#x27;B&#x27;, Duration(seconds: 2)), ]),);switchLatestStream.listen(print);//Stream.value(&#x27;F&#x27;), Rx.timer(&#x27;B&#x27;, Duration(seconds: 2)),交换位置后的输出内容是什么呢？为什么？ TimerStream&#x2F;Rx.timerTimerStream接受两个参数：一个是要发射的值，另一个是延迟的时间。它会创建一个流，这个流会在指定的延迟后发射指定的值。 UsingStream&#x2F;Rx.usingZipStream(zip2,zip3…zip9)&#x2F;Rx.zip…Rx.zip9 ZipStream接受一个流的列表和一个函数作为参数。这个函数接受一个包含每个流最新事件的列表，并返回一个值。当任何一个流发射一个新的事件时，ZipStream都会调用这个函数，并发射函数返回的值。 操作符buffer、bufferTime、bufferTest、bufferCount 1234567891011121314151617Stream.periodic(Duration(milliseconds: 100), (i) =&gt; i) .buffer(Stream.periodic(Duration(milliseconds: 160), (i) =&gt; i)) .listen(print); // prints [0, 1] [2, 3] [4, 5] ...RangeStream(1, 4).bufferCount(2).listen(print); // prints [1, 2], [3, 4] done!//startBufferEvery 表示跳过几个元素开始新的bufferRangeStream(1, 5).bufferCount(3, 2).listen(print); // prints [1, 2, 3], [3, 4, 5], [5] done!Stream.periodic(Duration(milliseconds: 100), (int i) =&gt; i) .bufferTest((i) =&gt; i % 2 == 0) .listen(print); // prints [0], [1, 2] [3, 4] [5, 6] ...Stream.periodic(Duration(milliseconds: 100), (int i) =&gt; i) .bufferTime(Duration(milliseconds: 220)) .listen(print); // prints [0, 1] [2, 3] [4, 5] ... concatWith接受一个流的列表作为参数。当原始流完成时，concatWith会开始监听列表中的下一个流。这个过程会一直持续，直到所有的流都完成。 123456789TimerStream(1, Duration(seconds: 10)) .concatWith([Stream.fromIterable([2])]) .listen(print); // prints 1, 2Stream.fromIterable([1, 2, 3]) .concatWith([Stream.fromIterable([4, 5, 6])]) .listen(print); // prints 1, 2, 3, 4, 5, 6 debounce、debounceTime delay、delayWhen 延迟一段时间再发射 flatMap、flatMapIterable接受一个返回流的函数作为参数。这个函数接受源流的事件作为参数，并返回一个流。flatMap会将这个返回的流的所有事件合并到一个新的流中。flatMapIterable的转换函数返回一个可迭代对象（例如列表或集合），flatMapIterable会将这个返回的可迭代对象的所有元素合并到一个新的流中 12345678Stream.fromIterable([1, 2, 3]) .flatMap((i) =&gt; Stream.fromIterable([i, i * 2])) .listen(print); // prints 1, 2, 2, 4, 3, 6Stream.fromIterable([1, 2, 3]) .flatMapIterable((value) =&gt; [value, value * 2]) .listen(print); // prints 1, 2, 2, 4, 3, 6 mapTo转换成常量 123Stream.fromIterable([1, 2, 3, 4]) .mapTo(true) .listen(print); // prints true, true, true, true mergeWith将多个流按顺序按顺序按顺序合并成一个 123TimerStream(1, Duration(seconds: 10)) .mergeWith([Stream.fromIterable([2])]) .listen(print); // prints 2, 1 skipLast跳过最后n个元素 123Stream.fromIterable([1, 2, 3, 4, 5]) .skipLast(3) .listen(print); // prints 1, 2 takeLast、takeUntil、takeWhileInclusive取最后n个元素 123Stream.fromIterable([1, 2, 3, 4, 5]) .takeLast(3) .listen(print); // prints 3, 4, 5 window、windowTime、windowTest、windowCount window：它接受一个返回流的函数作为参数。每当这个函数返回的流发射事件时，window就会开始一个新的窗口，也就是一个新的流。源流的事件会被添加到当前的窗口中 windowTime：它接受一个Duration作为参数。每隔指定的时间，windowTime就会开始一个新的窗口。源流的事件会被添加到当前的窗口中 windowTest：它接受一个返回布尔值的函数作为参数。每当这个函数返回true时，windowTest就会开始一个新的窗口。源流的事件会被添加到当前的窗口中 windowCount：它接受一个整数作为参数。每当源流发射指定数量的事件时，windowCount就会开始一个新的窗口 123456789101112131415161718192021Stream.periodic(Duration(seconds: 1), (i) =&gt; i) .window(Stream.periodic(Duration(seconds: 5))) .asyncMap((stream) =&gt; stream.toList()) .listen(print); // prints [0, 1, 2, 3, 4], [5, 6, 7, 8, 9], ...Stream.periodic(Duration(seconds: 1), (i) =&gt; i) .windowTime(Duration(seconds: 5)) .asyncMap((stream) =&gt; stream.toList()) .listen(print); // prints [0, 1, 2, 3, 4], [5, 6, 7, 8, 9], ...Stream.periodic(Duration(seconds: 1), (i) =&gt; i) .windowTest((i) =&gt; i % 5 == 0) .asyncMap((stream) =&gt; stream.toList()) .listen(print); // prints [0, 1, 2, 3, 4], [5, 6, 7, 8, 9], ...Stream.periodic(Duration(seconds: 1), (i) =&gt; i) .windowCount(5) .asyncMap((stream) =&gt; stream.toList()) .listen(print); // prints [0, 1, 2, 3, 4], [5, 6, 7, 8, 9], ... zipWithzipWith接受两个参数：一个流和一个函数。这个函数接受两个参数：源流的事件和另一个流的事件，并返回一个新的事件。zipWith会将这个函数返回的新的事件发射出去 123 scan对 Stream 序列应用累加器函数并返回每个中间结果。 种子值用作初始累加器值。 123Stream.fromIterable([1, 2, 3]) .scan((acc, curr, i) =&gt; acc + curr, 0) .listen(print); // prints 1, 3, 6 参考 https://colinzuo.github.io/dddtdd-docs/docs/frontend/flutter/reference/packages/rxdart/","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"}]},{"title":"鸿蒙构建flutter项目","date":"2024-01-26T13:01:08.846Z","path":"wiki/技术开发/HuaWei/鸿蒙构建flutter项目/","text":"基础环境12345678910111213141516171819sudo apt install python3sudo apt install makesudo apt install pkg-configsudo apt install ninja-buildgit clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitexport PATH=&quot;$PATH:/home/ubuntu/work/depot_tools&quot;# nodejsexport NODE_HOME=/home/uname/HuaWei/flutter/node-v14.19.1-mac-x64export PATH=$NODE_HOME/bin:$PATH# gradleexport PATH=/Users/uname/HuaWei/flutter/gradle-7.1/bin:$PATH 构建flutter_engine clone源码https://gitee.com/openharmony-sig/flutter_engine 构建flutter_flutter 参考 Flutter Love 鸿蒙 https://gitee.com/openharmony-sig/flutter_engine https://gitee.com/openharmony-sig/flutter_flutter 每日构建地址","tags":[{"name":"HuaWei harmonyOS","slug":"HuaWei-harmonyOS","permalink":"http://airshu.github.io/tags/HuaWei-harmonyOS/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"HuaWei","slug":"技术开发/HuaWei","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/HuaWei/"}]},{"title":"Flutter静态代码检测","date":"2024-01-26T13:01:08.845Z","path":"wiki/Flutter/未分类/Flutter静态代码检测/","text":"代码检测是规范写法，提高质量的一种重要方案，几乎所有的主流语言都有相关方案。在Flutter开发过程中，我们可以使用IDE自带的Inspect Code功能，也可以直接使用命令行dart analyze 官方方案Flutter官方提供analyzer来检测代码 使用步骤 pubspec.yaml配置 123456dev_dependencies: lint: # dart lint flutter_lints: ^1.0.0 # flutter 代码检测工具 新建analysis_options.yaml配置文件，放在项目的根目录。 1234567891011121314151617181920212223242526272829# 使用 include: url 来从指定的 URL 引入选项 —— 在这种情况下，通常是引入来自 lints 包中的文件。由于 YAML 不支持多个重复的 key，你只能引入最多一个文件# 常用的#include: package:flutter_lints/flutter.yaml#include: package:pedantic/analysis_options.1.9.0.yamlinclude: package:lints/recommended.yaml# 使用 analyzer: 入口来自定义静态分析： 启用更严格的类型检查, 排除文件, 忽略特定规则, 改变规则的警告等级, or 开启实验性功能analyzer: exclude: # 不分析的文件和文件夹 - [build/**] - lib/*.g.dart language: # 启用更严格的类型检查 strict-casts: true # 类型推理引擎不再将 dynamic 进行隐式类型转换 strict-inference: true # 确保当类型推理引擎无法确定静态类型时，不再选择dynamic 类型 strict-raw-types: true # 确保当类型推理引擎，由于省略类型参数而无法确定静态类型时，不再选择dynamic 类型 errors: # 设置严重程度 invalide_assignment: warning missing_return: error dead_code: info strong-mode: # 强制模式 implicit-casts: false # 强制使用废弃的选项# 使用 linter: 入口来配置 linter 规则，可以单独启用或停用某条规则linter: rules: - cancel_subscriptions 执行命令 123# 分析项目命令# 分析从根目录开始遍历，发现analysis_options.yaml配置文件，则执行自定义静态代码分析，若没有则默认配置(https://github.com/flutter/flutter/blob/master/analysis_options.yaml)dart analyze 自定义规则123456789101112131415161718192021222324252627282930313233343536373839include: package:flutter_lints/flutter.yaml# 使用 analyzer: 入口来自定义静态分析： 启用更严格的类型检查, 排除文件, 忽略特定规则, 改变规则的警告等级, or 开启实验性功能analyzer: exclude: # 不分析的文件和文件夹 - [build/**] - lib/*.g.dart - build/** # 排除整个build文件夹 language: strict-casts: true strict-raw-types: true errors: # 设置严重程度 分为ignore、info、warning、error always_declare_return_types: warning # 方法必须声明返回类型 null_closures: warning # 不要给闭包的参数传null invalide_assignment: warning missing_return: error # 返回值缺失 unnecessary_statements: warning # 无效的表达式 prefer_typing_uninitialized_variables: warning # 未初始化的变量 dead_code: info prefer_interpolation_to_compose_strings: ignore # 字符串的写法，不要使用+拼接，使用引号 use_key_in_widget_constructors: error # Widget的构造方法中默认需要带上key control_flow_in_finally: error #不要在finally中使用控制流（break、continue、return），可能会造成难以发现的问题 no_logic_in_create_state: error # 不要在createState方法中使用任何逻辑 hash_and_equals: error # 重写==的同时要重写hashCode unrelated_type_equality_checks: error # 不相关的类型不要进行比较 always_use_package_imports: error # 使用包导入 avoid_print: error # 不使用print，可以用debugPrint、或者自己封装的log use_build_context_synchronously: error # 不要在异步操作后使用context，使用的话需要添加mounted判断 strong-mode: implicit-casts: false # 禁止隐式转换，可能会产生Null check异常，通常在Map&lt;String, dynamic&gt;取值、范型方法返回值的转换时易出现# 使用 linter: 入口来配置 linter 规则linter: rules: cancel_subscriptions: true # 新增规范 avoid_shadowing_type_parameters: false # 删除规范 使用sonarqubehttps://betterprogramming.pub/flutter-and-sonarqube-for-static-code-analysis-51368a85c51c 安装sonarqube后台服务本地安装sonar-scanner工具本地项目配置参考 自定义静态分析 官方默认规则 Linter for Dart flutter_lints","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"与JS通讯","date":"2024-01-26T13:01:08.845Z","path":"wiki/Flutter/未分类/与JS通讯/","text":"原生侧有许多库可以实现与JS直接通讯，而不需要使用webview容器。 V8、JSCore、Hermes、QuickJS，hybrid开发JS引擎怎么选","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"内存分析","date":"2024-01-26T13:01:08.844Z","path":"wiki/Flutter/内存分析/","text":"https://github.com/bladeofgod/memory_detector_of_kit https://github.com/dart-lang/leak_tracker https://docs.flutter.dev/tools/devtools/memory#basic-memory-concepts Flutter上的内存泄漏监控 Flutter内存泄漏检测 Flutter: Don’t Fear the Garbage Collector https://github.com/liujiakuoyx/leak_detector&#x2F;blob&#x2F;main&#x2F;README_zh-CN.md","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"flutter_redux","date":"2024-01-26T13:01:08.844Z","path":"wiki/Flutter/开源库/flutter_redux/","text":"使用 Redux 的好处是： 共享状态 单一数据 Redux 主要由三个部分组成： Action 用于定义数据变化的行为 Reducer 用于根据Action来产生新的状态，一般是一个方法 Store 用于存储和管理state 一般流程： Widget 绑定了 Store 中的 state 数据。 Widget 通过 Action 发布一个动作。 Reducer 根据 Action 更新 state。 更新 Store 中 state 绑定的 Widget。 参考 官网 Redux、主题、国际化 title: flutter_reduxtoc: truetags: Flutter","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"Kraken","date":"2024-01-26T13:01:08.844Z","path":"wiki/Flutter/动态化/Kraken/","text":"阿里出品 使用前端技术开发，Flutter渲染。 因为种种原因，Kraken不在维护，openwebf是其继任者。如何看待阿里北海Kraken项目即将弃坑？ 深入解析基于 Flutter 的 Web 渲染引擎「北海 Kraken 」技术原理 官方文档 https://github.com/openkraken/kraken","tags":[{"name":"Flutter 动态化","slug":"Flutter-动态化","permalink":"http://airshu.github.io/tags/Flutter-%E5%8A%A8%E6%80%81%E5%8C%96/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"动态化","slug":"Flutter/动态化","permalink":"http://airshu.github.io/categories/Flutter/%E5%8A%A8%E6%80%81%E5%8C%96/"}]},{"title":"dart_eval和flutter_eval","date":"2024-01-26T13:01:08.844Z","path":"wiki/Flutter/动态化/dart_eval和flutter_eval/","text":"dart_eval 是一种基于 Dart AOT 动态执行 Dart 代码的技术，能够实现动态化（CodePush），支持 Flutter。它包含编译器和解释器，均使用 Dart 语言编写，并支持可扩展（如扩展 Flutter 支持）。 dart_eval 由两个 Repo 构成： dart_eval：提供 dart 代码动态执行能力。https://github.com/ethanblake4/dart_eval flutter_eval：基于 dart_eval，扩展 Flutter 代码动态化执行能力。https://github.com/ethanblake4/flutter_eval 预埋位置 安装命令：dart pub global activate dart_eval，命令安装在$HOME&#x2F;.pub-cache&#x2F;bin&#x2F;目录 动态生成evc文件，dart_eval compile -o version_xxx.evc，上传服务器 参考《Dart eval：Compiler 类》、《Dart Analyzer：Declaration 实体》《Dart eval：BridgeDeclaration 实体类》《Dart eval：DeclarationOrBridge 实体类》《Dart eval：DartCompilationUnit 实体类》《Dart eval：Library 实体类》《Dart import 语法》《Dart Analyzer：ImportDirective 实体》《Dart eval：exportGraph 概念》《Dart eval：Program 类》《Dart eval：compile 系列方法的调用链》《Dart eval：Compiler populateLookupTablesForDeclaration》《Dart Analyzer：TopLevelVariableDeclaration》《Dart eval：compileIdentifierAsReference》《Dart eval：CompilerContext 编译器上下文》《Dart eval：compileIdentifier》《Dart Analyzer：Identifier》","tags":[{"name":"Flutter 动态化","slug":"Flutter-动态化","permalink":"http://airshu.github.io/tags/Flutter-%E5%8A%A8%E6%80%81%E5%8C%96/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"动态化","slug":"Flutter/动态化","permalink":"http://airshu.github.io/categories/Flutter/%E5%8A%A8%E6%80%81%E5%8C%96/"}]},{"title":"openwebf","date":"2024-01-26T13:01:08.844Z","path":"wiki/Flutter/动态化/openwebf/","text":"Kraken的替代品 Web端开发指导开发流程 使用Vue、React等进行开发 安装openwebf cli，https://github.com/openwebf/cli，运行命令webf http://localhost:8080/可以进行简单调试 参考 官方文档 https://github.com/openwebf/webf","tags":[{"name":"Flutter 动态化","slug":"Flutter-动态化","permalink":"http://airshu.github.io/tags/Flutter-%E5%8A%A8%E6%80%81%E5%8C%96/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"动态化","slug":"Flutter/动态化","permalink":"http://airshu.github.io/categories/Flutter/%E5%8A%A8%E6%80%81%E5%8C%96/"}]},{"title":"fair","date":"2024-01-26T13:01:08.844Z","path":"wiki/Flutter/动态化/fair/","text":"58同城的开源动态化方案，目前市面上比较完善的开源方案。 将build方法内的代码使用dart2dsl转化成json，将非build方法里的代码使用dart2js转化成js。 环境配置FlatBuffers将js转化成bin文件，好处是不用反序列化，大大提升Fair解析、加载资源的速度 faircli用来快捷创建动态化工程和载体工程 1234567# 安装 Faircli 命令行工具dart pub global activate faircli# 创建动态化工程faircli create -n dynamic_project_name# 创建载体工程faircli create -k carrier -n carrier_project_name 开发流程 pubspec.yaml中配置依赖 入口添加FairApp 1234567891011121314151617void main() &#123; // runApp(MyApp()); WidgetsFlutterBinding.ensureInitialized(); FairApp.runApplication( _getApp(), plugins: &#123;&#125;, );&#125;dynamic _getApp() =&gt; FairApp( modules: &#123;&#125;, delegate: &#123;&#125;, child: MyApp(),); 使用 @FairPatch() 注解标记需要动态化的 Widget 执行 build_runner 命令，编译生成下发产物 使用 FairWidget 加载 bundle 资源 教程FairBinding的作用在某个 Widget 中引用了另一个本地自定义的 Widget。对于这样的情况，我们需要使用 @FairBinding 注解，为本地 Widget 生成映射关系。 FairWell注解和FairDelegate问题 如何运行js代码的？ 参考 https://fair.58.com/zh/ Flutter 热更新 Fair 真.体验","tags":[{"name":"Flutter 动态化","slug":"Flutter-动态化","permalink":"http://airshu.github.io/tags/Flutter-%E5%8A%A8%E6%80%81%E5%8C%96/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"动态化","slug":"Flutter/动态化","permalink":"http://airshu.github.io/categories/Flutter/%E5%8A%A8%E6%80%81%E5%8C%96/"}]},{"title":"Flutter包体积优化","date":"2024-01-26T13:01:08.844Z","path":"wiki/Flutter/未分类/Flutter包体积优化/","text":"包的构成 主要组成部分： so库，包含第三方依赖，flutter打包后的libapp.so等 assets文件夹中的资源文件 dex文件 字体文件 resources.arsc文件 通过DevTool工具分析包体积生成包体积分析文件12345flutter build &lt;your target platform&gt; --analyze-size --target-platform=android-arm64A summary of your APK analysis can be found at: build/apk-code-size-analysis_01.json 分析 优化措施 图片压缩，可以使用tinypng工具进行压缩 使用相关编译参数 dwarf_stack_trace表示在生成的动态库文件中，不使用堆栈跟踪符号 obfuscate表示混淆，通过减少变量名&#x2F;方法名的方式减小代码体积 12345678//编译release包并打印sizeflutter build aot --release --extra-gen-snapshot-options=--print-snapshot-sizes//--dwarf_stack_traces， --&gt;减少6.2%大小flutter build aot --release --extra-gen-snapshot-options=&quot;--dwarf_stack_traces,--print-snapshot-sizes&quot;//--obsfuscation， --&gt;减少2.5%大小flutter build aot --release --extra-gen-snapshot-options=&quot;--dwarf_stack_traces,--print-snapshot-sizes,--obfuscate&quot;//总大小减少8.7% iOS中，删除dSYM符号表信息文件 12RunCommand xcrun dsymutil -o &quot;$&#123;build_dir&#125;/aot/App.dSYM&quot; &quot;$&#123;app_framework&#125;/App&quot;RunCommand xcrun strip -x -S &quot;$&#123;derived_dir&#125;/App.framework/App&quot; 排除没有使用的so库 gradle打包apk时排除指定的so文件 参考 Flutter瘦身大作战 https://flutter.cn/docs/tools/devtools/app-size Flutter包大小治理上的探索与实践","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"shorebird","date":"2024-01-26T13:01:08.844Z","path":"wiki/Flutter/动态化/shorebird/","text":"https://github.com/shorebirdtech/shorebird Flutter创始人之一打造，只支持Flutter侧的热更，patch包存放在google服务器，需要翻墙 [Flutter - 混编项目集成Shorebird热更新🐦（安卓篇）)][https://juejin.cn/post/7321049411852664882]研究基于 Flutter Shorebird 热更新支持中国区域的问题","tags":[{"name":"Flutter 动态化","slug":"Flutter-动态化","permalink":"http://airshu.github.io/tags/Flutter-%E5%8A%A8%E6%80%81%E5%8C%96/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"动态化","slug":"Flutter/动态化","permalink":"http://airshu.github.io/categories/Flutter/%E5%8A%A8%E6%80%81%E5%8C%96/"}]},{"title":"flutter_hooks","date":"2024-01-26T13:01:08.844Z","path":"wiki/Flutter/开源库/flutter_hooks/","text":"什么是Hook？Hooks 是来自 React 的一个概念，flutter_hooks 只是 React 实现到 Flutter 的一个端口。 https://zh-hans.legacy.reactjs.org/docs/hooks-intro.html flutter_hookshttps://github.com/rrousselGit/flutter_hooks&#x2F;blob&#x2F;master&#x2F;packages&#x2F;flutter_hooks&#x2F;resources&#x2F;translations&#x2F;zh_cn&#x2F;README.md React Hooks 的 Flutter 实现。 其触发UI刷新使用的是setState，可能存在性能问题。 常用hooksuseEffect 你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。 相当于 initState + didUpdateWidget + dispose。用于在组件挂载、更新、卸载时执行副作用。副作用可能是访问网络、访问本地存储、订阅事件等等。 12345678910111213141516171819202122232425262728293031import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_hooks/flutter_hooks.dart&#x27;;import &#x27;package:http/http.dart&#x27; as http;class NetworkRequest extends HookWidget &#123; @override Widget build(BuildContext context) &#123; final response = useState(&#x27;&#x27;); useEffect(() &#123; http.get(&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;).then((res) &#123; response.value = res.body; &#125;); return () &#123; // 在组件卸载时取消订阅 &#125;; &#125;, []); return Scaffold( appBar: AppBar( title: Text(&#x27;Network Request&#x27;), ), body: Center( child: Text(response.value), ), ); &#125;&#125; 在上面的例子中，我们使用 useEffect Hook 订阅了一个网络事件。useEffect 接收两个参数，第一个参数是副作用函数，第二个参数是依赖数组。当依赖数组中的某个值发生变化时，useEffect 将重新执行副作用函数。如果依赖数组为空，useEffect 将只在组件挂载和卸载时执行副作用函数。 useStreamuseStream 接收一个 Stream 对象作为参数，并返回一个包含 Stream 数据的变量。 12345678910111213141516171819202122import &#x27;dart:async&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_hooks/flutter_hooks.dart&#x27;;class StreamDemo extends HookWidget &#123; @override Widget build(BuildContext context) &#123; final stream = Stream.periodic(Duration(seconds: 1), (i) =&gt; i).take(10); final data = useStream(stream); return Scaffold( appBar: AppBar( title: Text(&#x27;Stream Demo&#x27;), ), body: Center( child: Text(data.toString()), ), ); &#125;&#125; useMemoized用于缓存计算结果，避免重复计算。在生命周期中只会被调用一次 123456789101112131415161718192021222324import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_hooks/flutter_hooks.dart&#x27;;class MemoizedDemo extends HookWidget &#123; @override Widget build(BuildContext context) &#123; final data = useMemoized(() =&gt; expensiveCalculation()); return Scaffold( appBar: AppBar( title: Text(&#x27;Memoized Demo&#x27;), ), body: Center( child: Text(data.toString()), ), ); &#125; int expensiveCalculation() &#123; return 1 + 2 + 3 + 4 + 5; &#125;&#125; 参考 Making Sense of React Hooks Flutter Hooks 使用及原理 掌握 Flutter 中的 Hooks🪝 https://github.com/rrousselGit/flutter_hooks&#x2F;blob&#x2F;master&#x2F;packages&#x2F;flutter_hooks&#x2F;resources&#x2F;translations&#x2F;zh_cn&#x2F;README.md","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"DevTools","date":"2024-01-26T13:01:08.843Z","path":"wiki/Flutter/DevTools/","text":"开发者工具介绍 Flutter Inspector：检查 Flutter 应用程序的 UI 组件布局和状态 Performance View：在 Flutter 应用程序中诊断 UI 性能过低的问题 CPU Profiler View：Flutter 和 Dart 应用的 CPU 性能检测 Network View：为 Flutter 应用进行网络性能检测 为 Flutter 或 Dart 应用进行源码级的调试 Memory View：在 Flutter 或 Dart 命令行应用中测试内存问题 Logging View：查看正在运行的 Flutter 或 Dart 的命令行应用程序相关的常规日志和诊断信息 App Size Tool：分析代码和应用的大小 Flutter inspector 工具 查看 widget 树，诊断布局问题 Select Widget Mode启动此按钮，可在应用中选中某个Widget进行查看。通过此工具可以快速定位UI的详细信息 Slow Animations以五分之一的速度运行动画以便对它们进行优化 Show Guidelines 显示引导线覆盖一层引导线以帮助调整布局问题 Show Baselines 显示基线针对文字对齐展示文字的基线。对检查文字是否对齐有帮助。 Highlight Repaints 高亮重绘区域该选项会为所有的 RenderBox 绘制一层边框，在它们重新绘制时改变颜色。重新绘制时在图层上依次显示不同的颜色。例如，一个小动画可能会导致整个页面一直在重绘。将动画使用RepaintBoundary widget嵌套，可以保证动画只会导致其本身重绘。 Highlight Oversized Images 高亮尺寸过大的图片在运行的应用程序中高亮并反转消耗过多内存的图像。 技巧 对于loading、toast这种动画UI，使用RepaintBoundary包裹 对于大尺寸的图片，使用cacheHeight、cacheWidth等属性进行优化 性能视图 (Performance view) Flutter 帧图表（仅 Flutter 应用） 帧分析标签页（仅 Flutter 应用） 光栅统计标签页（仅 Flutter 应用） 时间轴事件跟踪查看器（所有原生 Dart 应用） 高级调试工具（仅 Flutter 应用） Flutter 帧图表光栅统计标签页 Raster Stats如果帧的卡顿来自光栅线程，这个工具也许能够帮助你诊断性能缓慢的原因。生成光栅统计的步骤： 在应用程序中导航到你看见光栅线程卡顿的画面。 点击 Take Snapshot 生成快照。 查看不同图层和它们各自的渲染时间。 时间线事件表 Timeline Events时间线事件图表显示了应用程序的所有事件追踪。 Flutter 底层框架在构建帧、绘制场景和跟踪其他活动（如 HTTP 请求时间和垃圾回收）时，会发出时间线事件。这些事件会在时间线中显示出来。你也可以使用 dart:developer Timeline 和 TimelineTask API 发送你自己的时间线事件 增强的追踪选项 Enhance Tracing 你可以重复操作你想要追踪的行为来查看新的时间线事件，操作后可以在时间线中选择一个构建帧进行查看。 追踪 widget 的构建 Track Widget Builds想要在时间线中查看 build() 方法的事件，启用 Track Widget Builds 选项，时间线中将出现 widget 对应名称的事件。 追踪布局 Track Layouts想要在时间线中查看 RenderObject 布局构建的事件，启用 Track Layouts 选项： 追踪绘制 Track Paints想要在时间线中查看 RenderObject 的绘制事件，启用 Track Paints 选项： 更多调试选项 More debugging options想要诊断渲染图层相关的问题，请先关闭渲染层。下述的选项将会默认启动。 想要查看你的应用的性能影响，请尝试以相同的操作重现性能问题。在渲染层关闭的情况下，于构建帧图表里选择一个新的构建帧，查看它的时间线细节。如果光栅线程的时间消耗有显著降低，那么你禁用的效果的滥用可能是导致卡顿的主要原因。 渲染裁剪的图层 Render Clip layers禁用该选项来检查已使用的裁剪图层是否影响了性能。如果禁用后性能有显著提升，请尝试减少你的应用中裁剪效果的使用。 渲染透明度图层 Render Opacity layers禁用该选项来检查已使用的透明度图层是否影响了性能。如果禁用后性能有显著提升，请尝试减少你的应用中透明度效果的使用。 渲染物理形状图层 Render Physical Shape layers禁用该选项来检查已使用的物理形状图层是否影响了性能，例如阴影和背景特效。如果禁用后性能有显著提升，请尝试减少你的应用中物理效果的使用。 CPU探测视图 CPU profiler单击“Record”开始记录 CPU 剖析。 当完成录制后，单击“Stop”。 此时，CPU 分析数据将从 VM 中提取并显示在分析器视图中（Call tree, Bottom up, Method table, and Flame chart） Bottom Up此表提供了 CPU 配置文件的自下而上表示。 这意味着自下而上表中的每个顶级方法或根实际上是一个或多个 CPU 样本的调用堆栈中的顶级方法。 换句话说，自下而上的表中的每个顶级方法都是自上而下的表（调用树）的叶节点。 在此表中，可以展开方法以显示其调用者。 Total TimeSelf TimeMethodCall tree 调用树自上而下的调用展示 CPU Flame Chart CPU火焰图 火焰图是一种可视化工具，用于显示方法调用的时间分布。 矩形的宽度表示方法的执行时间。 矩形的颜色表示方法的深度，即方法调用堆栈的深度。上面调用下面的方法。 CPU sampling rate内存视图 Memory view Root object, retaining path, and reachabilityShallow size vs retained sizeDart中的内存泄漏技巧 小心闭包函数的使用 小心context的传递。如果闭包的生命周期在widget内，则可以传递 注意widget和state，state中不要引用widget中的context，widget是短生命的，而state是长生命的 参考 Flutter 调试工具篇 | 壹 - 使用 Flutter Inspector 分析界面 性能视图 https://flutter.cn/docs/tools/devtools/overview Flutter性能分析工具使用 Mastering Dart &amp; Flutter DevTools — Part 6: CPU Profiler View Mastering Dart &amp; Flutter DevTools — Part 7: Memory View Mastering Dart &amp; Flutter DevTools — Part 8: Performance View","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"Dart内存管理","date":"2024-01-26T13:01:08.842Z","path":"wiki/Flutter/Dart/Dart内存管理/","text":"Dart运行环境（VM）和Android Art一样，Flutter也对Dart源码做了AOT编译，直接将Dart源码编译成了本地字节码，没有了解释执行的过程，提升执行性能。这里重点关注Dart VM内存分配(Allocate)和回收(GC)相关的部分。 和Java显著不同的是Dart的”线程”(Isolate)是不共享内存的，各自的堆(Heap)和栈(Stack)都是隔离的，并且是各自独立GC的，彼此之间通过消息通道来通信。Dart天然不存在数据竞争和变量状态同步的问题，整个Flutter Framework Widget的渲染过程都运行在一个isolate中。 Dart VM将内存管理分为新生代(New Generation)和老年代(Old Generation)。 新生代(New Generation): 通常初次分配的对象都位于新生代中，该区域主要是存放内存较小并且生命周期较短的对象，比如局部变量。新生代会频繁执行内存回收(GC)，回收采用“复制-清除”算法，将内存分为两块(图中的from 和 to)，运行时每次只使用其中的一块(图中的from)，另一块备用(图中的to)。当发生GC时，将当前使用的内存块中存活的对象拷贝到备用内存块中，然后清除当前使用内存块，最后，交换两块内存的角色。 老年代(Old Generation): 在新生代的GC中“幸存”下来的对象，它们会被转移到老年代中。老年代存放生命力周期较长，内存较大的对象。老年代通常比新生代要大很多。老年代的GC回收采用“标记-清除”算法，分成标记和清除两个阶段。在标记阶段会触发停顿(stop the world)，多线程并发的完成对垃圾对象的标记，降低标记阶段耗时。在清理阶段，由GC线程负责清理回收对象，和应用线程同时执行，不影响应用运行。 内存管理算法GC(Garbage Collection)，垃圾回收机制，简单地说就是程序中及时处理废弃不用的内存对象的机制，防止内存中废弃对象堆积过多造成内存泄漏 常见的垃圾回收算法有引用计数法（Reference Counting）、标注并清理（Mark and Sweep GC）、拷贝（Copying GC）和逐代回收（Generational GC）等算法。 Flutter使用了原生对应的垃圾回收机制。 参考 Dart 内存管理机制","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"}]},{"title":"Dart资料收集","date":"2024-01-26T13:01:08.842Z","path":"wiki/Flutter/Dart/Dart资料收集/","text":"Dart Programming Language Specification 5th edition draftdart pragma注解 vm:entry-point","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"}]},{"title":"北京游玩攻略","date":"2024-01-07T08:50:41.259Z","path":"wiki/随笔/北京游玩攻略/","text":"很小的时候就希望能去北京看看，看看古时候皇帝生活的地方，看看为了抵御外敌而修建的万里长城，看看皇帝的陵墓。那就做一份北京游玩攻略吧。以下从游住吃三个方面来介绍。推荐自由行 门票预约!!!!!作为自由行，一定要提前预约门票，万一没约到门票，将会打乱所有计划。 北京各景区放票时间： 毛记：提前6天12:00 国博：提前7天17:00 故宫：提前7天20:00 天坛：提前6天21：00 颐和园：提前7天21:00 恭王府：提前10天20:00 圆明园：提前7天0:00 科技馆：提前7天0:00 自然博物馆：提前3天11:00 天文馆：提前3天18:00 升旗：提前9天00:00 天安门城楼：提前7天17:00 军事博物馆：早上8点 中午12点 下午17点 三个点放票 孔庙国子监：提前7天 清华北大 提前7天 预约之前，提前登记身份证信息，可以先提前在淡季的时间操作一遍。放票的时候，按照流程点击就好了。预约的时候如果界面卡住不动，不建议退回重进，重新的时候大概率预约不到了。 游景点介绍 故宫故宫是明清两代的皇宫，故宫占地面积72万平方米，建筑面积约15万平方米，共有殿宇9999间，是世界上现存规模最大、保存最为完整的木质结构古建筑之一。地址在东城区景山前街4号。详细的介绍可以参考官方公众号。 注意事项 注意周一不开关，门票分为上午和下午，可以提前七天预约，建议提早预约，热门景点门票很抢手。 北门后的景山公园是故宫的最佳观景点，可以看到故宫的全景。强烈推荐 建议游玩路线图游玩后感受故宫很大，皇家宫殿确实很气派，很多宫殿内部现在已经不允许进入了，有点可惜。珍宝馆一定要去，里面有很多珍贵的文物，很值得一看。建议带上中午的干粮，里面的餐厅的饭菜不好吃。建议找个导游或者租一个讲解器，建议花一整天时间游玩，上午9点入宫，上午把除了珍宝馆以外的宫殿逛一遍，中午吃完饭休息一会，再进去珍宝馆，然后北门出来直奔景山公园顶部，遥看整个皇城。 故宫内的一些如钟表馆等建议去看看，看看皇家的生活用品，还有一些古代的科技成果，很有意思。建议购买一个电子讲解器，可以听到很多故事，很有意思。了解一些历史故事，然后去看看，会有不一样的感受。 颐和园清朝帝王的行宫和花园，它以昆明湖、万寿山为基础，以杭州西湖为蓝本，汲取江南园林的设计手法而建成，被誉为“皇家园林博物馆”。以仁壽殿為中心的政治活動區；以玉瀾堂、樂壽堂為主體的帝后生活區；以長廊沿線、後山、西區為主的苑園遊覽區。万寿山、昆明湖、东宫门、十七孔桥、大戏楼。 建议游玩路线图 注意事项路线规划住有条件的尽量住离天安门近一点的地方，去哪里都比较方便。这次选择了五道口，距离想去的景点都比较方便，去八达岭、十三陵、故宫、颐和园都比较方便。去八达岭长城坐清河站高铁半小时，加上地铁时间一个小时就够了。也可以到十三陵地铁站。 吃北京是世界第八大“美食之城”，小吃历史悠久、品种繁多、用料讲究、制作精细，堪称有口皆碑。京味小吃的代表有豆汁儿、豆面酥糖、酸梅汤、茶汤、小窝头、茯苓夹饼、果脯蜜饯、冰糖葫芦、艾窝窝、豌豆黄、驴打滚、灌肠、爆肚、炒肝等。同时，北京也有不少老字号饭馆，涮羊肉、烤鸭、家常菜等等，种类丰富。 这次吃了方砖厂69号炸酱面、小吊梨汤、局气烤鸭、护国寺小吃。没有特别惊艳，可能南方人口味不同。需要注意的是如四季民福之类的店人气很旺，需要提前预约。要么一开始营业就在公众号上预约（到达一定数量之后只能现场排队），如果是现场预约，排队会很久。","tags":[{"name":"旅游","slug":"旅游","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"2023-2024年度总结","date":"2024-01-07T08:50:41.259Z","path":"wiki/随笔/2023-2024年度总结/","text":"时间过的真快啊，一年又要过完了。还是要记录一下这一年的成长和收获，以及对未来的展望。 今年的行情很不好，不管是就业还是A股市场。虽说疫情已经放开管控，可不见经济快速的复苏，身边讨论的更多的是裁员、领“大礼包”。年中，公司也经历了两次裁员，自己也在反思要保持什么样的状态才能在这个时代生存下去。 今年做了哪些事情呢？ 看电影目前为数不多的爱好了，应该有三十几部。 苏菲的抉择 剑雨 安阳婴儿 我身体里的那个家伙 看见恶魔 空中监狱 虎兄虎弟 正义回廊 芙蓉镇 暗杀 低俗小说 千钧一发 湄公河行动 出租车司机 唐人街探案 回到未来 教父2 不可饶恕 奇迹·笨小孩 风中有朵雨做的云 满江红 保你平安 特洛伊 宇宙探索编辑部 苦月亮 我爱你！ 非诚勿扰 扫毒 关于我和鬼变成家人的那件事 消失的她 军中乐园 盲井 过年 八角笼中 消失的情人节 踏血寻梅 无名 芳华 封神第一部：朝歌风云 灌篮高手 第八个嫌疑人 触不可及 投名状 花月杀手 看书 中国经济增长的真实逻辑 万历十五年 汽车是怎样跑起来的 转型中的地方政府 置身事内 权力结构、政治激励和经济增长 人类之旅 旅行今年去了涠洲岛、崇左、北京。终于去了心心念的北京。虽然是国庆去的，人很多，但体验还是深刻的，感受到了皇家的气派。24年准备去西站、洛阳，感受一下古都的魅力。 投资结果跟预期差距很大，今年是亏损的一年，当整个环境不好的时候，想从股市赚钱很难。24年改变一下策略，将一部分资金投入到美、港股中。 工作和学习好好工作，好好学习，好好生活。继续增强自己的技术水平。","tags":[{"name":"总结","slug":"总结","permalink":"http://airshu.github.io/tags/%E6%80%BB%E7%BB%93/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"如何客观的评估开发人员的绩效","date":"2024-01-07T08:50:41.259Z","path":"wiki/技术开发/技术管理/如何客观的评估开发人员的绩效/","text":"","tags":[{"name":"技术管理","slug":"技术管理","permalink":"http://airshu.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"技术管理","slug":"技术开发/技术管理","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}]},{"title":"flutter_sound","date":"2024-01-07T08:50:41.258Z","path":"wiki/Flutter/开源库/flutter_sound/","text":"Flutter中音频的处理库，可以用来播放、录制。播放支持主流的格式，支持网络地址。 播放音频1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#x27;package:flutter_sound/flutter_sound.dart&#x27;;import &#x27;package:xtechpark/ws_utils/ws_log/ws_logger.dart&#x27;;class WSAudioPlayer &#123; factory WSAudioPlayer() =&gt; _getInstance(); static WSAudioPlayer get instance =&gt; _getInstance(); static WSAudioPlayer? _instance; WSAudioPlayer._internal(); static WSAudioPlayer _getInstance() &#123; _instance ??= WSAudioPlayer._internal(); return _instance!; &#125; FlutterSoundPlayer? _player; Future init() async &#123; _player = FlutterSoundPlayer(); await _player?.openPlayer().then((value) &#123; WSLogger.debug(&#x27;WSAudioPlayer init &#x27;); &#125;); await _player?.setSubscriptionDuration(const Duration(milliseconds: 100)); _player?.onProgress?.listen((event) &#123; WSLogger.debug(&#x27;WSAudioPlayer onProgress $&#123;event.duration&#125;&#x27;); &#125;); &#125; Future play(String url, [Function()? onFinished]) async &#123; if (_player == null) &#123; await init(); &#125; if (_player?.playerState == PlayerState.isPlaying) &#123; await stop(); &#125; return _player?.startPlayer(fromURI: url, codec: Codec.mp3, whenFinished: onFinished); &#125; Future stop() async &#123; await _player?.stopPlayer(); &#125;&#125; 录制音频123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import &#x27;dart:io&#x27;;import &#x27;package:audio_session/audio_session.dart&#x27;;import &#x27;package:flutter/foundation.dart&#x27;;import &#x27;package:flutter_sound/flutter_sound.dart&#x27;;import &#x27;package:permission_handler/permission_handler.dart&#x27;;import &#x27;package:xtechpark/ws_utils/ws_file_util.dart&#x27;;import &#x27;package:xtechpark/ws_utils/ws_log/ws_logger.dart&#x27;;import &#x27;package:xtechpark/ws_utils/ws_toast_util.dart&#x27;;import &#x27;package:path_provider/path_provider.dart&#x27;;import &#x27;package:flutter_sound_platform_interface/flutter_sound_recorder_platform_interface.dart&#x27;;class WSAudioRecorder &#123; factory WSAudioRecorder() =&gt; _getInstance(); static WSAudioRecorder get instance =&gt; _getInstance(); static WSAudioRecorder? _instance; WSAudioRecorder._internal(); static WSAudioRecorder _getInstance() &#123; _instance ??= WSAudioRecorder._internal(); return _instance!; &#125; FlutterSoundRecorder? _recorder; final Codec _codec = Codec.aacADTS; String _mPath = &#x27;temp.aac&#x27;; /// 录音时长 Duration? duration; /// 初始化 Future init() async &#123; _recorder = FlutterSoundRecorder(); await openTheRecorder(); &#125; /// 释放 dispose() &#123; _recorder?.closeRecorder(); _recorder = null; &#125; /// 初始化配置 Future&lt;void&gt; openTheRecorder() async &#123; var status = await Permission.microphone.request(); if (status != PermissionStatus.granted) &#123; WSToastUtil.show(&#x27;Microphone permission not granted&#x27;); return; &#125; await _recorder?.openRecorder(); final session = await AudioSession.instance; await session.configure(AudioSessionConfiguration( avAudioSessionCategory: AVAudioSessionCategory.playAndRecord, avAudioSessionCategoryOptions: AVAudioSessionCategoryOptions.allowBluetooth | AVAudioSessionCategoryOptions.defaultToSpeaker, avAudioSessionMode: AVAudioSessionMode.spokenAudio, avAudioSessionRouteSharingPolicy: AVAudioSessionRouteSharingPolicy.defaultPolicy, avAudioSessionSetActiveOptions: AVAudioSessionSetActiveOptions.none, androidAudioAttributes: const AndroidAudioAttributes( contentType: AndroidAudioContentType.speech, flags: AndroidAudioFlags.none, usage: AndroidAudioUsage.voiceCommunication, ), androidAudioFocusGainType: AndroidAudioFocusGainType.gain, androidWillPauseWhenDucked: true, )); _recorder?.dispositionStream()?.listen((event) &#123; WSLogger.debug(&#x27;debug dispositionStream：$event&#x27;); &#125;); _recorder?.setSubscriptionDuration(const Duration(milliseconds: 100)); _recorder?.onProgress?.listen((e) &#123; WSLogger.debug(&quot;debug onProgress：$&#123;e.decibels&#125; / $&#123;e.duration&#125;&quot;); duration = e.duration; &#125;); // _mRecorderIsInited = true; &#125; void startRecord() async &#123; if(_recorder == null) &#123; await init(); &#125; if(_recorder?.recorderState == RecorderState.isRecording) &#123; await _recorder?.stopRecorder(); return; &#125; WSLogger.debug(&quot;debug startRecord&quot;); var status = await Permission.microphone.request(); if (status != PermissionStatus.granted) &#123; WSToastUtil.show(&quot;Microphone permission not granted&quot;); &#125; else &#123; Directory tempDir = await getTemporaryDirectory(); _mPath = &quot;$&#123;tempDir.path&#125;/$&#123;DateTime.now().millisecondsSinceEpoch&#125;.aac&quot;; _recorder?.startRecorder( toFile: _mPath, codec: _codec, audioSource: AudioSource.microphone, ); WSLogger.debug(&quot;debug recording&quot;); &#125; &#125; /// 停止录音 void stopRecord(Function(String path, int duration) finished) async &#123; String? path = await _recorder?.stopRecorder(); if (path == null) &#123; WSToastUtil.show(&#x27;record failed&#x27;); WSLogger.error(&#x27;record failed $&#123;_recorder?.recorderState&#125;&#x27;); return; &#125; if(!await WSFileUtil.isFileExists(path)) &#123; WSToastUtil.show(&#x27;record failed&#x27;); return; &#125; if(duration != null &amp;&amp; duration!.inSeconds &lt; 1) &#123; WSToastUtil.show(&#x27;recording can\\&#x27;t be less than 1 second&#x27;); return; &#125; WSLogger.debug(&quot;Stop recording: path = $path，duration = $&#123;duration?.inSeconds&#125;&quot;); if (TargetPlatform.android == defaultTargetPlatform) &#123; path = &quot;file://$path&quot;; &#125; finished(path, duration?.inSeconds ?? 0); &#125;&#125; 参考 https://pub.dev/packages/flutter_sound","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"in_app_purchase苹果内购","date":"2024-01-07T08:50:41.258Z","path":"wiki/Flutter/开源库/in_app_purchase/","text":"使用in_app_purchase这个库 流程1. 修改XCode配置文件，支持内购 2. 项目中添加in_app_purchase配置1234567dependencies: flutter: sdk: flutter in_app_purchase: in_app_purchase_storekit: 3. 编写内购代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158class ShopPayUtil &#123; static ShopPayUtil? _instance; static ShopPayUtil getInstance() &#123; _instance ??= ShopPayUtil._internal(); return _instance!; &#125; ShopPayUtil._internal(); factory ShopPayUtil() =&gt; getInstance();///购买商品 void buy(GoodsModel item) async &#123; try &#123; EasyLoading.show(); // 根据商品信息创建订单 var res = await rechargeCreate(item.code!); if(res != null) &#123; // 调用苹果内购 await applePay(res); &#125; &#125; catch (e, s) &#123; Logger.error(&#x27;$e $s&#x27;); &#125; finally &#123; EasyLoading.dismiss(); &#125; &#125; /// 创建充值订单 Future&lt;dynamic&gt; rechargeCreate(String goodsCode) async &#123; // todo 调用服务器接口 &#125; /// 验单 static Future paymentIpa(String orderNo, String payload, String transactionId) async &#123; // todo 检查订单准确性 &#125; /// 消耗虚拟币 Future reviewModeConsume(String outlay) async &#123; // todo 调用后台接口 &#125; static StreamSubscription&lt;List&lt;PurchaseDetails&gt;&gt;? _subscription; /// 苹果内购 (购买) static Future&lt;void&gt; applePay(Map dataMap) async &#123; final Stream&lt;List&lt;PurchaseDetails&gt;&gt; purchaseUpdated = InAppPurchase.instance.purchaseStream; _subscription?.cancel(); // 添加监听器 _subscription = purchaseUpdated.listen((List&lt;PurchaseDetails&gt; purchaseDetailsList) &#123; _listenToPurchaseUpdated(purchaseDetailsList, dataMap); &#125;, onDone: () &#123; _subscription?.cancel(); Logger.debug(&#x27;=applePay=====onDone&#x27;); &#125;, onError: (Object error) &#123; Logger.error(error); ToastUtil.show(error.toString()); &#125;); final bool isAvailable = await InAppPurchase.instance.isAvailable(); // 判断是否可用 if (!isAvailable) &#123; ToastUtil.show(&#x27;The store cannot be reached, check your network connection please.&#x27;); return; &#125; if (Platform.isIOS) &#123; final InAppPurchaseStoreKitPlatformAddition iosPlatformAddition = InAppPurchase.instance.getPlatformAddition&lt;InAppPurchaseStoreKitPlatformAddition&gt;(); await iosPlatformAddition.setDelegate(PaymentQueueDelegate()); &#125; Set&lt;String&gt; ids = &#123;dataMap[&#x27;goodsCode&#x27;]&#125;; // 查询商品的信息（需要先在苹果后台配置） final ProductDetailsResponse productDetailResponse = await InAppPurchase.instance.queryProductDetails(ids); if (productDetailResponse.error != null) &#123; WSToastUtil.show(&#x27;Failed to obtain product information.&#x27;); return; &#125; if (productDetailResponse.productDetails.isEmpty) &#123; ToastUtil.show(&#x27;No product&#x27;); return; &#125; List&lt;ProductDetails&gt; _products = productDetailResponse.productDetails; // 查询成功 ProductDetails productDetails = _products[0]; PurchaseParam purchaseParam = PurchaseParam( productDetails: productDetails, applicationUserName: &#x27;$&#123;dataMap[&#x27;orderNo&#x27;]&#125;&#x27;, ); //向苹果服务器发起支付请求 var res = await InAppPurchase.instance.buyConsumable(purchaseParam: purchaseParam); Logger.debug(&#x27;buyConsumable result: $res&#x27;); &#125; static Future&lt;void&gt; _listenToPurchaseUpdated(List&lt;PurchaseDetails&gt; purchaseDetailsList, Map dataMap) async &#123; Logger.debug(&#x27;===&gt;&gt;&gt;_listenToPurchaseUpdated callback&#x27;); for (final PurchaseDetails purchaseDetails in purchaseDetailsList) &#123; Logger.debug( &#x27;===&gt;&gt;&gt;_listenToPurchaseUpdated status=$&#123;purchaseDetails.status&#125; productID=$&#123;purchaseDetails.productID&#125; &#x27; &#x27;transactionDate=$&#123;purchaseDetails.transactionDate&#125;&#x27; &#x27;purchaseID=$&#123;purchaseDetails.purchaseID&#125; transactionDate=$&#123;purchaseDetails.transactionDate&#125;&#x27; &#x27;verificationData.localVerificationData=$&#123;purchaseDetails.verificationData.localVerificationData&#125;&#x27; &#x27;verificationData.serverVerificationData=$&#123;purchaseDetails.verificationData.serverVerificationData&#125;&#x27; &#x27;verificationData.source=$&#123;purchaseDetails.verificationData.source&#125;&#x27;); if (purchaseDetails.status == PurchaseStatus.pending) &#123; /// 等待购买中 &#125; else if (purchaseDetails.status == PurchaseStatus.canceled) &#123; /// 取消订单 InAppPurchase.instance.completePurchase(purchaseDetails); &#125; else &#123; if (purchaseDetails.status == PurchaseStatus.error) &#123; /// 购买出错 WSToastUtil.show(&#x27;Purchase error&#x27;); InAppPurchase.instance.completePurchase(purchaseDetails); &#125; else if (purchaseDetails.status == PurchaseStatus.purchased || purchaseDetails.status == PurchaseStatus.restored) &#123; if (purchaseDetails.pendingCompletePurchase) &#123; await InAppPurchase.instance.completePurchase(purchaseDetails); &#125; if (purchaseDetails.productID == dataMap[&#x27;goodsCode&#x27;]) &#123; // 支付成功，发放商品 await deliverProduct(purchaseDetails, dataMap); &#125; &#125; &#125; &#125; &#125; /// 调用后台接口,发放商品 static Future&lt;void&gt; deliverProduct(PurchaseDetails purchaseDetails, Map dataMap) async &#123; String code = dataMap[&#x27;goodsCode&#x27;]; String payload = purchaseDetails.verificationData.serverVerificationData; String transactionId = purchaseDetails.purchaseID!; var res = await paymentIpa(dataMap[&#x27;orderNo&#x27;], payload, transactionId); // todo 调用后台接口 &#125;&#125;class PaymentQueueDelegate implements SKPaymentQueueDelegateWrapper &#123; @override bool shouldContinueTransaction(SKPaymentTransactionWrapper transaction, SKStorefrontWrapper storefront) &#123; return true; &#125; @override bool shouldShowPriceConsent() &#123; return false; &#125;&#125; 参考 https://pub.dev/packages/in_app_purchase","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"空安全","date":"2024-01-07T08:50:41.257Z","path":"wiki/Flutter/Dart/空安全/","text":"概述为什么需要空安全？ 当你选择使用空安全时，代码中的类型将默认是非空的，意味着除非你声明它们可空，它们的值都不能为空。有了空安全，原本处于你的 运行时 的空值引用错误将变为 编辑时 的分析错误。这样可以大大降低空指针问题。 比如以下代码，string参数可能会报NoSuchMethodError异常。 1234567// Without null safety:bool isEmpty(String string) =&gt; string.length == 0;main() &#123; isEmpty(null);&#125; 健全的空安全已在 Dart 2.12 和 Flutter 2 中可用。 深入理解空安全类型系统中的可空性静态类型系统中，你的Dart程序包含了整个类型世界：基本类型（如 int 和 String）、集合类型（如 List）以及你和你所使用的依赖所定义的类和类型。在空安全推出之前，静态类型系统允许所有类型的表达式中的每一处都可以有 null。 从类型理论的角度来说，Null 类型被看作是所有类型的子类； 类型会定义一些操作对象，包括 getters、setters、方法和操作符，在表达式中使用。如果是 List 类型，你可以对其调用 .add() 或 []。如果是 int 类型，你可以对其调用 +。但是 null 值并没有它们定义的任何一个方法。所以当 null 传递至其他类型的表达式时，任何操作都有可能失败。这就是空引用的症结所在——所有错误都来源于尝试在 null 上查找一个不存在的方法或属性。 非空和可空类型空安全通过修改了类型的层级结构，从根源上解决了这个问题。 Null 类型仍然存在，但它不再是所有类型的子类。现在的类型层级看起来是这样的： 既然 Null 已不再被看作所有类型的子类，那么除了特殊的 Null 类型允许传递 null 值，其他类型均不允许。我们已经将所有的类型设置为 默认不可空 的类型。如果你的变量是 String 类型，它必须包含 一个字符串。这样一来，我们就修复了所有的空引用错误。 使用可空类型Dart在实现空安全之前，是存在隐式转换的。为了保持健全性，编译器为 requireStringNotObject() 的参数静默添加了 as String 强制转换。 12345678910// Without null safety:requireStringNotObject(String definitelyString) &#123; print(definitelyString.length);&#125;main() &#123; Object maybeString = &#x27;it is&#x27;; requireStringNotObject(maybeString);&#125; 确保正确性无效的返回值12345// Without null safety:String missingReturn() &#123; // No return.&#125; 在空安全以前，Dart会隐式的返回一个null。 未初始化的变量 顶层变量和静态字段必须包含一个初始化方法。 由于它们能在程序里的任何位置被访问到，编译器无法保证它们在被使用前已被赋值。唯一保险的选项是要求其本身包含初始化表达式，以确保产生匹配的类型的值。 123456789// Using null safety:int topLevel = 0;class SomeClass &#123; static int staticField = 0;&#125; 实例的字段也必须在声明时包含初始化方法，可以为常见初始化形式，也可以在实例的构造方法中进行初始化。 这类初始化非常常见。举个例子： 12345678910111213// Using null safety:class SomeClass &#123; int atDeclaration = 0; int initializingFormal; int initializationList; SomeClass(this.initializingFormal) : initializationList = 0;&#125; 局部变量的灵活度最高。一个非空的变量 不一定需要 一个初始化方法。这里有个很好的例子： 12345678910111213141516// Using null safety:int tracingFibonacci(int n) &#123; int result; if (n &lt; 2) &#123; result = n; &#125; else &#123; result = tracingFibonacci(n - 2) + tracingFibonacci(n - 1); &#125; print(result); return result;&#125; 此处遵循的规则是局部变量必须确保在使用前被赋值。 可选参数必须具有默认值。 如果一个可选位置参数或可选命名参数没有传递内容，Dart 会自动使用默认值进行填充。在未指定默认值的情况下，默认的 默认值为 null，如此一来，非空类型的参数就要出事了。 与可空类型共舞智能的非空判断方法123456789101112131415161718// Using null safety:showGizmo(Thing? thing) &#123;//doohickey后面可以不用?符号。//Dart从 C# 相同功能的设计中借鉴了一个聪明的处理方法。当你在链式方法调用中使用避空运算符时，如果接收器被判断为 null，那么 整个链式调用的剩余部分都会被截断并跳过。 print(thing?.doohickey.gizmo);&#125;// Null-aware cascade:receiver?..method();// Null-aware index operator:receiver?[index];function?.call(arg1, arg2); 空值断言操作符有时候操作可空变量的某个属性，当变量为空，则会抛出异常。代码是通不过lint检测的，这个时候需要使用空值断言操作符，当出现异常会抛出。 123456// Using null safety:String toString() &#123; if (code == 200) return &#x27;OK&#x27;; return &#x27;ERROR $code $&#123;error!.toUpperCase()&#125;&#x27;;//使用!转换成非空&#125; 懒加载的变量late关键字是“在运行时而非编译时对变量进行约束”。这就让 late 这个词语约等于 何时 执行对变量的强制约束。 12345678910// Using null safety:class Coffee &#123; late String _temperature; void heat() &#123; _temperature = &#x27;hot&#x27;; &#125; void chill() &#123; _temperature = &#x27;iced&#x27;; &#125; String serve() =&gt; _temperature + &#x27; coffee&#x27;;&#125; 当前场景里，字段并不一定已经被初始化，每次它被读取时，都会插入一个运行时的检查，以确保它已经被赋值。如果并未赋值，就会抛出一个异常。给一个变量加上 String 类型就是在说：“我的值绝对是字符串”，而加上 late 修饰符意味着：“每次运行都要检查检查是不是真的”。 延迟初始化1234567// Using null safety:class Weather &#123; late int _temperature = _readThermometer();&#125; 当你这么声明时，会让初始化 延迟 执行。实例的构造将会延迟到字段首次被访问时执行，而不是在实例构造时就初始化。换句话说，它让字段的初始化方式变得与顶层变量和静态字段完全一致。当初始化表达式比较消耗性能，并且有可能不需要时，这会变得非常有用。 延迟的终值12345678910// Using null safety:class Coffee &#123; late final String _temperature; void heat() &#123; _temperature = &#x27;hot&#x27;; &#125; void chill() &#123; _temperature = &#x27;iced&#x27;; &#125; String serve() =&gt; _temperature + &#x27; coffee&#x27;;&#125; 与普通的 final 字段不同，你不需要在声明或构造时就将其初始化。你可以稍后在运行中的某个地方加载它。但是你只能对其进行 一次 赋值，并且它在运行时会进行校验。如果你尝试对它进行多次赋值，比如 heat() 和 chill() 都调用，那么第二次的赋值会抛出异常。这是确定字段状态的好方法，它最终会被初始化，并且在初始化后是无法改变的。 换句话说，新的 late 修饰符与 Dart 的其他变量修饰符结合后，已经实现了 Kotlin 中的 lateinit 和 Swift 中的 lazy 的大量特性。如果你需要给局部变量加上一些延迟初始化，你也可以在局部变量上使用它。 必需的命名参数12//这里的所有参数都必须通过命名来传递。参数 a 和 c 是可选的，可以省略。参数 b 和 d 是必需的，调用时必须传递。在这里请注意，是否必需和是否可空无关。function(&#123;int? a, required int? b, int? c, required int? d&#125;) &#123;&#125; 总结 类型默认是非空的，可以添加 ? 变为可空的。 可选参数必须是可空的或者包含默认值的。你可以使用 required 来构建一个非可选命名参数。非空的全局变量和静态字段必须在声明时被初始化。实例的非空字段必须在构造体开始执行前被初始化。 如果接收者为 null，那么在其避空运算符之后的链式方法调用都会被截断。我们引入了新的空判断级联操作符 (?..) 及索引操作符 (?[])。后缀空断言“重点”操作符 (!) 可以将可空的操作对象转换为对应的非空类型。 新的流程分析，让你更安全地将可空的局部变量和参数，转变为可用的非空类型。它同时还对类型提升、遗漏的返回、不可达的代码以及变量的初始化，有着更为智能的规则。 late 修饰符以在运行时每次都进行检查的高昂代价，让你在一些原本无法使用的地方，能够使用非空类型和 final。它同时提供了对字段延迟初始化的支持。 List 类现在不再允许包含未初始化的元素。 参考 空安全官方文档 Null safety codelab 迁移至空安全","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"}]},{"title":"isolate","date":"2024-01-07T08:50:41.257Z","path":"wiki/Flutter/Dart/异步编程/isolate/","text":"定义isolate是Dart对actor并发模式的实现。运行中的Dart程序由一个或多个actor组成，这些actor也就是Dart概念里面的isolate。isolate是有自己的内存和单线程控制的运行实体。isolate本身的意思是“隔离”，因为isolate之间的内存在逻辑上是隔离的。isolate中的代码是按顺序执行的，任何Dart程序的并发都是运行多个isolate的结果。因为Dart没有共享内存的并发，没有竞争的可能性所以不需要锁，也就不用担心死锁的问题。 由于isolate之间没有共享内存，所以他们之间的通信唯一方式只能是通过Port进行，而且Dart中的消息传递总是异步的。 isolate跟线程类似，但线程之间可以共享内存，isolate不可以。 原理 初始化isolate数据结构 初始化堆内存(Heap) 进入新创建的isolate，使用跟isolate一对一的线程运行isolate 配置Port 配置消息处理机制(Message Handler) 配置Debugger，如果有必要的话 将isolate注册到全局监控器（Monitor） 12345isolate.cc 实例参考 Dart 异步编程：隔离区和事件循环 聊一聊Flutter线程管理与Dart Isolate机制","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"异步编程","slug":"Flutter/Dart/异步编程","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"}]},{"title":"dart命令行工具","date":"2024-01-07T08:50:41.256Z","path":"wiki/Flutter/Dart/dart命令行工具/","text":"dart analyze 命令代码分析工具 1234567# 设置分析等级 --no-fatal-warningsdart analyze --fatal-infos# 指定目录或文件dart analyze [&lt;DIRECTORY&gt; | &lt;DART_FILE&gt;] dart compile 命令编译dart文件 子命令 exe: 编译成可执行文件 aot-snapshot：编译成AOT快照 jit-snapshot：编译成JIT快照 kernel：编译成kernel文件 js：编译成js文件 12345dart compile exe main.dart -o main.exe# 查看子命令用法dart compile exe --help dart create 命令创建Dart项目，通过-t参数设置不同的项目模版 模版类型 cli console package server-shelf web dart doc 命令生成文档 dart fix 命令查找和修复代码中的问题 1234567891011121314# 预览建议的修改dart fix --dry-run# 应用建议的修改dart fix --applydart fix --apply --code annotate_overrides dart fix --apply --code prefer_const_constructors dart fix --apply --code prefer_const_declarations dart fix --apply --code unnecessary_brace_in_string_interps dart fix --apply --code unnecessary_cast dart fix --apply --code unused_import dart format 命令格式化代码 123456# 设置目录dart format .# 下面的命令将会对 lib 目录中的所有 Dart 文件，以及一个 bin 目录下的 Dart 文件进行格式整理dart format lib bin/updater.dart dart pub 命令管理依赖 子命令 add: cache: 管理本地缓存 deps: 显示当前Package使用的所有依赖项 downgrade: 检索当前Package所依赖的其他Package的最低版本 get: 用于检索当前 Package 所依赖的其它 Package。如果 pubspec.lock 文件已经存在，则根据该文件中保存的依赖项版本获取对应的依赖项。如有必要，将会创建或更新该文件。 global: outdated: 查看当前软件包所依赖的每个 package，确定哪些 package 的依赖项已过时，并为您提供有关如何更新它们的建议。当您要更新 package 的依赖性时，请使用此命令。 publish: remove: token: upgrade: 用于检索当前 Package 所依赖的其它 Package 的最新版本。如果 pubspec.lock 文件已经存在，则忽略其保存的版本并以 pubspec 文件中指定的最新版本为主。如有必要，将会创建或更新该文件。 dart run 命令12345678910dart run [options] [&lt;DART_FILE&gt; | &lt;PACKAGE_TARGET&gt;] [args]# 运行一个Dart程序dart run tool/debug.dart# 启动断言dart run --enable-asserts tool/debug.dart# 使用开发者工具来调试和性能分析dart run --observe tool/debug.dart dart test 命令运行测试脚本 build runner 命令build_runner 的命令需要与使用 Dart 编译系统 从输入文件生成输出文件的生成器 Package 配合使用。例如，json_serializable 与 built_value_generator 这两个 Package 共同定义了生成 Dart 代码的生成器。 123456dart run build_runner builddart packages pub run build_runner build --delete-conflicting-outputs","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"}]},{"title":"TypeScript入门","date":"2023-12-24T13:26:24.687Z","path":"wiki/JavaScript/TypeScript学习笔记/","text":"约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。 123456#全局安装typescriptnpm install -g typescript#编译tsc xxx.ts#运行node xxx.js 基础原始数据类型JavaScript的类型分为： 原始数据类型：布尔值、数值、字符串、null、undeined、Symbol、BigInt 对象类型 接口 数组 1234567891011121314151617181920### 接口// 接口类型interface Person &#123; name: string; age?: number; //?表示可选属性 readonly id: number; //只读属性 [propName: string]: any; //任意属性&#125;let tom: Person = &#123; id: 89757, name: &#x27;Tom&#x27;, age: 25, gender: &#x27;male&#x27;&#125;; 声明文件声明文件必需以 .d.ts 为后缀。 库的使用场景主要有以下几种： 全局变量：通过 标签引入第三方库，注入全局变量 npm 包：通过 import foo from 'foo' 导入，符合 ES6 模块规范 UMD 库：既可以通过 标签引入，又可以通过 import 导入 直接扩展全局变量：通过 标签引入后，改变一个全局变量的结构 在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构 模块插件：通过 或 import 导入后，改变另一个模块的结构 在 ES6 模块系统中，使用 export default 可以导出一个默认值，使用方可以用 import foo from 'foo' 而不是 import { foo } from 'foo' 来导入这个默认值 注意，只有 function、class 和 interface 可以直接默认导出，其他的变量需要先定义出来，再默认导出 1234567891011121314declare var 声明全局变量declare function 声明全局方法declare class 声明全局类declare enum 声明全局枚举类型declare namespace 声明（含有子属性的）全局对象interface 和 type 声明全局类型export 导出变量export namespace 导出（含有子属性的）对象export default ES6 默认导出export = commonjs 导出模块export as namespace UMD 库声明全局变量declare global 扩展全局变量declare module 扩展模块/// &lt;reference /&gt; 三斜线指令 import中@的作用路径映射，可以在tsconfig.json中配置 12345678&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@nui/*&quot;: [&quot;src/*&quot;] &#125; &#125;&#125; 使用 123import &#123; YYYY &#125; from &#x27;@nui/xxx&#x27;; 扩展全局变量的类型1234567891011interface String &#123; // 这里是扩展，不是覆盖，所以放心使用 double(): string;&#125;String.prototype.double = function () &#123; return this + &#x27;+&#x27; + this;&#125;;console.log(&#x27;hello&#x27;.double()); 参考 官方手册 阮一峰TypeScript教程 TypeScript 入门教程","tags":[{"name":"TypeScript JavaScript","slug":"TypeScript-JavaScript","permalink":"http://airshu.github.io/tags/TypeScript-JavaScript/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"}]},{"title":"tsconfig.json","date":"2023-12-24T13:26:24.687Z","path":"wiki/JavaScript/tsconfig.json/","text":"如果一个目录下存在 tsconfig.json 文件，那么它意味着这个目录是 TypeScript 项目的根目录。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// configs/base.json&#123; &quot;compilerOptions&quot;: &#123;&#125;&#125;// tsconfig.json&#123; &quot;extends&quot;: &quot;./configs/base&quot;, //继承配置 &quot;compilerOptions&quot;: &#123; //编译选项 &quot;incremental&quot;: true, //开启增量编译 &quot;tsBuildInfoFile&quot;:&quot;./&quot;,//指定增量比编译的文件位置 &quot;diagnostics&quot;:true,//打印诊断信息 &quot;listFiles&quot;:true,//打印编译的文件 &quot;&quot;:&quot;&quot;, /* 指定编译版本： &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27; or &#x27;ESNEXT&#x27;. */ &quot;target&quot;: &quot;es6&quot;, /* 指定模块代码的生成方式: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, or &#x27;ESNext&#x27;. */ &quot;module&quot;: &quot;commonjs&quot;, //模版标准 &quot;lib&quot;: [], //指定要包含在编译中的库文件 &quot;allowJs&quot;: true, //允许编译js文件 &quot;checkJs&quot;: true, //检查和报告js文件中的错误 &quot;jsx&quot;: &quot;preserve&quot;,//指定jsx代码用于的开发环境： preserve、react、react-native &quot;declaration&quot;: false, //是否在编译的时候生成相应的d.ts声明文件。declaration和allowJs不能同时设置为true &quot;declarationMap&quot;: true, //是否在编译的时候生成相应的map声明文件 &quot;sourceMap&quot;: true,// &quot;outFile&quot;: &quot;./&quot;, //指定输出文件合并为一个文件，只有设置module的值为amd和system模块时才支持这个配置 &quot;outDir&quot;: &quot;./&quot;, //指定输出文件夹 &quot;rootDir&quot;: &quot;./&quot;,//指定编译文件的根目录 &quot;composite&quot;: true,//是否编译构建引用项目 &quot;removeComments&quot;: true,//是否将编译后的文件注释删除掉 &quot;noEmit&quot;: true,//不生成编译文件 &quot;importHelpers&quot;: true,//是否引入tslib里的复制工具函数，默认为false &quot;downlevelIteration&quot;: true,//当target为“es5”或“es3”时，为“for-of”、“spread”和“destructuring”中的迭代器提供完全支持 &quot;strict&quot;: true,//开启所有类型检查 &quot;noImplicitAny&quot;: true,//没有设置明确类型会报错 &quot;strictNullChecks&quot;: true, //为true时，null和undefined值不能赋值给非这两种类型的值，别的类型的值也不能赋给他们，除了any类型，还有个例外就是undefined可以赋值给void类型 &quot;baseUrl&quot;: &quot;/&quot;,//设置解析非相对模块名称的基本目录， &quot;paths&quot;: &#123;//基于baseUrl的路径映射 &quot;&quot;:&quot;&quot;, &#125;, /* 指定模块的解析策略： node、classic */ /* 若未指定，那么在使用了 --module AMD | System | ES2015 时的默认值为 Classic，其它情况时则为 Node */ &quot;moduleResolution&quot;: &quot;&quot;, &quot;&quot;: &quot;&quot;, &#125;, /* 指定需要编译的单个文件列表 */ &quot;files&quot;: [ ], &quot;include&quot;: [], //指定要编译的路径列表 &quot;exclude&quot;: [],//要排除的不编译的文件/文件夹列表&#125; 参考 耗时一年整理，全网最全的TypeScript踩坑集锦(tsconfig.json 常用配置项注释以及问题） https://www.tslang.cn/docs/handbook/tsconfig-json.html","tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://airshu.github.io/tags/TypeScript/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"}]},{"title":"前端模块化概念","date":"2023-12-24T13:26:24.687Z","path":"wiki/JavaScript/前端模块化概念/","text":"在NodeJS之前，由于没有过于复杂的开发场景，前端是不存在模块化的，后端才有模块化。NodeJS诞生之后，它使用CommonJS的模块化规范。从此，js模块化开始快速发展。 CommonJSNode.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。 123456789101112131415161718// 定义模块math.jsvar basicNum = 0;function add(a, b) &#123; return a + b;&#125;module.exports = &#123; //在这里写上需要向外暴露的函数、变量 add: add, basicNum: basicNum&#125;// 引用自定义的模块时，参数包含路径，可省略.jsvar math = require(&#x27;./math&#x27;);math.add(2, 5);// 引用核心模块时，不需要带路径var http = require(&#x27;http&#x27;);http.createService(...).listen(3000); AMDAMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 CMDCMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。 ES6 ModuleES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 123456789101112131415/** 定义模块 math.js **/var basicNum = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; basicNum, add &#125;;/** 引用模块 **/import &#123; basicNum, add &#125; from &#x27;./math&#x27;;function test(ele) &#123; ele.textContent = add(99 + basicNum);&#125; ES6和CommonJS的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。模块内部引用的变化，会反应在外部。 参考 前端模块化——彻底搞懂AMD、CMD、ESM和CommonJS","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/tags/JavaScript/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"}]},{"title":"文本参数","date":"2023-12-24T13:26:24.686Z","path":"wiki/JavaScript/ReactNative/属性参数/文本参数/","text":"","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"},{"name":"属性参数","slug":"JavaScript/ReactNative/属性参数","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/%E5%B1%9E%E6%80%A7%E5%8F%82%E6%95%B0/"}]},{"title":"布局参数","date":"2023-12-24T13:26:24.686Z","path":"wiki/JavaScript/ReactNative/属性参数/布局参数/","text":"先看Flex 布局教程：语法篇，了解Flex布局的历史和基本概念。 Flexbox布局 flex flexDirection justifyContent alignItems flexWrap alignSelf 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123;Component&#125; from &#x27;react&#x27;;import &#123;StyleSheet, Text, View&#125; from &#x27;react-native&#x27;; export default class App extends Component&lt;Props&gt; &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.red&#125;/&gt; &lt;View style=&#123;styles.blue&#125;/&gt; &lt;View style=&#123;styles.orange&#125;/&gt; &lt;/View&gt; ); &#125;&#125; const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &#x27;center&#x27;, alignItems: &#x27;center&#x27;, backgroundColor: &#x27;#F5FCFF&#x27;, &#125;, red: &#123; flex: 1, width: 100, backgroundColor: &#x27;red&#x27; &#125;, blue: &#123; flex: 2, width: 100, backgroundColor: &#x27;blue&#x27; &#125;, orange: &#123; width: 100, height: 100, backgroundColor: &#x27;orange&#x27; &#125;&#125;); flexDirection主轴方向，默认值为column row: child水平方向排列 column: child竖直方向排列(默认) row-reverse: child水平方向反向排列 column-reverse: child竖直方向反向排列 justifyContent固定好主轴之后，可以通过justifyContent来指定主轴方向child的排列方式 flex-start: child在主轴起点方向排列（默认） flex-end：child在主轴终点方向排列 center：child居中对齐主轴 space-between：child在主轴方向相邻child等间距对齐，首尾child与父容器对齐 space-around：child在主轴方向相邻child等间距对齐，首尾child与父容器的间距相等且为相邻child间距的一半 space-evenly：child在主轴方向均匀分布。相邻间距与首尾间距相等 alignItems副轴上child的排列方式 flex-start: child对齐副轴起点(默认) flex-end: child对齐副轴终点 center: child居中对齐副轴 stretch: child为弹性布局时(未设置副轴方向的大小或者为auto)，拉伸对齐副轴 baseline: 有文本存在时，child在副轴方向基于第一个文本基线对齐 flexWrap如果再增加一个View，由于空间不足它会展示不全。这时可以使用flexWrap属性，它可以支持自动换行展示。 nowrap: 不换行(默认) wrap: 自动换行 alignSelfalignSelf属性类似于alignItems，它也是控制副轴上的排列规则，不同的是它使用的对象是child自己。它可以改变父容器alignItems的属性控制的child排列规则，在副轴上实现自己的排列规则。默认值为auto，继承父容器的alignItems属性。因此它也有五个可选值： flex-start flex-end center stretch baseline 参考 5分钟吃透React Native Flexbox https://reactnative.dev/docs/layout-props Flex 布局教程：语法篇","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"},{"name":"属性参数","slug":"JavaScript/ReactNative/属性参数","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/%E5%B1%9E%E6%80%A7%E5%8F%82%E6%95%B0/"}]},{"title":"react-native-elements","date":"2023-12-24T13:26:24.686Z","path":"wiki/JavaScript/ReactNative/开源库/react-native-elements/","text":"Icon基本用法https://reactnativeelements.com/docs/1.2.0/icon查阅基本属性和使用 12345678&lt;Icon type=&quot;MaterialIcons&quot; name=&quot;delete&quot; size=&#123;24&#125; color=&quot;#D1D1D6&quot; onPress=&#123;() =&gt; console.log(&#x27;delete&#x27;)&#125;/&gt; 属性 name： type：支持的类型，查阅https://reactnativeelements.com/docs/1.2.0/icon#available-icon-sets具体类型 material material-community font-awesome octicon ionicon foundation evilicon simple-line-icon zocial entypo feather antdesign size： color： iconStyle： Component： disabled： disabledStyle： onPress： onLongPress： underlayColor： reverse： raised： containerStyle： reverseColor： 使用react-native-vector-icons，在https://oblador.github.io/react-native-vector-icons/查询图标名称和类型。 参考https://github.com/react-native-elements","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"},{"name":"开源库","slug":"JavaScript/ReactNative/开源库","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"React Hooks","date":"2023-12-24T13:26:24.685Z","path":"wiki/JavaScript/React/基础知识/React Hooks/","text":"React Hooks产生的原因Functional（Stateless）Component，功能组件也叫无状态组件，一般只负责渲染。 1234function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; Class（Stateful）Component，类组件也是有状态组件，一般有交互逻辑和业务逻辑。 123456789101112131415161718class Welcome extends React.Component &#123; state = &#123; name: ‘tori’, &#125; componentDidMount() &#123; fetch(…); … &#125; render() &#123; return ( &lt;&gt; &lt;h1&gt;Hello, &#123;this.state.name&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123;name: ‘007’&#125;)&#125;&gt;改名&lt;/button&gt; &lt;/&gt; ); &#125;&#125; Presentational Component则是和功能组件类似 12345678const Hello = (props) =&gt; &#123; return ( &lt;div&gt; &lt;h1&gt;Hello! &#123;props.name&#125;&lt;/h1&gt; &lt;/div&gt; )&#125; useState：状态管理，某个状态发生变化，组件重新渲染 useEffect： 在函数组件中执行副作用操作，方便，且避免不必要的bug useRef：用于在不进行渲染的情况下存储和访问最新的值 useReducer： useCallback： React Hooks组件从v16.8开始 官方文档Introducing Hooks React Hooks 入门教程 使用 Effect Hook","tags":[{"name":"React","slug":"React","permalink":"http://airshu.github.io/tags/React/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://airshu.github.io/categories/JavaScript/React/"},{"name":"基础知识","slug":"JavaScript/React/基础知识","permalink":"http://airshu.github.io/categories/JavaScript/React/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"动画","date":"2023-12-24T13:26:24.685Z","path":"wiki/JavaScript/ReactNative/动画/","text":"动画组件 Animated.View 12345Animated.timing(this.state.xPosition, &#123; toValue: 100, easing: Easing.back(), duration: 2000&#125;).start(); 组合动画 parallel（同时执行） sequence（顺序执行） stagger delay 123456789101112131415161718Animated.sequence([ // decay, then spring to start and twirl Animated.decay(position, &#123; // coast to a stop velocity: &#123; x: gestureState.vx, y: gestureState.vy &#125;, // velocity from gesture release deceleration: 0.997 &#125;), Animated.parallel([ // after decay, in parallel: Animated.spring(position, &#123; toValue: &#123; x: 0, y: 0 &#125; // return to start &#125;), Animated.timing(twirl, &#123; // and twirl toValue: 360 &#125;) ])]).start(); // start the sequence group 参考 https://reactnative.cn/docs/animated","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"props和stat的区别","date":"2023-12-24T13:26:24.685Z","path":"wiki/JavaScript/React/props和state的区别/","text":"UI &#x3D; Component(props, state) React 的核心思想是组件化的思想，所有的页面会被切分成一些独立的、可复用的组件。那么数据从何而来呢？React 的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在 props 和 state 中。 props 是组件对外的接口，state 是组件对内的接口。 组件内可以引用其他组件，组件之间的引用形成了一个树状结构（组件树），如果下层组件需要使用上层组件的数据或方法，上层组件就可以通过下层组件的 props 属性进行传递，因此 props 是组件对外的接口。组件除了使用上层组件传递的数据外，自身也可能需要维护管理数据，这就是组件对内的接口 state。根据对外接口 props 和对内接口 state，组件计算出对应界面的UI。 props： props 是组件对外的接口，是一个对象，包含了所有通过父组件传递过来的数据，一般由父组件传递给子组件，子组件通过 props 对象获取父组件传递过来的数据。 props 是只读的，不允许子组件修改父组件传递过来的 props 数据。 props 是单向数据流，父组件的更新会向下传递到子组件中，但是子组件的更新不会影响父组件，也不会影响其他子组件，每个组件都是独立的。 state： state 是组件对内的接口，是一个对象，包含了组件内部的状态和数据。 state 是可变的，可以通过 this.setState 方法修改 state 数据，组件每次更新都会重新渲染 render。 修改state后，刷新UI是异步的，React 会将多个 setState() 调用合并成一个调用，只渲染一次组件，提高性能。Flutter的setState类似 只能在 constructor 中初始化，它是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的 this.setState 来修改 propsstate参考","tags":[{"name":"JavaScript Redux","slug":"JavaScript-Redux","permalink":"http://airshu.github.io/tags/JavaScript-Redux/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://airshu.github.io/categories/JavaScript/React/"}]},{"title":"声明文件的写法的区别","date":"2023-12-24T13:26:24.685Z","path":"wiki/JavaScript/React/声明文件的写法和区别/","text":"基本的声明声明文件12345678910111213141516171819202122232425262728var x = 1;module.exports.x = x; //导出变量var add = function(a, b)&#123; return a + b;&#125;;module.exports.add = add; //导出函数function multiplay(a, b) &#123;&#125;export &#123;multiplay&#125; // 导出对象module.exports = &#123;&#125;; //ES5的写法，导出多个文件export &#123;add as default&#125;; //导出默认值export default class A &#123;&#125;export default () =&gt; &#123;&#125;export &#123;Header, Bottom&#125;;export type &#123;TypeA, TypeB&#125;; //导出类型 导入文件123456789101112131415161718var app = require(&#x27;./app.js&#x27;);import A from &#x27;./a&#x27;;import &#123; B &#125; from &#x27;./b&#x27;;import &#123; C, D, E &#125; from &#x27;./c&#x27;;import &#123; F &#125; from &#x27;@rui/f&#x27;; //使用路径配置import * as example from &#x27;./example&#x27;; //导入所有并重命名import * as React from &#x27;react&#x27;;//将所有用export导出的成员赋值给React，导入后用React.xx访问import React from &#x27;react&#x27;;//仅将默认导出的内容赋值给React//导入再导出import &#123;sum as sumXX&#125; from &#x27;./example&#x27;;export &#123;sumXX&#125;; JavaScript、TypeScript文件怎么互相调用呢？ importexport require 全局声明 模块导出声明 module.exports 和 exports的区别node执行一个文件时，会在这个文件内生成一个exports和module对象，而module对象又有一个exports对象 exports：对于本身来讲是一个变量（对象），它不是module的引用，它是{}的引用，它指向module.exports的{}模块。只能使用.语法 向外暴露变量。 module.exports：module是一个变量，指向一块内存，exports是module中的一个属性，存储在内存中，然后exports属性指向{}模块。既可以使用.语法，也可以使用&#x3D;直接赋值。 module.exports 和 export的区别前者是ES5的写法，后者是ES6的写法 因为： module.exports初始值为一个空对象 {} require返回的是module.exports export default class 中default作用有default的时候，在引用时可以自定义名称，没有default时需要使用{}括起来并且名称必须与class名称一致，每个文件只能有一个default 123456789101112// 声明export default class Template&#123;&#125;// 导入import Template from &#x27;./components/Templates&#x27;;// 别名import TheTemplate from &#x27;./components/Templates&#x27;; 注意 尽量使用ES6的写法，不要混用 export default语法不兼容CommonJS和AMD的exports 使用 export &#x3D; 导出一个模块，则必须使用 TypeScript 的特定语法 import module &#x3D; require(“module”) 来导入此模块","tags":[{"name":"JavaScript Redux","slug":"JavaScript-Redux","permalink":"http://airshu.github.io/tags/JavaScript-Redux/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://airshu.github.io/categories/JavaScript/React/"}]},{"title":"View参数","date":"2023-12-24T13:26:24.685Z","path":"wiki/JavaScript/ReactNative/属性参数/View参数/","text":"","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"},{"name":"属性参数","slug":"JavaScript/ReactNative/属性参数","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/%E5%B1%9E%E6%80%A7%E5%8F%82%E6%95%B0/"}]},{"title":"图片参数","date":"2023-12-24T13:26:24.685Z","path":"wiki/JavaScript/ReactNative/属性参数/图片参数/","text":"","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"},{"name":"属性参数","slug":"JavaScript/ReactNative/属性参数","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/%E5%B1%9E%E6%80%A7%E5%8F%82%E6%95%B0/"}]},{"title":"JavaScript入门","date":"2023-12-24T13:26:24.684Z","path":"wiki/JavaScript/JavaScript入门/","text":"先了解一下JS的历史：Javascript诞生记。基本的语法，从官方文档开始：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript 一些知识点 原义字符 等价字符引用 &lt; &amp;lt; &gt; &amp;gt; &quot; &quot; ‘ &amp;apos; &amp; &amp; 1234&lt;p&gt;HTML 中用 &lt;p&gt; 来定义段落元素。&lt;/p&gt;&lt;p&gt;HTML 中用 &amp;lt;p&amp;gt; 来定义段落元素&lt;/p&gt; HTML头123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;我的测试页面&lt;/title&gt; &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;my-css-file.css&quot; /&gt; &lt;script src=&quot;my-js-file.js&quot; defer&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是我的页面&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; title：表示页面标题 meta：元数据 link：自定义图标 script：引入需要加载的js文件 常见标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;h1&gt;标题元素标签，数字表示不同大小&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h4&gt;&lt;/h4&gt;&lt;h5&gt;&lt;/h5&gt;&lt;h6&gt;&lt;/h6&gt;&lt;!--无序列表 --&gt;&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; 我创建了一个指向 &lt;a href=&quot;https://www.mozilla.org/zh-CN/&quot;&gt;Mozilla 主页&lt;/a&gt;的链接。&lt;/p&gt;&lt;!--上标和下标 --&gt;&lt;p&gt; 咖啡因的化学方程式是 C&lt;sub&gt;8&lt;/sub&gt;H&lt;sub&gt;10&lt;/sub&gt;N&lt;sub&gt;4&lt;/sub&gt;O&lt;sub&gt;2&lt;/sub&gt;。&lt;/p&gt;&lt;p&gt;如果 x&lt;sup&gt;2&lt;/sup&gt; 的值为 9，那么 x 的值必为 3 或 -3。&lt;/p&gt;&lt;div&gt; &lt;/div&gt;&lt;!-- 可在段落中进行换行 --&gt;&lt;br/&gt;&lt;!-- 元素在文档中生成一条水平分割线 --&gt;&lt;hr/&gt;&lt;img src=&quot;images/dinosaur.jpg&quot; alt=&quot;一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。&quot; width=&quot;400&quot; height=&quot;341&quot; title=&quot;A T-Rex on display in the Manchester University Museum&quot; &gt;&lt;video controls&gt; &lt;source src=&quot;rabbit320.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;rabbit320.webm&quot; type=&quot;video/webm&quot;&gt; &lt;p&gt;你的浏览器不支持 HTML5 视频。可点击&lt;a href=&quot;rabbit320.mp4&quot;&gt;此链接&lt;/a&gt;观看&lt;/p&gt;&lt;/video&gt;&lt;iframe src=&quot;https://developer.mozilla.org/zh-CN/docs/Glossary&quot; width=&quot;100%&quot; height=&quot;500&quot; frameborder=&quot;0&quot; allowfullscreen sandbox&gt; &lt;p&gt; &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Glossary&quot;&gt; Fallback link for browsers that don&#x27;t support iframes &lt;/a&gt; &lt;/p&gt;&lt;/iframe&gt;&lt;picture&gt; &lt;source type=&quot;image/svg+xml&quot; srcset=&quot;pyramid.svg&quot; /&gt; &lt;source type=&quot;image/webp&quot; srcset=&quot;pyramid.webp&quot; /&gt; &lt;img src=&quot;pyramid.png&quot; alt=&quot;regular pyramid built from four equilateral triangles&quot; /&gt;&lt;/picture&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;&amp;nbsp;&lt;/td&gt; &lt;td&gt;Knocky&lt;/td&gt; &lt;td&gt;Flor&lt;/td&gt; &lt;td&gt;Ella&lt;/td&gt; &lt;td&gt;Juan&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Breed&lt;/td&gt; &lt;td&gt;Jack Russell&lt;/td&gt; &lt;td&gt;Poodle&lt;/td&gt; &lt;td&gt;Streetdog&lt;/td&gt; &lt;td&gt;Cocker Spaniel&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Age&lt;/td&gt; &lt;td&gt;16&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Owner&lt;/td&gt; &lt;td&gt;Mother-in-law&lt;/td&gt; &lt;td&gt;Me&lt;/td&gt; &lt;td&gt;Me&lt;/td&gt; &lt;td&gt;Sister-in-law&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eating Habits&lt;/td&gt; &lt;td&gt;Eats everyone&#x27;s leftovers&lt;/td&gt; &lt;td&gt;Nibbles at food&lt;/td&gt; &lt;td&gt;Hearty eater&lt;/td&gt; &lt;td&gt;Will eat till he explodes&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; HTML文档的组成部分 页眉： 是简介形式的内容。如果它是 的子元素，那么就是网站的全局页眉。如果它是 或 的子元素，那么它是这些部分特有的页眉 导航栏： 包含页面主导航功能。其中不应包含二级链接等内容 主内容： 存放每个页面独有的内容。每个页面上只能用一次 ，且直接位于 中。最好不要把它嵌套进其他元素 侧边栏： 包含一些间接信息（术语条目、作者简介、相关链接，等等） 页脚： CSSCSS能定义网页中特定元素样式的一组规则 使用CSS的方式 改变元素的默认行为123li &#123; list-style-type: none;&#125; 使用类名12345678910111213141516171819&lt;ul&gt; &lt;li&gt;项目一&lt;/li&gt; &lt;li class=&quot;special&quot;&gt;项目二&lt;/li&gt; &lt;li&gt;项目 &lt;em&gt;三&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;.special &#123; color: orange; font-weight: bold;&#125;#对类名是special，标签类型是li和span使用样式li.special,span.special &#123; color: orange; font-weight: bold;&#125; 根据元素在文档中的位置确定样式12345/*选择&lt;li&gt;内部的任何&lt;em&gt;元素*/li em &#123; color: rebeccapurple;&#125; 根据状态确定样式12345678a:link &#123; color: pink;&#125;a:visited &#123; color: green;&#125; 同时使用选择器和选择器1234567891011121314/* selects any &lt;span&gt; that is inside a &lt;p&gt;, which is inside an &lt;article&gt; */article p span &#123; ... &#125;/* selects any &lt;p&gt; that comes directly after a &lt;ul&gt;, which comes directly after an &lt;h1&gt; */h1 + ul + p &#123; ... &#125;body h1 + p .special &#123; color: yellow; background-color: black; padding: 5px;&#125; 冲突规则 层叠：后面的样式会覆盖前面的 优先级：类被认为更具体，优先级高于元素选择器 主流JavaScript框架 Ember：Ember 于 2011 年 12 月发布，最初作为 SproutCore 项目的延续而开始。比其新式的替代品（例如 React 和 Vue），作为老框架，它的用户人数要少得多。但因其稳定性、社区支持以及编程原则都非常良好，它仍然享有很高的知名度 Angular：一种基于组件的框架，使用声明式的 HTML 模板。在应用构建时，框架的编译器将 HTML 模板转换为优化好的 JavaScript 指令，这一过程对开发者是透明的。Angular 使用 TypeScript Vue React：2013年Facebook发布 .js .jsx .ts .tsx .js：JavaScript文件 .jsx：JavaScript文件并使用JSX语法 .ts：TypeScript文件 .tsx：TypeScript文件并使用JSX语法 JSX 就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到&lt;，JSX就当HTML解析，遇到就当JavaScript解析。JSX 只是为 React.createElement(component, props, …children) 方法提供的语法糖。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/tags/JavaScript/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"}]},{"title":"build_runner","date":"2023-12-24T13:26:24.684Z","path":"wiki/Flutter/未分类/build_runner/","text":"dart的build系统 build_config： build_modules： build_resolvers： build_runner： build_test： build_web_compilers： build_runner这个Package提供了一些用于生成文件的通用命令，常见的如json_serializable。 build_runner命令使用1234dart run build_runner buildflutter pub run build_runner build 主要流程 生成和预编译build脚本 处理输入环境和资源 根据前面的脚本和输入信息，开始正式执行builder生成代码； 缓存信息，用于下一回生成代码的时候增量判断使用 build_runner后的参数 build： watch： serve： test： 命令行的属性 –delete-conflicting-outputs： –[no-]fail-on-severe： –build-filter： 123456flutter packages pub run build_runner build --delete-conflicting-outputs# 只编译lib/pages/xxx/目录下的文件dart run build_runner build --build-filter=&quot;lib/pages/xxx/prefix*.dart&quot; 参考 https://github.com/dart-lang/build/blob/master/docs/getting_started.md Flutter 自定义 build_runner 的 build Flutter 代码生成 source_gen 使用与原理分析 [Flutter] Flutter 的 build 系统(一) https://pub.dev/packages/build_runner [build_runner] execute builder on only a single file #2928","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"Path的使用","date":"2023-12-24T13:26:24.684Z","path":"wiki/Flutter/未分类/Path的使用/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/// rect 圆弧所在的矩形/// startAngle 初始化弧度/// sweepAngle 需要绘制的弧度大小/// forceMoveTo 是否强制连线void arcTo(Rect rect, double startAngle, double sweepAngle, bool forceMoveTo) &#123;&#125;class ArcWidget extends StatefulWidget &#123; const ArcWidget(&#123;super.key&#125;); @override State&lt;ArcWidget&gt; createState() =&gt; _ArcWidgetState();&#125;class _ArcWidgetState extends State&lt;ArcWidget&gt; &#123; @override Widget build(BuildContext context) &#123; return Container( height: 50.h, child: CustomPaint( painter: ArcPainter(), child: Container(), ), ); &#125;&#125;class ArcPainter extends CustomPainter &#123; @override void paint(Canvas canvas, Size size) &#123; final paint = Paint() ..color = Colors.white ..style = PaintingStyle.fill; final path = Path() ..moveTo(0, size.height + 1) // Start at the bottom-left corner ..lineTo(0, size.height - 10.h) // Move up by 100 pixels ..quadraticBezierTo(size.width / 2, size.height - 48.h, size.width, size.height - 10.h) // Draw a quadratic bezier curve ..lineTo(size.width, size.height + 1) // Draw a line to the bottom-right corner ..close(); // Close the path canvas.drawPath(path, paint); &#125; @override bool shouldRepaint(CustomPainter oldDelegate) =&gt; true;&#125;","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"ES6","date":"2023-12-24T13:26:24.684Z","path":"wiki/JavaScript/ES6/","text":"Babel 转码器Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子 12345678// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); let 和 const 命令ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效 1234567891011121314151617&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1// for循环很适合使用let命令for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined const声明一个只读的常量。一旦声明，常量的值就不能改变。 123456const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 123456window.a = 1;a // 1a = 2;window.a // 2 ES6 为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 123456789var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined globalThis对象JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持 ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this 变量的解构赋值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293let a = 1;let b = 2;let c = 3;//ES6 可以这样写，允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。let [a, b, c] = [1, 2, 3];let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&#x27;a&#x27;];x // &quot;a&quot;y // undefined 如果解构不成功，变量的值就等于undefinedz // []//不完全解构let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4//设置默认值let [foo = true] = [];foo // truelet [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;]; // x=&#x27;a&#x27;, y=&#x27;b&#x27;let [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;, undefined]; // x=&#x27;a&#x27;, y=&#x27;b&#x27;//对象的解构赋值，对象的属性没有次序，变量必须与属性同名，才能取到正确的值。let &#123; foo, bar &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;//字符串的解构赋值const [a, b, c, d, e] = &#x27;hello&#x27;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;let &#123;length : len&#125; = &#x27;hello&#x27;;len // 5// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example();//提取json数据let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 字符串模版字符串123 标签模版函数的扩展函数参数的默认值12345678910function log(x, y = &#x27;World&#x27;) &#123; console.log(x, y);&#125;log(&#x27;Hello&#x27;) // Hello Worldlog(&#x27;Hello&#x27;, &#x27;China&#x27;) // Hello Chinalog(&#x27;Hello&#x27;, &#x27;&#x27;) // Hello 与解构赋值默认值结合使用12345678910function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property &#x27;x&#x27; of undefined 箭头函数12345678910111213141516171819var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;;// 普通函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 注意点 箭头函数没有自己的this对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替 不可以使用yield命令，因此箭头函数不能用作 Generator 函数 数组的扩展 Array.from() Array.of() 实例方法： copyWithin() find() findIndex() findLast() findLastIndex() fill() entries() keys() values() includes() flat() flatMap() at() toReversed() toSorted() toSpliced() with() group() groupToMap() 扩展运算符12345678910111213141516function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]);const arr = [ ...(x &gt; 0 ? [&#x27;a&#x27;] : []), &#x27;b&#x27;,];//字符串扩展运算符[...&#x27;hello&#x27;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 对象的扩展属性的简洁表示法1234567891011121314151617181920212223242526272829303132const foo = &#x27;bar&#x27;;const baz = &#123;foo&#125;;baz // &#123;foo: &quot;bar&quot;&#125;// 等同于const baz = &#123;foo: foo&#125;;function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125;//方法简写const o = &#123; method() &#123; return &quot;Hello!&quot;; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return &quot;Hello!&quot;; &#125;&#125;; 属性名表达式123456789let propKey = &#x27;foo&#x27;;let obj = &#123; [propKey]: true, [&#x27;a&#x27; + &#x27;bc&#x27;]: 123&#125;; 属性的遍历123456789101112131415161718192021（1）for...infor...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。（2）Object.keys(obj)Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。（3）Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。（4）Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。（5）Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 super指向当前对象的原型对象 1234567891011121314const proto = &#123; foo: &#x27;hello&#x27;&#125;;const obj = &#123; foo: &#x27;world&#x27;, find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // &quot;hello&quot; 上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 对象的新增方法12345678910111213141516171819202122232425262728293031Object.is() // 比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。Object.assign() // 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125;Object.getOwnPropertyDescriptors() // 返回指定对象所有自身属性（非继承属性）的描述对象。__proto__属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法Object.keys() // 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。Object.values() // 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。Object.entries() // 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。Object.fromEntries() // 是Object.entries()的逆操作，用于将一个键值对数组转为对象。Object.hasOwn() // JavaScript 对象的属性分成两种：自身的属性和继承的属性。对象实例有一个hasOwnProperty()方法，可以判断某个属性是否为原生属性。ES2022 在Object对象上面新增了一个静态方法Object.hasOwn()，也可以判断是否为自身的属性。Object.hasOwn()可以接受两个参数，第一个是所要判断的对象，第二个是属性名。 运算符的扩展123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//指数运算符2 ** 2 // 42 ** 3 // 8//链判断运算符const firstName = message?.body?.user?.firstName || &#x27;default&#x27;;const fooValue = myForm.querySelector(&#x27;input[name=foo]&#x27;)?.valuea?.b// 等同于a == null ? undefined : a.ba?.[x]// 等同于a == null ? undefined : a[x]a?.b()// 等同于a == null ? undefined : a.b()a?.()// 等同于a == null ? undefined : a()//Null 判断运算符const animationDuration = response.settings?.animationDuration ?? 300;// 逻辑赋值运算符// 或赋值运算符x ||= y// 等同于x || (x = y)// 与赋值运算符x &amp;&amp;= y// 等同于x &amp;&amp; (x = y)// Null 赋值运算符x ??= y// 等同于x ?? (x = y) Set和Map数据结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Set类似于数组，但是成员的值都是唯一的，没有重复的值。// WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。// - WeakSet 的成员只能是对象和 Symbol 值，而不能是其他类型的值// - WeakSet 中的对象都是弱引用// Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。const map = new Map();map.set(&#x27;foo&#x27;, true);map.set(&#x27;bar&#x27;, false);map.size // 2const m = new Map();const hello = function() &#123;console.log(&#x27;hello&#x27;);&#125;;m.set(hello, &#x27;Hello ES6!&#x27;) // 键是函数m.get(hello) // Hello ES6!const m = new Map();m.set(undefined, &#x27;nah&#x27;);m.has(undefined) // truem.delete(undefined)m.has(undefined) // let map = new Map();map.set(&#x27;foo&#x27;, true);map.set(&#x27;bar&#x27;, false);map.size // 2map.clear()map.size // 0Map.prototype.keys()：返回键名的遍历器。Map.prototype.values()：返回键值的遍历器。Map.prototype.entries()：返回所有成员的遍历器。Map.prototype.forEach()：遍历 Map 的所有成员。// WeakMap// WeakRef Proxy参考 阮一峰ES6入门教程","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/tags/JavaScript/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"}]},{"title":"常用开源库","date":"2023-12-24T13:26:24.684Z","path":"wiki/Flutter/开源库/常用开源库/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116# 处理model，用于自动生成对应实体类 json_annotation: json_serializable: # 设备信息、包信息 package_info_plus: device_info_plus: # 下拉、上拉刷新 easy_refresh: # 吐司提示 fluttertoast: # 模态提示 flutter_easyloading: 3.0.5# 音频处理 just_audio: audio_session: flutter_sound: # Reactive dart实现 rxdart: # 数据库操作 sqflite: # 网络请求 dio: # 加解密 encrypt: # 缓存 shared_preferences: # 图片扩展库、缓存图片 extended_image: # 强大的工具包，支持路由、状态管理等 get: # 屏幕适配方案 flutter_screenutil: # 左滑删除 flutter_slidable: # 苹果登录 sign_in_with_apple: # 可滑动展示的控件、轮播图 card_swiper: # 增强版文字控件 extended_text_field: # 浏览器容器 webview_flutter: # 权限管理 permission_handler: # 系统文件选择 file_picker: # 系统图片选择 image_picker: #svg控件 flutter_svg: # 支持svga控件 svgaplayer_flutter: # 支持打开各种格式的文件 open_file: # 强大的状态管理框架 flutter_bloc:# 剪切板工具 clipboard:# 事件总线工具 event_bus:# 支持lottie动画 lottie:# 异常捕获 sentry_flutter:# 开发调试框架 flutter_ume:# 各种路径的封装，比如临时目录、缓存目录 path_provider:# 外部浏览器打开url url_launcher:# 系统分享组件 share_plus:# 实体类工具，快捷生成model freezed:# 视频播放 video_player: 参考 https://pub.dev/packages?q=is%3Aflutter-favorite","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"bloc_test","date":"2023-12-24T13:26:24.683Z","path":"wiki/Flutter/单元测试/bloc_test/","text":"创建Mock1234import &#x27;package:bloc_test/bloc_test.dart&#x27;;class MockCounterBloc extends MockBloc&lt;CounterEvent, int&gt; implements CounterBloc &#123;&#125;class MockCounterCubit extends MockCubit&lt;int&gt; implements CounterCubit &#123;&#125; blocTest1234567891011121314void blocTest&lt;B extends BlocBase&lt;State&gt;, State&gt;( String description, &#123; //测试的描述 required B Function() build, //创建bloc FutureOr&lt;void&gt; Function()? setUp, //在每个测试用例执行前执行 State Function()? seed, dynamic Function(B bloc)? act, //执行的动作 Duration? wait, int skip = 0, dynamic Function()? expect, //期望的结果 dynamic Function(B bloc)? verify, dynamic Function()? errors, FutureOr&lt;void&gt; Function()? tearDown, //在每个测试用例执行后执行 dynamic tags,&#125;) 参数 setUp：前置设置 tearDown：用例结束后的动作，可用于释放资源 build（必需）：一个回调函数，用于创建BLoC的实例。在这个回调函数中，我们可以创建并返回要测试的BLoC实例 seed：提供一个初始状态（state），该状态将在执行act之前用于初始化bloc。它是一个可选的回调函数，返回一个状态对象 act（可选）：一个回调函数，用于执行BLoC的操作。在这个回调函数中，我们可以调用BLoC的方法或发送事件，以触发BLoC的状态变化 expect（可选）：一个回调函数，用于定义预期的状态流或结果。在这个回调函数中，我们可以使用expect函数来定义预期的状态流或结果，以便与实际的状态流或结果进行比较 skip：用于指定是否跳过此测试。如果设置为true，则跳过此测试；如果设置为false或不提供该参数，则执行此测试。 error：用于指定在执行act后预期bloc会抛出的错误。它接受一个返回Matcher的函数，该Matcher用于验证bloc抛出的错误是否符合预期。如果act执行后没有抛出错误，或者抛出的错误与预期不符，则测试将失败。 verify：执行完expect后被调用，用于进行额外的验证和断言操作。该函数接受一个bloc对象作为参数，可以在函数体内对该对象进行操作和断言。 tags：可添加测试标签，可以通过运行flutter test –tags&#x3D;xxx来只运行带有”xxx”标签的测试 参数示例build、act、expect1234567891011121314group(&#x27;CounterBloc&#x27;, () &#123; blocTest( &#x27;emits [] when nothing is added&#x27;, build: () =&gt; CounterBloc(), expect: () =&gt; [], ); blocTest( &#x27;emits [1] when CounterIncrementPressed is added&#x27;, build: () =&gt; CounterBloc(), act: (bloc) =&gt; bloc.add(CounterIncrementPressed()), expect: () =&gt; [1], );&#125;); seed12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import &#x27;package:bloc_test/bloc_test.dart&#x27;;import &#x27;package:equatable/equatable.dart&#x27;;import &#x27;package:flutter_bloc/flutter_bloc.dart&#x27;;import &#x27;package:flutter_test/flutter_test.dart&#x27;;import &#x27;package:mockito/mockito.dart&#x27;;import &#x27;package:xdragon/services/interceptors/verify_permission.dart&#x27;;class CounterEvent extends Equatable &#123; @override List&lt;Object?&gt; get props =&gt; [];&#125;class CounterIncrementEvent extends CounterEvent &#123;&#125;class CounterDecrementEvent extends CounterEvent &#123;&#125;class CounterState extends Equatable &#123; final int count; CounterState(this.count); @override List&lt;Object?&gt; get props =&gt; [count];&#125;class CounterBloc extends Bloc&lt;CounterEvent, CounterState&gt; &#123; CounterBloc() : super(CounterState(0)) &#123; on&lt;CounterIncrementEvent&gt;(onCounterIncrementEvent); on&lt;CounterDecrementEvent&gt;(onCounterDecrementEvent); &#125; void onCounterIncrementEvent(CounterEvent event, Emitter&lt;CounterState&gt; emit) &#123; emit(CounterState(state.count + 1)); &#125; void onCounterDecrementEvent(CounterEvent event, Emitter&lt;CounterState&gt; emit) &#123; emit(CounterState(state.count - 1)); &#125;&#125;void main() &#123; test(&#x27;test event&#x27;, () &#123; expect(CounterEvent(), CounterEvent()); &#125;); test(&#x27;test state&#x27;, () &#123; expect(CounterState(10), CounterState(10)); &#125;); blocTest&lt;CounterBloc, CounterState&gt;( &#x27;CounterBloc test &#x27;, build: () =&gt; CounterBloc(), seed: () =&gt; CounterState(10), act: (bloc) =&gt; bloc.add(CounterIncrementEvent()), expect: () =&gt; [CounterState(11)], verify: (bloc) &#123; // 校验 expect(bloc.state.count , 11); &#125;, );&#125; errors123456blocTest( &#x27;CounterBloc throws Exception when decrement is added&#x27;, build: () =&gt; CounterBloc(), act: (bloc) =&gt; bloc.add(CounterEvent.decrement), errors: () =&gt; throwsA(isA&lt;Exception&gt;()),); verify12345678910111213141516blocTest( &#x27;CounterBloc emits [1] when increment is added&#x27;, build: () =&gt; CounterBloc(), act: (bloc) =&gt; bloc.add(CounterEvent.increment), expect: () =&gt; [1], verify: (bloc) &#123; // 验证某个方法被调用了一次 verify(() =&gt; repository.someMethod(any())).called(1); // 验证某个属性的值 expect(bloc.someProperty, equals(42)); // 进行其他的验证操作 // ... &#125;,); 测试event123456789101112131415161718//注意如果不继承Equatable，则会比较地址，前后两个event会不相等sealed class PostEvent extends Equatable &#123; @override List&lt;Object&gt; get props =&gt; [];&#125;final class PostFetched extends PostEvent &#123;&#125;void main() &#123; group(&#x27;PostEvent&#x27;, () &#123; group(&#x27;PostFetched&#x27;, () &#123; test(&#x27;supports value comparison&#x27;, () &#123; expect(PostFetched(), PostFetched()); &#125;); &#125;); &#125;);&#125; 测试state123456789101112131415161718192021222324252627282930313233343536373839404142final class PostState extends Equatable &#123;const PostState(&#123; this.status = PostStatus.initial, this.hasReachedMax = false,&#125;);final PostStatus status;final bool hasReachedMax;PostState copyWith(&#123; PostStatus? status, bool? hasReachedMax,&#125;) &#123; return PostState( status: status ?? this.status, hasReachedMax: hasReachedMax ?? this.hasReachedMax, );&#125;@overrideString toString() &#123; return &#x27;&#x27;&#x27;PostState &#123; status: $status, hasReachedMax: $hasReachedMax &#125;&#x27;&#x27;&#x27;;&#125;@overrideList&lt;Object&gt; get props =&gt; [status, hasReachedMax];&#125;/// 同理，state也需要继承Equatablevoid main() &#123; group(&#x27;PostState&#x27;, () &#123; test(&#x27;supports value comparison&#x27;, () &#123; expect(PostState(), PostState()); expect( PostState().toString(), PostState().toString(), ); &#125;); &#125;);&#125; - 参考 https://pub.dev/packages/bloc_test","tags":[{"name":"Flutter 单元测试","slug":"Flutter-单元测试","permalink":"http://airshu.github.io/tags/Flutter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"单元测试","slug":"Flutter/单元测试","permalink":"http://airshu.github.io/categories/Flutter/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"集成测试","date":"2023-12-24T13:26:24.683Z","path":"wiki/Flutter/单元测试/集成测试/","text":"integration_test集成测试框架，可分析测试用例的性能指标 官方文档：https://flutter.cn/docs/cookbook/testing/integration/introduction 基本使用1. 添加配置123456789dev_dependencies: flutter_test: sdk: flutter flutter_lints: ^1.0.0 mockito: integration_test: sdk: flutter flutter_driver: sdk: flutter 2. 根目录下新建test_driver文件夹，编写integration_test.dart文件1234567891011121314151617import &#x27;dart:io&#x27;;import &#x27;package:integration_test/integration_test_driver_extended.dart&#x27;;Future&lt;void&gt; main() =&gt; integrationDriver( onScreenshot: (String screenshotPath, List&lt;int&gt; screenshotBytes) async &#123; final File image = File(screenshotPath); final dir = image.parent; print(image); if(!await dir.exists()) await dir.create(recursive: true); image.writeAsBytesSync(screenshotBytes); return true; &#125;); 3. 根目录新建integration_test文件夹，编写app_test.dart文件123456789void main() async &#123; // 确保Flutter框架已经初始化完成 IntegrationTestWidgetsFlutterBinding.ensureInitialized(); testWidgets(&#x27;test app&#x27;, (widgetTester) async &#123; expect(XDragonApp(), isA&lt;StatefulWidget&gt;()); &#125;); &#125; 4. 运行123456# --flavor 指定develop、staging、release# --driver 指定驱动文件# --target 指定测试用例，可以不设置driver，默认driver名字为测试用例名字_test.dart# 比如：target的名字为app_feature.dart，则driver名字为app_feature_test.dartflutter driver --driver=test_driver/integration_test.dart --target=integration_test/app_test.dart --flavor development 统计覆盖率123456789101112# Generate `coverage/lcov.info` file# 运行测试脚本flutter test --coverage# Generate HTML report# Note: on macOS you need to have lcov installed on your system (`brew install lcov`) to use this:# 将生成文件转换成html文件genhtml coverage/lcov.info -o coverage/html# Open the reportopen coverage/html/index.html 参考文档 https://juejin.cn/post/7106403440774889509","tags":[{"name":"Flutter 单元测试","slug":"Flutter-单元测试","permalink":"http://airshu.github.io/tags/Flutter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"单元测试","slug":"Flutter/单元测试","permalink":"http://airshu.github.io/categories/Flutter/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"flutter_test","date":"2023-12-24T13:26:24.683Z","path":"wiki/Flutter/单元测试/flutter_test/","text":"描述基于dart的test库，用于Flutter项目的测试库。 可用于测试： 方法、函数 UI 基本用法1. 添加配置123dev_dependencies: flutter_test: sdk: flutter 2. 编写测试用例1234567891011121314151617181920212223242526272829303132@Skip(&#x27;跳过当前测试用例&#x27;)@Timeout(Duration(seconds: 10)) //设置超时时间import &#x27;package:flutter_test/flutter_test.dart&#x27;;void main() &#123;//在每个测试用例执行前执行 setUp(() &#123; &#125;); //在每个测试用例执行后执行 tearDown(() &#123; &#125;);//单个用例 test(&#x27;描述测试内容&#x27;, () async &#123; //支持异步测试 expect(1+1, 2); &#125;);//组用例 group(&#x27;描述分组&#x27;, () &#123; test(&#x27;描述测试内容&#x27;, () async &#123; &#125;); &#125;, skip: &#x27;跳过当前分组&#x27;, timeout: Timeout(Duration(seconds: 10)) //设置超时时间 );&#125; 常用API介绍基本方法 group：分组，可以把一些相关的测试用例放在一起 test：单个测试用例 testWidgets：测试UI pumpWidget()：创建并渲染widget pump(): 触发widget重建，仅重建已更改的 widget pumpAndSettle():在给定期间内不断重复调用 pump() 直到完成所有绘制帧，一般需要等到所有动画全部完成 setUp：在每个测试用例执行前执行 tearDown：在每个测试用例执行后执行 expect：断言，判断是否符合预期 交互类API enterText(): 模拟输入 tap(): 模拟点击 drag(): 模拟拖拽 longPress():模拟长按 scrollUntilVisible(): 模拟滚动到可见位置 scrollIntoView(): 模拟滚动到可见位置 scroll(): 模拟滚动 fling(): 模拟拖拽 flingFrom(): 模拟拖拽 flingFromEdge(): 模拟拖拽 flingFromCenter(): 模拟拖拽 使用Finder定位Widget text(String text): 查找特定文本的Text widget byWidget(Widget widget, {bool skipOffstage &#x3D; true}): 通过widget查找widget byWidgetPredicate：根据具体条件进行查找 byKey(Key key): 通过key查找widget byType(Type type): 通过类型查找widget byElementType(Type type, { bool skipOffstage &#x3D; true }): matchers findsOneWidget：找到一个widget findsWidgets：找到一个或多个 findsNothing：没有找到 findsNWidgets：找到指定数量的widget TestPointer：测试手势，按下、滑动、抬起等 TestTextInput：测试输入框 AutomatedTestWidgetsFlutterBinding：会模拟用户操作并控制应用程序的状态。它可以处理异步操作、动画和定时器等，以确保测试代码在正确的上下文中运行。通常与 flutter_driver 或其他自动化测试框架一起使用，用于执行集成测试或端到端测试 AnimationSheetBuilder：用于测试动画 UI测试用例主要是用以下工具进行UI的测试： WidgetTester，可在测试环境建立widget并与其交互 testWidgets()函数，此函数会自动为每个测试创建一个WidgetTester，用来代替普通的test函数 Finder类，方便在测试环境下查找widgets Widget-specific Matcher常量，用于验证 1. 创建用于测试的Widget12345678910111213141516171819202122232425class MyWidget extends StatelessWidget &#123; const MyWidget(&#123; super.key, required this.title, required this.message, &#125;); final String title; final String message; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;Flutter Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text(title), ), body: Center( child: Text(message), ), ), ); &#125;&#125; 2. 创建一个testWidgets测试方法123456789void main() &#123; // Define a test. The TestWidgets function also provides a WidgetTester // to work with. The WidgetTester allows you to build and interact // with widgets in the test environment. testWidgets(&#x27;MyWidget has a title and message&#x27;, (tester) async &#123; //建立Widget await tester.pumpWidget(const MyWidget(title: &#x27;T&#x27;, message: &#x27;M&#x27;)); &#125;);&#125; 3. 使用Finder查找widget123456789void main() &#123; testWidgets(&#x27;MyWidget has a title and message&#x27;, (tester) async &#123; await tester.pumpWidget(const MyWidget(title: &#x27;T&#x27;, message: &#x27;M&#x27;)); // Create the Finders. final titleFinder = find.text(&#x27;T&#x27;); final messageFinder = find.text(&#x27;M&#x27;); &#125;);&#125; 4. 使用Matcher验证widget是否正常工作123456789101112void main() &#123; testWidgets(&#x27;MyWidget has a title and message&#x27;, (tester) async &#123; await tester.pumpWidget(const MyWidget(title: &#x27;T&#x27;, message: &#x27;M&#x27;)); final titleFinder = find.text(&#x27;T&#x27;); final messageFinder = find.text(&#x27;M&#x27;); // Use the `findsOneWidget` matcher provided by flutter_test to verify // that the Text widgets appear exactly once in the widget tree. expect(titleFinder, findsOneWidget); expect(messageFinder, findsOneWidget); &#125;);&#125; 参考 https://api.flutter.dev/flutter/flutter_test&#x2F;flutter_test-library.html https://flutter.cn/docs/cookbook/testing/widget/introduction","tags":[{"name":"Flutter 单元测试","slug":"Flutter-单元测试","permalink":"http://airshu.github.io/tags/Flutter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"单元测试","slug":"Flutter/单元测试","permalink":"http://airshu.github.io/categories/Flutter/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"文本处理","date":"2023-12-24T13:26:24.682Z","path":"wiki/Flutter/UI/文本处理/","text":"TextPainter文本的折叠12345678910111213//计算最后一个文字的位置LayoutBuilder( builder: (context, size) &#123; final span = TextSpan(text: widget.text, style: style); final tp = TextPainter( text: span, maxLines: widget.maxLines, textDirection: TextDirection.ltr);//设置最大行数 tp.layout(maxWidth: size.maxWidth); final pos = tp.getPositionForOffset(Offset(tp.size.width, tp.size.height));//获取文字所占位置 String txt = widget.text.substring(0, pos.offset);//获取当前范围的文字 &#125;); 参考 Text widget with read more or expand feature - Flutter How to Use a TextPainter to Draw Text In Flutter?","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"}]},{"title":"Mockito","date":"2023-12-24T13:26:24.682Z","path":"wiki/Flutter/单元测试/Mockito/","text":"描述用于模拟数据的Flutter测试库。为了使用模拟类，需要在pubspec.yaml中添加build_runner依赖。 基本用法1. pubspec.yaml添加依赖12345dev_dependencies: flutter_test: sdk: flutter mockito: build_runner: 2. mock类12345678910111213141516171819202122import &#x27;package:mockito/annotations.dart&#x27;;import &#x27;package:mockito/mockito.dart&#x27;;// 标注创建cat.mocks.dart文件和MockCat类@GenerateNiceMocks([MockSpec&lt;Cat&gt;()])import &#x27;cat.mocks.dart&#x27;;// 真实的类class Cat &#123; String sound() =&gt; &quot;Meow&quot;; bool eatFood(String food, &#123;bool? hungry&#125;) =&gt; true; Future&lt;void&gt; chew() async =&gt; print(&quot;Chewing...&quot;); int walk(List&lt;String&gt; places) =&gt; 7; void sleep() &#123;&#125; void hunt(String place, String prey) &#123;&#125; int lives = 9;&#125;void main() &#123; // 创建mock对象 object.var cat = MockCat();&#125; 3. 生成文件1234flutter pub run build_runner build# ORdart run build_runner build 4. 验证123456789101112131415161718192021222324252627282930// 在交互前插桩一个mock方法when(cat.sound()).thenReturn(&quot;Purr&quot;);expect(cat.sound(), &quot;Purr&quot;);// 可以再次调用expect(cat.sound(), &quot;Purr&quot;);// 改变一下插桩when(cat.sound()).thenReturn(&quot;Meow&quot;);expect(cat.sound(), &quot;Meow&quot;);// You can stub getters.when(cat.lives).thenReturn(9);expect(cat.lives, 9);// 抛出一个异常 when(cat.lives).thenThrow(RangeError(&#x27;Boo&#x27;));expect(() =&gt; cat.lives, throwsRangeError);// We can calculate a response at call time.var responses = [&quot;Purr&quot;, &quot;Meow&quot;];when(cat.sound()).thenAnswer((_) =&gt; responses.removeAt(0));expect(cat.sound(), &quot;Purr&quot;);expect(cat.sound(), &quot;Meow&quot;);// We can stub a method with multiple calls that happened in a particular order.when(cat.sound()).thenReturnInOrder([&quot;Purr&quot;, &quot;Meow&quot;]);expect(cat.sound(), &quot;Purr&quot;);expect(cat.sound(), &quot;Meow&quot;);expect(() =&gt; cat.sound(), throwsA(isA&lt;StateError&gt;())); 主要功能 可通过标注或Fake的方式来生成mock类 可通过when().thenReturn()来模拟方法的返回值 thenReturn会返回Future或Stream，可能抛出ArgumentError thenAnswer只会返回Future或Stream 可通过argThat()来模拟方法的参数 reset重置 可通过verify()来验证方法的调用 verifyInOrder可校验顺序 可通过verifyNoMoreInteractions()来验证没有更多的调用 可通过reset()来重置mock 可通过verifyZeroInteractions()来验证没有调用 可通过verifyNever()来验证没有调用 可通过verifyInOrder()来验证顺序 可通过verifyStream()来验证Stream 可通过verifyStreamEvent()来验证Stream的事件 called能校验调用次数 captured存储调用时的参数 参数匹配器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// You can use plain arguments themselveswhen(cat.eatFood(&quot;fish&quot;)).thenReturn(true);// ... including collectionswhen(cat.walk([&quot;roof&quot;,&quot;tree&quot;])).thenReturn(2);// ... or matchers//如果参数以dry开头，调用eatFood时返回结果为falsewhen(cat.eatFood(argThat(startsWith(&quot;dry&quot;)))).thenReturn(false);when(cat.eatFood(any)).thenReturn(false);// ... or mix arguments with matcherswhen(cat.eatFood(argThat(startsWith(&quot;dry&quot;)), hungry: true)).thenReturn(true);expect(cat.eatFood(&quot;fish&quot;), isTrue);expect(cat.walk([&quot;roof&quot;,&quot;tree&quot;]), equals(2));expect(cat.eatFood(&quot;dry food&quot;), isFalse);expect(cat.eatFood(&quot;dry food&quot;, hungry: true), isTrue);// You can also verify using an argument matcher.verify(cat.eatFood(&quot;fish&quot;));verify(cat.walk([&quot;roof&quot;,&quot;tree&quot;]));//参数包含foodverify(cat.eatFood(argThat(contains(&quot;food&quot;))));// You can verify setters.cat.lives = 9;verify(cat.lives=9);如果一个参数不是 ArgMatcher， （如 any、 anyNamed、 argThat、 captureThat、等) 传递给 mock 方法的参数，那么 equals 匹配器用于参数匹配。 如果需要更严格的匹配，考虑下使用 argThat(identical(arg))。尽管这样，注意 null 不能用作 ArgMatcher 参数相邻的参数，或传递一个未包装的值作为命名参数。例如：verify(cat.hunt(&quot;backyard&quot;, null)); // OK：没有参数匹配器verify(cat.hunt(argThat(contains(&quot;yard&quot;)), null)); // BAD: 相邻参数为 nullverify(cat.hunt(argThat(contains(&quot;yard&quot;)), argThat(isNull))); // OK: 使用参数匹配器包装verify(cat.eatFood(&quot;Milk&quot;, hungry: null)); // BAD: 使用 null 作为命名参数verify(cat.eatFood(&quot;Milk&quot;, hungry: argThat(isNull))); // BAD: 使用 null 作为命名参数```### 命名参数关于此语法，Mockito 现在有一个尴尬的麻烦：命名参数和参数匹配器需要比想象中更多的配置：必须在参数匹配器中声明参数的名称。这是因为我们无法依赖命名参数的位置，并且语言没有提供一个机制来回答 ”这个元素是在用作命名元素” 吗？```dart// GOOD: argument matchers include their names.when(cat.eatFood(any, hungry: anyNamed(&#x27;hungry&#x27;))).thenReturn(true);when(cat.eatFood(any, hungry: argThat(isNotNull, named: &#x27;hungry&#x27;))).thenReturn(false);when(cat.eatFood(any, hungry: captureAnyNamed(&#x27;hungry&#x27;))).thenReturn(false);when(cat.eatFood(any, hungry: captureThat(isNotNull, named: &#x27;hungry&#x27;))).thenReturn(true);// BAD: argument matchers do not include their names.when(cat.eatFood(any, hungry: any)).thenReturn(true);when(cat.eatFood(any, hungry: argThat(isNotNull))).thenReturn(false);when(cat.eatFood(any, hungry: captureAny)).thenReturn(false);when(cat.eatFood(any, hungry: captureThat(isNotNull))).thenReturn(true); 校验验证精确的调用次数&#x2F;至少x次&#x2F;永不123456789101112131415161718192021222324252627282930313233343536cat.sound();cat.sound();// Exact number of invocationsverify(cat.sound()).called(2);// Or using matcherverify(cat.sound()).called(greaterThan(1));// Or never calledverifyNever(cat.eatFood(any));验证顺序cat.eatFood(&quot;Milk&quot;);cat.sound();cat.eatFood(&quot;Fish&quot;);verifyInOrder([ cat.eatFood(&quot;Milk&quot;), cat.sound(), cat.eatFood(&quot;Fish&quot;)]);为之后的断言捕获参数capturedcaptured会存储调用参数// Simple capturecat.eatFood(&quot;Fish&quot;);expect(verify(cat.eatFood(captureAny)).captured.single, &quot;Fish&quot;);// Capture multiple callscat.eatFood(&quot;Milk&quot;);cat.eatFood(&quot;Fish&quot;);expect(verify(cat.eatFood(captureAny)).captured, [&quot;Milk&quot;, &quot;Fish&quot;]);// Conditional capturecat.eatFood(&quot;Milk&quot;);cat.eatFood(&quot;Fish&quot;);expect(verify(cat.eatFood(captureThat(startsWith(&quot;F&quot;)))).captured, [&quot;Fish&quot;]); Nice mocks vs classic mocksMockito有两种生成mocks的API，使用标注@GenerateNiceMocks和@GenerateMocks。推荐使用@GenerateNiceMocks，两者不同点： Nice Mocks：Nice Mocks是默认的模拟对象类型。它们在调用未定义的方法时会返回默认值，如0、null或空列表。这使得测试代码更容易编写，因为您不需要为每个未使用的方法定义行为。Nice Mocks适用于大多数情况下，特别是当您只关注被测试对象的部分行为时。 Classic Mocks：Classic Mocks是严格的模拟对象类型。它们在调用未定义的方法时会抛出异常。Classic Mocks适用于需要精确控制模拟对象行为的情况，特别是当您希望确保被测试对象只调用模拟对象上的特定方法时 使用Fake来模拟类12345678910111213141516171819202122232425262728293031// 假的类class FakeCat extends Fake implements Cat &#123; @override bool eatFood(String food, &#123;bool? hungry&#125;) &#123; print(&#x27;Fake eat $food&#x27;); return true; &#125;&#125;void main() &#123; // 在运行时创建一个新的假 Cat（实例）。 var cat = FakeCat(); cat.eatFood(&quot;Milk&quot;); // 打印 &#x27;Fake eat Milk&#x27;。 cat.sleep(); // 抛出&#125;模拟抽象类@GenerateMocks([Cat, Callbacks])import &#x27;cat_test.mocks.dart&#x27;abstract class Callbacks &#123; Cat findCat(String name);&#125;void main() &#123; var mockCat = MockCat(); var findCatCallback = MockCallbacks().findCat; when(findCatCallback(&#x27;Pete&#x27;)).thenReturn(mockCat);&#125; 参考 使用Mockito模拟依赖关系 https://pub-web.flutter-io.cn/packages/mockito Readme中文说明文档 Flutter如何Mock MethodChannel进行单元测试","tags":[{"name":"Flutter 单元测试","slug":"Flutter-单元测试","permalink":"http://airshu.github.io/tags/Flutter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"单元测试","slug":"Flutter/单元测试","permalink":"http://airshu.github.io/categories/Flutter/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"Flutter命令详解","date":"2023-12-24T13:26:24.681Z","path":"wiki/Flutter/Flutter命令详解/","text":"create在指定的目录中,创建新的flutter项目,如果没有指定目录,则在当前目录下创建项目 12345flutter create ~/flutter #在家目录下的flutter目录项目flutter create . #在当前目录下创建flutter create -t module flutter_module # 创建一个module -v查看APP所有日志的输出,对于调试是非常有用处,在调试时需要配合run命令使用 1flutter -v run -d切换在不同设备上运行app,如果没有指定设备,默认将会使用设备列表的第一个设备,这对于计算机连接多个设备时非常有用,可以使用设备名称或者设备id作为参数 123flutter run -d NX569J #设备名称flutter run -d devices_id #设备id analyze编辑Flutter代码时，使用分析器检查代码是非常重要,默认是分析整个项目的代码,你也可以通过使用analysis_options.yaml文件来排除不需要的代码分析 analysis_options.yaml 123analyzer:exclude:- flutter/** 有时候你可能需要代码分析一直在运行,可以使用–watch选项 flutter analyze –watch 当运行分析命令flutter都执行一次pub get命令,如果不需要运行,可以执行以下命令 flutter analyze –no-pub attach相当于命令flutter run命令,不同之处在很多执行都是自己手动,比如热重载, build构建应用程序的apk,appbundle,aot,iOS, iOS应用需要在Mac上构建 1234flutter build apkflutter build apk --debugflutter build appbundle channel切换flutter不同的版本,在执行flutter channel会输出不同分支信息,默认使用stable分支。 有四个分支： master dev beta stable 123flutter channel # 输出channelflutter channel dev # 切换到dev channel clean删除build/和.dart_tool/目录,清除缓存信息,避免之前不同版本代码的影响 config可以用于指定gradle,android sdk,android studio的目录或者开启,禁用analytics选项,analytics选项用于flutter工具的报告 1flutter config --gradle-dir /gradle/ devices列出已经连接到计算机的设备 123flutter devicesNX569J • 192.168.43.1:5555 • android-arm64 • Android 7.1.2 (API 25)Android SDK built for x86 • emulator-5554 • android-x86 • Android 9 (API 28) (emulator) doctor检查开发工具链是否完整安装,对于安装环境非常有用处 12345678910flutter doctorDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, v1.2.1, on Linux, locale en_US.UTF-8)[✓] Android toolchain - develop for Android devices (Android SDK version 28.0.3)[✓] Android Studio (version 3.3)[✓] VS Code (version 1.33.1)[✓] Connected device (2 available)• No issues found! drive执行flutter ui测试,该工具类似与web端的Selenium,WebDriver,Protractor.你可以指定不同模式进行测试,可以是debug,profile,release,flavor模式,flavor模式可以指定平台规范,你还可以指定在不同的平台测试,甚至可以指定页面路由 1flutter drive --debug --target-platform android-x86 emulators列出,创建,启动模拟器,默认是列出模拟器 1234flutter emulators --launch flutter_emulator #启动flutter emulators # 列出flutter emulators --create Pixel_API_28 # 创建 format按照dart代码规范格式项目代码文件,flutter format .是当前项目所有文件,也可以指定目录或者文件 1flutter format dartfile run参考：源码解读Flutter run机制 flutter build apk：通过gradle来构建APK，由以下两部分组成： flutter build aot，分为如下两个核心过程，该过程详情见下一篇文章 frontend_server前端编译器生成kernel文件 gen_snapshot来编译成AOT产物 - flutter build bundle，将相关文件放入flutter_assets目录 通过adb install来安装APK 通过adb am start来启动应用 123456# profile方式运行，对于Profile模式，启动Observatory调试器，可通过127.0.0.1:xxx地址，打开网页版性能分析工具Observatory，其中包含有timeline工具，类似于Android的systrace。flutter run --profile --disable-service-auth-codes --local-engine-src-path=&lt;FLUTTER_ROOT&gt;/engine/src --local-engine android_profile# 关闭鉴权flutter run --disable-service-auth-codes 参数 说明 –debug 调试版本，这是默认模式 –profile profile版本 –release 发布版本 –target-platform 指定app运行的目标平台，比如android-arm&#x2F;android-arm64，iOS平台不可用 –target&#x3D; 主入口，默认值lib&#x2F;main.dart –observatory-port 指定observatory端口，默认为0（随机生成可用端口） –disable-service-auth-codes 关闭observatory服务鉴权 –trace-startup 跟踪应用启动&#x2F;退出，并保存trace到文件 –trace-skia 跟踪skia，用于调试GPU线程 –trace-systrace 转为systrace，适用于Android&#x2F;Fuchsia –dump-skp-on-shader-compilation 转储触发着色器编译的skp，默认关闭 –verbose-system-logs 包括来自flutter引擎的详细日志记录 –enable-software-rendering 开启软件渲染，默认采用OpenGL或者Vulkan –skia-deterministic-rendering 确定性采用skia渲染 –no-hot 可关闭热重载，默认是开启 –start-paused 应用启动后暂停 –local-engine-src-path 指定本地引擎源码路径，比如xxx&#x2F;engine&#x2F;src –local-engine 指定本地引擎类型，比如android_profile verion列出或者切换flutter版本,默认是列出所有版本 12flutter versionflutter version v1.5.8 upgrade更新flutter代码,实质就是git代码更新拉取,下载flutter sdk是git仓库的打包 test运行flutter单元测试,可以使用--start-paused模式等待调试器的连接,--concurrency可以指定并发任务数默认值是6 1flutter test --concurrency=8 install安装app到一个已经连接的设备 1flutter install screenshot截取当前屏幕,默认是将图片输出到家目录下,使用-o指定输出目录 1flutter screenshot -o /home/work packages获取,测试,更新依赖包,flutter pub 将会传递剩余参数到dart工具的pub pub12345678910111213141516flutter pub get #获取依赖flutter pub deps #用于显示当前Package使用的所有依赖项flutter pub cache add/clear/repair #管理本地Package缓存flutter pub upgrade #检索当前Package所依赖的其他Package的最新版本，如果pubspec.lock存在，则忽略其保存的版本并以pubspec文件中指定的最新版本为主。pub run 命令可以调用当前 Package 或当前 Package 所依赖的其它 Package 中的 Dart 脚本。pub global 命令可以让你使用那些可以全局可用的 Package。pub publish #发布 修改源码调试 &#x2F;path&#x2F;to&#x2F;flutter&#x2F;bin&#x2F;cache&#x2F;flutter_tools.stamp 当你修改了flutter tools的源码，删除上面这个文件，代码即可生效 参考 Flutter Tools 断点调试","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"北京游玩攻略：清华北大","date":"2023-12-24T13:26:04.320Z","path":"wiki/随笔/北京游玩攻略/清华北大/","text":"历史背景景点介绍博雅塔未名湖图书馆路线游客只能从东侧门进入（地铁站北京大学A口向北），要求19:00前由东侧门离开。 就餐家园四层、农园三层、艺园二层、勺园西餐厅 门票预约北大公众号预约，每天早上8点开放，提前一周预约。","tags":[{"name":"旅游 清华北大","slug":"旅游-清华北大","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E6%B8%85%E5%8D%8E%E5%8C%97%E5%A4%A7/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"北京游玩攻略：长城","date":"2023-12-24T13:26:04.320Z","path":"wiki/随笔/北京游玩攻略/长城/","text":"景点介绍八达岭长城 介绍：是明長城的一個隘口，岔道城、古炮、关城、敌楼、烽火台、战台 營業時間： 07:30-16:00營業 地址：北京市延慶區G6京藏高速58號出口 tips：如果想一天内游长城和十三陵，建议报团一日游，两地相距甚远 清河站坐高铁直达八达岭长城（20分钟） 慕田峪长城（推荐） 介绍 司马台长城 介绍：位于北京市的远郊，接近古北水镇，是长城中保存得最为完好的一段，也是最为危险的一段长城 居庸关长城 介绍：位于北京市昌平区的一段长城，也是历史上重要的军事关口。其得名于其地理位置，“居”和“庸”在古汉语中分别代表“中间”和“险要”，因此，“居庸关”意为“处在险要中间的关口” 金山岭长城 介绍：金山岭长城位于河北省承德市，是长城的精华段落之一。它以雄伟壮观的长城和美丽的自然风光而闻名。金山岭长城蜿蜒于山岭之间，城墙、敌楼、马面和烽火台等长城元素保存完好。金山岭长城是长城摄影的热门地点，也是徒步者的天堂 路线门票预约","tags":[{"name":"旅游 长城","slug":"旅游-长城","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E9%95%BF%E5%9F%8E/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"北京游玩攻略：颐和园","date":"2023-12-24T13:26:04.320Z","path":"wiki/随笔/北京游玩攻略/颐和园/","text":"历史背景路线 西郊宾馆坐地铁到北宫门站 北宫门走几百米到北如意门 宿云檐城关 石舫、清晏舫画中游长廊排云门乘船去南湖岛十七孔桥八方亭铜牛文昌阁玉澜堂乐寿堂仁寿殿东宫门西苑站","tags":[{"name":"旅游 颐和园","slug":"旅游-颐和园","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E9%A2%90%E5%92%8C%E5%9B%AD/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"北京游玩攻略：恭王府","date":"2023-12-24T13:26:04.312Z","path":"wiki/随笔/北京游玩攻略/恭王府/","text":"恭王府 介绍：和珅住处，恭亲王住处，银安殿、嘉乐堂、锡晋斋、王府花园。戏楼内可欣赏北京传统节目演出、喝茶、品小吃 地址：北京市西城區前海西街17號 路线： tips：福厅需要预约 游玩路线","tags":[{"name":"旅游 恭王府","slug":"旅游-恭王府","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E6%81%AD%E7%8E%8B%E5%BA%9C/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"北京游玩攻略：故宫","date":"2023-12-24T13:26:04.312Z","path":"wiki/随笔/北京游玩攻略/故宫/","text":"历史背景故宫是中国明清两朝二十四位皇帝的皇宫。故宫始建于明成祖永乐四年（1406年），永乐十八年（1420年）落成。 故宫南北长961米，东西宽753米，四面围有高10米的城墙，外有59米宽的护城河环绕。有四座城门，南面为午门，北面为神武门，东面为东华门，西面为西华门。城墙的四角，各有一座风姿绰约的角楼，民间有九梁十八柱七十二条脊之说，来形容其结构的复杂。城内的建筑分为外朝和内廷两部分。外朝的中心为太和殿、中和殿、保和殿，统称三大殿，是国家举行大典礼的地方。三大殿左右两翼辅以文华殿、武英殿两组建筑。内廷的中心是乾清宫、交泰殿、坤宁宫，统称后三宫，是皇帝和皇后居住的正宫。其后为御花园。后三宫两侧排列着东、西六宫，是后妃们居住休息的地方。东六宫东侧是天穹宝殿等佛堂建筑，西六宫西侧是中正殿等佛堂建筑。外朝、内廷之外还有外东路、外西路两部分建筑。 主要建筑故宫在辛亥革命之前称为“紫禁城”。它的名字来自“紫微星垣”，中国古代星像学家把天上的星星分为三垣，四象，二十八星宿等。其中三垣指紫微星垣，太微星垣和天市星垣。紫微星垣居于正中，据传皇天上帝的居所（紫宫）就在紫微星垣中，人间皇帝自称“天子”便仿皇天上帝居所的名字用其“紫”字为紫禁城。故宫是以黄瓦、红墙、金饰、白石构成的建筑群。其中黄色琉璃瓦是天子的象征。 城池故宫有4座主要的城门，分别是南面午门、北面神武门、东面东华门、和西面西华门。 午门建于明永乐十八年（1420年），清顺治年间重建。楼阁巍峨，十分壮观，是故宫建筑群的第一高楼。平面呈倒“凹”字型，分上下两部分。上部正中为门楼一座，面阔9间，进深5间，重檐庑殿顶。两侧有重檐攒尖顶的方亭。下部为敦台，正中开三门，两侧各有一掖门。中门为皇帝出入专用，但在清代，新科状元、榜眼、探花在发榜之日可以从该门进出一次。此外，皇帝结婚时，皇后可以乘轿从中门进入，其他文武官员从左门进出，宗室王公从右门进出。清代时，午门还是皇帝每年冬至颁发下一年历书之处。遇有战争获胜，也在此处举行凯旋、“献俘”的仪式。午门前两侧有阙左门、阙右门。 神武门建于明永乐十八年（1420年），原名“玄武门”。清康熙帝（玄烨）即位为避讳所以将其易名“神武门”。原来门楼上设有钟鼓，每日起更、黄昏时鸣钟108响。清代，该门是帝后巡幸和去京西各园时进出的大门。当选秀女时，此门也是被选女子出入紫禁城的通道。 东华门和西华门分别是故宫的东西两道侧门。 外朝外朝中路-太和门广场是紫禁城内最大的宫门，也是紫禁城外朝宫殿的正门。是自天安门南侧向北进紫禁城时经过的第四道门（前三道依次为天安门、端门、午门）。太和门面阔九间，进深三间。明初称“奉天门”，后称“皇极门”，清朝时称“太和门”，全高二十三点八米。现存的太和门是光绪年间重建的。明朝规定，文武官员每天拂晓在奉天门早朝，皇帝也亲自到此处接受朝拜和处理政务，称为“御门听政”。清初，皇帝曾在太和门受朝、赐宴等，但御门听政改在乾清门举行。 外朝中路-前三殿太和殿、中和殿、保和殿合称“三大殿”。这三大殿连同与东侧文华殿、西侧武英殿合称为“外朝”。 太和殿：俗称“金銮殿”，明初称“奉天殿”，后称“皇极殿”，清朝时称“太和殿”。袁世凯登基时一度改名为“承运殿”。“太和”二字取自《易经》乾卦“乾道变化，各正性命，保合太和，乃利贞”一句，是说宇宙间一切关系都得到协调的意思。建在有汉白玉围栏的三层高大露台上，为“前三殿”之第一殿，殿高三十五米，面积2381平方米，是中国最大的一座木结构宫殿。面阔十一间，进深五间，为中国古代殿宇最高等级的重檐庑殿顶。檐角有十个走兽，为中国古建筑之特例。太和殿是举行新皇帝登基、颁布重要诏书、“金殿传胪”（公布新进士名单）、派大将出征以及每年元旦节、冬至节、皇帝生日，册封皇后，为太皇或太后加徽号等等重大仪式的地方。 中和殿：在明初时称为“华盖殿”，后来称为“中极殿”，至清代时称为“中和殿”。袁世凯登基时一度改名为“体元殿”。“中和”二字是说凡事要做到不偏不倚，才能使各方面关系处理得协和调顺，符合中庸之道。面阔、进深各3间。四角攒尖顶。内设宝座，皇帝参加大典前先在此休息，或由近臣演习礼仪。 保和殿：在明初时称为“谨身殿”，后称“建极殿”，清朝时称“保和殿”。袁世凯登基时一度复名为“建极殿”。“保和”二字是说要保持事物间的协调关系。面阔九间，进深五间。重檐歇山顶。宴请外藩王公大臣的场所。从乾隆开始，殿试由太和殿移到此举行。 外朝东路 文华殿 文华门 主敬殿 本仁殿、集义殿 文渊阁 传心殿：位于紫禁城东南隅的文华殿东侧，为清朝皇帝御经筵前举行“祭告礼”之所。 治牲所 景行门 大庖井 銮仪卫 銮驾库、仪仗库 内阁 内阁大堂（大学士堂） 汉票签房、蒙古堂、汉本堂、满本堂、祝版房、满票签房、稽查房、满票签档子房、典籍厅、汉本库 内阁大库（红本库、实录库） 箭亭 外朝西路-武英殿 武英门 敬思殿 凝道殿、焕章殿 恒寿斋、浴德堂 断虹桥 方略馆、回子学、缅子学 咸安宫（宝蕴楼） 南薰殿、御书处 激桶处 南大库（武器库、灯库、木库、鞍䩞库）、干肉库、外瓷器库 内廷内廷中路-乾清门广场 乾清门：乾清门广场是一个东西长、南北窄的矩形广场。广场西面是隆宗门，东面是景运门。这个小广场是故宫外朝和内廷的分界。清初“御门听政”在此举行。清康熙时，在此处听政最多，至咸丰以后就不再实行了。乾清门西侧有一排消防，东为侍卫值房，西为内务府值房，中间为军机值房，俗称“军机处”。 景运门、隆宗门 军机处 内廷中路-后三宫 乾清宫：故宫“后三宫”之第一宫。连廊面阔9间，进深5间，重檐庑殿顶。崇祯于此宫内迫周皇后悬梁自尽。清康熙时为康熙幼年时代寝室。内有“正大光明”匾，清朝雍正设“秘密立储”制度后传位诏书藏此匾后。此处为明清两朝礼制上的皇帝正寝，直到清初也是皇帝在紫禁城里的寝宫，和召见王公大臣，处理政务的地方。而至清代第三个皇帝雍正移居养心殿后，皇帝就不居住于此。 日精门、月华门 端凝殿、懋勤殿 昭仁殿、弘德殿 交泰殿：故宫“后三宫”之第二宫。面阔进深匀为3间，单檐攒尖顶。该殿是皇后过生日举办寿庆活动的地方。 坤宁宫：故宫“后三宫”之第三宫。清顺治十二年（1655年），该宫仿照沈阳故宫重建。面阔连廊9间，进深3间，重檐庑殿顶。此处为明清两朝礼制度上的皇后正寝，明朝皇后一般也居住于此处。清朝入关后，仿照沈阳清宁宫的布局进行了改造而成为深具满族特色的建筑，其中殿身西五间为萨满教神殿，东两间的暖阁为帝后成婚的大婚喜房。 内廷中路-御花园 天一门、钦安殿 绛雪轩、养性斋 万春亭、千秋亭 浮碧亭、澄瑞亭 堆秀山、延晖阁 摛藻堂、位育斋 凝香亭、玉翠亭 四神祠 顺贞门、承光门、延和门、集福门 内廷西路─养心殿养心殿：清朝自雍正之后，皇帝在故宫内的实际居所。慈禧、慈安二太后垂帘听政就在养心殿东暖阁。内设宝座、御案，皇帝在此办理日常政务及接见大臣。 内廷西路─西六宫 永寿宫 太极殿（启祥宫） 体元殿 怡性轩、乐道堂 长春宫 绥寿殿、承禧殿 怡情书史 益寿斋、乐志轩 翊坤宫 延洪殿（庆云斋）、元和殿（道德堂） 体和殿 平康室、益寿斋 储秀宫 养和殿、缓福殿 丽景轩 凤光室、猗兰馆 咸福宫 同道堂 内廷西路─重华宫区（原乾西五所） 漱芳斋 漱芳斋戏台 重华宫：乾隆皇帝修建，是笃信藏传佛教乾隆信仰佛堂：重华是古代典籍对舜帝敬称，大臣张廷玉建议以此为宫区命名，乾隆欣然采纳。 崇敬殿 葆中殿、浴德殿 翠云馆 重华宫厨房 建福宫 抚辰殿 惠风亭 建福宫花园 延春阁、敬胜斋、碧琳馆、凝晖堂、玉壶冰、积翠亭、吉云楼 静怡轩、慧曜楼 内廷西路─延庆殿、中正殿 延庆殿 中正殿 雨花阁：位在重华宫西南端，是紫禁城内最具藏传佛教风格建筑，内为喇嘛佛堂菩萨佛像数尊 梵宗楼 宝华殿 香云亭 淡远楼 内廷外西路 慈宁宫 慈宁门 大佛堂 西三所（头所殿、二所殿、三所殿） 寿三宫（西宫殿、中宫殿、东宫殿） 寿康宫 慈宁宫花园 临溪亭 含清斋、延寿堂 咸若馆 宝相楼、吉云楼 慈荫楼 寿安宫 春禧殿 福宜斋、萱寿堂 英华殿 英华门 英华殿碑亭 内廷东路─斋宫、毓庆宫、奉先殿 斋宫 诚肃殿 毓庆宫：清朝皇帝十岁以后自立生活之寝宫。 继德堂 惇本殿 奉先殿 内廷东路─东六宫 景仁宫 承乾宫 贞顺斋、明德堂 锺粹宫 膺天庆、绥万邦 延禧宫 灵沼轩 永和宫 同顺斋 景阳宫 御书房 静观斋、古鉴斋 内廷东路─乾东五所 如意馆 寿药局 敬事房 四执库 古董房 内廷东路其他院落 玄穹宝殿 茶库、缎库 景山景山公园位于中国北京市西城区的景山前街，西临北海，南与故宫神武门隔街相望，是元、明、清三代的御苑。公园坐落在明清北京城的中轴线上，公园中心的景山，曾是全城的制高点。 在元、明、清三代，景山及其附属建筑不仅是一座供游赏的皇家园林，还具有习射、停灵、祭祖、官学、躬耕、戏曲、宗教等多重功能。目前公园占地23公顷，园内松柏葱郁，游人如织，是北京皇城内独具特色的所在。 路线 按照红色路线图进行游玩，出神武门到景山俯瞰整个皇城 参考 https://zh.wikipedia.org/zh-hans/%E6%95%85%E5%AE%AB https://zh.wikipedia.org/wiki/%E6%99%AF%E5%B1%B1%E5%85%AC%E5%9B%AD","tags":[{"name":"旅游 故宫","slug":"旅游-故宫","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E6%95%85%E5%AE%AB/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"","date":"2023-12-24T13:26:04.303Z","path":"wiki/随笔/北京游玩攻略/吃/","text":"","tags":[],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"北京游玩攻略","slug":"随笔/北京游玩攻略","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/%E5%8C%97%E4%BA%AC%E6%B8%B8%E7%8E%A9%E6%94%BB%E7%95%A5/"}]},{"title":"北京游玩攻略：天坛","date":"2023-12-24T13:26:04.303Z","path":"wiki/随笔/北京游玩攻略/天坛/","text":"历史背景 介绍：明、清兩朝皇帝祭天、求雨和祈禱豐收的專用祭壇，整個天壇分為內壇、外壇兩部分，祈年殿、回音壁等知名的建築都位於內壇。遊玩天壇，除了觀感受古代帝王祭天的宏大場面外，回音壁、三音石等巧妙的設計也值得一看 地址：北京市東城區天壇路甲1號 购票指南：24点放票，公众号购票 游玩路线 从东门入，通过七星石和七十二长廊到达最核心的景点祈年殿。 从祈年殿通过丹陛桥往南到达皇穹宇、三音石和回音壁，再往南到达圜丘坛。 最后您还可以去西边的万寿亭、百花园、和斋宫参观。","tags":[{"name":"旅游 天坛","slug":"旅游-天坛","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E5%A4%A9%E5%9D%9B/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"","date":"2023-12-24T13:26:04.294Z","path":"wiki/随笔/北京游玩攻略/住/","text":"","tags":[],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"北京游玩攻略","slug":"随笔/北京游玩攻略","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/%E5%8C%97%E4%BA%AC%E6%B8%B8%E7%8E%A9%E6%94%BB%E7%95%A5/"}]},{"title":"北京游玩攻略：十三陵","date":"2023-12-24T13:26:04.294Z","path":"wiki/随笔/北京游玩攻略/十三陵/","text":"历史背景十三陵是明朝皇帝的墓葬建筑群。自永乐七年五月（1409年）起用，直到安葬崇祯帝后结束，历时230多年，共葬有13位皇帝，23位皇后、2位太子、30余名妃嫔、1位太监，是全球保存最完整的皇陵墓葬群之一。 明朝共有16位皇帝，但北京的明十三陵只有13位皇帝，未入陵者因由各异。明朝开国皇帝朱元璋早年建都于南京，死后葬于南京紫金山的“孝陵”；继位的长孙惠帝朱允炆，在其叔父燕王朱棣（即后来的成祖）发起“靖难之役”攻破南京之后下落不明，加上成祖不承认其帝位，因此没有帝陵；第七帝代宗朱祁钰，在其兄英宗于土木堡之变被瓦剌所俘之后登上帝位。后来英宗复辟，朱祁钰速死，英宗不承认其帝位，捣毁其在天寿山修建的寿陵。还有一说，寿陵被改建为在位仅29天的光宗陵墓，改名为庆陵。宪宗以亲王身份将他葬于北京西郊金山。金山是安葬妃嫔、早夭的亲王公主（皇子皇女）的皇家陵区。而景泰陵所在地，今为玉泉山。 十三陵的主陵是朱棣于1409年至1413年最早兴建的长陵，他当时经“车驾临视”，钦定山名为“天寿山”，1424年他于北征鞑靼途中驾崩，后安葬于此，但长陵工程直至1427年始全部竣工。期后近20年的兴建，形成长达7公里多的完整建筑群。 13座陵墓中，永乐帝的长陵、嘉靖帝的永陵和万历帝的定陵，均是生前所建，规模亦最大，其余陵墓则是死后才动工，大约会用半年修建。崇祯帝因为是亡国之君，并没有正式建陵，现时的陵墓是以其妃田氏的墓穴改建。 目前，长陵、定陵、昭陵、康陵和神道可供游客参观，其余陵均未开放。 风水布局 十三陵背靠的天寿山麓属于太行山脉，西通居庸关，北通黄花镇，南向昌平州，成为十三陵及京师之北面屏障。太行山起泽州，蜿蜒绵亘北走千百里山脉不断，至居庸关。明末清初学者顾炎武曾指：“群山自南来，势若蛟龙翔；东趾踞卢龙，西脊驰太行；后尻坐黄花（指黄花镇），前面临神京；中有万年宅，名曰康家庄；可容百万人，豁然开明堂。”明代视此为风水地，陵区以常绿的松柏树为主。 十三陵原有一圈围墙（部分依山势，无人工墙体），围墙上有两门、十口。两门为大红门和小红门，十口为榨子口、西山口、德胜口、雁子口、锥石口、贤庄口、灰岭口、老君堂口、东山口和中山口。这些山口为水关（泄洪口）或交通要道。围墙及山口大部分为明朝嘉靖年间，为保护陵寝安全而修建。清朝以后，才允许守陵人住在墙内，陵寝周围也才渐渐出现村庄。围墙和山口现仅存一些遗迹。[2] 石牌坊位于神道的最南端（也是目前陵区最南端保留的地面建筑），建于嘉靖十九年（1540年），此后明代前往陵区的官员都要从此下舆改骑马前行，以示尊敬。石牌坊北1.5公里为陵区门户大红门。大红门为单檐庑殿顶，黄琉璃瓦，下辟券门三洞。中门为帝后棺椁、神御物等通过，东门为皇帝前来朝拜通道，西门为大臣们的通道[3]。 明十三陵依山而建，沿袭南京孝陵的模式，即除神道共用外，各陵都是前为祭享区，后为墓冢区。陵墓规格相近，各据山头，陵与陵之间相距500米至8000米不等。除思陵偏在西南一隅外，其余均成扇面形分列于长陵左右。亦有陵仿孝陵之制，称有一座叫“哑巴院”的建筑，或更设一座琉璃照壁作为屏幕障。 每座陵墓的陵门设有碑亭，碑文记载皇帝生前的业绩，应由嗣皇帝来撰写。但自从明仁宗为其父朱棣写了一篇3500字的纪功碑文后，再也没有嗣皇帝续写。所以现在除了长陵碑外，其余各陵都成了无字碑。 以规模较大的定陵（万历帝墓）为例，其地面建筑的总布局，呈前方后圆，象征“天圆地方”。地面建筑占地18万平方米，前有宽阔院落三进，后有高大宝城一座。陵墓有祠祭署、宰牲亭、定陵监、神宫监、神马房等附属等建筑物300多间，往后是陵园最外面的围墙－外罗城（围墙外的围墙）。 皇帝陵列表 陵名 皇帝名 年号 长陵 朱棣 永乐 献陵 朱高炽 洪熙 景陵 朱瞻基 宣德 裕陵 朱祁镇 正统天顺 景泰陵 朱祁钰 景泰 茂陵 朱见深 成化 泰陵 朱祐樘 弘治 显陵 朱祐杬 康陵 朱厚照 正德 永陵 朱厚熜 嘉靖 昭陵 朱载坖 隆庆 定陵 朱翊钧 万历 庆陵 朱常洛 泰昌 德陵 朱由校 天启 思陵 朱由检 崇祯 长陵明长陵是明朝第三位皇帝成祖朱棣和皇后徐氏的合葬陵寝。在十三陵中建筑规模最大，营建时间最早，地面建筑也保存得最为完好。它是十三陵中的祖陵 定陵朱翊钧和两皇后的合葬墓 昭陵路线明十三陵开放的陵墓景区只有三个：昭陵、定陵和长陵 路线：定陵—&gt;长陵 乘坐地铁或者公交到达德胜门，并在德胜门乘坐872路公交车直达明十三陵（872为旅游大巴，行驶大约1小时，到达大宫门站） 乘坐地铁昌平线到达终点南邵站，再换乘公交67路到达十三陵 乘坐345支线或886、888路公交车到达昌平东关总站，再换乘314路公交车到达十三陵 神道-&gt;长陵-&gt;定陵-&gt;神道 长陵祾恩殿–建筑经典、金丝楠木大殿","tags":[{"name":"旅游 十三陵","slug":"旅游-十三陵","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E5%8D%81%E4%B8%89%E9%99%B5/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"数据埋点方案","date":"2023-12-24T13:26:04.191Z","path":"wiki/技术开发/技术方案/埋点方案/","text":"数据埋点是一种数据采集方法，主要用于收集用户在使用产品或服务过程中的行为、操作、事件等数据。这些数据可以帮助分析用户行为、优化产品设计、提升用户体验等方面。 数据埋点的规范定义包括以下几点 采集目标明确：明确需要采集的数据类型、目的和范围。 数据准确性：确保采集的数据真实、无误，避免数据污染。 数据完整性：确保采集到的数据能够全面反映用户行为。 低侵入性：尽量不影响用户正常使用产品或服务。 高性能：尽量减少数据采集对产品或服务性能的影响。 数据安全：保护用户隐私，防止数据泄露。 实现过程 确定关键事件：首先，我们需要确定需要观察的关键事件。例如用户访问首页、浏览商品、点击商品、加入购物车、提交订单等。 编写埋点代码：针对这些关键事件，我们会在APP的相应位置编写埋点代码。这些代码就像是我们的“摄像头”，负责捕捉用户的行为信息。例如，在商品详情页的“加入购物车”按钮上，我们会添加一段代码，当用户点击这个按钮时，代码会自动执行，记录用户的操作。 收集数据：埋点代码执行时，会将用户的行为信息发送到我们的数据服务器。这些信息包括用户ID、操作时间、事件类型（如点击、浏览）、事件名称（如加入购物车）等。 数据处理：数据服务器收到这些信息后，会对数据进行清洗、整理和存储，以便后续分析使用。 数据分析：运营和产品团队可以通过数据分析工具查询和分析这些数据，发现用户在购物过程中可能遇到的问题，例如某个环节的流失率较高、某个功能的使用率较低等。 优化改进：根据分析结果，运营和产品团队可以对APP进行优化改进。例如调整商品展示、优化购物流程、增加优惠活动等。并持续关注数据变化，评估优化效果。 埋点类型 业务埋点，产品要求的埋点，比如分享次数，点击购物车次数，某个页面的曝光次数 技术埋点，比如页面加载时间，网络请求时间，内存占用、自定义异常收集等 对于开发人员，我们需要在代码中添加一些埋点的逻辑，比如按钮点击、页面曝光等，这些代码会后续维护性较差，于是出现了无埋点方案，这些方案的核心思想是通过AOP的方式，自动插入埋点代码，从而减少开发人员的工作量。我们实际的工作当中会使用多套方案，比如友盟用来收集基本用户活跃信息、异常信息；GrowingIO用来收集业务埋点信息。 埋点数据平台 Google Analytics 友盟 GrowingIO Sensors Analytics（神策） 参考 ChatGPT：一文搞懂数据埋点的认知、方案、代码实现 美团点评前端无痕埋点实践","tags":[{"name":"埋点 技术方案","slug":"埋点-技术方案","permalink":"http://airshu.github.io/tags/%E5%9F%8B%E7%82%B9-%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"技术方案","slug":"技术开发/技术方案","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"}]},{"title":"数据埋点方案","date":"2023-12-24T13:26:04.191Z","path":"wiki/技术开发/技术方案/App升级方案/","text":"","tags":[{"name":"埋点 技术方案","slug":"埋点-技术方案","permalink":"http://airshu.github.io/tags/%E5%9F%8B%E7%82%B9-%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"技术方案","slug":"技术开发/技术方案","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"}]},{"title":"Firefox插件推荐","date":"2023-12-24T13:26:04.184Z","path":"wiki/工具软件/Firefox插件推荐/","text":"AdGuard去广告神器 https://github.com/AdGuardTeam/AdGuardBrowserExtension In My Pocket将网页内容缓存起来，方便以后阅读，查看。 JSON Lite对json类型格式化显示 OctotreeGithub的文件目录用树形表示 Greasemonkey脚本管理器 Dark Reader设置黑色主题 印象笔记·剪藏保存网页内容到Evernote iCloud书签同步Firefox和Safira书签 New Tab Suspender内存占用过大时，自动挂起标签页。省内存 Sidebery侧边栏标签页管理器。如果使用的笔记本，屏幕的高度是很珍贵的，在使用浏览器时我会尽量节省高度，比如将书签栏隐藏，书签放到跟地址栏同一行。标签栏也可以隐藏，Sidebery可用于在侧边管理标签，相比默认的标签栏，它更方便。可以分组管理，标签可以按树形排列，推荐使用。 如何隐藏Firefox的标签栏Firefox的标签栏是不能隐藏的，但是可以通过修改userChrome.css文件来实现。 设置 about:config中设置：toolkit.legacyUserProfileCustomizations.stylesheets为true 创建userChrome.css文件，打开帮助-&gt;故障排除信息-&gt;点击配置文件夹，进入配置文件夹，创建chrome文件夹，创建userChrome.css文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#main-window:not([drawtitle=&quot;true&quot;]):not([inFullscreen=&quot;true&quot;]) #nav-bar &#123; margin-left : 30px; /* leftTop drag area */ border-right: 140px solid var(--toolbar-bgcolor); &#125;:root[sizemode=&quot;maximized&quot;] #nav-bar &#123; margin-top: 10px !important; /* Top drag area */ margin-left : 0px !important; /* hidden leftTop drag area in Fullscreen mode*/ border-right: 140px solid var(--toolbar-bgcolor); &#125;:root[privatebrowsingmode=&quot;temporary&quot;] #nav-bar &#123; border-right: 180px solid var(--toolbar-bgcolor) !important; &#125;/* move down to hidden titlebar */#titlebar &#123; margin-bottom: -45px !important;&#125;/* move down 3 button on rightTop */.titlebar-buttonbox-container &#123; margin-bottom: -5px !important;&#125;:root[sizemode=&quot;maximized&quot;] .titlebar-buttonbox-container &#123; margin-bottom: -15px !important;&#125;/* move down private icon */.private-browsing-indicator &#123; margin-bottom: -8px !important;&#125;:root[sizemode=&quot;maximized&quot;] .private-browsing-indicator &#123; margin-bottom: -18px !important;&#125;/* hidden horizontal tabbar on top */#tabbrowser-tabs[orient=&quot;horizontal&quot;] &#123; visibility: collapse !important;&#125;#sidebar-box[sidebarcommand=&quot;_0ad88674-2b41-4cfb-99e3-e206c74a0076_-sidebar-action&quot;] sidebarheader &#123; visibility: collapse !important; &#125;","tags":[{"name":"效率","slug":"效率","permalink":"http://airshu.github.io/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"调试方式","date":"2023-12-24T13:26:04.163Z","path":"wiki/JavaScript/ReactNative/调试方式/","text":"使用流程 启动Metro服务 npm start，可以设置不同端口号npm run start –verbose – –port 8082 启动项目npm run android 打开开发者菜单，点击Debug，如果没有打开浏览器调试窗口，可尝试在Settings页面配置IP：Port，设置端口转发 开发人员菜单 Android真机调试方式:摇一摇手机，弹出调试窗口 VS Code中按F1，输入reactnative：显示开发人员菜单 通过adb命令：adb shell input keyevent 82 调试菜单Reload如果只是修改了JS文件，可通过此菜单重新load。如果修改了资源文件则需要重新编译项目。 Change Bundle Location改变打包后的地址 Show Element Inspector显示元素检查器 Disable Fast Refresh禁止快速刷新 Show Perf Monitor显示监控窗口 SettingsEnable Sampling ProfilerDebug点击Debug，会打开浏览器调试窗口，可以在浏览器中通过开发者工具进行debug。可以在浏览器页面reload Android端如何debug 项目根目录启动项目，确保package server启动。localhost:8081可以访问 对于Android5.0+，端口转发，adb reverse tcp:8081 tcp:8081， 打开开发者菜单，选择Setting，配置Debug server host &amp; port for device，输入ip:8081 点击菜单中的Reload 常见问题总结Invariant Violation: Calling synchronous methods on native modules is not supported in Chromehttps://stackoverflow.com/questions/61067004/invariant-violation-calling-synchronous-methods-on-native-modules-is-not-suppor Error: Unable to resolve module .&#x2F;debugger-ui&#x2F;debuggerWorker.xxxx.js尝试打开React Native Debug Menu 页面，重新关闭打开debug https://github.com/facebook/react-native/issues/28844","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"npm使用","date":"2023-12-24T13:26:04.160Z","path":"wiki/JavaScript/ReactNative/npm/","text":"npmnpm配置文件为$Home&#x2F;.npmrc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 查看npm配置文件目录npm config get userconfig# 查看配置项npm config lsnpm config ls -l #查看所有配置项npm config list# 编辑配置文件npm config edit# 获取源地址npm config get registry# 设置源地址# https://registry.npmjs.orgnpm config set registry http://10.193.204.59:8888/repository/group-npm/# 创建package.json文件npm init# 查看所有依赖项npm list# 查看具体依赖的版本npm info react-native# 全局安装xxnpm install electron@12 -g# 安装yarn npm替代工具npm install -g yarn# 更新npm update -g xxx# 卸载npm uninstall --save xx # save指从package.json文件中删除npm publish npmrc配置文件123echo -n &#x27;admin:admin&#x27; | openssl base64 nvm12345678# 查看当前安装的node版本nvm list# 设置默认的node版本nvm alias default v18.17.1 npm与npx的区别npm从5.2.0开始增加了npx命令 npx 使用教程 npx是什么命令？npx和npm有什么区别？","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"React入门","date":"2023-12-24T13:26:04.159Z","path":"wiki/JavaScript/React/基础知识/React入门/","text":"React时一个用于构建用户界面的库，使用JSX（JavaScript和XML）的HTML-in-JavaScript语法。该语法能提升编码效率，浏览器是无法直接解析JSX的，通过Babel或Parcel之类的工具进行编译，生成浏览器能解析的JS代码。 React依赖Node.js。Node包含npm（Node程序包管理器）和npx（Node程序包运行器） 创建React项目 1234#默认使用yarnnpx create-react-app moz-todo-react --use-npmcd moz-todo-reactnpm start 项目文件结构123456789101112131415161718moz-todo-react├── README.md├── node_modules├── package.json├── package-lock.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html #React将src的代码嵌入到这个文件│ └── manifest.json└── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg └── serviceWorker.js React示例-代办列表 官方文档","tags":[{"name":"React","slug":"React","permalink":"http://airshu.github.io/tags/React/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://airshu.github.io/categories/JavaScript/React/"},{"name":"基础知识","slug":"JavaScript/React/基础知识","permalink":"http://airshu.github.io/categories/JavaScript/React/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Redux","date":"2023-12-24T13:26:04.130Z","path":"wiki/JavaScript/React/redux/","text":"了解历史 Flux：https://www.ruanyifeng.com/blog/2016/01/flux.html 基本概念和APIStoreStore是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个Store。 Redux提供createStore这个函数，用来生成Store。 123456789import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(fn);store.getState()store.dispatch()store.subscribe() StateStore对象包含所有数据。如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合，就叫做State。 当前时刻的State，可以通过store.getState()拿到。 1234import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(fn);const state = store.getState(); Redux规定，一个State对应一个View。只要State相同，View就相同。你知道State，就知道View是什么样，反之亦然。 ActionState的变化，会导致View的变化。但是，用户接触不到State，只能接触到View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。 Action是一个对象。其中的type属性是必须的，表示Action的名称。其他属性可以自由设置，社区有一个规范可以参考。 1234&#123; type: &#x27;ADD_TODO&#x27;, payload: &#x27;Learn Redux&#x27;&#125; Action CreatorView要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦。可以定义一个函数来生成Action，这个函数就叫Action Creator。 12345678const ADD_TODO = &#x27;添加 TODO&#x27;;function addTodo (text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; store.dispatch()store.dispatch()是View发出Action的唯一方法。 1234567import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(fn);store.dispatch(&#123; type: &#x27;ADD_TODO&#x27;, payload: &#x27;Learn Redux&#x27;&#125;); ReducerStore收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。 Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。 Reducer 必需符合以下规则： 仅使用 state 和 action 参数计算新的状态值 禁止直接修改 state。必须通过复制现有的 state 并对复制的值进行更改的方式来做 不可变更新（immutable updates）。 禁止任何异步逻辑、依赖随机值或导致其他“副作用”的代码 1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case &#x27;ADD&#x27;: return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: &#x27;ADD&#x27;, payload: 2&#125;); store.subscribe()Store允许使用store.subscribe方法设置监听函数，一旦State发生变化，就自动执行这个函数。 1234import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(fn);store.subscribe(listener); 123456789# 安装Redux Toolkitnpm install @reduxjs/toolkityarn add @reduxjs/toolkit#npx create-react-app my-app --template reduxnpx create-react-app my-app --template redux-typescript React ReduxReact Toolkit参考 https://redux-toolkit-cn.netlify.app/introduction/quick-start https://react-redux.js.org/introduction/getting-started","tags":[{"name":"JavaScript Redux","slug":"JavaScript-Redux","permalink":"http://airshu.github.io/tags/JavaScript-Redux/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://airshu.github.io/categories/JavaScript/React/"}]},{"title":"异常分析","date":"2023-12-24T13:26:04.081Z","path":"wiki/Flutter/未分类/异常分析/","text":"Crash文件 符号化iOS crashsdk文档是什么意思 转载Symbolicating stack traces for engine crashesFlutter 引擎崩溃分析方法简介","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"rtw","date":"2023-12-24T13:26:04.080Z","path":"wiki/Flutter/开源库/rtw/","text":"https://pub.dev/packages/rfw rfw（Remote Flutter Widgets）库是一个用于在 Flutter 应用程序中渲染远程部件树的库。它提供了一种动态加载和渲染远程部件的机制，使得应用程序可以在运行时根据远程数据来构建用户界面。 rfw 库的作用包括： 动态加载远程部件：rfw 库允许应用程序从远程位置动态加载部件树的描述。这意味着您可以将部件树的描述存储在远程服务器上，并在应用程序运行时根据需要加载和渲染这些部件。 远程数据驱动的用户界面：通过使用 rfw 库，您可以根据远程数据来构建用户界面。您可以将用户界面的描述存储在远程位置，并在应用程序运行时根据远程数据来动态构建和更新用户界面。 支持动态更新和变化：rfw 库支持动态更新和变化。当远程部件树或远程数据发生变化时，您可以使用 rfw 库来更新应用程序的用户界面，而无需重新编译和部署应用程序。 灵活的远程部件管理：rfw 库提供了一套灵活的远程部件管理机制。您可以使用 rfw 库来管理远程部件的加载、缓存和更新，以便在应用程序中实现高效的远程部件渲染。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"《渐行渐远的红利》读书笔记","date":"2023-08-19T09:57:33.298Z","path":"wiki/读书笔记/渐行渐远的红利/","text":"","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Nexus笔记","date":"2023-08-19T09:57:33.298Z","path":"wiki/技术开发/杂项/Nexus笔记/","text":"Nexus作为私有仓库，可以用来存储jar、aar、js库，一般公司内可以搭建一个用来存储共用的库，一来可以提升同步时间，一来统一管理基础库，提升开发效率。 搭建环境123456789101112131415161718192021222324# 下载安装包https://www.sonatype.com/products/sonatype-nexus-oss# 解压到$HOME/tools文件夹下# 设置软链ls -s /Users/liuyunxia/tools/nexus-3.55.0-01-mac/nexus-3.55.0-01 /Users/liuyunxia/tools/nexus-3.55.0-01-mac/nexus-latest# 往 ~/.bash_profile 文件添加如下两行export NEXUS_HOME=/Users/liuyunxia/tools/nexus-3.55.0-01-mac/nexus-latestPATH=$PATH:$NEXUS_HOME/bin# 执行如下命令使添加到 ~/.profile 文件的配置生效source ~/.bash_profilenexus startnexus stopnexus restart 新建npm私有仓库 使用 Maven Publish 插件 使用nexus3配置npm私有仓库","tags":[{"name":"mac","slug":"mac","permalink":"http://airshu.github.io/tags/mac/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"rebase","date":"2023-08-19T09:57:33.298Z","path":"wiki/技术开发/Git/rebase/","text":"当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向基分支的最新提交，最后将刚才提取的修改应用到基分支的最新提交的后面。 在我们的实际操作过程中，会发现要对多次commit进行冲突处理就是因为要生成新的提交记录 在实际开发过程中，rebase一般用于合并主分支代码到开发分支 参考 git rebase详解（图解+最简单示例，一次就懂） 分支的合并 git-rebase","tags":[{"name":"Git","slug":"Git","permalink":"http://airshu.github.io/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Git","slug":"技术开发/Git","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Git/"}]},{"title":"Git使用技巧","date":"2023-08-19T09:57:33.297Z","path":"wiki/技术开发/Git/Git使用技巧/","text":"amend将本地提交和最后一次提交合并成一个新的提交 1git commit --amend rebase 交互式变基9使用场景 调整提交记录的顺序（通过鼠标拖放来完成） 删除你不想要的提交（通过切换 pick 的状态来完成，关闭就意味着你不想要这个提交记录） 合并提交，允许你把多个提交记录合并成一个 123456789101112131415161718192021222324252627282930# Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous# commit&#x27;s log message, unless -C is used, in which case# keep only this commit&#x27;s message; -c is same as -C but# opens the editor# x, exec &lt;command&gt; = run command (the rest of the line) using shell# b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)# d, drop &lt;commit&gt; = remove commit# l, label &lt;label&gt; = label current HEAD with a name# t, reset &lt;label&gt; = reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# . create a merge commit using the original merge commit&#x27;s# . message (or the oneline, if no original merge commit was# . specified); use -c &lt;commit&gt; to reword the commit message## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## 合并最近4条提交记录， -i 表示交互界面git rebase -i HEAD~4 命令参数p, pick &#x3D; use commitpick，简写p，意思是使用commit。git-rebase内的commits默认都是pick命令，意思是选择这个commit，不需要任何改动 r, reword &#x3D; use commit, but edit the commit messagereword, 简写r，意思是使用commit，但是需要编辑（修改）commit message。 e, edit &#x3D; use commit, but stop for amendingedit，简写e，意思是可以暂时停止rebase，此时允许修改文件内容、允许修改commit message，然后继续rebase。 s, squash &#x3D; use commit, but meld into previous commitsquash，简写s，意思是使用commit，但是把修改的内容融入到上一个commit，这个命令用来合并多个commit。 f, fixup &#x3D; like “squash”, but discard this commit’s log messagefixup， 简写f，与squash意思一样，但是直接丢弃commit message。 x, exec &#x3D; run command(the rest of the line) using shellexec，简写x，意思是在rebase过程中执行脚本命令。 d, drop &#x3D; remove commitdrop，简写d，意思是移除commit 参考 Android Studio 实战 git-rebase 交互式变基高阶技巧","tags":[{"name":"Git","slug":"Git","permalink":"http://airshu.github.io/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Git","slug":"技术开发/Git","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Git/"}]},{"title":"cherry-pick","date":"2023-08-19T09:57:33.297Z","path":"wiki/技术开发/Git/cherry-pick/","text":"cherry-pick像摘桃子一样，可以选择具体某个commit记录到当前分支 12# 选择两个提交记录到本分支git cherry-pick commit_1 commit_2","tags":[{"name":"Git","slug":"Git","permalink":"http://airshu.github.io/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Git","slug":"技术开发/Git","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Git/"}]},{"title":"merge","date":"2023-08-19T09:57:33.297Z","path":"wiki/技术开发/Git/merge/","text":"merge用于分支的合并 123git merge branch_name 参数-ff：快速合并 –ff-only：只有能快速合并的时候才合并–no-ff：不使用快速合并，生成一次新的提交记录 如果设置了此参数，即使可以快速合并，也会生成一次新的提交记录 –squash：压缩合并，将待合并的分支的内容压缩成一个新的提交合并进来此种方式用于将多个提交记录合并成一个提交记录，比如进行gerrit review时使用","tags":[{"name":"Git","slug":"Git","permalink":"http://airshu.github.io/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Git","slug":"技术开发/Git","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Git/"}]},{"title":"Mac新系统环境配置","date":"2023-08-19T09:57:33.296Z","path":"wiki/工具软件/Mac/Mac新系统环境配置/","text":"安装必备软件安装Alfred基本配置 配置常用文本 安装Sublime Text安装安装必备workflow安装TinyCal安装Commander One安装Firefox安装ClashX安装BetterZip安装LX Music安装开发环境开发IDE Android Studio XCode Pycharm Visual Studio Code Postman 安装iterm+oh my zsh安装Ruby版本管理使用rbenv 安装Pytho版本管理使用pyenv 安装Java版本管理使用jenv 安装Flutter版本管理使用fvm","tags":[{"name":"效率","slug":"效率","permalink":"http://airshu.github.io/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"滑动原理","date":"2023-08-19T09:57:33.295Z","path":"wiki/Flutter/源码分析/滑动原理/","text":"用到的API Viewport：视窗，滑动可以看见的区域 Scrollable：对手势的处理，实现滑动效果 Sliver：用于在Viewport里面布局和渲染内容 ScrollPosition ScrollDragController ScrollConfiguration ScrollBehavior ScrollActivity ScrollPhysics：可滚动控件的物理特性 BouncingScrollPhysics ：允许滚动超出边界，但之后内容会反弹回来。 ClampingScrollPhysics ： 防止滚动超出边界，夹住 。 AlwaysScrollableScrollPhysics ：始终响应用户的滚动。 NeverScrollableScrollPhysics ：不响应用户的滚动。 在Flutter中： ListView使用的是SliverFixedExtentList或SliverList GridView使用的是SliverGrid PageView使用的是SliverFillViewport SingleChildScrollView内容是单个RenderObject 滑动过程 setCanDrag正式激活 Scrollable中DragGestureRecognizer监听各种事件onDown,对应ScrollableState中_handleDragDown开始，对应ScrollPosition的hold ScrollableState中_handleDragStart，对应ScrollPosition的drag，构造ScrollDragController，切换状态 ScrollableState中_handleDragUpdate，对应Drag的update，手指滑动响应， ScrollableState的_handleDragUpdate，对应Drag的onEnd， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171class ScrollableState &#123; // 对应onDown， void _handleDragDown(DragDownDetails details) &#123; assert(_drag == null); assert(_hold == null); _hold = position.hold(_disposeHold);//ScrollPosition的hold方法创建了HoldScrollActivity &#125; void _handleDragStart(DragStartDetails details) &#123; // It&#x27;s possible for _hold to become null between _handleDragDown and // _handleDragStart, for example if some user code calls jumpTo or otherwise // triggers a new activity to begin. assert(_drag == null); _drag = position.drag(details, _disposeDrag); assert(_drag != null); assert(_hold == null); &#125; void _handleDragUpdate(DragUpdateDetails details) &#123; // _drag might be null if the drag activity ended and called _disposeDrag. assert(_hold == null || _drag == null); _drag?.update(details);//ScrollDragController进行update &#125; void _handleDragEnd(DragEndDetails details) &#123; // _drag might be null if the drag activity ended and called _disposeDrag. assert(_hold == null || _drag == null); _drag?.end(details); assert(_drag == null); &#125;&#125;class ScrollPositionWithSingleContext &#123; @override ScrollHoldController hold(VoidCallback holdCancelCallback) &#123; final double previousVelocity = activity!.velocity; final HoldScrollActivity holdActivity = HoldScrollActivity( delegate: this, onHoldCanceled: holdCancelCallback, ); beginActivity(holdActivity); _heldPreviousVelocity = previousVelocity; return holdActivity; &#125; ScrollDragController? _currentDrag; @override Drag drag(DragStartDetails details, VoidCallback dragCancelCallback) &#123; final ScrollDragController drag = ScrollDragController( delegate: this, details: details, onDragCanceled: dragCancelCallback, carriedVelocity: physics.carriedMomentum(_heldPreviousVelocity), motionStartDistanceThreshold: physics.dragStartDistanceMotionThreshold, ); beginActivity(DragScrollActivity(this, drag)); assert(_currentDrag == null); _currentDrag = drag; return drag; &#125; //切换状态 @override void beginActivity(ScrollActivity? newActivity) &#123; _heldPreviousVelocity = 0.0; if (newActivity == null) &#123; return; &#125; assert(newActivity.delegate == this); super.beginActivity(newActivity); _currentDrag?.dispose(); _currentDrag = null; if (!activity!.isScrolling) &#123; updateUserScrollDirection(ScrollDirection.idle); &#125; &#125;/// 滑动结束时的处理，首先通过 ScrollPhysics 创建一个 Simulation，然后将其传给 BallisticScrollActivity。从 BallisticScrollActivity 的构造函数可以看到，本质上我们也可以将其看作是一个由动画驱动的滑动过程，只不过这个动画是根据一个给定的初始速度创建的 @override void goBallistic(double velocity) &#123; assert(hasPixels); final Simulation? simulation = physics.createBallisticSimulation(this, velocity); if (simulation != null) &#123; //BallisticScrollActivity 与 DrivenScrollActivity 的相似度很高，它们都是在构造函数中先根据提供的信息（simulation，duration、curve等）创建一个 AnimationController，然后监听更新和结束事件，在 _tick 中更新偏移值，在 _end 中结束自己。 beginActivity(BallisticScrollActivity(this, simulation, context.vsync)); &#125; else &#123; goIdle(); &#125; &#125;&#125;class ScrollDragController &#123; @override void update(DragUpdateDetails details) &#123; assert(details.primaryDelta != null); _lastDetails = details; double offset = details.primaryDelta!; //_lastDetails 是为了在之后发送通知的时候，加上这个滑动事件信息，比如 dispatchScrollUpdateNotification if (offset != 0.0) &#123; _lastNonStationaryTimestamp = details.sourceTimeStamp; &#125; // By default, iOS platforms carries momentum and has a start threshold // (configured in [BouncingScrollPhysics]). The 2 operations below are // no-ops on Android. _maybeLoseMomentum(offset, details.sourceTimeStamp); offset = _adjustForScrollStartThreshold(offset, details.sourceTimeStamp); if (offset == 0.0) &#123; return; &#125; if (_reversed) &#123; offset = -offset; &#125; delegate.applyUserOffset(offset);//传递给ScrollPhysics，不同的physics不同的效果 &#125;///是否损失动量的判断///这个过程的目的，是为了判断是否损失动量，我们知道，一般在 ios 的滑动中，连续快速滑动的时候，速度是会积累的，所以后面会越滑越快，而 flutter 为了保持这一特性，就有了动量积累这样一个功能，目前也只在 BouncingScrollPhysics 中才有 /// Determines whether to lose the existing incoming velocity when starting /// the drag. void _maybeLoseMomentum(double offset, Duration? timestamp) &#123; if (_retainMomentum &amp;&amp; offset == 0.0 &amp;&amp; (timestamp == null || // If drag event has no timestamp, we lose momentum. timestamp - _lastNonStationaryTimestamp! &gt; momentumRetainStationaryDurationThreshold)) &#123; // If pointer is stationary for too long, we lose momentum. _retainMomentum = false; &#125; &#125;///当滑动手势结束时，远不意味着整个滑动的结束，为了用户体验，我们赋予滑动速度的概念，那它的滑动也就有动量，所以停止不能只是戛然而止，需要一个慢慢停下来的过程，所以就有了 BallisticScrollActivity 所代表的减速过程，而这个过程的主要控制者，实际为 ScrollPhysics 所生成的 Simulation，不同的 Simulation 相距甚远 @override void end(DragEndDetails details) &#123; assert(details.primaryVelocity != null); // We negate the velocity here because if the touch is moving downwards, // the scroll has to move upwards. It&#x27;s the same reason that update() // above negates the delta before applying it to the scroll offset. double velocity = -details.primaryVelocity!; if (_reversed) &#123; velocity = -velocity; &#125; _lastDetails = details; if (_retainMomentum) &#123; // Build momentum only if dragging in the same direction. final bool isFlingingInSameDirection = velocity.sign == carriedVelocity!.sign; // Build momentum only if the velocity of the last drag was not // substantially lower than the carried momentum. final bool isVelocityNotSubstantiallyLessThanCarriedMomentum = velocity.abs() &gt; carriedVelocity!.abs() * momentumRetainVelocityThresholdFactor; if(isFlingingInSameDirection &amp;&amp; isVelocityNotSubstantiallyLessThanCarriedMomentum) &#123; velocity += carriedVelocity!; &#125; &#125; //此时就是计算一下当前的滑动速度，以便后面进入 BallisticScrollActivity 阶段，也就是 goBallistic 调用 delegate.goBallistic(velocity); &#125;&#125; 参考 Flutter滑动体系 Flutter：图文解析滑动列表原理","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"热重载原理","date":"2023-08-19T09:57:33.295Z","path":"wiki/Flutter/源码分析/热重载原理/","text":"在开发项目中，我们直接点击Hot Reload或Hot Restart按钮可以方便的进行更新，那Flutter是如何实现的呢？ 首次编译：第一次启动会生成全量app.dill文件； 增量编译：对修改的文件编译生成app.dill.incremental.dill增量文件； 更新文件：将增量产物推送到设备中； UI更新：DartVM收到增量文件后进行合并，并通知Flutter引擎更新UI 整个过程并没有让App重启，从而达到高效开发调试效果 参考 解读Flutter中热重载原理","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"Element","date":"2023-08-19T09:57:33.294Z","path":"wiki/Flutter/源码分析/Element/","text":"概念Widget是UI元素的配置数据，Element代表屏幕显示元素。主要作用： 维护这棵Element Tree，根据Widget Tree的变化来更新Element Tree，包括：节点的插入、更新、删除、移动等； 将Widget和RenderObject关联到Element Tree上。 ComponentElement：用来组合其他更基础的Element，开发时常用到的StatelessWidget和StatefulWidget相对应的Element：StatelessElement和StatefulElement。其子节点对应的Widget需要通过build方法创建，该类型Element只有一个子节点。 RenderObjectElement：渲染类Element，对应Renderer Widget，是框架最核心的Element。RenderObjectElement主要包括LeafRenderObjectElement，SingleChildRenderObjectElement，和MultiChildRenderObjectElement。 LeafRenderObjectElement对应的Widget是LeafRenderObjectWidget，没有子节点； SingleChildRenderObjectElement对应的Widget是SingleChildRenderObjectWidget，有一个子节点； MultiChildRenderObjectElement对应的Widget是MultiChildRenderObjecWidget，有多个子节点。 重要属性和方法属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Map&lt;Type, InheritedElement&gt;? _inheritedWidgets;Set&lt;InheritedElement&gt; _dependencies;class InheritedElement extends ProxyElement &#123; final Map&lt;Element, Object?&gt; _dependents = HashMap&lt;Element, Object?&gt;(); void _updateInheritance() &#123; assert(_lifecycleState == _ElementLifecycle.active); final Map&lt;Type, InheritedElement&gt;? incomingWidgets = _parent?._inheritedWidgets; if (incomingWidgets != null) _inheritedWidgets = HashMap&lt;Type, InheritedElement&gt;.of(incomingWidgets); else _inheritedWidgets = HashMap&lt;Type, InheritedElement&gt;(); _inheritedWidgets![widget.runtimeType] = this; &#125;&#125;abstract class Element extends DiagnosticableTree implements BuildContext &#123; // 槽，用来存储一些额外信息，比如坐标 Object? get slot =&gt; _slot; Object? _slot; // element tree上的深度 late int _depth; // 开发人员需要处理的Widget Widget _widget; BuildOwner _owner;//用来处理Element的对象，全局一个，将element tree转换成renderobject tree @override InheritedWidget dependOnInheritedElement(InheritedElement ancestor, &#123; Object? aspect &#125;) &#123; assert(ancestor != null); _dependencies ??= HashSet&lt;InheritedElement&gt;(); _dependencies!.add(ancestor); ancestor.updateDependencies(this, aspect); return ancestor.widget; &#125; @override T? dependOnInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;(&#123;Object? aspect&#125;) &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T]; if (ancestor != null) &#123; return dependOnInheritedElement(ancestor, aspect: aspect) as T; &#125; _hadUnsatisfiedDependencies = true; return null; &#125; @override InheritedElement? getElementForInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;() &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T]; return ancestor; &#125;&#125; 从根节点到子节点，以runtimeType作为key，保存最新的Element对象。getElementForInheritedWidgetOfExactType方法可以通过类型查找离自己最近的类型的对象。dependOnInheritedWidgetOfExactType方法会注册依赖，当InheritedWidget发生变化时就会更新依赖它的子组件。 updateChild123456789/// 父节点通过该方法来修改子节点对应的Widget/// newWidget == null 说明子节点对应的Widget已被移除，直接remove child element/// child == null 说明newWidget是新插入的，通过inflateWidget创建子节点/// child != null 分以下几种情况：/// 1. child.widget == newWidget，说明没变化，若child.slot != newSlot 表明子节点在兄弟节点间移动了位置，通过updateSlotForChild修改child.slot即可；/// 2. widget.canUpdate判断是否可以用newWidget修改child element，若可以则调用update方法；/// 3. 否则先将child element移除，并通过newWidget创建新的element子节点。Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) &#123; &#125; updateElement12345678910111213void update(covariant Widget newWidget) &#123; _widget = newWidget;&#125;void rebuild() &#123; if (_lifecycleState != _ElementLifecycle.active || !_dirty) return; Element? debugPreviousBuildTarget; performRebuild();//ComponentElement中调用build、updateChild&#125;Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) &#123;&#125; StatelessElement1234567@overridevoid update(StatelessWidget newWidget) &#123; super.update(newWidget); assert(widget == newWidget); _dirty = true; rebuild();&#125; rebuild调用performRebuild，调用当前build方法和updateChild。 StatefulElement123456789101112131415161718192021222324252627class StatefulElement extends ComponentElement &#123; //开发者操作的对象，同样有相应生命周期，参考_StateLifecycle State&lt;StatefulWidget&gt;? _state; @override void update(StatefulWidget newWidget) &#123; super.update(newWidget); final StatefulWidget oldWidget = state._widget!; _dirty = true; state._widget = widget as StatefulWidget; try &#123; _debugSetAllowIgnoredCallsToMarkNeedsBuild(true); final Object? debugCheckForReturnedFuture = state.didUpdateWidget(oldWidget) as dynamic; assert(() &#123; if (debugCheckForReturnedFuture is Future) &#123; &#125; return true; &#125;()); &#125; finally &#123; _debugSetAllowIgnoredCallsToMarkNeedsBuild(false); &#125; rebuild(); &#125;&#125; 处理State： 修改_widget属性 调用didUpdateWidget更新属性 然后出发rebuild操作。 ProxyElement123456789101112131415@overridevoid update(ProxyWidget newWidget) &#123; final ProxyWidget oldWidget = widget; super.update(newWidget); updated(oldWidget); _dirty = true; rebuild();&#125;@protectedvoid updated(covariant ProxyWidget oldWidget) &#123; notifyClients(oldWidget);&#125; update方法会通知关联对象Widget有更新。不同子类的notifyClients实现不同。 RenderObjectElement123456789101112131415@overridevoid update(covariant RenderObjectWidget newWidget) &#123; super.update(newWidget); assert(widget == newWidget); assert(() &#123; _debugUpdateRenderObjectOwner(); return true; &#125;()); _performRebuild(); // calls widget.updateRenderObject()&#125;void _performRebuild() &#123; widget.updateRenderObject(this, renderObject); _dirty = false;&#125; SingleChildRenderObject1234567@overridevoid update(SingleChildRenderObjectWidget newWidget) &#123; super.update(newWidget); assert(widget == newWidget); _child = updateChild(_child, widget.child, null);&#125; MultiChildRenderObject123456@overridevoid update(MultiChildRenderObjectWidget newWidget) &#123; super.update(newWidget); _children = updateChildren(_children, widget.children, forgottenChildren: _forgottenChildren); _forgottenChildren.clear();&#125; updateChildren中处理子节点的插入、移动、更新、删除等操作。 inflateWidget12345678910111213141516Element inflateWidget(Widget newWidget, Object? newSlot) &#123; final Key? key = newWidget.key; if (key is GlobalKey) &#123; //如果带有GlobalKey，首先在inactive Elements列表中查找是否有处于inactive状态的节点（即刚从树上移除），如找到就直接复活该节点。 final Element? newChild = _retakeInactiveElement(key, newWidget); if (newChild != null) &#123; newChild._activateWithParent(this, newSlot); final Element? updatedChild = updateChild(newChild, newWidget, newSlot); return updatedChild!; &#125; &#125; final Element newChild = newWidget.createElement(); newChild.mount(this, newSlot);//挂载到树上 return newChild;&#125; mountElement12345678910111213141516void mount(Element? parent, Object? newSlot) &#123; _parent = parent; _slot = newSlot; _lifecycleState = _ElementLifecycle.active; _depth = _parent != null ? _parent!.depth + 1 : 1; if (parent != null) &#123; _owner = parent.owner;//传递owner给子节点 &#125; final Key? key = widget.key; if (key is GlobalKey) &#123; owner!._registerGlobalKey(key, this);//GlobalKey注册自己，方便其他地方使用 &#125; _updateInheritance();&#125; ComponentElement123456789101112131415@overridevoid mount(Element? parent, Object? newSlot) &#123; super.mount(parent, newSlot); assert(_child == null); assert(_lifecycleState == _ElementLifecycle.active); _firstBuild(); assert(_child != null);&#125;void _firstBuild() &#123; // StatefulElement overrides this to also call state.didChangeDependencies. rebuild(); // This eventually calls performRebuild.&#125; 组合型 Element 在挂载时会执行_firstBuild-&gt;rebuild操作。 RenderObjectElement123456void mount(Element parent, dynamic newSlot) &#123; super.mount(parent, newSlot); _renderObject = widget.createRenderObject(this); attachRenderObject(newSlot); _dirty = false;&#125; 创建RenderObject并插入到树上。 SingleChildRenderObjectElement12345@overridevoid mount(Element parent, dynamic newSlot) &#123; super.mount(parent, newSlot); _child = updateChild(_child, widget.child, null);//创建新Element实例&#125; MultiChildRenderObjectElement12345678910void mount(Element parent, dynamic newSlot) &#123; super.mount(parent, newSlot); _children = List&lt;Element&gt;(widget.children.length); Element previousChild; for (int i = 0; i &lt; _children.length; i += 1) &#123; final Element newChild = inflateWidget(widget.children[i], previousChild); _children[i] = newChild; previousChild = newChild; &#125;&#125; 对每个子节点调用inflateWidget。 markNeedsBuild12345678910void markNeedsBuild() &#123; if (!_active) return; if (dirty) return; _dirty = true; owner.scheduleBuildFor(this);&#125; 标记需要重建，其作用是将当前Element加入_dirtyElements，以便在下一帧可以rebuild。以下场景会调用markNeedsBuild： State.setState Element.reassemble：debug hot reload Element.didChangeDependencies： StatefulElement.activate rebuild1234567void rebuild() &#123; if (!_active || !_dirty) return; performRebuild();&#125; 活跃的或脏节点会执行performRebuild，以下场景会调用rebuild： 对于dirty element，在新一帧绘制过程中由BuildOwner.buildScope 在element挂载时，由Element.mount调用 在update方法内被调用 performRebuildComponentElement123456void performRebuild() &#123; Widget built; built = build(); _child = updateChild(_child, built, slot);&#125; 组合型Element，先build自己，再更新子节点 RenderObjectElement1234void performRebuild() &#123; widget.updateRenderObject(this, renderObject); _dirty = false;&#125; 生命周期Element有4种状态：initial，active，inactive，defunct。其对应的意义如下： initial：初始状态，Element刚创建时就是该状态。、 active：激活状态。此时Element的Parent已经通过mount将该Element插入Element Tree的指定的插槽处（Slot），Element此时随时可能显示在屏幕上。 inactive：未激活状态。当Widget Tree发生变化，Element对应的Widget发生变化，同时由于新旧Widget的Key或者的RunTimeType不匹配等原因导致该Element也被移除，因此该Element的状态变为未激活状态，被从屏幕上移除。并将该Element从Element Tree中移除，如果该Element有对应的RenderObject，还会将对应的RenderObject从Render Tree移除。但是，此Element还是有被复用的机会，例如通过GlobalKey进行复用。 defunct：失效状态。如果一个处于未激活状态的Element在当前帧动画结束时还是未被复用，此时会调用该Element的unmount函数，将Element的状态改为defunct，并对其中的资源进行清理。 ComponentElement创建 更新 销毁 RenderObjectElement创建 更新 销毁 总结Element继承自BuildContext，所以我们在平常使用的context其实就是Element。各种of方法其实就是操作Element树来获取相应对象。 参考 深入浅出 Flutter Framework 之 Element","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"PaintingContext","date":"2023-08-19T09:57:33.294Z","path":"wiki/Flutter/源码分析/PaintingContext/","text":"概要 继承自ClipContext，提供裁剪相关辅助方法 _currentLayer、_recorder、_canvas用于具体的绘制操作 _containerLayer 基本概念CanvasCanvas是 Engine(C++) 层到 Framework(Dart) 层的桥接，真正的功能在 Engine 层实现。Canvas 向 Framework 层曝露了与绘制相关的基础接口，如：draw、clip、transform以及scale等，RenderObject 正是通过这些基础接口完成绘制任务的。 通过这套接口进行的所有操作都将被PictureRecorder记录下来。 除了正常的绘制操作(draw*)，Canvas 还支持矩阵变换(transformation matrix)、区域裁剪(clip region)，它们将作用于其后在该 Canvas 上进行的所有绘制操作。 123456789101112131415void scale(double sx, [double sy]);void rotate(double radians) native;void transform(Float64List matrix4);void clipRect(Rect rect, &#123; ClipOp clipOp = ClipOp.intersect, bool doAntiAlias = true &#125;);void clipPath(Path path, &#123;bool doAntiAlias = true&#125;);void drawColor(Color color, BlendMode blendMode);void drawLine(Offset p1, Offset p2, Paint paint);void drawRect(Rect rect, Paint paint);void drawCircle(Offset c, double radius, Paint paint);void drawImage(Image image, Offset p, Paint paint);void drawParagraph(Paragraph paragraph, Offset offset); Picture其本质是一系列「graphical operations」的集合，对 Framework 层透明。Future toImage(int width, int height)，通过toImage方法可以将其记录的所有操作经光栅化后生成Image对象。 PictureRecorder其主要作用是记录在Canvas上执行的「graphical operations」，通过Picture#endRecording最终生成Picture。 Scene一系列 Picture、Texture 合成的结果。UI 帧刷新时，在 Rendering Pipeline 中 Flutter UI 经 build、layout、paint 等步骤后最终生成 Scene。其后通过window.render将该 Scene 送入 Engine 层，最终经 GPU 光栅化后显示在屏幕上。 SceneBuilder用于将多个图层(Layer)、Picture、Texture 合成为 Scene。 1234567891011121314151617181920212223242526272829303132333435363738void main() &#123; PictureRecorder recorder = PictureRecorder(); // 初始化 Canvas 时，传入 PictureRecorder 实例 // 用于记录发生在该 canvas 上的所有操作 // Canvas canvas = Canvas(recorder); Paint circlePaint= Paint(); circlePaint.color = Colors.blueAccent; // 调用 Canvas 的绘制接口，画一个圆形 // canvas.drawCircle(Offset(400, 400), 300, circlePaint); // 绘制结束，生成Picture // Picture picture = recorder.endRecording(); SceneBuilder sceneBuilder = SceneBuilder(); sceneBuilder.pushOffset(0, 0); // 将 picture 送入 SceneBuilder // sceneBuilder.addPicture(Offset(0, 0), picture); sceneBuilder.pop(); // 生成 Scene // Scene scene = sceneBuilder.build(); window.onDrawFrame = () &#123; // 将 scene 送入 Engine 层进行渲染显示 // window.render(scene); &#125;; window.scheduleFrame();&#125; 参考 深入浅出 Flutter Framework 之 PaintingContext","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"引擎启动流程（一）","date":"2023-08-19T09:57:33.294Z","path":"wiki/Flutter/源码分析/引擎启动流程(一)/","text":"Flutter是如何在Android的基础上启动的呢？查看Flutter项目的Android端代码，会发现Activity是继承FlutterActivity，Application是继承FlutterApplication的，那么他们是如何链接Native和Flutter的呢？ FlutterApplication： onCreate过程中进行初始化配置，加载libflutter.so，注册JNI方法 FlutterActivity：onCreate过程中进行创建FlutterView、Dart虚拟机、Enigine、Isolate、taskRunner等对象，最终执行到Dart的main方法 FlutterApplication启动流程FlutterActivity启动流程参考 深入理解Flutter引擎启动","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"编译Flutter源码","date":"2023-08-19T09:57:33.293Z","path":"wiki/Flutter/未分类/编译Flutter源码/","text":"Mac下编译EngineEngine实现了Flutter的核心库，包括动画、图形、文件、网络、访问支持、插件架构、Dart的运行时、编译工具链等 准备工作1234567# 准备depot_tools工具# 假设当前目录是$HOME/Flutter/sourcecd $HOME/Flutter/sourcegit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git#添加环境变量export PATH=$PATH:$HOME/Flutter/source/depot_tools 下载源码 进入github的flutter官网，fork一份engine的源码：https://github.com/flutter/engine 在$HOME&#x2F;Flutter&#x2F;source目录新建.gclient文件 12345678910solutions = [ &#123; &quot;managed&quot;: False, &quot;name&quot;: &quot;src/flutter&quot;, &quot;url&quot;: &quot;git@github.com:airshu/engine.git&quot;,//这里使用自己的仓库地址 &quot;custom_deps&quot;: &#123;&#125;, &quot;deps_file&quot;: &quot;DEPS&quot;, &quot;safesync_url&quot;: &quot;&quot;, &#125;,] 运行命令：gclient sync 同步最新的分支代码 123456cd src/fluttergit remote add upstream git@github.com:flutter/engine.gitcd ..gclient sync 调整版本123456789#查看engine对应版本获取commit idvim src/flutter/bin/internal/engine.version# 调整代码cd engine/src/fluttergit reset --hard &lt;commit id&gt;gclient sync -D --with_branch_heads --with_tags 编译iOS平台1234567891011121314151617181920212223cd xxx/source #source目录为自定义的源码目录# 下载对应Engine的Flutter Framework源码 https://github.com/flutter/fluttercd flutter# 不建议使用master分支，这里使用2.5.1的分支git pull origin flutter-2.5-candidate.1:flutter-2.5-candidate.1# 查看该分支的提交版本号cat bin/internal/engine.version# 进入src/flutter目录，切换分支cd ../src/fluttergit checkout -b a877f6fed68e1b961f76ec0fece9e7c684679e75cd ..gclient sync./flutter/tools/gn --ios --unoptimized./flutter/tools/gn --unoptimizedninja -C out/ios_debug_unopt &amp;&amp; ninja -C out/host_debug_unopt# 使用cd xxx/source./flutter/bin/flutter create hello_worldcd hello_world# 用本地编译的Engine运行项目../flutter/bin/flutter run --local-engine-src-path ~/flutter/source/src --local-engine=ios_debug_unopt 编译Android平台12345678910111213141516# 预编译设备侧可执行文件./flutter/tools/gn --android --unoptimized#预编译arm64设备的预编译文件./flutter/tools/gn --android --android-cpu arm64 --unoptimized #预编译host-side可执行文件./flutter/tools/gn --unoptimized## 构建# 构建设备侧可执行文件ninja -C out/android_debug_unopt -j 8# 构建arm64平台ninja -C out/android_debug_unopt_arm64# 编译host-side文件ninja -C out/host_debug_unopt Debug源码Debug Java层源码 将engine&#x2F;src&#x2F;flutter&#x2F;shell&#x2F;platform&#x2F;android（Flutter引擎项目）目录导入Android Studio 用本地Engine运行Flutter项目 1234#local-engine-src-path指向源码目录#local-engine指向编译的目标#也可以直接在gradle.properties中配置这两个属性../flutter/bin/flutter run --local-engine=android_debug_unopt --local-engine-src-path=/Users/xpeng/flutter/source/src Flutter引擎项目进行attach，选中Show all processes 注意 attach的时候，有些代码已经运行过了。如果想要早一点断点，可以使用Debug.waitForDebugger()，应用一直处于等待状态，直到有Debugger连接才执行。 1234567891011// 添加App文件，配置Applicationpackage com.yourdomain.your_app_nameimport android.os.Debugimport io.flutter.app.FlutterApplicationclass App:FlutterApplication() &#123; override fun onCreate() &#123; Debug.waitForDebugger() super.onCreate() &#125;&#125; Debug C++层源码参考 Flutter 引擎编译、运行与调试 Flutter-Engine-C-源码调试初探 编译前环境准备 编译文档","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"AspectD","date":"2023-08-19T09:57:33.292Z","path":"wiki/Flutter/开源库/AspectD/","text":"AOP的作用 减少代码入侵的埋点 性能监控 参考 咸鱼aspectd 贝壳Beike_AspectD Flutter aspectd （二）源码解析","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"性能优化之分帧渲染","date":"2023-08-19T09:57:33.292Z","path":"wiki/Flutter/未分类/性能优化之分帧渲染/","text":"https://github.com/LianjiaTech/keframe https://github.com/fzyzcjy/flutter_smooth ListView流畅度翻倍！！Flutter卡顿分析和通用优化方案 Flutter 分帧上屏源码浅析","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"extended_image","date":"2023-08-19T09:57:33.292Z","path":"wiki/Flutter/开源库/图片相关/extended_image/","text":"https://pub.dev/packages/extended_image https://github.com/fluttercandies/extended_image&#x2F;blob&#x2F;master&#x2F;README-ZH.md Android中图片占用内存计算方法 强大的官方 Image 扩展组件, 支持加载以及失败显示，缓存网络图片，缩放拖拽图片，图片浏览，滑动退出页面，编辑图片(裁剪旋转翻转)，保存，绘制自定义效果等功能 图片处理过程中的一些技巧 网络图片记得进行压缩，否则可能会出现内存溢出问题 对于常用的不变的图片，可以添加磁盘缓存，避免每次都从网络加载","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"图片相关","slug":"Flutter/开源库/图片相关","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3/"}]},{"title":"Image基础","date":"2023-08-19T09:57:33.292Z","path":"wiki/Flutter/开源库/图片相关/image基础/","text":"图片也是一种二进制文件，图片的原始数据中每个像素在内存中一般占用2-4个字节 type bits memory ARGB_8888 32 4wh ARBG_4444 16 2wh RGB_565 16 2wh ALPHA_8 8 1wh Flutter中常见的图片相关APIRawImage属性color、colorBlendModecolor指定混合色，colorBlendMode指定混合模式 fit缩放方式，如果只设置width、height的其中一个，则另一个属性会按照fit的设置来缩放 fill：拉伸填充 contain：这是图片的默认适应规则，图片会在保证图片本身长宽比不变的情况下缩放以适应当前显示空间，图片不会变形 cover：会按图片的长宽比放大后居中填满显示空间，图片不会变形，超出显示空间部分会被剪裁 fitWidth：图片的宽度会缩放到显示空间的宽度，高度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁 fitHeight：图片的高度会缩放到显示空间的高度，宽度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁 none：图片没有适应策略，会在显示空间内显示图片，如果图片比显示空间大，则显示空间只会显示图片中间部分 scaleDown： Image封装了RawImage，方便使用 123456789Widget image = Image.asset(&quot;images/yuan.png&quot;);Widget image = Image.network(&quot;http://img.rangaofei.cn/01b18.jpg&quot;);Widget image = Image.file(file);Widget image = Image.memory(byteList); 属性 image：ImageProvider类型，定义了图片数据获取和加载的相关接口 CircleAvatar圆形图片 12345678CircleAvatar( child: Text(&quot;头像&quot;), backgroundImage: AssetImage(&quot;images/yuan.png&quot;), backgroundColor: Colors.red, radius: 50.0,), DecorationImage1234Container( decoration: BoxDecoration( image: DecorationImage(image: AssetImage(&quot;images/yuan.png&quot;))),); Ink.image1Ink.image(image: AssetImage(&quot;images/timg.jpeg&quot;)); ImageIcon1ImageIcon(AssetImage(&quot;images/timg.jpeg&quot;)); FadeInImage注意flutter默认提供图片内存的缓存，但没有磁盘缓存，可以使用flutter_cached_network_image来做磁盘缓存 源码分析相关类： Image：用来显示图片 _ImageState：状态类，处理生命周期、调用加载 ImageProvider：图片提供者，用于加载图片，例如NetworkImage、ResizeImage ImageStreamCompleter：图片资源的管理类 ImageStream：图片资源的句柄，持有图片资源，加载完毕后的回调和图片资源的管理着，ImageStreamCompleter对象就是图片资源的管理类 MultiFrameImageStreamCompleter：多帧图片解析器 ImageStreamListener：监听图片的加载结果，加载完成后会进行回调，然后刷新页面显示 参考 Flutter实战：图片及ICON Flutter实战：图片加载原理与缓存 Flutter中的Image入门讲解 Flutter图片内存优化实践","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"图片相关","slug":"Flutter/开源库/图片相关","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3/"}]},{"title":"Flutter学习资源汇总","date":"2023-08-19T09:57:33.291Z","path":"wiki/Flutter/Flutter学习资源汇总/","text":"官方文档库 Flutter渲染机制—UI线程 Flutter渲染机制—GPU线程 深入理解Flutter引擎启动 深入理解Dart虚拟机启动 深入理解Flutter应用启动 深入理解setState更新机制 深入理解Flutter动画原理 深入理解Flutter消息机制 Flutter UI 渲染浅析（五）Layout Flutter UI 渲染浅析（六）Paint Flutter UI 渲染浅析（七）Composite 获取并还原Flutter-Engine-Crash堆栈 http://gityuan.com http://w4lle.com https://fucknmb.com","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"Android面试题收集","date":"2023-08-19T09:57:33.291Z","path":"wiki/Android/未分类/Android面试题收集/","text":"https://github.com/Moosphan/Android-Daily-Interview https://github.com/lizhangqu/CoreLink","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://airshu.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"Handler使用不当造成的OOM","date":"2023-08-19T09:57:33.291Z","path":"wiki/Android/性能优化/OOM专题/Handler使用不当造成的OOM/","text":"问题重现编写以下代码 123456789101112131415161718public class OOMHandlerActivity extends Activity &#123; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); ((EditText) findViewById(R.id.oom_handler_edit_text)).setText(&quot;aaaas&quot;); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_oom_handler); mHandler.sendEmptyMessageDelayed(1, 1000 * 60); //这里注意，当延迟时间较小时，Profile中Leaks显示为0 &#125;&#125; 使用Android Studio自带的Profile进行监控，打开OOMHandlerActivity页面，然后返回上一个页面。Dump内存后，会出现以下提示： 原因分析依据Handler的实现原理，我们可知，内存泄漏的引用链如下： 主线程 —&gt; threadlocal —&gt; Looper —&gt; MessageQueue —&gt; Message —&gt; Handler —&gt; Activity 解决办法对于Handler的使用技巧，我们应该： 使用静态内部类的方式 如果需要处理宿主，则通过弱引用的传入进来 Activity生命周期结束时，释放Handler资源 参考以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.lqd.androidpractice.oom.handler;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.widget.TextView;import com.lqd.androidpractice.R;import java.lang.ref.WeakReference;/** * @author: Airshu * @Date 2021/6/18 */public class OOMHandlerRightActivity extends Activity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView; //使用静态内部类 private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference;//使用弱引用 public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; OOMHandlerRightActivity activity = (OOMHandlerRightActivity) reference.get(); if (activity != null) &#123; activity.mTextView.setText(&quot;&quot;); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_oom_handler); mTextView = (TextView) findViewById(R.id.textview); mHandler.sendEmptyMessageDelayed(1, 1000 * 60); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mHandler.removeCallbacksAndMessages(null);//Activity销毁时同时移除handler的监听 &#125;&#125; 参考 https://www.cnblogs.com/jimuzz/p/14187408.html","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}]},{"title":"HTTP协议","date":"2023-07-15T01:43:36.912Z","path":"wiki/程序语言/网络编程/HTTP协议/","text":"HTTP 协议的请求报文和响应报文的结构基本相同，主要由三大部分组成： 状态行（status line）：描述响应的基本信息，也就是服务器响应的状态； 头部字段集合（header）：使用 key-value 形式更详细地说明报文； 消息正文（entity）：实际响应的数据，它不一定是纯文本，可以是图片、视频等二进制数据。 header参数请求头 Request URL( 请 求 的 地 址 ) Request Method(请求的方式) Status Code(状态码) Accept: &#x2F;(客户端能接收的资源类型) Accept-Language: en-us( 客 户 端 接 收 的 语 言 类 型 ) Connection: Keep-Alive(维护客户端和服务端的连接关系) Host:localhost:8080(连接的目标主机和端口号) Referer: http://localhost/links.asp(告诉服务器我来自哪里) User-Agent:Mozilla&#x2F;4.0(客户端版本号的名字) Accept-Encoding:gzip, deflate(客户端能接收的压缩数据的类型) If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT( 缓 存 时 间 ) Cookie(客户端暂存服务端的信息) Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间) 响应 Location:http://www.baidu.com(服务端需要客户端访问的页面路径) Server:apache tomcat(服务端的Web服务端名) Content-Encoding:gzip(服务端能够发送压缩编码类型) Content-Length:80(服务端发送的压缩数据的长度) Content-Language:zh-cn(服务端发送的语言类型) Content-Type:text&#x2F;html;charset&#x3D;GB2312(服务端发送的类型及采用的编码方式) Last-Modified:Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间) Refresh:1;url&#x3D;http://www.it315.org(服务端要求客户端一秒钟后，刷新，然后访问指定的页面 路径) Content-Disposition:attachment;filename&#x3D;aaa.zip(服务端要求客户端以下载文件的方式打开 该文件) Transfer-Encoding:chunked(分块传递数据到客户端) Set-Cookie:SS&#x3D;Q0&#x3D;5Lb_nQ;path&#x3D;&#x2F;search(服务端发送到客户端的暂存数据) Expires:-1&#x2F;&#x2F;3种(服务端禁止客户端缓存页面数据) Cache-Control:no-cache(服务端禁止客户端缓存页面数据) Pragma:no-cache(服务端禁止客户端缓存页面数据) Connection: close(1.0)&#x2F;(1.1)Keep-Alive(维护客户端和服务端的连接关系) Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间) Cache-Control：缓存配置 private: 客户端可以缓存 public: 客户端和代理服务器都可缓存 max-age&#x3D;xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据(后面介绍) no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发 状态码1xx1×× 类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。 2xx2×× 类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。 “200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果。 “204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。 “206 Partial Content” 一般用于分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-66&#x2F;888”，意思是此次获取的是总计 888 个字节的前 66 个字节。 3xx3×× 类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括“著名”的 301、302 跳转。 “301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。与它类似的是“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。 “304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。 4xx4××类状态码表示客户端发送的请求报文有误，服务器无法处理，它是具有真正的“错误码”含义的状态码了。 “400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头或者还是其他错误则不会明确指示，因此在Web开发时一般会尽量避免给客户端返回 400，使用其他更有明确含义的状态码。 “403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等。 “404 Not Found”可能是我们最常看到的一个状态码，它一般指资源在本服务器上未找到，所以无法提供给客户端。 405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET； 406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文； 408 Request Timeout：请求超时，服务器等待了过长的时间； 409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态； 413 Request Entity Too Large：请求报文里的 body 太大； 414 Request-URI Too Long：请求行里的 URI 太大； 429 Too Many Requests：客户端发送了太多的请求，触发了服务器的限制； 431 Request Header Fields Too Large：请求头某个字段或总体太大。 5xx5×× 类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。 “500 Internal Server Error” 与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过和 400 的响应相反，开发人员通常不会把服务器内部的出错详细信息返回给访问端。虽然不利于调试，但能够防止黑客的窥探或者分析。 “501 Not Implemented” 表示客户端请求的功能还不支持，类似于“即将开业，敬请期待”的意思。 “502 Bad Gateway” 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。 “503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。 HTTP请求过程参考","tags":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"网络编程","slug":"程序语言/网络编程","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"计算机网络知识总结","date":"2023-07-15T01:43:36.912Z","path":"wiki/程序语言/网络编程/计算机网络知识总结/","text":"计算机网络的带宽网络可通用的最高数据率，即每秒多少比特bit。 计算机网络性能指标 速率 带宽 吞吐量 时延（delay或latency）： 传输时延：从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需时间 传播时延：电磁波在信道中需要传播一定的距离而花费的时间 处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间 排队时延：结点缓存队列中分组排队所经历的时延 时延带宽积 利用率： 信道利用率 网络利用率 数据链路层： 信道主要有以下两种类型： 点对点信道： 广播信道： 各层传输的数据单位： 网络层：IP数据报 数据链路层：帧 物理层：比特 数据链路层传输数据时三个基本问题： 封装成帧 透明传输 差错控制 点对点协议（Point-to-Point Protocol） PPP协议应满足的需求： 简单 封装成帧 透明性 多种网络层协议 多种类型链路 差错检测 检测连接状态 最大传输单元 网络层地址协商 数据压缩协商 PPP协议不需要的功能： 纠错 流量控制 序号 多点线路 半双工或单工链路 PPP协议有三个组成部分 一个将IP数据报封装到串行链路的方法； 链路控制协议LCP 网络控制协议NCP PPP协议之不使用序号和确认机制 网际协议IP IP时TCP&#x2F;IP体系中两个最主要的协议之一，与IP协议配套使用的还有四个协议： 地址解析协议ARP（Address Resolution Protocol） 逆地址解析协议RARP（Reverse Address Resolution Protocol） 网际控制报文协议ICMP（Internet Control Message Protocol） 网际组管理协议IGMP（Internet Group Management Protocol） 网络互相连接起来要使用的一些中间设备 物理层中继系统：转发器（repeater）、中继器 数据链路层中继系统：网桥或桥接器 网络层中继系统：路由器 网桥和路由器的混合物：桥路器（brouter） 网络层以上的中继系统：网关（gateway） TCP、UDP的区别 TCP三次握手 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户 端和服务器总共发送 3 个包。三次握手的目的是连接服务器指定端口，建立 TCP 连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。 在 socket 编程中，客户端执行 connect()时，将触发三次握手:即客户端和服务端通信前要进行连接，3次握手的作用就是双方都能明确自己和对方的收、发能力正常。 TCP四次挥手 参考 https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://airshu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"网络编程","slug":"程序语言/网络编程","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"HTTPS","date":"2023-07-15T01:43:36.911Z","path":"wiki/程序语言/网络编程/HTTPS/","text":"工作流程 Client发起一个HTTPS(比如 https://juejin.im/user )的请求，根据RFC2818的规定，Client知道需要连接Server的443(默认)端口。 Server把事先配置好的公钥证书(public key certificate)返回给客户端。 Client验证公钥证书:比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书(操作系统内置的Root证书或者Client内置的Root证书)。如果验证通过则继续，不通过则显示警告信息。 Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 Server使用自己的私钥(private key)解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。 Server使用对称密钥加密“明文内容A”，发送给Client。 Client使用对称密钥解密响应的密文，得到“明文内容A”。 Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥 解密密文，得到“明文内容B”。 参考","tags":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"网络编程","slug":"程序语言/网络编程","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"复杂度定义","date":"2023-07-15T01:43:36.911Z","path":"wiki/程序语言/算法/复杂度定义/","text":"时间复杂度一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变 化情况并确定T(n)的数量级。这里用”O”来表示数量级，给出算法的时间复杂度。 T(n)&#x3D;O(f(n)); 它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。 时间复杂度的分析方法: 时间复杂度就是函数中基本操作所执行的次数 一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数 忽略掉常数项 关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数 计算时间复杂度是估算随着n的增长函数执行次数的增长趋势 递归算法的时间复杂度为:递归总次数 x 每次递归中基本操作所执行的次数 常用的时间复杂度有以下七种，算法时间复杂度依次增加: O(1)常数型 O(log2 n)对数型 O(n) 线性型 O(n log2 n)二维型 O(n^2)平方型 O(n^3)立方型 O(2^n)指数型 空间复杂度算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级。 S(n)&#x3D;O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1); 递归算法的空间复杂度:递归深度N*每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N). 算法效率算法效率分析分为两种:第一种是时间效率，第二种是空间效率。时间效率被称为时间复杂度， 而空间效率被称作空间复杂度。时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主 要衡量一个算法所需要的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。 所以我们如今已经不需要再特别关注一个算法的空间复杂度。","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"程序语言/算法","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95/"}]},{"title":"查找算法","date":"2023-07-15T01:43:36.911Z","path":"wiki/程序语言/算法/查找/","text":"顺序查找顺序查找（Sequential Search）又称线性查找。从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，如果查找到表中最后一个元素，还没有找到，则查找不成功。 二分查找二分查找（Binary Search）又称折半查找。它的前提是线性表中的记录必须是关键码有序，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。 插值查找(Interpolation Search)基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。即根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式mid&#x3D;low+(key-a[low])&#x2F;(a[high]-a[low])(high-low)，替换了二分查找的计算公式mid&#x3D;low+1&#x2F;2(high-low)。 这样的好处在于，对表长较长，且关键字分布比较均匀，插值查找算法的平均性能要比折半查找要好的多。但是如果表中关键字分布极端不均匀，那么插值查找还不如折半查找呢。 斐波那契查找(Fibonacci Search)也是一种改进的二分查找，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。 斐波那契查找的整个过程可以分为： 构建斐波那契数列； 计算数组长度对应的斐波那契数列元素个数； 对数组进行填充； 循环进行区间分割，查找中间值； 判断中间值和目标值的关系，确定更新策略； 二叉树查找对二叉查找树进行中序遍历，即可得到有序的数列。 平衡树2-3查找树红黑树B树(B_树)、B+树B树也称B-树,它是一颗多路平衡查找树 分块查找分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…… 算法流程： step1 先选取各块中的最大关键字构成一个索引表； step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。 哈希查找我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。 总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。 什么是哈希函数？ 哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。 算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。 算法流程： 1）用给定的哈希函数构造哈希表； 2）根据选择的冲突处理方法解决地址冲突； 常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：浅谈算法和数据结构: 十一 哈希表。 3）在哈希表的基础上执行哈希查找。 哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。 复杂度分析： 单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。 使用Hash，我们付出了什么？ 我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？ Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。 参考 算法可视化演示","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"程序语言/算法","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法","date":"2023-07-15T01:43:36.911Z","path":"wiki/程序语言/算法/排序/","text":"插入排序直接插入排序具体算法： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2-5。 希尔排序希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。 希尔排序实质上是一种分组直接插入方法。 基本思想： 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap&#x3D;1时，即所有记录放在同一组中进行直接插入排序为止, 整个数列就是有序的。 选择排序直接选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 堆选择排序什么是堆？堆结构有很多种，如二叉堆、B堆、斐波那契堆、三元堆，树堆、弱堆等。二叉堆是堆实现中最流行的一种。二叉堆是一个完全二叉树，树的所有内部节点都被完全填充，最后一层可以完全填充的或部分填充。通俗的说，堆（二叉堆）可以视为一棵完全的二叉树。完全二叉树的一个优秀的性质就是，除了最底层之外，每一层都是满的。堆又分为最大堆（堆顶Root是最大值）和最小堆（堆顶Root是最小值）。 总结一下，只要你是一个完全二叉树，父节点又大于子节点，你就是堆。 完全二叉树 + 父节点大于(或小于)子节点 &#x3D; 堆 https://chihokyo.com/post/18/ 交换排序冒泡排序从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。 快速排序 https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html 归并排序归并排序算法完全遵循分治模式。直观上其操作如下： 分解：分解等排序的n个元素的序列成各具n&#x2F;2个元素的两个子序列；解决：使用归并排序递归地排序两个子序列；合并：合并两个已排序的子序列以产生已排序的答案。 https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F#Python3 各种内排序方法的比较","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"程序语言/算法","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95/"}]},{"title":"线性表","date":"2023-07-15T01:43:36.910Z","path":"wiki/程序语言/数据结构/线性表/","text":"定义线性表（Linear List）是具有相同特性的数据元素的一个有限序列。该序列中所含元素的个数叫做线性表的长度，用n表示，n&gt;&#x3D;0。当n&#x3D;0时，表示线性表是一个空表。设序列中第i个元素为a1（1 ≤ i ≤ n），则线性表的一般表示为： (a1,a2,a3,…,ai,…,an) 特性 元素在位置上是有序的 长度是可变的 线性存储将数据依次存储在连续的整块物理空间中。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。 链式存储数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系。 在线性表的链接存储中，存储的第一个元素的结点称为表头结点，存储最后一个元素的结点称为表尾结点，其余为中间结点。每个链接表都需要设置一个指针指向表头结点，称为表头指针。从表头指针出发，沿着结点的链可以访问到每一个结点。 链接表由于每个结点带有指针域，因而在存储空间上比线性存储要付出较大代价。由于每个结点的存储位置可以任意安排，因此插入、删除操作方便又省时。 单链表 双链表 循环双链表尾结点的下一个结点是头结点。 代码实现","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://airshu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"程序语言/数据结构","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"动态规划","date":"2023-07-15T01:43:36.910Z","path":"wiki/程序语言/算法/动态规划/","text":"","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"程序语言/算法","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95/"}]},{"title":"回溯算法","date":"2023-07-15T01:43:36.910Z","path":"wiki/程序语言/算法/回溯算法/","text":"回溯法（Back Tracking Method）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 12345678910result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 参考 https://my.oschina.net/u/3024426/blog/4689026","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"程序语言/算法","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95/"}]},{"title":"红黑树","date":"2023-07-15T01:43:36.908Z","path":"wiki/程序语言/数据结构/红黑树/","text":"定义红黑树是一种自平衡二叉查找树，它可以在 O($\\log(n)$ ) 时间内完成查找、插入和删除，这里的n是树中元素的数目。 红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求： 节点是红色或黑色。 根节点是黑色。 每个叶子节点都是黑色的空节点（NIL节点）。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 操作因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O($\\log(n)$)的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为 O ($\\log(n)$)次。 左旋转 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。下图中身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。 右旋转 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。下图中身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。 插入应用场景 JDK的集合类TreeMap、TreeSet、HashMap 参考 https://www.cxyxiaowu.com/3173.html https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://airshu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"程序语言/数据结构","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"稀疏矩阵和广义表","date":"2023-07-15T01:43:36.907Z","path":"wiki/程序语言/数据结构/稀疏矩阵和广义表/","text":"定义矩阵矩阵是一个具有m行 x n列的数表，共包含m x n个数（元素），每个元素处在确定行和列的交点位置上，都与一对行号和列号唯一对应。当一个矩阵中的行数和列数相同时，即m &#x3D; n时则称为n阶矩阵或方阵。 稀疏矩阵（SparseMatrix）是矩阵中的一种特殊情况，其非零元素的个数小于零元素的个数。 对于稀疏矩阵中的每个非零元素，可用它所在的行号、列号以及元素这三元组（i，j，aij）来表示。若把所有的三元组按照行号为主序（即主关键字）、列号为辅序（次关键字）进行排序，就构成一个表示稀疏矩阵的三元组线性表。 ((1,1,3),(1,4,5),(2,3,-2),(3,1,1),(3,3,4),(3,5,6),(5,3,-1)) 稀疏矩阵的存储结构顺序存储链式存储 带行指针向量的链接存储 在这种链接存储中，需要把具有相同行号的三元组结点按照列号从小到大的顺序链接成一个单链表，每个三元组结点的类型可定义为： 1234567class TripleNode: def __init__(self): self.row = 0 self.col = 0 self.val = None self.next = None # 指向同一行的下一个结点 稀疏矩阵中的每一行对应一个单链表，每一个单链表都有一个表头指针，为了把它们保存起来，便于访问每一个单链表，需要一个行指针向量，该向量中的第i个分量用来存储稀疏矩阵中的第i行所对应的单链表的表头指针。 12345678class LMatrix: def __init__(self): self.m = 0 self.n = 0 self.t = 0 # 非零元素的个数 self.vector = [] 十字链接存储 既带行指针向量又带列指针向量的链接存储。在这种链接存储中，每个三元组结点既处于同一行的单链表中，又处于同一列的单链表中，即处于所在的行单链表和列单链表的交点处。 1234567891011121314151617class CrossNode: def __init__(self): self.row = 0 self.col = 0 self.val = None self.right = None # 存储指向同一行下一个结点的指针 self.down = None # 存储同一列下一个结点的指针class CLMatrix: def __init__(self): self.m = 0 self.n = 0 self.t = 0 self.rv = [] # 行向量指针，存储行单链表的表头指针 self.cv = [] # 列向量指针，存储列单链表的表头指针 广义表(Generalized List)一个广义表是n（n ≥ 0）个元素的一个序列，当n &#x3D; 0时则称为空表。在一个非空的广义表中，其元素可以是某一确定类型的对象（这种元素被称为单元素），也可以是由单元素构成的表（这种元素可相对的被称为子表或表元素）。显然，广义表的定义是递归的。 设ai为广义表的第i个元素，则广义表的一般表示与线性表相同： (a1,a2,a3,…,ai,…,an) 其中n表示广义表的长度，即广义表中所含元素的个数，n ≥ 0。 深度：表中括号的最大层数 表示方式 用小写字母表示单元素，用大写字母表示表 A &#x3D; ()A是空表，长度为0，深度为1。 B &#x3D; (e)B是长度为1的广义表，深度为1。线性表。 C &#x3D; (a, (b,c,d))C是长度为2的广义表，深度为2。 D &#x3D; (A, B, C) &#x3D; ((), (e), (a, (b, c, d)))D是长度为3的广义表，深度为3。A、B、C为子表。 E &#x3D; ((a, (a,b), ((a,b), c))) 用圆圈和方框分别表示表和单元素，并用线段把表和它的元素连接起来，则可得到一个广义表的图形表示。 抽象数据类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ADT GList&#123;数据对象： D=&#123;ei | i=1,2,...,n; n&gt;0; ei∈AtomSet 或ei∈GList, AtomSet为某个数据对象 &#125;数据关系： R1=&#123;&lt;ei-1,ei&gt; | ei-1,ei∈D, 2&lt;=i&lt;=n&#125;基本操作： InitGList(&amp;L); 操作结果： 创建空的广义表L。 CreateGList(&amp;L, S); 初始条件： S是广义表的书写形式串。 操作结果： 由S创建广义表L。 DestroyGList(&amp;L); 初始条件： 广义表L存在 操作结果： 销毁广义表L。 CopyGList(&amp;T, L); 初始条件： 广义表L存在 操作结果： 由广义表L复制得到广义表T。 GListLength(L); 初始条件： 广义表L存在 操作结果： 求广义表L的长度 GListenDepth(L); 初始条件： 广义表L存在 操作结果： 求广义表L的深度 GListEmpty(L); 初始条件： 广义表L存在 操作结果： 判定广义表L是否为空 GetHead(L); 初始条件： 广义表L存在 操作结果： 取广义表L的头 GetTail(L); 初始条件： 广义表L存在 操作结果： 取广义表L的尾 InsertFirst_GL(&amp;L, e); 初始条件： 广义表L存在 操作结果： 插入元素e作为广义表L的第一元素 DeleteFirst_GL(&amp;L, &amp;e); 初始条件： 广义表L存在 操作结果： 删除广义表L的第一元素，并用e返回其值 Traverse_GL(L, Visit()); 初始条件： 广义表L存在 操作结果： 遍历广义表L，用函数Visit处理每个元素&#125;ADT GList; 存储在一个广义表中，其数据元素有单元素和子表之分，所以在对应的存储结构中，其存储结点也有单元素结点和子表结点之分。对于单元素结点，应包括值域和指向其后继结点的指针域；对于子表结点，应包括指向子表中第一个结点的表头指针域和指向其后继结点的指针域。为了把广义表中的单元素结点和子表结点区别开，还必须在每个结点中增设一个标志域，让标志域取不同的值，从而区别不同的结点。 由于列表中的数据元素可能为原子或列表， 由此需要两种结构的结点： 一种是表结点，用于表示列表；一种是原子结点，用以表示原子。若列表不空，则可分解成表头和表尾；反之，一对确定的表头和表尾可唯一确定列表。由此，一个表结点可由3个域组成： 标志域、指示表头的指针域和指示表尾的指针域； 而原子结点只需两个域： 标志域和值域。 头尾链表存储结构123456789101112131415161718//------ 广义表的头尾链表存储表示 -------typedef enum&#123; ATOM, //ATOM == 0: 原子 LIST //LIST == 1: 子表&#125;ElemTag;typedef GLNode&#123; ElemTag tag; //公共部分，用于区分原子结点和表结点 union&#123; //原子结点和表结点的联合部分 AtomType atom; //atom是原子结点的值域，AtomType由用户定义 struct&#123; struct GLNode *hp; struct GLNode *tp; &#125;ptr; //ptr是表节点的指针域，ptr.hp和ptr.tp分别指向表头和表尾 &#125;&#125;*GList; //广义表类型 扩展线性链表存储结构123456789101112131415161718//------ 广义表的扩展线性链表存储表示 -------typedef enum&#123; ATOM, //ATOM == 0: 原子 LIST //LIST == 1: 子表&#125;ElemTag;typedef GLNode&#123; ElemTag tag; //公共部分，用于区分原子结点和表结点 union&#123; //原子结点和表结点的联合部分 AtomType atom; //atom是原子结点的值域，AtomType由用户定义 struct GLNode *hp; //表结点的表头指针 &#125;; struct GLNode *tp; //相当于线性链表的next，指向下一个元素结点&#125;*GList; 参考 https://www.scipy.org/ SciPy使用多个数据结构为创建稀疏矩阵提供了工具，以及将稠密矩阵转化为稀疏矩阵的工具。 csc_matrix: Compressed Sparse Column format csr_matrix: Compressed Sparse Row format bsr_matrix: Block Sparse Row format lil_matrix: List of Lists format dok_matrix: Dictionary of Keys format coo_matrix: COOrdinate format (aka IJV, triplet format) dia_matrix: DIAgonal format","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://airshu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"程序语言/数据结构","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"平衡二叉树AVL","date":"2023-07-15T01:43:36.903Z","path":"wiki/程序语言/数据结构/平衡二叉树AVL/","text":"定义平衡二叉树也叫自平衡二叉搜索树（Self-Balancing Binary Search Tree），所以其本质也是一颗二叉搜索树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树（旋转操作）。 最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。Ï 平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。根据旋转的方向有两种处理方式，左旋与右旋。 旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。 左旋 节点的右孩子替代此节点位置 右孩子的左子树变为该节点的右子树 节点本身变为右孩子的左子树 右旋 节点的左孩子代表此节点 节点的左孩子的右子树变为节点的左子树 将此节点作为左孩子节点的右子树。 AVL树的四种插入节点方式平衡二叉树插入节点的情况分为以下四种： 插入方式 描述 旋转方式 LL 在 A 的左子树根节点的左子树上插入节点而破坏平衡 右旋转 RR 在 A 的右子树根节点的右子树上插入节点而破坏平衡 左旋转 LR 在A的左子树根节点的右子树上插入节点而破坏平衡 先左旋后右旋 RL 在 A 的右子树根节点的左子树上插入节点而破坏平衡 先右旋后左旋 详细分析删除AVL 树和二叉查找树的删除操作情况一致，都分为四种情况： 删除叶子节点 删除的节点只有左子树 删除的节点只有右子树 删除的节点既有左子树又有右子树 只不过AVL树在删除节点后需要重新检查平衡性并修正，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。 删除操作的大致步骤如下： 以前三种情况为基础尝试删除节点，并将访问节点入栈。 如果尝试删除成功，则依次检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。 如果尝试删除失败，证明是第四种情况。这时先找到被删除节点的右子树最小节点并删除它，将访问节点继续入栈。 再依次检查栈顶节点的平衡状态和修正直到栈空。 对于删除操作造成的非平衡状态的修正，可以这样理解：对左或者右子树的删除操作相当于对右或者左子树的插入操作，然后再对应上插入的四种情况选择相应的旋转就好了。 详细分析参考 https://blog.csdn.net/jyy305/article/details/70949010 https://zhuanlan.zhihu.com/p/56066942 https://www.cs.usfca.edu/~galles&#x2F;visualization&#x2F;AVLtree.html","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://airshu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"程序语言/数据结构","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"栈和队列","date":"2023-07-15T01:43:36.903Z","path":"wiki/程序语言/数据结构/栈和队列/","text":"栈栈（Stack），也叫后进先出表（Last In First Out），是一种运算受限的线性表，其限制是仅允许在表的一端进行插入和删除运算。这一端称为栈顶，栈顶的第一个元素被称为栈顶元素，相对的，另一端称为栈底。向一个栈插入新元素称为进栈或入栈，从一个栈删除元素又称为出栈或退栈。 存储结构栈分为顺序栈和链式栈，可以使用数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。 顺序存储链式存储队列队列（Queue），也叫先进先出表（First In First Out）仅允许在表的一端（队尾rear）进行插入，在表的另一端（队首front）进行删除。","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://airshu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"程序语言/数据结构","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树","date":"2023-07-15T01:43:36.903Z","path":"wiki/程序语言/数据结构/树/","text":"定义 树是由n（n&gt;&#x3D;1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树的术语 节点的度：一个节点含有的子树的个数称为该节点的度； 树的度：一棵树中，最大的节点的度称为树的度； 叶节点或终端节点：度为零的节点； 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点：具有相同父节点的节点互称为兄弟节点； 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 树的高度或深度：树中节点的最大层次； 堂兄弟节点：父节点在同一层的节点互为堂兄弟； 节点的祖先：从根到该节点所经分支上的所有节点； 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。 森林：由m（m ≥ 0）棵互不相交的树的集合称为森林； 树的种类 无序树： 树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树 有序树 树中任意节点的子节点之间有顺序关系，这种树称为有序树 二叉树：每个节点最多含有两个子树的树称为二叉树 完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树; 平衡二叉树：当且仅当任何节点的两棵子树的高度差不大于1的二叉树； 排序二叉树： 霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树； B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。 树的性质 树中的节点数等于所有节点的度数加1。 度为k的树中第i层上至多有ki-1个节点（i ≥ 1）。 深度为h的k叉树至多有个节点 $\\frac{k^{h}-1}{h-1}$ 个节点。 具有n个节点的k叉树的最小深度为 ⌈$\\log_{k} (n(k-1)+1)$⌉ 二叉树 二叉树（Binary Tree）是指树的度为2的有序树。每个节点的左子树的根节点称为左孩子（left child），右子树的根节点称为右孩子（right child）。 性质 二叉树上终端节点数等于双分支节点数加1。 二叉树上第i层至多有2i-1个节点（i ≥ 1）。 深度为h的二叉树至多有2h-1个节点。 对完全二叉树中编号为i的节点（1 ≤ i ≤ n， n ≥ 1，n为节点数 ）有： 若i ≤ ⌊n&#x2F;2⌋，即2i ≤ n，则编号为i的节点为分支节点，否则为叶子节点。 若n为奇数，则每个分支节点都既有左孩子，又有右孩子；若n为偶数，则编号最大的分支节点（编号为n&#x2F;2）只有左孩子，没有右孩子，其余分支节点左、右孩子都有。 若编号为i的节点右左孩子，则左孩子节点的编号为2i；若编号为i的节点有右孩子，则右孩子节点的编号为2i+1。 除树根节点外，若一个节点的编号为i，则他的双亲节点的编号为 ⌊i&#x2F;2⌋，也就是说，当i为偶数时，其双亲节点的编号为i&#x2F;2，它时双亲节点的左孩子， 当i为奇数时，其双亲节点的编号为(i-1)&#x2F;2，它是双亲节点的右孩子。 具有n个（n &gt; 0）节点的完全二叉树的深度为⌈$\\log_{2} (n+1)$⌉或⌊$\\log_{2} n$⌋+1。 二叉树的存储结构 二叉树的遍历 遍历二叉树的问题可以分为： 访问根节点 遍历左子树 遍历右子树 遍历方式分为：DLR、LDR、LRD、DRL、RDL、RLD。 前序遍历算法 中序遍历算法 后续遍历算法 线索二叉树二叉树的线索化对二叉树进行某种遍历得到的节点序列，可以看做一个线性表，在该线性表中，除第一个节点外，每个节点有且仅有一个前驱，除最后一个节点外，每个节点有且仅有一个后继。为了同节点在二叉树中具有的前驱（即双亲）和后继（即孩子）区别开来，在容易混淆的地方，我们通常把序列中节点的前驱或后继冠以某种遍历的名称，如把中序序列中节点的前驱称做中序前驱，节点的后继称做中序后继。 对于一颗具有n个节点的二叉树，对应的二叉链表中共有2n个指针域，其中n-1个用于指向除树根节点的其余n-1个节点，另有n+1个指针域空着。若把每个节点中空着的左指针域和右指针域用于分别指向某种遍历次序的前驱节点和后继节点，则在遍历这种二叉树时，可由此信息直接找到在该遍历次序下的前驱节点或后继节点，从而比递归遍历提高了遍历速度和节省了建立系统栈所使用的存储空间。这种在节点的空指针域中存放的该节点在某次遍历次序下的前驱节点或后继节点的指针叫做线索，其中在空的左指针域中存放的指向其前驱节点的指针叫做左线索或前驱线索，在空的右指针域中存放的指向其后继节点的指针叫做右线索或后继线索。对一颗二叉树中的所有节点的空指针域按照某种遍历次序加线索的过程叫做线索化，被线索化了的二叉树叫做线索二叉树。 二叉排序树定义二叉排序树（Binary Sort Tree）又称为二叉查找树（Binary Search Tree），它或者是一颗空树，或者是一颗具有如下特征的非空二叉树： 若它的左子树非空，则左子树上所有节点的关键字小于根节点的关键字； 若它的右子树非空，则右子树上所有节点的关键字均大于（若允许具有相同的关键字的节点存在，则大于等于）根节点的关键字； 左、右子树本身又是二叉排序树。 查找和插入当二叉查找树不为空时： 首先将给定值与根节点的关键字比较，若相等，则查找成功 若小于根节点的关键字值，递归查左子树 若大于根节点的关键字值，递归查右子树 若子树为空，查找不成功 二叉排序树是一种动态树表。其特点是：树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的节点时再进行插入。新插入的节点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。如下图所示： 删除二叉查找树的删除操作分为三种情况： 如果待删除的节点是叶子节点，那么可以立即被删除，如下图所示： 如果节点只有一个儿子，则将此节点parent的指针指向此节点的儿子，然后删除节点，如下图所示： 如果节点有两个儿子，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除，如下图所示： 参考 https://pegasuswang.github.io/python_data_structures_and_algorithms&#x2F;17_%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&#x2F;binary_search_tree&#x2F; 哈夫曼树（最优二叉树） 路径和路径长度 若在一颗树中存在着一个节点序列k1，k2，….kj，使得kj是kj+1的双亲（1 ≤ i &lt; j），则称此节点序列是从k1～kj的路径，因树中每个节点只有一个双亲节点，所以它也是这两个节点之间的唯一路径。从k1～kj所经过的分支数称为这两点之间的路径长度，它等于路径上的节点数减1。 节点的权和带权路径长度 在许多应用中，常常将树中的节点赋上一个有着某种意义的实数，我们称此实数为该节点的权。节点的带权路径长度规定为从树根节点到该节点之间的路径长度于该节点上权的乘积。 树的带权路径长度 树的带权路径长度定义为树中所有叶子节点的带权路径长度之和，通常记为： $\\sum_{i&#x3D;1}^n {w_{i}}l_{i}$ 其中n表示叶子节点的数目，wi和li分别表示叶子节点ki的权值和根到ki之间的路径长度。 哈夫曼树 哈夫曼树（Huffman）树又称最优二叉树。它是n个带权叶子节点构成的所有二叉树中，带权路径长度WPL最小的二叉树。 构造哈夫曼树 根据给定的n个权值{w1,w2,…,wn}构成二叉树集合F&#x3D;{T1,T2,…,Tn},其中每棵二叉树Ti中只有一个带权为wi的根节点,其左右子树为空。 在F中选取两棵根节点权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根节点的权值为左右子树根节点的权值之和。 在F中删除这两棵树,同时将新的二叉树加入F中。 重复2、3,直到F只含有一棵树为止.(得到哈夫曼树)。 平衡二叉树（AVL树）二叉搜索树中，每一个节点的左右子树深度差的绝对值不大于1。 (a）所示为 AVL 树，而（b）所示则不是 AVL 树。 那么，如何判断一棵树是否符合 AVL 树的性质？答案就是维护每个节点的平衡因子。每个节点的平衡因子即为节点左子树的深度减去右子树的深度得到的差。在符合 AVL 性质的情况下，平衡因子只能取 -1、0、1。 正因为这样，在插入或删除一个节点之后，要从插入或删除的位置沿通向根的路径回溯，更新这些经过的节点的平衡因子。在检测到当前节点的平衡因子的绝对值大于1时，停止回溯，根据回溯路径中当前节点以及当前节点深度+1 和深度+2 两层节点的位置，选择旋转方法对二叉树的结构进行调整。 如果一棵平衡二叉树中的节点发生了变化，使二叉树不再平衡，此时需要采用平衡化旋转来调整树的结构，使得在不破坏二叉搜索树性质的情况下，让二叉树重新达到平衡。 平衡化旋转分为两种：单向旋转和双向旋转。如果回溯路径中当前节点以及下两层节点处于一条直线上，就可以采用单向旋转。如果在下两层的节点中，每一个节点都是父亲节点的右孩子，那么如图 3 所示，此时采用单向左旋。 由于此处 A&lt;B&lt;C，所以左旋后并不破坏二叉搜索树的性质，而刚好使得平衡因子恢复到符合 AVL 树性质的大小。 这样的过程同样可以用图来展示。举例来说，在图 4 这样一棵平衡二叉树中插入节点后，整棵树就变得不平衡了。每个节点上方的数字就是该节点的平衡因子，而长方形代表子树，长方形里面的式子等于它的深度。 要想调整二叉树的结构，这里就要用到平衡左旋了。我们取每一棵子树的根节点来代表这一整棵子树，用一共 5 个节点来演示单向左旋的过程。图 5 所示就是单向左旋的效果。 平衡树的结构最后被调整成了图 6 所示这样，而平衡因子也重新变得符合 AVL 树性质了。 同样的道理，如果需要进行平衡旋转时，当前节点的下两层节点都是父节点的左孩子，那么就需要采用单向右旋。单向右旋的道理和单向左旋非常相似，下面就主要用图来演示，不多做讲解了。单向右旋的过程如图 7～图 9 所示。 参考 https://www.cxyxiaowu.com/1663.html","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://airshu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"程序语言/数据结构","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"B树、B+树","date":"2023-07-15T01:43:36.896Z","path":"wiki/程序语言/数据结构/B树/","text":"B树B树也称B-树,它是一颗多路平衡查找树。描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。 一颗m阶的B树定义如下： 每个结点最多包含m个子结点；且M&gt;2 根结点的儿子数为[2, M] 除根结点以外，非叶子结点的子结点数为[M&#x2F;2, M] 每个结点存放至少M&#x2F;2-1（取上整）和至多M-1个关键字；（至少2个关键字） 非叶子结点的关键字个数&#x3D;指向儿子的指针个数-1； 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]； 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 所有叶子结点位于同一层； 插入插入在叶节点级别完成。要将项目插入B树，需要遵循以下算法。 遍历B树以找到可插入节点的适当叶节点。 如果叶节点包含少于m-1个键，则按递增顺序插入元素。 否则，如果叶节点包含m-1个键，则按照以下步骤操作。 按元素的递增顺序插入新元素。 将节点拆分为中间的两个节点。 将中值元素推送到其父节点。 如果父节点还包含m-1个键，则按照相同的步骤将其拆分。 删除还在叶节点处执行删除。 要删除的节点可以是叶节点或内部节点。 需要遵循以下算法才能从B树中删除节点。 找到叶节点。 如果叶节点中有多于m&#x2F;2个键，则从节点中删除所需的键。 如果叶节点不包含m&#x2F;2个键，则通过从8个或左兄弟中获取元素来完成键。 如果左侧兄弟包含多于m&#x2F;2个元素，则将其最大元素推送到其父元素，并将插入元素向下移动到删除键的节点。 如果右侧兄弟包含多于m&#x2F;2个元素，则将其最小元素向上推送到父节点，并将插入元素向下移动到删除键的节点。 如果兄弟节点都不包含多于m&#x2F;2个元素，则通过连接两个叶节点和父节点的插入元素来创建新的叶节点。 如果父节点的节点少于m&#x2F;2，那么也应在父节点上应用上述过程。 如果要删除的节点是内部节点，则将节点替换为其有序后继或前一个节点。 由于后继或前任将始终位于叶节点上，因此该过程将类似于从叶节点中删除节点。 应用场景 查找磁盘中的大量数据。 数据库中的索引。 参考 https://www.yiibai.com/data_structure&#x2F;b-tree.html B+树B+树是B树的变体，有着更高的查询性能。 参考 https://www.cnblogs.com/nullzx/p/8729425.html","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://airshu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"程序语言/数据结构","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图","date":"2023-07-15T01:43:36.896Z","path":"wiki/程序语言/数据结构/图/","text":"定义图（Graph）是图形结构的简称。 G &#x3D; (V, E) V称为顶点集（Vertices set），E称为边集（Edges set）。E的元素是一个二元组数对，用(x,y)表示，其中x,y∈V。 其中V是非空的顶点集合，即V &#x3D; {Vi|0≤i≤n-1,n≥1, Vi$\\in$VertexType}，其中VertexType表示任何类型，n为顶点数；E是V上二元关系的集合。 V(G1) &#x3D; {0,1,2,3,4,5,}E(G1) &#x3D; {(0,1),(0,2),(0,3),(0,4),(1,4),(2,4),(3,5),(4,5)}V(G2) &#x3D; {0,1,2,3,4}E(G2) &#x3D; {&lt;0,1&gt;,&lt;0,2&gt;,&lt;1,2&gt;,&lt;1,4&gt;,&lt;2,1&gt;,&lt;2,3&gt;,&lt;4,3&gt;} G1为无向图（undirected graph），图中每个元素为一个无序二元组 (u,v)，称作无向边 (Undirected edge)，简称**边 (Edge)，其中 u,v∈V。设 e&#x3D;(u,v)，则 u,v 称为 e 的端点 (End-vertex)**。 G2为有向图（directed graph），每一个元素为一个 (有序) 二元组 (u,v)，有时也写作 u→v，称作有向边 (Directed edge) 或弧 (Arc)，在不引起混淆的情况下也可以称作边。设 e&#x3D;u→v，则此时 u 称为 e 的起点 (Origin)，v 称为 e 的终点 (Terminus)，起点和终点也称为 e 的端点。 对于 V 中的每个元素，我们称其为**顶点 (Vertex)或节点 (Node)**，简称点 (Vertex)，顶点的集合称为点集 (Vertex set)，边的集合称为边集 (Edge set)。 图 G 的点集和边集可以表示为 V(G) 和 E(G)，在不引起混淆的情况下，也能表示成 V,E。图 G 的点数 |V(G)| 也被称作图 G 的阶 (Order)。 基本术语 顶点的度、入度、出度度：顶点v的度（Degree）是和v相关联的边的数目，记为TD(v)。 对于有向图G&#x3D;(V,{E})，如果弧∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧和顶点v，v’相关联。以顶点v为头弧的数目称为v的入度（InDegree），记为ID(v)；以v为尾的弧的数目称为v的出度（OutDegree），记为OD(v)； 顶点v的度为TD(v)&#x3D;ID(v)+OD(v)。 完全图、稠密图、稀疏图完全图：每个顶点都与其他顶点相邻接的图。 有很少条边或弧（边的条数|E|远小于|V|²）的图称为稀疏图（sparse graph），反之边的条数|E|接近|V|²，称为稠密图（dense graph）。 路径和回路依次遍历顶点序列之间的边所形成的轨迹。下图中依次访问顶点 V0 、V3 和 V2 ，则构成一条路径。 连通和连通分量在无向图 G 中，如果从顶点 v 到顶点 v’ 有路径，则称 v 和 v’ 是连通的。 如果对于图中任意两个顶点 vi 、vj ∈E， vi，和vj都是连通的，则称 G 是连通图，否则图为非连通图。 非连通图： 连通图： 强连通图和强连通分量在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 网“权”指边上面的信息，一般为数字。 每条边上都带有权的图叫做网。 存储结构12345678910111213141516171819ADT 图(Graph)Data 顶点的有穷非空集合和边的集合。Operation CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。 DestroyGraph(*G): 图G存在则销毁。 LocateVex(G, u): 若图G中存在顶点u，则返回图中的位置。 GetVex(G, v): 返回图G中顶点v的值。 PutVex(G, v, value): 将图G中顶点v赋值value。 FirstAdjVex(G, *v): 返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。 NextAdjVex(G, v, *w): 返回顶点v相对于顶点w的下一个邻接顶点， 若w是v的最后一个邻接点则返回“空”。 InsertVex(*G, v): 在图G中增添新顶点v。 DeleteVex(*G, v): 删除图G中顶点v及其相关的弧。 InsertArc(*G, v, w): 在图G中增添弧&lt;v,w&gt;，若G是无向图，还需要增添对称弧&lt;w,v&gt;。 DeleteArc(*G, v, w): 在图G中删除弧&lt;v,w&gt;，若G是无向图，则还删除对称弧&lt;w,v&gt;。 DFSTraverse(G): 对图G中进行深度优先遍历，在遍历过程对每个顶点调用。 HFSTraverse(G): 对图G中进行广度优先遍历，在遍历过程对每个顶点调用。endADT 邻接矩阵（Adjacency Matrix）用两个数组来表示图。一个一维的数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 对于 n 个点，构造一个 n * n 的矩阵，如果有从点 i 到点 j 的边，就将矩阵的位置 matrix[i][j] 置为 1。 通常会将图 G 中的结点编为1，2，…，|V| （这种编号可以是任意的），然后使用一个 |V| ×|V| 的矩阵 A&#x3D;(aij) 表示，该矩阵满足以下条件： 可以看出邻接矩阵是在无向图的表示中是转置矩阵，而在有向图中则不是。 对于带权图来说，可以将aij用来存储权值，如果两结点无连接，用0或无穷表示： 无向图邻接矩阵的特征 无向图的邻接矩阵对称且唯一。 有向图的邻接矩阵的第 i 行非零元素个数为第 i 个顶点的出度；第 j 列非零元素个数为第 j 个顶点的入度。 可快速判断两结点间是否有边。 A[i][j] &#x3D; 1代表顶点i与顶点j邻接，A[i][j] &#x3D; 0代表顶点i与顶点j不邻接。 顶点与自身之间并未邻接关系，因此边数组的对角线上的元素均为0。 顶点的度即为顶点所在的行或者列1的数目。 有向图邻接矩阵的特征 顶点数组长度为图的顶点数目n。边数组为n X n的二维数组。 边数组中，数组元素为1，即A[i][j] &#x3D; 1,代表第i个顶点与第j个顶点邻接，且i为尾，j为头。 A[i][j] &#x3D; 0代表顶点与顶点不邻接。 在有向图中，由于边存在方向性，因此数组不一定为对称数组。 对角线上元素为0。 第i行中，1的数目代表第i个顶点的出度。例如：顶点V1的出度为2，则顶点V1所在行的1的数目为2。 第j列中，1的数目代表第j个顶点的入度。例如：V3的入度为1，则V3所在列中1的数目为1。 邻接表（adjacency list）邻接链表（adjacency list）由图中的每一个结点及其相邻结点生成以该结点为头结点的一组链表。 当处理稀疏图时，相对于邻接矩阵，邻接链表无需一次就分配那么大的空间，而是在遍历图的过程中一点一点地分配，它是一种顺序分配和链式分配相结合的存储结构。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。 虽然邻接链表是一种非常节约空间的结构，但在无向图中用邻接链表表示也会出现数据冗余。这是因为表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。 邻接表存储方法是一种数组存储和链式存储相结合的存储方法。在邻接表中，对图中的每个顶点建立一个单链表，第 i 个单链表中的结点依附于顶点 Vi 的边（对有向图是以顶点Vi为尾的弧）。链表中的节点称为表节点，共有 3个域，具体结构见下图： 表结点由三个域组成，adjvex存储与Vi邻接的点在图中的位置，nextarc存储下一条边或弧的结点，info存储与边或弧相关的信息如权值。 除表结点外，需要在数组中存储头结点，头结点由两个域组成，分别指向链表中第一个顶点和存储Vi的名或其他信息。具体结构如下图： 其中，data域中存储顶点相关信息，firstarc指向链表的第一个节点。 无向图采用邻接表方式存储 采用邻接表方式存储图 6.1 中的无向图，绘图过程中忽略边节点的info信息，头结点中的 data 域存储顶点名称。以V1顶点为例，V1顶点的邻接顶点为V2、V3、V4，则可以创建3个表节点，表节点中adjvex分别存储V2、V3、V4的索引1、2、3，按照此方式，得到的邻接表为： 特征 数组中头节点的数目为图的顶点数目。 链表的长度即为顶点的度。例如：V1顶点的度为3，则以V1为头节点的链表中表节点的数目为3。 有向图采用邻接链表方式存储 采用邻接表方式存储图6.3中的有向图，绘图过程中忽略边节点的info信息，头结点中的data域存储顶点名称。以V1顶点为例，V1顶点的邻接顶点为V2、V3、V4，但是以V1顶点为尾的边只有两条，即和因此，创建2个表节点。表节点中adjvex分别存储V3、V4的索引2、3，按照此方式，得到的邻接表为： 特征 数组中表节点的数目为图的顶点数目。 链表的长度即为顶点的出度。例如V1的出度为2，V1为头节点的链表中，表节点的数目为2。 顶点Vi的入度为邻接表中所有adjvex值域为i的表结点数目。例如：顶点V3的入度为4，则链表中所有adjvex值域为2的表结点数目为4。 逆邻接表在邻接表中，可以轻易的得出顶点的出度，但是想要得到顶点的入度，则需要遍历整个链表。为了便于确定顶点的入度，可以建立有向图的逆邻接表。逆邻接表的建立与邻接表相反。 十字链表对于有向图而言，邻接链表的缺陷是要查询某个顶点的入度时需要遍历整个链表，而逆邻接链表在查询某个顶点的出度时要遍历整个链表。为了解决这些问题，十字链表将邻接链表和逆邻接链表综合了起来，而得到的一种十字链表。在十字链表中，每一条边对应一种边节点，每一个顶点对应为顶点节点。 顶点结点 顶点节点即为头节点，由3个域构成，具体形式如下： 其中，data域存储与顶点相关的信息，firstin和firstout分别指向以此顶点为头或尾的第一个边节点。 边结点 在边节点为链表节点，共有5个域，具体形式如下： 其中，尾域tailvex和头域headvex分别指向尾和头的顶点在图中的位置。链域hlink指向头相同的下一条边，链域tlink指向尾相同的下一条边。info 存储此条边的相关信息。 例如： 采用十字链表的方式存储图的有向图，绘图过程忽略边节点中的info信息，表头节点中的data域存储顶点名称。以V1顶点为例，顶点节点的data域存储V1顶点名，firstin存储以V1顶点为头第一个边节点，以V1顶点为头边为，firstout存储以以V1顶点为尾第一个边节点，对应边为。按照此规则，得到的十字链表存储为： 邻接多重表对于无向图而言，其每条边在邻接链表中都需要两个结点来表示，而邻接多重表正是对其进行优化，让同一条边只用一个结点表示即可。邻接多重表仿照了十字链表的思想，对邻接链表的边表结点进行了改进。 其中，ivex和jvex是指某条边依附的两个顶点在顶点表中的下标。 ilink指向依附顶点ivex的下一条边，jlink指向依附顶点jvex的下一条边。info存储边的相关信息。 重新定义的顶点结构如下图： 其中，data存储顶点的相关信息，firstedge指向第一条依附于该顶点的边。 所示的无向图，采用邻接多重表存储，以 V0 为例，顶点节点的data域存储V0名称，firstedge 指向(V0 , V1)边，边节点中的ilink指向依附V0顶点的下一条边(V0 , V3)，jlink指向依附V1顶点的下一条边(V1 , V2)，按照此方式建立邻接多重表： 关联矩阵邻接矩阵和邻接链表都是用来表示图中各个点和每个点之间的关系，而关联矩阵（incidence matrix）即用一个矩阵来表示各个点和每条边之间的关系。 设无向图 G&#x3D;(V,E)，其中顶点集 V&#x3D;v1,v2,⋯,vn, 边集 E&#x3D;e1,e2,⋯,em，用 aij 表示顶点vi与边ej 关联的次数，可能取值为0, 1, 2, ….，我们称所得矩阵A&#x3D;A(G)&#x3D;(aij)n×m为图 G 的关联矩阵。 对于关联矩阵第一行1 1 1 0，表示点v1和各边的关系。如图所示，v1和e1,e2,e3相连，和e4未连，故关联矩阵的值为1 1 1 0. 下面各行为点v2，v3,v4 和各边的关联，以此类推。因此每一行值的总和为该点的度。 对于有向图，若bij&#x3D;1，表示边j离开点i。 若 bij&#x3D; -1， 表示边j进入点i。 若 bij &#x3D; 0，表示边j和点i不相关联。 图的遍历 深度优先搜索遍历（DFS: Depdth First Search）广度优先搜索遍历（BFS: Breadth First Search）非连通图的遍历 图的生成树和最小生成树普里姆算法克鲁斯卡尔算法最短路径 从一顶点到其余顶点的最短路径每对顶点之间的最短路径拓扑排序 关键路径参考 https://www.cxyxiaowu.com/1293.html","tags":[{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://airshu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"程序语言/数据结构","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"开发流程的思考","date":"2023-07-15T01:43:36.895Z","path":"wiki/技术开发/技术管理/开发流程的思考/","text":"目前大多数互联网公司的开发流程如下图： 需求收集一个新功能的出现，可能来自多个地方。运营觉得有了XX功能，用户量就能增加XX倍；产品觉得XX竟品做了XX功能，我们也要做个一模一样的；开发觉得XX库又提升了XX性能。版本初期，一般由产品统一收集相关需求。 产品文档、设计文档这个阶段，产品开始整理前面收集到的idea。他不太清楚的点可能会找开发、测试。比如XX功能技术上是否可行。然后开始写产品文档。完成后，会进行需求宣讲，开发、测试同事会参与。这个过程中，开发、测试会提出自己的意见，产品方进行解答。没问题后，该需求会进入设计阶段。这个阶段中，开发人员会根据需求进行概要设计，比如了解需要用到的技术，看看里面有什么坑。 开发阶段当设计稿完成后，该需求会进入到开发阶段。开发人员拿到需求后，一般的小厂就开始对着产品文档、设计稿开发了，大厂会做详细设计，比如画流程图。开发完成后，小厂就直接进入测试阶段了，做的稍微好点，开发会进行简单的自我测试，稍微再好点的，可能会自己写些测试脚本。而大厂会有其他的一些流程，比如单元测试、集成测试，开发完成后，进行代码Review。开发的过程中还牵扯到前后端联调，所以在刚开始开发时，做同一个需求的不同端同事应该沟通好联调相关事宜。 开发阶段，测试同事也会同步了解需求，并完成相关测试用例。 测试阶段这个阶段就是发现bug、改bug的循环，当把测试发现的所有bug改完后，就达到灰度条件了。 上线阶段上线之前准备一份上线清单，列出该次版本所有需要部署的项，标注处理人、处理时间、处理状态。对于比较大的需求，这一步非常重要，方便大家检查是否有遗漏。 灰度的作用是进行少量的更新，检查新上线的需求是否存在问题，将风险降到最低。当灰度一段时间后，App的崩溃率在正常范围内时，即可安排正式上线。 上线后异常收集，通过各种方式收集线上的bug，发现测试没有发现的问题 总结本次迭代的产品需求变更情况、开发bug情况，bug按照严重性进行归类，总结出现的原因，积累沉淀 思考有些小厂为了能快速的上线，会省掉其中的一些环节，而那些环节恰恰又是很重要的。为什么会经常在线上出锅，一方面来自测试的不严谨，漏掉了某些使用场景没测试，或者说就是没发现那些问题。一方面也来自开发人员，他们为了赶快，不会花很多心思去考虑代码的复用、性能问题。结果造成问题频繁出现。 代码review个人觉得是非常有必要去做的一件事情，让资深的工程师来review其他人的代码，一方面能发现问题，一方面对于被review方，也是快速提升的好机会。 还有单元测试、集成测试，这些虽然做的时候可能会多花一些时间，但当项目不断迭代，他们也是发现问题的重要方式。现实环境中，很多小厂都是不会考虑这方面的。 现在市面上出现了很多项目管理的工具，个人是不建议同时使用多个工具。来回切换麻烦，数据也无法统一处理。其实大家都大同小异，而且大部分的定制化程度很是蛮高的，完全可以在一款工具中，进行相关的定制来达到自己的目的。比如TAPD就实现了从需求收集到项目上线整个流程的管理方案。 项目的进度可以通过相应的工具来管理，项目的质量则更多的应该通过人来管理。只有让团队成员的技术都变得强大了，整体的代码质量才会稳定。光抓进度不管质量，项目迟早有一点会掉到大坑里面。","tags":[{"name":"技术管理","slug":"技术管理","permalink":"http://airshu.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"技术管理","slug":"技术开发/技术管理","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}]},{"title":"Mac瘦身","date":"2023-07-15T01:43:36.895Z","path":"wiki/工具软件/Mac/Mac瘦身/","text":"","tags":[{"name":"mac","slug":"mac","permalink":"http://airshu.github.io/tags/mac/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"name":"Mac","slug":"工具软件/Mac","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Mac/"}]},{"title":"Mac软件安装笔记","date":"2023-07-15T01:43:36.895Z","path":"wiki/工具软件/Mac/Mac软件安装笔记/","text":"brew命令1234567brew services list 查看服务状态brew services run mysql # 启动mysql 服务brew services start mysql # 启动 mysql 服务，并注册开机自启brew services stop mysql # 停止 mysql 服务，并取消开机自启brew services restart mysql # 重启 mysql 服务，并注册开机自启brew services cleanup # 清除已卸载应用的无用配置 mysql123456789101112131415161718brew install mysqlbrew services start mysqlbrew services stop mysqlmysql -urootSHOW VARIABLES LIKE &#x27;validate_password%&#x27;; //查看密码初始策略SET GLOBAL validate_password.policy=LOW; //设置某个属性SET GLOBAL validate_password.length=6; //修改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH caching_sha2_password BY &#x27;yourpasswd&#x27;;flush privileges;describe user; //查看表字段 使用mysql的配置脚本：&#x2F;usr&#x2F;local&#x2F;opt&#x2F;mysql&#x2F;bin&#x2F;mysql_secure_installation &#x2F;&#x2F;mysql 提供的配置向导启动这个脚本后 重置密码123456$ brew services stop mysql$ pkill mysqld$ rm -rf /usr/local/var/mysql/ # NOTE: this will delete your existing database!!!$ brew postinstall mysql$ brew services restart mysql$ mysql -u root","tags":[{"name":"mac","slug":"mac","permalink":"http://airshu.github.io/tags/mac/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"name":"Mac","slug":"工具软件/Mac","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Mac/"}]},{"title":"热更新","date":"2023-07-15T01:43:36.894Z","path":"wiki/JavaScript/ReactNative/热更新/","text":"基本使用 安装CodePush CLI 注册账号 注册App 原生端配置 RN代码集成 发布 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#安装appcenter工具npm install -g appcenter-cli#登录appcenter login#登出appcenter logoutappcenter tokens listappcenter tokens delete &lt;machineName&gt;#查看账户信息appcenter profile list# 1、创建iOS应用appcenter apps create -d MyApp-iOS -o iOS -p React-Native# 2、创建Android应用appcenter apps create -d MyApp-Android -o Android -p React-Native# 查询账号下的所有应用appcenter apps listappcenter apps delete -a &lt;ownerName&gt;/&lt;appName&gt;# ownerName：用户名称# appName：创建的应用名称# 创建部署appcenter codepush deployment add -a &lt;ownerName&gt;/&lt;appName&gt; Staging# 配置生产环境appcenter codepush deployment add -a &lt;ownerName&gt;/&lt;appName&gt; Productionn# ownerName：用户名称# appName：创建的应用名称# 删除应用的开发环境appcenter codepush deployment remove -a &lt;ownerName&gt;/&lt;appName&gt; Staging# 删除应用的生产环境appcenter codepush deployment remove -a &lt;ownerName&gt;/&lt;appName&gt; Production#查询应用keyappcenter codepush deployment list -a &lt;ownerName&gt;/&lt;appName&gt; -k#发布appcenter codepush release-react -a airdady/test -t 1.0.11 -o ./build -d Staging","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"Android原生UI组件","date":"2023-07-15T01:43:36.892Z","path":"wiki/JavaScript/ReactNative/Android原生UI组件/","text":"提供原生视图的流程： 创建一个ViewManager子类 实现createViewInstance 导出视图的属性设置器：使用@ReactProp（或@ReactPropGroup）注解 把这个视图管理器注册到应用程序包的createViewManagers 实现JavaScript模块 参考 Android原生UI组件","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"Android原生模块","date":"2023-07-15T01:43:36.892Z","path":"wiki/JavaScript/ReactNative/Android原生模块/","text":"模块的定义要实现通信，需要先定义ReactContexBaseJavaModule，并将ReactPackage注册到ReactInstanceManager中 ReactMethod在module中定义可以被JS调用的函数 1. 使用集成到现有Android应用中的IndexModule文件，添加一个ReactMethod1234567891011121314151617181920212223242526272829public class IndexModule extends ReactContextBaseJavaModule &#123; @NonNull @Override public String getName() &#123; return &quot;IndexModule&quot;; &#125; @ReactMethod public void show(String message, int duration) &#123; Toast.makeText(getReactApplicationContext(), message, duration).show(); &#125; private static final String DURATION_SHORT_KEY = &quot;SHORT&quot;; private static final String DURATION_LONG_KEY = &quot;LONG&quot;; //返回的常量可供JS使用 @Nullable @Override public Map&lt;String, Object&gt; getConstants() &#123; final Map&lt;String, Object&gt; constants = new HashMap&lt;&gt;(); constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT); constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG); return constants; &#125;&#125; ReactMethod支持的参数类型映射关系 Boolean -&gt; Bool Integer -&gt; Number Double -&gt; Number Float -&gt; Number String -&gt; String Callback -&gt; function ReadableMap -&gt; Object ReadableArray -&gt; Array 2. js调用1234567891011121314//ToastExample.jsimport &#123;NativeModules&#125; from &#x27;react-native&#x27;;//index对于IndexModule中getName的返回值export default NativeModules.index;//其他地方使用import ToastExample from &#x27;./ToastExample&#x27;;ToastExample.show(&#x27;hoho&#x27;, ToastExample.SHORT); 回调函数CallbackCallback可以在JS调用原生的方法里回调JS方法 123456789//Callback测试@ReactMethodpublic void testCallback(String param1, Callback successCallback, Callback errorCallback) &#123; try &#123; successCallback.invoke(param1); &#125; catch (Exception e) &#123; errorCallback.invoke(&quot;error:&quot; + e.getMessage()); &#125;&#125; 123456789&lt;Button onPress=&#123;()=&gt;&#123; NativeModules.IndexModule.testCallback(&quot;测试回调&quot;, (msg)=&gt;&#123; NativeModules.IndexModule.show(msg, NativeModules.IndexModule.SHORT); &#125;, (error) =&gt; &#123; NativeModules.IndexModule.show(error, NativeModules.IndexModule.SHORT); &#125;);&#125;&#125; title=&#123;&quot;Callback测试&quot;&#125;&gt;&lt;/Button&gt; Promise使用Promise，可以在声明了async的异步函数内使用await关键字来调用 1234@ReactMethodpublic void testPromise(String param1, Promise promise) &#123; promise.resolve(param1);&#125; 12345678&lt;Button onPress=&#123;async ()=&gt; &#123; var result = await NativeModules.IndexModule.testPromise(&#x27;Awesome&#x27;); NativeModules.IndexModule.show(result, NativeModules.IndexModule.SHORT);&#125;&#125; title=&#123;&quot;测试Promise&quot;&#125;&gt;&lt;/Button&gt; 发送事件原生模块可以在没有被调用的情况下通过RCTDeviceEventEmitter往JavaScript发送事件通知， 1234567891011121314151617181920@ReactMethodpublic void testSendEvent(String param1) &#123; WritableMap params = Arguments.createMap(); params.putString(&quot;eventProperty&quot;, param1); setEvent(&quot;EventReminder&quot;, params);&#125;/** * 往JS发送事件 * @param eventName * @param params */public void setEvent(String eventName, WritableMap params) &#123; getReactApplicationContext().getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class) .emit(eventName, params);&#125; 12345678910111213141516171819202122232425&lt;Button onPress=&#123;()=&gt; &#123; NativeModules.IndexModule.testSendEvent(&#x27;emitttt&#x27;);&#125;&#125; title=&#123;&quot;测试Event Emitter&quot;&#125;&gt;&lt;/Button&gt;//监听原生事件function compnentDidMount() &#123; const eventEmitter = new NativeEventEmitter(NativeModules.IndexModule); this.listener = eventEmitter.addListener(&#x27;EventReminder&#x27;, (reminder) =&gt; &#123; console.log(reminder.name); console.log(reminder.location); console.log(reminder.date); //toast原生侧发送的消息 NativeModules.IndexModule.show(reminder.eventProperty, NativeModules.IndexModule.SHORT); &#125;);&#125;function componentWillUnmount() &#123; this.listener &amp;&amp; this.listener.remove();&#125;compnentDidMount(); 从startActivityResult中获取结果运用Promise，当JS调用某个原生方法，原生打开另一个原生界面，原生界面返回的数据通过Promise再返回给JS。通过以下代码来监听回调 1reactContext.addActivityEventListener(mActivityResultListener); 具体实例创建一个ImagePickerModule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.lqd.androidpractice.rn.modules;import android.util.Log;import androidx.annotation.NonNull;import com.facebook.react.bridge.ActivityEventListener;import com.facebook.react.bridge.BaseActivityEventListener;import com.facebook.react.bridge.Promise;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.bridge.ReactContextBaseJavaModule;import com.facebook.react.bridge.ReactMethod;public class ImagePickerModule extends ReactContextBaseJavaModule &#123; private static final int IMAGE_PICKER_REQUEST = 467081; private static final String E_ACTIVITY_DOES_NOT_EXIST = &quot;E_ACTIVITY_DOES_NOT_EXIST&quot;; private static final String E_PICKER_CANCELLED = &quot;E_PICKER_CANCELLED&quot;; private static final String E_FAILED_TO_SHOW_PICKER = &quot;E_FAILED_TO_SHOW_PICKER&quot;; private static final String E_NO_IMAGE_DATA_FOUND = &quot;E_NO_IMAGE_DATA_FOUND&quot;; @NonNull @Override public String getName() &#123; return &quot;ImagePickerModule&quot;; &#125; private Promise mPickerPromise; private final ActivityEventListener mActivityEventListener = new BaseActivityEventListener() &#123; @Override public void onActivityResult(int requestCode, int resultCode, android.content.Intent data) &#123; if (requestCode == IMAGE_PICKER_REQUEST) &#123; if (mPickerPromise != null) &#123; if (resultCode == android.app.Activity.RESULT_CANCELED) &#123; mPickerPromise.reject(E_PICKER_CANCELLED, &quot;Image picker was cancelled&quot;); &#125; else if (resultCode == android.app.Activity.RESULT_OK) &#123; android.net.Uri uri = data.getData(); if (uri == null) &#123; mPickerPromise.reject(E_NO_IMAGE_DATA_FOUND, &quot;No image data found&quot;); &#125; else &#123; mPickerPromise.resolve(uri.toString()); &#125; &#125; mPickerPromise = null; &#125; &#125; &#125; &#125;; public ImagePickerModule(ReactApplicationContext reactContext) &#123; super(reactContext); reactContext.addActivityEventListener(mActivityEventListener); &#125; /** * JS调用选择图片，并回调给JS * @param promise */ @ReactMethod public void pickImage(final Promise promise) &#123; Log.d(&quot;ImagePickerModule&quot;, &quot;pickImage&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); android.app.Activity currentActivity = getCurrentActivity(); if (currentActivity == null) &#123; promise.reject(E_ACTIVITY_DOES_NOT_EXIST, &quot;Activity doesn&#x27;t exist&quot;); return; &#125; // Store the promise to resolve/reject when picker returns data mPickerPromise = promise; try &#123; final android.content.Intent galleryIntent = new android.content.Intent(); galleryIntent.setType(&quot;image/*&quot;); galleryIntent.setAction(android.content.Intent.ACTION_GET_CONTENT); final android.content.Intent chooserIntent = android.content.Intent.createChooser(galleryIntent, &quot;Pick an image&quot;); currentActivity.startActivityForResult(chooserIntent, IMAGE_PICKER_REQUEST); &#125; catch (android.content.ActivityNotFoundException e) &#123; mPickerPromise.reject(E_FAILED_TO_SHOW_PICKER, e); mPickerPromise = null; &#125; &#125;&#125; JS测试 12345678&lt;Button onPress=&#123; async ()=&gt;&#123; var result = await NativeModules.ImagePickerModule.pickImage(); console.log(result);&#125;&#125; title=&#123;&quot;测试Activity Result&quot;&#125;&gt;&lt;/Button&gt; 监听生命周期事件12345678910111213141516171819//监听生命周期回调reactContext.addLifecycleEventListener(new LifecycleEventListener() &#123; @Override public void onHostResume() &#123; &#125; @Override public void onHostPause() &#123; &#125; @Override public void onHostDestroy() &#123; &#125;&#125;);","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"}]},{"title":"React JS源码分析","date":"2023-07-15T01:43:36.892Z","path":"wiki/JavaScript/React/源码分析/reactjs源码分析/","text":"参考 reactjs源码分析-下篇（更新机制实现原理）","tags":[{"name":"React","slug":"React","permalink":"http://airshu.github.io/tags/React/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://airshu.github.io/categories/JavaScript/React/"},{"name":"源码分析","slug":"JavaScript/React/源码分析","permalink":"http://airshu.github.io/categories/JavaScript/React/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"Flutter动画","date":"2023-07-15T01:43:36.891Z","path":"wiki/Flutter/Flutter动画/","text":"https://flutter.cn/docs/development/ui/animations 动画的基本组成Animation作用：保存动画的差值和状态。整个动画执行过程可以是线性的、曲线的、一个步进函数活着任何其他曲线，由Curve来决定。 addListener 给Animation添加帧监听器 addStatusListener 动画开始、结束、正向或反向时的回调 Curve作用：定义动画曲线 内置Curves曲线： linear：匀速 decelerate：匀减速 ease：开始加速后面减速 easeIn：开始慢后面快 easeOut：开始快后面慢 easeInOut：开始慢，然后加速，最后再减速 AnimationController作用：用于控制动画，包含启动forward、停止stop、反向播放reverse等 Ticker当创建AnimationController时，需要传递一个vsync参数，它接收一个TickerProvider类型。通常我们会将SingleTickerProviderStateMixin添加到State的定义中，然后将State对象作为vsync的值。 SingleTickerProviderStateMixin和TickerProviderStateMixin，这两个类的区别就是是否支持创建多个TickerProvider Tween默认情况下，AnimationController对象值的范围是[0.0，1.0]。如果我们需要构建UI的动画值在不同的范围或不同的数据类型，则可以使用Tween来添加映射以生成不同的范围或数据类型的值。例如，像下面示例，Tween生成[-200.0，0.0]的值 1final Tween doubleTween = Tween&lt;double&gt;(begin: -200.0, end: 0.0); Tween构造函数需要begin和end两个参数。Tween的唯一职责就是定义从输入范围到输出范围的映射。输入范围通常为[0.0，1.0]，但这不是必须的，我们可以自定义需要的范围。Tween继承自Animatable，而不是继承自Animation，Animatable中主要定义动画值的映射规则。 123456789101112final Tween colorTween = ColorTween(begin: Colors.transparent, end: Colors.black54);final AnimationController controller = AnimationController( duration: const Duration(milliseconds: 500), vsync: this,);Animation&lt;int&gt; alpha = IntTween(begin: 0, end: 255).animate(controller);final Animation curve = CurvedAnimation(parent: controller, curve: Curves.easeOut);Animation&lt;int&gt; alpha = IntTween(begin: 0, end: 255).animate(curve); Tween对象不存储任何状态，相反，它提供了evaluate(Animation animation)方法，它可以获取动画当前映射值。 Animation对象的当前值可以通过value()方法取到。evaluate函数还执行一些其他处理，例如分别确保在动画值为0.0和1.0时返回开始和结束状态 Tween的子类： ColorTween ConstantTween CurveTween IntTween RectTween ReverseTween SizeTween StepTween 基本用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ScaleAnimationRoute extends StatefulWidget &#123; const ScaleAnimationRoute(&#123;Key? key&#125;) : super(key: key); @override _ScaleAnimationRouteState createState() =&gt; _ScaleAnimationRouteState();&#125;//需要继承TickerProvider，如果有多个AnimationController，则应该使用TickerProviderStateMixin。class _ScaleAnimationRouteState extends State&lt;ScaleAnimationRoute&gt; with SingleTickerProviderStateMixin &#123; late Animation&lt;double&gt; animation; late AnimationController controller; @override initState() &#123; super.initState(); controller = AnimationController( duration: const Duration(seconds: 2), vsync: this, ); //匀速 //图片宽高从0变到300 animation = Tween(begin: 0.0, end: 300.0).animate(controller); animation.addListener(() &#123; setState(() =&gt; &#123;&#125;); &#125;); //启动动画(正向执行) controller.forward(); &#125; @override Widget build(BuildContext context) &#123; return Center( child: Image.asset( &quot;imgs/avatar.png&quot;, width: animation.value, height: animation.value, ), ); &#125; @override dispose() &#123; //路由销毁时需要释放动画资源 controller.dispose(); super.dispose(); &#125;&#125; 以上写法封装后便是AnimatedBuilder 1234AnimatedBuilder(&#123; child: xx, animation: yy,//绑定Animation&#125;); 隐式动画Implicit Animations ImplicitlyAnimatedWidget的子类，可以方便的设置各种各种属性的动画。隐式动画只需要传递duration，即可自行驱动。简单的动画场景可使用。 系统实现的隐式动画 AnimatedContainer：Container属性变化过渡动画 AnimatedAlign：alignment变化过渡动画 AnimatedOpacity：透明度 AnimatedPositioned：配合Stack使用 AnimatedRotation AnimatedScale AnimatedSlide AnimatedSwitcher AnimatedSize AnimatedCrossFade AnimatedTheme AnimatedPositionedDirectional AnimatedPhysicalModel AnimatedPadding 常用属性 duration：设置动画时长 curve：设置动画曲线 onEnd：动画结束回调 自定义隐式动画使用TweenAnimationBuilder，该 Widget 使用的时候我们需要传递 duration 参数动画时间、tween 参数动画要设置的值的范围（补间）、重要的还有 builder 参数，builder函数的参数包含context、补间参数tween的类型、还有child 123456789101112131415161718TweenAnimationBuilder&lt;double&gt;( tween: Tween&lt;double&gt;(begin: 0, end: 2 * pi), duration: Duration(seconds: 2), builder: (BuildContext context, double angle, Widget child) &#123; return Transform.rotate( angle: angle, child: Container( color: Colors.red, width: 100, height: 100, ), ); &#125;,), 显示动画Explicit Animations 继承自AnimatedWidget，通过传入listenable来驱动视图变化。自己来控制动画的运行 AlignTransition AnimatedBuilder DecoratedBoxTransition DefaultTextStyleTransition RelativePositionedTransition RotationTransition：旋转 ScaleTransition：缩放动画，可以指定中心点 FadeTransition：透明度动画 SizeTransition：宽高变化，不会引起内容的变形 SlideTransition：位移动画 交织动画多个动画交错在一起，通过一个controller控制。 12345// 多个tween绑定controllerAnimationController controller = AnimationController();Tween&lt;double&gt;(begin: 0, end: 100).animate(CurvedAnimation(parent: controller, curve: Interval(0.0, 0.5, curve: Curves.ease)));ColorTween(begin: Colors.green, end: Colors.red,).amimate(CurvedAnimation(parent: controller, curve: Interval(0.5, 0.8, curve: Curves.ease,))); 自定义动画参考 Flutter实战-动画 深入理解Flutter动画原理","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"图片内存优化","date":"2023-07-15T01:43:36.891Z","path":"wiki/Flutter/未分类/图片内存优化/","text":"Flutter中图片内存优化策略： 使用ResizeImage 使用cacheWidth、cacheHeight Android中图片占用内存计算方法 Flutter图片加载优化探索 Flutter加载大图内存问题处理","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"flutter_image_compress","date":"2023-07-15T01:43:36.891Z","path":"wiki/Flutter/开源库/图片相关/flutter_image_compress/","text":"https://pub.dev/packages/flutter_image_compress https://github.com/fluttercandies/flutter_image_compress 图片压缩工具 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 1. compress file and get Uint8List// 根据配置压缩图片Future&lt;Uint8List&gt; testCompressFile(File file) async &#123; var result = await FlutterImageCompress.compressWithFile( file.absolute.path, minWidth: 2300, minHeight: 1500, quality: 94, rotate: 90, ); print(file.lengthSync()); print(result.length); return result;&#125;// 2. compress file and get file.// 将图片压缩成新的图片Future&lt;File&gt; testCompressAndGetFile(File file, String targetPath) async &#123; var result = await FlutterImageCompress.compressAndGetFile( file.absolute.path, targetPath, quality: 88, rotate: 180, ); print(file.lengthSync()); print(result.lengthSync()); return result;&#125;// 3. compress asset and get Uint8List.// 压缩asset的图片，返回Uint8List类型Future&lt;Uint8List&gt; testCompressAsset(String assetName) async &#123; var list = await FlutterImageCompress.compressAssetImage( assetName, minHeight: 1920, minWidth: 1080, quality: 96, rotate: 180, ); return list;&#125;// 4. compress Uint8List and get another Uint8List.// 对Uint8List图片数据进行压缩Future&lt;Uint8List&gt; testComporessList(Uint8List list) async &#123; var result = await FlutterImageCompress.compressWithList( list, minHeight: 1920, minWidth: 1080, quality: 96, rotate: 135, ); print(list.length); print(result.length); return result;&#125; 常用参数 rotate 需要旋转，可使用此参数 quality 图片质量，如果是png格式，在iOS端会被忽略 format 支持jpeg、png，默认是jpeg","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"图片相关","slug":"Flutter/开源库/图片相关","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3/"}]},{"title":"image_cropper","date":"2023-07-15T01:43:36.891Z","path":"wiki/Flutter/开源库/图片相关/image_cropper/","text":"https://pub.dev/packages/image_cropper https://github.com/hnvn/flutter_image_cropper 图片裁剪库，封装了uCrop、TOCropViewController和croppie","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"图片相关","slug":"Flutter/开源库/图片相关","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3/"}]},{"title":"Android中图片占用内存计算方法","date":"2023-07-15T01:43:36.890Z","path":"wiki/Android/性能优化/Android中图片占用内存计算方法/","text":"我们在电脑上看到的 png 格式或者 jpg 格式的图片，png(jpg) 只是这张图片的容器，它们是经过相对应的压缩算法将原图每个像素点信息转换用另一种数据格式表示，以此达到压缩目的，减少图片文件大小。而当我们通过代码，将这张图片加载进内存时，会先解析图片文件本身的数据格式，然后还原为位图，也就是 Bitmap 对象，Bitmap 的大小取决于像素点的数据格式以及分辨率两者。 结论： 占用内存大小的计算公式：分辨率 * 像素点大小；Android中像素点大小有： 123456789101112131415161718192021222324252627282930313233/** * 可用的bitmap配置， 一个bitmap配置描述的是每个像素的存储格式，这将会影响到图片的质量 (颜色深 * 度) 以及显示透明/半透明颜色的能力 */public enum Config &#123; // 这些枚举中的值必须要与Skia图像引擎的SkBitmap.h中对应值一一对应 /** * 只有一个alpha通道 * 每个像素占1个字节 */ ALPHA_8 (1), /** *每个像素占用2个字节，只有RGB 3个通道，没有alpha 通道 * 红色的精度是5 bits, 绿色精度是6 bits，蓝色精度是5 */ RGB_565 (3), /** * 每个像素占用2个字节. * (虽然占用内存只有 ARGB8888 的一半，不过已经被官方嫌弃) */ @Deprecated ARGB_4444 (4), /** * 每个像素占用4个字节. 每个通道 (RGB的3个通道和alpha * 的1个透明度通道) 的进度是8bit (256个可能值) * 这种配置是最灵活的， 质量最好，尽量使用这种格式. */ ARGB_8888 (5);&#125; 同一张图放在不同地方分辨率不一样，不同res目录占用内存大小不一样。本地磁盘、网络等按照原图的分辨率来计算；res目录中的图片，分辨率会进行转换，规则如下： 新分辨率&#x3D;原图横向分辨率（设备dpi&#x2F;目录对应的dpi）原图纵向分辨率*（设备的dpi&#x2F;目录对应的dpi） 优化内存的方法： 设置像素点的使用方式，比如使用RGB_565 降低分辨率inSampleSize 参考 Android中一张图片占据的内存大小是如何计算","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"虚拟主机的玩法","date":"2023-06-17T02:29:30.110Z","path":"wiki/技术开发/杂项/虚拟主机的玩法/","text":"代理神器Shadowsocks安装 wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 操作 启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 设置密码 查看ss服务器所开放的端口 ss -lntp | grep ssserver 查看ss的配置文件 ps aux | grep ssserver 修改对应的配置文件，重启 什么是socks代理Socks 是个电路级的底层网关，是 DavidKoblas 在 1990 年开发的， 此后就一直作为 Internet RFC 标准的开放标准。Socks 不要求应用程序遵循特定的操作系统平台，Socks 代理与应用层代理、 HTTP 层代理不同，Socks 代理只是简单地传递数据包，而不必关心是何种应用协议(比如 FTP、HTTP 和 NNTP 请求)。所以，Socks 代理比其他应用层代理要快得多。 云储存工具seafiledocker run -d --name seafile -e SEAFILE_SERVER_HOSTNAME=seafile.example.com -e SEAFILE_ADMIN_EMAIL=xxxj@gmail.com -e SEAFILE_ADMIN_PASSWORD=123456 -v /opt/seafile-data:/shared -p 8088:80 seafileltd/seafile:latest 搭建Maven仓库docker pull sonatype/ docker run -d -p 8081:8081 --name nexus -v /home/alone/nexus-data:/nexus-data sonatype/nexus3 /home/alone/nexus-data:/nexus-data表示数据存储目录 搭建FTP服务器修改ssh端口vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config修改Port 2222重启服务&#x2F;etc&#x2F;init.d&#x2F;ssh restart 安装v2ray123456789101112131415161718192021222324252627282930313233343536373839404142卸载v2raysystemctl stop v2raysystemctl disable v2rayservice v2ray stopupdate-rc.d -f v2ray removerm -rf /etc/v2ray/* #(配置文件)rm -rf /usr/bin/v2ray/* #(程序)rm -rf /var/log/v2ray/* #(日志)rm -rf /lib/systemd/system/v2ray.service #(systemd 启动项)rm -rf /etc/init.d/v2ray #(sysv 启动项)wget https://install.direct/go.shsudo bash go.shwget https://git.io/v2ray.sh## 启动systemctl start v2ray## 停止systemctl stop v2ray## 重启systemctl restart v2ray## 开机自启systemctl enable v2ray查看状态service v2ray statuscenter os使用## 查看已开放端口firewall-cmd --zone=public --list-ports## 添加开放端口firewall-cmd --zone=public --add-port=80/tcp --permanent","tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://airshu.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"Ruby版本管理工具rbenv","date":"2023-06-17T02:29:30.106Z","path":"wiki/工具软件/rbenv/","text":"类似Java、Python、Flutter，Ruby也进行版本管理，主流有rvm、rbenv两种方案，这里因为Java选择jenv，看名字选的rbenv。其实大家的原理都是一样的，通过修改Path来指定对应版本 安装和使用12345678910111213141516171819202122232425262728293031323334brew install rbenv ruby-build# 添加以下内容到zshrc文件中eval &quot;$(rbenv init - zsh)&quot;# 查看最新稳定版本号rbenv install -l# 列出本地所有版本rbenv install -L# 安装具体版本rbenv install 3.1.2# 指定全局版本rbenv global 3.1.2# 指定当前目录使用的版本rbenv local 3.1.2# 卸载具体某个版本rbenv uninstall 3.1.2# 展示安装的版本 rbenv versions# 展示当前使用的版本rbenv version# 卸载rbenvrm -rf &quot;$(rbenv root)&quot;brew uninstall rbenv 参考 https://github.com/rbenv/rbenv","tags":[],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"Mac OS常用命令","date":"2023-06-17T02:29:30.091Z","path":"wiki/工具软件/Mac/MacOS常用命令/","text":"12345678# 查看端口使用sudo lsof -i :8088# 杀掉进程kill -9 pid","tags":[{"name":"mac","slug":"mac","permalink":"http://airshu.github.io/tags/mac/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"name":"Mac","slug":"工具软件/Mac","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Mac/"}]},{"title":"高效的使用Mac","date":"2023-06-17T02:29:30.091Z","path":"wiki/工具软件/Mac/高效的使用Mac/","text":"Effective use of XXX系列 Effective use of Mac Effective use of iPhone Effective use of Windows Effective use of Firefox Effective use of Alfred 对于高效使用的理解 所谓的高效，在笔者看来就是可以一步完成的事情，一定不要花两步。虽然Mac本身的操作已经比较人性化了，但还是有很多地方可以值得我们优化的。下面列一些场景分析一下。 场景一：想在不同软件之间快速切换。一般的做法是使用Command+Tab进行已经打开的软件间切换，使用聚焦搜索软件名进行打开。其实可以使用快捷键进行切换，参考Alfred的用法。 场景二：比如当前在文本编辑器页面写文章，突然想到某个东西需要去百度搜索一下。一般的做法是，使用Command+Tab切换到浏览器，在浏览器中新建tab页，输入baidu.com，输入关键字，进行搜索。而使用Alfred，则可以优化为：Alt+space打开Alfred搜索框，输入bd+空格，输入关键字，回车，即可自动打开浏览器搜索页。 场景三：在做复制粘贴的时候，有时候想对以前复制过的内容进行粘贴。 场景四：有一些使用率非常高的词，比如QQ号、邮箱、手机号、身份证号等信息，需要不停的输入，如果可以做到输入几个关键字就能全部输出岂不是提升了很多时间？ 好了，下面正式开始动手吧！ 此文致力于提高使用效率，基本的操作请读者自行阅读官方文档或其他文档。 Mac的基本优化访达的优化显示隐藏文件方法一： 使用快捷键Command+Shift+. 方法二： 终端中输入下面的命令，这种方式会长久生效。 1234隐藏defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder显示defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finder 顶部栏显示完整路径可以通过在访达中设置显示路径栏的方式显示，不过这种方式会在访达底部多一栏。可以通过终端输入以下命令。 123456显示完整路径defaults write com.apple.finder _FXShowPosixPathInTitle -bool TRUE;killall Finder隐藏完整路径defaults delete com.apple.finder _FXShowPosixPathInTitle;killall Finder 标签的使用这是一个非常实用的功能，将文件&#x2F;文件夹标记成不同的标签，然后通过点击标签来快速定位。对于目录层次很深的文件非常有用。 使用也很简单，右键某个文件或文件夹，点击某个标签即可。标签也可以进行管理，标签的图标也可以自定义，选中标签栏中某个标签，使用command+control+空格。 对于使用频率非常高的文件夹，可以直接拖拽到个人收藏栏，也可以拖拽到工具栏 开机启动脚本设置首先创建一个shell文件，根据自己的需求实现一些逻辑，比如： 123456789#开机启动脚本# 开机需要启动的程序open /Applications/DingTalk.appopen /Applications/QQ.app# 其他操作#exit 然后给这个文件添加执行权限，chmod +x 文件名。然后设置打开方式为终端。 然后打开系统偏好设置–&gt;用户与群组–&gt;登录项，添加新建的shell文件。 Mac上的提高效率的软件Alfred（神器）由于此软件非常强大，因此单独写一篇来介绍它，[点击查看]() switchhost（hosts切换）该软件是用来做hosts管理的，对于程序员来说非常友好，用法也很简单。可以建立一个个tab来分组管理，每个tab可以的显示隐藏互不影响。点击行号可以对该行进行快速注释或者取消注释。 [img] iTerm（终端的替代品）配置 资源管理器工具Commander One不完善的地方： 路径栏无法直接编辑，不方便直接跳转到某个路径。Total Commander的路径是可编辑的。 无法直接使用快捷键将当前页面显示到另外一测。Total Commander可以直接使用Ctrl+←→来操作。 不可配置编辑所使用的软件，只能用默认的。 BatterZip（文件解压压缩）Sublime Text（文件编辑器）轻量级文本编辑器，可配置性很强。 CleanMyMac（优化工具）Dash（程序员API查询工具）iShot（截图、录屏工具）Commander One（访达替代品）KeyCue（显示快捷键）Mac常用命令12345678910111213141516# finder中标题栏显示全路径~ defaults write com.apple.finder _FXShowPosixPathInTitle -bool TRUE;killall Finder# finder中标题栏只显示文件夹名字~ defaults delete com.apple.finder _FXShowPosixPathInTitle;killall Finder# 关闭声音$ sudo nvram SystemAudioVolume=%80# 如果想要恢复正常的开机声音，只要在终端中再次输入如下命令即可：$ sudo nvram -d SystemAudioVolumelsof -i:port 查询端口对应的进程idkill pid 杀死进程 参考","tags":[{"name":"mac","slug":"mac","permalink":"http://airshu.github.io/tags/mac/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"name":"Mac","slug":"工具软件/Mac","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Mac/"}]},{"title":"Mac M1使用问题记录","date":"2023-06-17T02:29:30.090Z","path":"wiki/工具软件/Mac/Mac M1使用问题记录/","text":"Python命令使用不同CPU架构 mach-o file, but is an incompatible architecture (have ‘x86_64’, need ‘arm64e’) 12345# 使用苹果架构arch -arm64 python xxx.py# 使用intel架构arch -x86_64 python xxx.py 注意：有时候终端工具会设置开启罗赛塔，这个时候默认会使用intel架构的。","tags":[{"name":"效率","slug":"效率","permalink":"http://airshu.github.io/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"资源处理","date":"2023-06-17T02:29:30.088Z","path":"wiki/Python/PyQt/资源处理/","text":"","tags":[{"name":"Qt","slug":"Qt","permalink":"http://airshu.github.io/tags/Qt/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"}]},{"title":"QListWidget","date":"2023-06-17T02:29:30.081Z","path":"wiki/Python/PyQt/QListWidget/","text":"一些技巧让QListWidget的高度跟着内容的高度变化12345678910111213141516from PySide import QtGui, QtCoreapp = QtGui.QApplication([])window = QtGui.QWidget()layout = QtGui.QVBoxLayout(window)list = QtGui.QListWidget()list.addItems([&#x27;Winnie Puh&#x27;, &#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Minnesota&#x27;, &#x27;Dracula Calista Flockhart Meningitis&#x27;, &#x27;Once&#x27;, &#x27;123345&#x27;, &#x27;Fin&#x27;])list.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)list.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)list.setFixedSize(list.sizeHintForColumn(0) + 2 * list.frameWidth(), list.sizeHintForRow(0) * list.count() + 2 * list.frameWidth())layout.addWidget(list)window.show()app.exec_() 参考 https://stackoverflow.com/questions/6337589/qlistwidget-adjust-size-to-content","tags":[{"name":"Qt","slug":"Qt","permalink":"http://airshu.github.io/tags/Qt/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"}]},{"title":"emoji表情处理","date":"2023-06-17T02:29:30.081Z","path":"wiki/Python/PyQt/emoji表情处理/","text":"在QLabel上显示emoji表情，win10和win7显示的效果不一样，win10能显示出彩色的，但win7只能显示黑白色，且有些表情甚至不能显示。 不同系统的实现效果都是不一样的，所以要实现统一，最好的方式就是自己实现，通过其unicode值建立一套对应的图片，显示的时候，直接绘制本地的图片。而不走系统渲染。 参考 https://appuals.com/how-to-get-windows-10-emojis-on-windows-7-8/ 这篇文章说明win7是不支持的系统显示彩色emoji的 https://github.com/carpedm20/emoji unicode值和对应表情的字符串之间的互相转换，有一些非标准的emoji表情，比如**:thumbs_up:**表示 👍 https://github.com/googlefonts/noto-emoji google 彩色字体库 https://github.com/DeeDeeG/noto-color-emoji-font","tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://airshu.github.io/tags/PyQt/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"}]},{"title":"Qt中圆形头像","date":"2023-06-17T02:29:30.081Z","path":"wiki/Python/PyQt/圆形头像/","text":"业务需求中经常需要头像是圆形的，一些数字底部有圆形背景，于是将其整理出来，以便以后方便的使用。 123456789101112131415161718192021class CircleThumbWiget(QWidget): def __init__(self, parent=None, radius=40): &quot;&quot;&quot; radius 表示这个圆形控件的大小 &quot;&quot;&quot; super(CircleThumbWiget, self).__init__(parent) self.imageLabel = QLabel(self) self.imageLabel.setScaledContents(True) self.imageLabel.setGeometry(0, 0, radius, radius) defaultPixmap = QPixmap(&quot;resources/icon/default_user.png&quot;) self.imageLabel.setPixmap(defaultPixmap) # 这里使用一张周边透明的圆形的png图片 img = QImage(&quot;resources/icon/default_user_mask.png&quot;) bg = QPixmap.fromImage(img.scaled(QSize(radius, radius), Qt.IgnoreAspectRatio)) palette = self.palette() palette.setBrush(QPalette.Background, QBrush(bg)) self.setPalette(palette) self.setMask(bg.mask()) def setPixmap(self, pixmap): self.imageLabel.setPixmap(pixmap) 平滑的圆形头像1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from PyQt5.QtCore import Qt, QRectfrom PyQt5.QtGui import QBrush, QImage, QPainter, QPixmap, QWindowfrom PyQt5.QtWidgets import QLabel, QVBoxLayout, QWidgetdef mask_image(imgdata, imgtype=&#x27;png&#x27;, size=64): &quot;&quot;&quot;Return a ``QPixmap`` from *imgdata* masked with a smooth circle. *imgdata* are the raw image bytes, *imgtype* denotes the image type. The returned image will have a size of *size* × *size* pixels. &quot;&quot;&quot; # Load image and convert to 32-bit ARGB (adds an alpha channel): image = QImage.fromData(imgdata, imgtype) image.convertToFormat(QImage.Format_ARGB32) # Crop image to a square: imgsize = min(image.width(), image.height()) rect = QRect( (image.width() - imgsize) / 2, (image.height() - imgsize) / 2, imgsize, imgsize, ) image = image.copy(rect) # Create the output image with the same dimensions and an alpha channel # and make it completely transparent: out_img = QImage(imgsize, imgsize, QImage.Format_ARGB32) out_img.fill(Qt.transparent) # Create a texture brush and paint a circle with the original image onto # the output image: brush = QBrush(image) # Create texture brush painter = QPainter(out_img) # Paint the output image painter.setBrush(brush) # Use the image texture brush painter.setPen(Qt.NoPen) # Don&#x27;t draw an outline painter.setRenderHint(QPainter.Antialiasing, True) # Use AA painter.drawEllipse(0, 0, imgsize, imgsize) # Actually draw the circle painter.end() # We are done (segfault if you forget this) # Convert the image to a pixmap and rescale it. Take pixel ratio into # account to get a sharp image on retina displays: pr = QWindow().devicePixelRatio() pm = QPixmap.fromImage(out_img) pm.setDevicePixelRatio(pr) size *= pr pm = pm.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation) return pmclass Window(QWidget): &quot;&quot;&quot;Simple window that shows our masked image and text label.&quot;&quot;&quot; def __init__(self): super().__init__() imgpath = &quot;U:/xxx/logo.png&quot; imgdata = open(imgpath, &#x27;rb&#x27;).read() ext = imgpath.split(&quot;.&quot;)[-1] pixmap = mask_image(imgdata, ext) ilabel = QLabel() ilabel.setScaledContents(True) ilabel.setFixedWidth(26) ilabel.setFixedHeight(26) ilabel.setPixmap(pixmap) layout = QVBoxLayout() layout.addWidget(ilabel, 0, Qt.AlignCenter) self.setLayout(layout)if __name__ == &#x27;__main__&#x27;: import sys from PyQt5.QtWidgets import QApplication app = QApplication(sys.argv) w = Window() w.show() sys.exit(app.exec_()) 参考 https://stefan.sofa-rockers.org/2018/05/04/how-to-mask-an-image-with-a-smooth-circle-in-pyqt5/","tags":[{"name":"Qt","slug":"Qt","permalink":"http://airshu.github.io/tags/Qt/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"}]},{"title":"快捷键处理","date":"2023-06-17T02:29:30.081Z","path":"wiki/Python/PyQt/快捷键处理/","text":"屏蔽alt+F4等快捷键12345678910111213141516171819202122232425262728class GlobalEventFilter(QAbstractNativeEventFilter): def __init__(self): super(GlobalEventFilter, self).__init__() def nativeEventFilter(self, event_type, sip_voidptr): if event_type == &quot;windows_generic_MSG&quot; or event_type == &quot;windows_dispatcher_MSG&quot;: msg = MSG.from_address(sip_voidptr.__init__()) if msg.message in [WM_KEYDOWN, WM_SYSKEYDOWN]: if VK_F4 == msg.wParam and win32api.GetKeyState(VK_MENU) &amp; 0xF000: return True, 1 # True 代表我处理了消息，不需要Qt处理 elif VK_ESCAPE == msg.wParam: return True, 1 # 屏蔽esc键 return False, 1class App(QApplication): def __init__(self, *args): super(App, self).__init__(*args) self.global_event_filter = GlobalEventFilter() self.intallNativeEventFilter(self.global_event_filter) def exit_app(self): self.removeNativeEventFilter(self.global_event_filter)","tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://airshu.github.io/tags/PyQt/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"}]},{"title":"编译PyQt5","date":"2023-06-17T02:29:30.081Z","path":"wiki/Python/PyQt/编译PyQt5/","text":"目录： 官方文档翻译 编译MinGW版本 编译VS版本 下载SIPSIP必现在编译和使用PyQt5之前安装。你可以从https://www.riverbankcomputing.com/software/sip/download使用最新的发布版本的源码。 SIP的安装说明请参阅http://pyqt.sourceforge.net/Docs/sip4/installation.html 当编译v5.11或以上的版本时，你必须配饰SIP来创建私有的备份。可以使用下面的命令： python configure.py –sip-module PyQt5.sip –no-tools 下载PyQt5你可以从https://www.riverbankcomputing.com/software/pyqt/download5下载最新的源码 如果你使用商业版的PyQt5，则需要购买商业授权，并下载属于你的pyqt-commercial.sip授权文件 配置PyQt5解压后，你应该阅读相应平台的README文件。 如果你使用商业版的PyQt5，你必须复制你的pyqt-commercial.sip授权文件到sip文件夹，或者使用–license-dir参数指定。 你需要确定你的环境变量是否正确。 为了配置构建PyQt5，你需要运行以下脚本： 1python3 configure.py 脚本完整的参数属性如下： -h, --help 展示帮助信息 --allow-sip-warnings 5.9.1版本的新特性。 Normally any warning message generated by sip is treated as an error. This option causes warning messages to be considered non-fatal. It is normally only required if a later version of sip is being used that has deprecated a feature used by this version of PyQt5. --assume-shared Normally Qt is checked to see if it has been built as shared libraries. Some Linux distributions configure their Qt builds to make this check unreliable. This option ignores the result of the check and assumes that Qt has been built as shared libraries. --bindir pyuic5, pyrcc5 and pylupdate5工具将会安装到的目录。 --concatenate The C++ source files for a Python module will be concatenated. This results in significantly reduced compilation times. Most, but not all, C++ compilers can handle the large files that result. See also the –concatenate-split option. --concatenate-split If the –concatenate option is used to concatenate the C++ source files then this option determines how many files are created. The default is 1. --configuration 指定配置文件 contains the configuration of the PyQt5 build to be used instead of dynamically introspecting the system and is typically used when cross-compiling. See Configuring with Configuration Files. --confirm-license 使用授权证书 Using this confirms that you accept the terms of the PyQt5 license. If it is omitted then you will be asked for confirmation during configuration. --dbus 根据&#x2F;dbus目录找到dbus-python.h头文件 The dbus-python.h header file of the dbus-python package can be found in the directory&#x2F;dbus. --debug The PyQt5 modules will be built with debugging symbols. On Windows configure.py must be run using a debug version of Python. --designer-plugindir 指定Qt Designer安装目录 --destdir 指定PyQt5安装目录。默认安装在Python的site-packages目录。如果你使用这个属性，则PYTHONPATH必须指定在 The PyQt5 Python package will be installed in the directory. The default is the Python installation’s site-packages directory. If you use this option then the PYTHONPATH environment variable must include. --disable 5.5.1新特性 Normally all PyQt5 modules are enabled and are built if the corresponding Qt library can be found. This option will suppress the check for &gt;. The option may be specified any number of times. --disable-feature 5.10.1新特性 A PyQt5 module may be configured differently depending on the corresponding Qt configuration. This takes the form of a set of features that may be disabled. Normally this is determined automatically. This option will explicitly disable the &gt; feature. The option may be specified any number of times. --enable Normally all PyQt5 modules are enabled and are built if the corresponding Qt library can be found. Using this option only those modules specifically enabled will be built. The option may be specified any number of times. Note that using this option suppresses the checks that are normally made to determine how the module should be configured, i.e. which features should be disabled. --license-dir 指定授权证书的目录 The license files needed by the commercial version of PyQt5 can be found in the directory. --link-full-dll 5.8版本新特性 On Windows the full Python API and the limited API (as used by PyQt) are implemented in different DLLs. Normally the limited DLL is linked (unless a debug version of the Python interpreter is being used to run configure.py). This option forces the full API DLL to be linked instead. --no-designer-plugin Qt Designer 插件将不会被编译 --no-dist-info 5.11新特性 This disables the creation of the PEP 376 .dist-info directory. Starting with this version a .dist-info directory is created. This contains meta-data about the installation including version information for dependent packages. It also means that pip can be used to uninstall the package. --no-docstrings PyQt5模块不会包含自动产生的文档字符串 The PyQt5 modules will not contain automatically generated docstrings. --no-python-dbus The Qt support for the standard Python DBus bindings is disabled. --no-qml-plugin qmlscene 插件不会被编译 --no-qsci-api The PyQt5.api QScintilla API file is not installed even if QScintilla does appear to be installed. --no-sip-files The .sip files for the PyQt5 modules will not be installed. --no-stubs New in version 5.6. The PEP 484 type hint stub files for the PyQt5 modules will not be installed. This option is ignored (and the stub files are not installed) for versions of Python earlier than v3.5. --no-tools New in version 5.3. The pyuic5, pyrcc5 and pylupdate5 tools will not be built. --no-timestamp Normally the header comments of each generated C&#x2F;C++ source file includes a timestamp corresponding to when the file was generated. This option suppresses the inclusion of the timestamp. --protected-is-public On certain platforms the size of PyQt5 modules can be significantly reduced by redefining the C++ protected keyword as public during compilation. This option enables this behaviour and is the default on Linux and macOS. --protected-not-public The default redefinition of protected to public during compilation on Linux and macOS is disabled. --pyuic5-interpreter is the name of the Python interpreter used in the pyuic5 wrapper. The default is platform dependent. --qmake Qt’s qmake program is used to determine how your Qt installation is laid out. Normally qmake is found on your PATH. This option can be used to specify a particular instance of qmake to use. --qml-debug New in version 5.8. Enable the QML debugging infrastructure. This should not be enabled in a production environment. --qml-plugindir The Python plugin for qmlscene will be installed in the directory. --qsci-api The PyQt5.api QScintilla API file is installed even if QScintilla does not appear to be installed. This option is implied if the –qsci-api-destdir option is specified. --qsci-api-destdir The QScintilla API file will be installed in the python subdirectory of the api subdirectory of the directory. --qtconf-prefix New in version 5.6. A qt.conf file is embedded in the PyQt5.QtCore module with Prefix set to which is assumed to be relative to the directory that the PyQt5.QtCore module will be installed in. --sip The sip program is used to generate PyQt5’s C++ source code. Normally sip is found on your PATH. This option can be used to specify a particular instance of sip to use. --sip-incdir The sip.h header file can be found in the directory. --sipdir The .sip files for the PyQt5 modules will be installed in the directory. --spec The argument -spec SPEC will be passed to qmake. The default behaviour is platform specific. On Windows configure.py will choose the value that is correct for the version of Python that is being used. (However if you have built Python yourself then you may need to explicitly specify .) On macOS configure.py will try and avoid macx-xcode if possible.) --static The PyQt5 modules will be built as static libraries. This is useful when building a custom interpreter with the PyQt5 modules built in to the interpreter. --stubsdir New in version 5.6. The PEP 484 type hint stub files for the PyQt5 modules will be installed in the directory. By default they will be stored in the same directory where (by default) the corresponding extension modules would be installed. This option is ignored (and the stub files are not installed) for versions of Python earlier than v3.5. --sysroot New in version 5.3. is the name of an optional directory that replaces sys.prefix in the names of other directories (specifically those specifying where the various PyQt5 components will be installed and where the Python include and library directories can be found). It is typically used when cross-compiling or when building a static version of PyQt5. See Configuring with Configuration Files. --target-py-version New in version 5.3. is the major and minor version (e.g. 3.4) of the version of Python being targetted. By default the version of Python being used to run the configure.py script is used. It is typically used when cross-compiling. See Configuring with Configuration Files. --trace The generated PyQt5 modules contain additional tracing code that is enabled using SIP’s sip.settracemask() function. --verbose Compiler commands and any output issued during configuration is displayed instead of being suppressed. Use this if configure.py is having problems to see what exactly is going wrong. --version 显示版本号 编译PyQt5make make install 配置配置文件配置文件的格式如下： 使用[]来表示一部分的名字 配置的条目为单一的行，用&#x3D;分开的键值对 在值中可以使用%(name)的方式来嵌套其他的值 注释需要以#开头 空白行被忽略 配置文件通过定义不同的[]部分来使用不同的版本。configure.py将会选择对应的Qt版本。比如，如果配置文件包含Qt v5.1和Qt v5.3，你使用Qt v5.2.1，则会选择Qt v5.1的版本。 configure.py提供了以下预制变量： py_major 对应Python安装最大的版本 py_minor 对应Python安装最小的版本 sysroot 系统根目录，可以使用–sysroot选项指定 下面是一个配置文件的实例： # The target Python installation. py_platform = linux py_inc_dir = %(sysroot)/usr/include/python%(py_major).%(py_minor) py_pylib_dir = %(sysroot)/usr/lib/python%(py_major).%(py_minor)/config py_pylib_lib = python%(py_major).%(py_minor)mu # The target PyQt installation. pyqt_module_dir = %(sysroot)/usr/lib/python%(py_major)/dist-packages pyqt_bin_dir = %(sysroot)/usr/bin pyqt_sip_dir = %(sysroot)/usr/share/sip/PyQt5 pyuic_interpreter = /usr/bin/python%(py_major).%(py_minor) pyqt_disabled_features = PyQt_Desktop_OpenGL PyQt_qreal_double # Qt configuration common to all versions. qt_shared = True [Qt 5.1] pyqt_modules = QtCore QtDBus QtDesigner QtGui QtHelp QtMultimedia QtMultimediaWidgets QtNetwork QtOpenGL QtPrintSupport QtQml QtQuick QtSensors QtSerialPort QtSql QtSvg QtTest QtWebKit QtWebKitWidgets QtWidgets QtXmlPatterns _QOpenGLFunctions_ES2 下面的值可以在配置文件中指定： qt_shared 设置Qt是否是动态共享文件，默认值为False py_platform Python目标平台 py_debug is set if a debug version of the target Python is being used. py_inc_dir is the target Python include directory, i.e. the directory containing the Python.h file. py_pylib_dir is the target Python library directory. py_pylib_lib is the target Python interpreter library. It should not include any platform-specific prefix or suffix. pyqt_disabled_features is the space separated list of features (as defined by SIP’s %Feature directive) that should be disabled. pyqt_module_dir is the target directory where the PyQt5 modules will be installed. It can be overridden by the –destdir option. pyqt_modules is the space separated list of PyQt5 modules that will be built. It can be overridden by the –enable option. pyqt_bin_dir is the name of the target directory where the PyQt5 related executables will be installed. It can be overridden by the –bindir option. pyqt_sip_dir is the name of the target directory where the PyQt5 .sip files will be installed. It can be overridden by the –sipdir option. pyuic_interpreter is the name of the Python interpreter (as it would be called from the target system) that will be used to run pyuic5. It can be overridden by the –pyuic5-interpreter option. 参考 http://pyqt.sourceforge.net/Docs/PyQt5/installation.html","tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://airshu.github.io/tags/PyQt5/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"}]},{"title":"编译QtWebEngine","date":"2023-06-17T02:29:30.081Z","path":"wiki/Python/PyQt/编译QtWebEngine/","text":"由于QtWebEngine本身并不支持H.264编码的音视频，现自行编译，整个过程如下： 依赖准备VS2015 Update3 下载地址 安装Qt 5.10.1：安装的时候选择带源码 下载地址 安装Python 2.7.5以上版本 下载地址 Perl 下载地址 Bison和Flex 下载地址 Gperf 下载地址 Windows SDK 要求10.0.10586版本以上 环境准备如果出现以下问题，则将系统语言设置为英文 1ninja: build stopped: subcommand failed. NMAKE : fatal error U1077: &#x27;call&#x27; : return code &#x27;0x1&#x27; Stop. NMAKE : fatal error U1077: &#x27;&quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.14.26428\\bin\\HostX64\\x64\\nmake.exe&quot;&#x27; : return code &#x27;0x2&#x27; Stop. NMAKE : fatal error U1077: &#x27;(&#x27; : return code &#x27;0x2&#x27; Stop. NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop. NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop 编译rem 运行VC环境 &quot;D:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\vcvars32.bat&quot; set PYTHON_PATH=D:\\Python\\Python27-32 set PERL_PATH=E:\\Perl\\bin set Bison_Flex_PATH=D:\\Qt\\Qt5.10.1\\5.10.1\\build_depends\\win_flex_bison set Gperf_PATH=D:\\Qt\\Qt5.10.1\\5.10.1\\build_depends\\gperf-3.0.1-bin\\bin set PATH=%PYTHON_PATH%;%PERL_PATH%;%Bison_Flex_PATH%;%Gperf_PATH%;%PATH% rem 配置 &quot;D:\\Qt\\Qt5.10.1\\5.10.1\\msvc2015\\bin\\qmake.exe&quot; -- -webengine-proprietary-codecs rem 编译、安装 nmake &amp;&amp; namek install 参考 https://wiki.qt.io/Building_Qt_5_from_Git http://doc.qt.io/qt-5/build-sources.html http://doc.qt.io/qt-5/windows-requirements.html https://www.pressc.cn/1044.html https://blog.afach.de/?page_id&#x3D;399","tags":[{"name":"Qt QtWebEngine","slug":"Qt-QtWebEngine","permalink":"http://airshu.github.io/tags/Qt-QtWebEngine/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"}]},{"title":"Qt视图模型","date":"2023-06-17T02:29:30.081Z","path":"wiki/Python/PyQt/视图模型/","text":"数据（Data）：是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个 StringList，或磁盘文件结构等。 视图或视图组件（View）：是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），通过模型索引获取数据，然后为界面组件提供显示数据。Qt 提供一些现成的数据视图组件，如 QListView、QTreeView 和 QTableView 等。 模型或数据模型（Model）：与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Qt 中有一些预定义的数据模型，如 QStringListModel 可作为 StringList 的数据模型，QSqlTableModel 可以作为数据库中一个数据表的数据模型。 委托（Delegate）：根据数据绘制UI 模型、视图和代理之间使用信号和槽通信。当源数据发生变化时，数据模型发射信号通知视图组件；当用户在界面上操作数据时，视图组件发射信号表示这些操作信息；当编辑数据时，代理发射信号告知数据模型和视图组件编辑器的状态。 视图视图组件（View）就是显示数据模型的数据的界面组件，Qt 提供的视图组件如下： QListView：用于显示单列的列表数据，适用于一维数据的操作。 QTreeView：用于显示树状结构数据，适用于树状结构数据的操作。 QTableView：用于显示表格状数据，适用于二维表格型数据的操作。 QColumnView：用多个QListView显示树状层次结构，树状结构的一层用一个QListView显示。 QHeaderView：提供行表头或列表头的视图组件，如QTableView的行表头和列表头。 模型在 model&#x2F;view架构中，model提供一种标准接口，供视图和委托访问数据。在Qt中，这个接口由QAbstractItemModel类进行定义。不管底层数据是如何存储的，只要是QAbstractItemModel的子类，都提供一种表格形式的层次结构。视图利用统一的转换来访问模型中的数据。 下面是各种model的组织示意图。我们利用此图来理解什么叫“一种表格形式的层次结构”。 List Model虽然是线性的列表，也有一个 Root Item（根节点），之下才是呈线性的一个个数据，而这些数据实际可以看作是一个只有一列的表格，但是它是有层次的，因为有一个根节点。Table Model 就比较容易理解，只是也存在一个根节点。Tree Model 主要面向层次数据，而每一层次都可以都很多列，因此也是一个带有层次的表格。 为了能够使得数据的显示同存储分离，我们引入模型索引（model index）的概念。通过索引，我们可以访问模型的特定元素的特定部分。视图和委托使用索引来请求所需要的数据。由此可以看出，只有模型自己需要知道如何获得数据，模型所管理的数据类型可以使用通用的方式进行定义。索引保存有创建的它的那个模型的指针，这使得同时操作多个模型成为可能。 1QAbstractItemModel *model = index.model(); 模型索引提供了所需要的信息的临时索引，可以用于通过模型取回或者修改数据。由于模型随时可能重新组织其内部的结构，因此模型索引很可能变成不可用的，此时，就不应该保存这些数据。如果你需要长期有效的数据片段，必须创建持久索引。持久索引保证其引用的数据及时更新。临时索引（也就是通常使用的索引）由QModelIndex类提供，持久索引则是QPersistentModelIndex类。 为了定位模型中的数据，我们需要三个属性：行号、列号以及父索引。 我们前面介绍过模型的基本形式：数据以二维表的形式进行存储。此时，一个数据可以由行号和列号进行定位。注意，我们仅仅是使用“二维表”这个名词，并不意味着模型内部真的是以二维数组的形式进行存储；所谓“行号”“列号”，也仅仅是为方便描述这种对应关系，并不真的是有行列之分。通过指定行号和列号，我们可以定位一个元素项，取出其信息。此时，我们获得的是一个索引对象： 123456QModelIndex index = model-&gt;index(row, column, ...);QModelIndex QAbstractItemModel::index(int row, int column, const QModelIndex &amp;parent=QModelIndex()) const 在一个简单的表格中，每一个项都可以由行号和列号确定。因此，我们只需提供两个参数即可获取到表格中的某一个数据项： 123QModelIndex indexA = model-&gt;index(0, 0, QModelIndex());QModelIndex indexB = model-&gt;index(1, 1, QModelIndex());QModelIndex indexC = model-&gt;index(2, 1, QModelIndex()); 函数的最后一个参数始终是 QModelIndex() 在类似表格的视图中，比如列表和表格，行号和列号足以定位一个数据项。但是，对于树型结构，仅有两个参数就不足够了。这是因为树型结构是一个层次结构，而层次结构中每一个节点都有可能是另外一个表格。所以，每一个项需要指明其父节点。前面说过，在模型外部只能用过索引访问内部数据，因此，index()函数还需要一个 parent 参数： 1QModelIndex index = model-&gt;index(row, column, parent); 图中，A 和 C 都是模型中的顶级项： 12QModelIndex indexA = model-&gt;index(0, 0, QModelIndex());QModelIndex indexC = model-&gt;index(2, 1, QModelIndex()); A 还有自己的子项。那么，我们就应该使用下面的代码获取 B 的索引： 1QModelIndex indexB = model-&gt;index(1, 0, indexA); 由此我们看到，如果只有行号和列号两个参数，B 的行号是 1，列号是 0，这同与 A 同级的行号是 1，列号是 0 的项相同，所以我们通过 parent 属性区别开来。 以上我们讨论了有关索引的定位。现在我们来看看模型的另外一个部分：数据角色。模型可以针对不同的组件（或者组件的不同部分，比如按钮的提示以及显示的文本等）提供不同的数据。例如，Qt::DisplayRole用于视图的文本显示。通常来说，数据项包含一系列不同的数据角色，这些角色定义在Qt::ItemDataRole枚举中。 我们可以通过指定索引以及角色来获得模型所提供的数据： 1QVariant value = model-&gt;data(index, role); 通过为每一个角色提供恰当的数据，模型可以告诉视图和委托如何向用户显示内容。不同类型的视图可以选择忽略自己不需要的数据。当然，我们也可以添加我们所需要的额外数据。 总结一下： 模型使用索引来提供给视图和委托有关数据项的位置的信息，这样做的好处是，模型之外的对象无需知道底层的数据存储方式； 数据项通过行号、列号以及父项三个坐标进行定位； 模型索引由模型在其它组件（视图和委托）请求时才会被创建； 如果使用index()函数请求获得一个父项的可用索引，该索引会指向模型中这个父项下面的数据项。这个索引指向该项的一个子项；如果使用index()函数请求获得一个父项的不可用索引，该索引指向模型的最顶级项； 角色用于区分数据项的不同类型的数据。 下面回到前面我们曾经见过的模型QFileSystemModel，看看如何从模型获取数据。 123QFileSystemModel *model = new QFileSystemModel;QModelIndex parentIndex = model-&gt;index(QDir::currentPath());int numRows = model-&gt;rowCount(parentIndex); 在这个例子中，我们创建了QFileSystemModel的实例，使用QFileSystemModel重载的index()获取索引，然后使用rowCount()函数计算当前目录下有多少数据项（也就是行数）。前面一章中迷迷糊糊的代码，现在已经相当清楚了。 为简单起见，下面我们只关心模型第一列。我们遍历所有数据，取得第一列索引： 12for (int row = 0; row &lt; numRows; ++row) &#123; QModelIndex index = model-&gt;index(row, 0, parentIndex); 我们使用index()函数，第一个参数是每一行行号，第二个参数是 0，也就是第一列，第三个参数是parentIndex，也就是当前目录作为父项。我们可以使用模型的data()函数获取每一项的数据。注意，该函数返回值是QVariant，实际是一个字符串，因此我们直接转换成QString： 1QString text = model-&gt;data(index, Qt::DisplayRole).toString();// 使用 text 数据 上面的代码片段显示了从模型获取数据的一些有用的函数： 模型的数目信息可以通过rowCount()和columnCount()获得。这些函数需要制定父项； 索引用于访问模型中的数据。我们需要利用行号、列号以及父项三个参数来获得该索引； 当我们使用QModelIndex()创建一个空索引使用时，我们获得的就是模型中最顶级项； 数据项包含了不同角色的数据。为获取特定角色的数据，必须指定这个角色。 QStringListModel、QDirModel、QFileSystemModel等预定义model QStandardItemModel 可当作列表模型、表格模型、树模型来使用的通用模型 QAbstractItemModel自定义模型 QStandardItemModel常用API flags(const QModelIndex &amp;index):返回被给模型索引index的标志 data(const QModelIndex &amp;index, int role &#x3D; Qt::DisplayRole):返回模型索引index的底层数据（一个模型索引包括某一元素的信息，包括行，列，以及数据），用于视图和委托访问数据 headerData(int selection, Qt::Orientation orientation, int role &#x3D;Qt::DisplayRole):返回某部分对应方向上的表头 ，为Views提供显示在Views顶部（即最上方和最左边）的标识 rowCount(const QModelIndex &amp;parent&#x3D;QModelIndex()):返回被给的模型索引下有多少行，返回的是parent的孩子数。而不是整个行数。如果没有子元素，则返回0。 columnCount(const QModelIndex &amp;parent&#x3D;QModelIndex()):这个函数通常与给定的parent无关，所涉及的类有几列就返回几 setData(const QModelIndex &amp;index, const QVariant &amp;value, int role&#x3D;Qt::EditRole):用来设置模型索引index中存储的数据 setHeaderData(int section, Qt::Orientation orientation, const QVariant &amp;value, int role &#x3D; Qt::EditRole): insertRows(int position, int rows, const QModelIndex &amp;index &#x3D; QModelIndex()):进行插入操作时，前后分别需要调用beginInsertRows()和endInsertRows()函数 委托（Delegate）代理就是在视图组件上为编辑数据提供编辑器，如在表格组件中编辑一个单元格的数据时，缺省是使用一个 QLineEdit 编辑框。代理负责从数据模型获取相应的数据，然后显示在编辑器里，修改数据后，又将其保存到数据模型中。 QAbstractltemDelegate 是所有代理类的基类，作为抽象类，它不能直接使用。它的一个子类 QStyledltemDelegate，是 Qt 的视图组件缺省使用的代理类。 QStyledItemDelegate常用API updateEditorGeometry：设置编辑器editor的尺寸和位置 painter： 绘制给定模型索引index所对应的项 setEditorData： 使用给定模型索引index所对应的模型项的数据来填充编辑器editor setModelData：从编辑器editor中获取数据并设置为给定模型索引index所对应的模型项的数据 setHint： 返回委托需要的、显示或编辑给定模型索引index所代表的项的尺寸 updateEditorGeometry： 设置编辑器editor的尺寸和位置 实例参考 https://doc.qt.io/qt-5/model-view-programming.html","tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://airshu.github.io/tags/PyQt/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"}]},{"title":"PyQt5开发心得","date":"2023-06-17T02:29:30.080Z","path":"wiki/Python/PyQt/PyQt5开发心得/","text":"其实大部分的客户端开发都有共通性。一套GUI API，Button、Text、Dialog等等，绘制机制，事件传递机制，都是根据不同平台的特性做了封装。但开发的时候，用法是类似的。而Python由于语法的简易性，开发效率比使用C++版的Qt高很多。所谓的性能损耗其实在大部分的应用中是可以忽略的。 基础结构的搭建不管是做一个项目还是多个项目，准备一套基础框架，对开发效率是非常有帮助的。这个基础框架通常包括： 基础结构 基础工具类、工具函数：字符串处理、时间处理、日期处理、线程处理、网络请求、拖拽工具、缩放工具、资源下载工具、 基础控件：弹窗提示、确认框、webview的封装和通讯模块、loading框、全局样式处理 日志工具： 数据模拟工具：mock 单元测试框架： 性能分析工具：分析代码质量 打包工具：分发安装包 更新工具 异常捕获分析工具：分析线上可能存在的问题 项目框架的搭建：分层、抽象、解耦、MVC思想的体现。随着业务的增长，在重构代码的时候要遵循高内聚、低耦合的思想。 关于线程的使用随着业务的增长，项目会越来越复杂，不可避免的会使用到多线程。使用的过程中，要注意以下几点： 线程要及时释放 比如有一个场景，用户点击某个按钮，需要向服务器请求数据，然后将数据更新到文本框中。你需要在非UI线程中请求http接口，收到服务器响应后，切换回UI线程更新。但有时候由于网络原因，响应的时间较长，在收到响应结果时，UI已经被销毁了。所以要注意在UI销毁的同时，对应的线程都要进行释放。同样的场景还有下载器，各种定时操作。都要进行及时的清理。 最好能封装几个工具类、工具函数，统一管理。 QTimer初始化时带上parent，创建和start在同一个线程 Model初始化的时候需要传入parent 关于性能虽然前面说性能问题可以忽略，但如果你很随意的在主线程中做一些频繁的复杂的运算，UI也是会卡顿的。这里介绍一点自己的经验。 非UI操作尽量全部放到非UI线程处理。 对于非常频繁的操作使用间隔，比如1秒中调用一次。直白说就是降低UI刷新的频率。 由于python GIL的存在，当某些计算需要消耗较多CPU时，需要考虑是否将其移到C&#x2F;C++中处理。 使用更优秀的json处理库 关于程序崩溃http://enki-editor.org/2014/08/23/Pyqt_mem_mgmt.html https://stackoverflow.com/questions/11945183/what-are-good-practices-for-avoiding-crashes-hangs-in-pyqt http://python-camelot.s3.amazonaws.com/gpl/release/pyqt/doc/advanced/development.html 常见问题汇总libpng warning: iCCP: known incorrect sRGB profile UpdateLayeredWindowIndirect failed for ptDst&#x3D; 程序使用一段时间后，关闭某个窗口，会造成整个程序崩溃。crashrpt捕获到的dump指向的是Qt的某个函数。可无法定位到业务层的代码。后打包成debug模式，在崩溃的时候控制台输出了以上信息，google进行搜索，看到了这里，想起来边框阴影的实现就是使用了QGraphicsDropShadowEffect滤镜。去掉后，果然没有再出现了。 如何彻底销毁QWidget close() 在Qt中，每个 QObject 内部都有一个list，用来保存所有的 children，还有一个指针，保存自己的parent。当它自己析构时，它会将自己从parent的列表中删除，并且析构掉所有的children。 调用close()方法后首先它会向widget发送一个关闭事件（QCloseEvent）。如果widget接受了关闭事件（QCloseEvent），窗口将会隐藏（实际上调用hide()）。如果widget不接受关闭事件，那么窗口将什么也不做。默认情况下widget会接受关闭事件,我们可以重写QCloseEvent事件，可以选择接受或者不接受。 如果widget设置了Qt::WA_DeleteOnClose属性，widget将会被释放。不管widget是否可见，关闭事件都会传递给widget。即接收到QCloseEvent事件后，除了调用hide()方法将窗口隐藏，同时会调用deleteLater()方法将窗口释放掉，不会再占用资源。 所以说调用close()并不一定就会将窗口对象销毁。而只有设置了 Qt::WA_DeleteOnClose属性才会删除销毁。如果这个属性没有设置，close()的作用和hide（），setvisible（false）一样，只会隐藏窗口对象而已，并不会销毁该对象。 deleteLater() 走Qt的事件循环，延迟删除。 sip.delete(widget) 调用了Qt的delete来删除对象 QWidget的Qt.WA_TranslucentBackground默认值是False。 123456789101112131415class FooWidget(QWidget): def __init__(self): super(FooWidget, self).__init__() self.setAttribute(Qt.WA_TranslucentBackground, True) def closeEvent(self, event): # accept退出，ingore取消退出，默认值为accept print(&#x27;closeEvent&#x27;)self.foo = FooWidget()self.foo.close()self.foo = None 参考 https://blog.csdn.net/GoForwardToStep/article/details/53647146 https://doc.qt.io http://c.biancheng.net/view/1864.html","tags":[{"name":"Qt","slug":"Qt","permalink":"http://airshu.github.io/tags/Qt/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"}]},{"title":"异步编程","date":"2023-06-17T02:29:30.077Z","path":"wiki/Flutter/Dart/异步编程/异步编程/","text":"isolate机制Dart是单线程模型，它的并发机制叫isolate。APP的启动入口main函数就是一个类似Android主线程的一个主isolate。和Java的Thread不同的是，Dart中的isolate无法共享内存。 123456789101112131415161718// 导入isolate包import &#x27;dart:isolate&#x27;;// 使用async关键词将main函数标记为一个异步函数，这样才能使用await关键词void main() async &#123; // 使用await关键词等待任务执行完成 await Isolate.spawn&lt;String&gt;(subTask, &quot;Task1 parameter&quot;); // main函数结束标记 print(&quot;main func end.&quot;);&#125;// Isolate入口函数定义，接受一个String参数void subTask(String msg) &#123; print(&quot;subTask recv: $msg&quot;);&#125; 消息机制Dart在执行完main函数后，就会由Loop开始执行两个任务队列中的Event。首先Loop检查微服务队列，依次执行Event，当微服务队列执行完后，就检查Event queue队列依次执行，在执行Event queue的过程中，每执行完一个Event就再检查一次微服务队列。所以微服务队列优先级高，可以利用微服务进行插队。 Future在 Dart 库中随处可见 Future 对象，通常异步函数返回的对象就是一个 Future。 当一个 future 执行完后，他里面的值就可以使用了，可以使用then()来在future完成的时候执行其他代码。Future对象其实就代表了在事件队列中的一个事件的结果。 Stream表示发出的一系列的异步数据。Stream是一个异步数据源，它是Dart中处理异步事件流的统一API。 Future表示稍后获得的一个数据，所有异步的操作的返回值都用Future来表示。但是Future只能表示一次异步获得的数据。而Stream表示多次异步获得的数据。比如 IO 处理的时候，每次只会读取一部分数据和一次性读取整个文件的内容相比，Stream的好处是处理过程中内存占用较小。而File的 readAsString()是一次性读取整个文件的内容进来，虽然获得完整内容处理起来比较方便，但是如果文件很大的话就会导致内存占用过大的问题。 1234567new File(&quot;/Users/enjoy/app-release.apk&quot;).openRead().listen((List&lt;int&gt; bytes) &#123; print(&quot;stream执行&quot;); //执行多次 &#125;); new File(&quot;/Users/enjoy/app-release.apk&quot;).readAsBytes().then((_)&#123; print(&quot;future执行&quot;); //执行1次 &#125;); listen()其实就是订阅这个Stream，它会返回一个StreamSubscription订阅者。订阅者肯定就提供了取消订阅的cancel()，去掉后我们的listen中就接不到任何信息了。除了cancel()取消方法之外，我们还可以使用onData()重置listene方法，onDone监听完成等等操作。 12345678910111213141516StreamSubscription&lt;List&lt;int&gt;&gt; listen = new File(&quot;/Users/enjoy/app-release.apk&quot;).openRead().listen((List&lt;int&gt; bytes) &#123; print(&quot;stream执行&quot;);&#125;);listen.onData((_)&#123; print(&quot;替代listene&quot;);&#125;);listen.onDone(()&#123; print(&quot;结束&quot;);&#125;);listen.onError((e,s)&#123; print(&quot;异常&quot;);&#125;);//暂停，如果没有继续则会退出程序listen.pause();//继续listen.resume(); 广播模式Stream有两种订阅模式：单订阅和多订阅。单订阅就是只能有一个订阅者，上面的使用我们都是单订阅模式，而广播是可以有多个订阅者。通过 Stream.asBroadcastStream() 可以将一个单订阅模式的 Stream 转换成一个多订阅模式的 Stream，isBroadcast 属性可以判断当前 Stream 所处的模式。 123456789101112131415var stream = new File(&quot;/Users/enjoy/app-release.apk&quot;).openRead(); stream.listen((List&lt;int&gt; bytes) &#123; &#125;); //错误 单订阅只能有一个订阅者// stream.listen((_)&#123;// print(&quot;stream执行&quot;);// &#125;); var broadcastStream = new File(&quot;/Users/enjoy/app-release.apk&quot;).openRead().asBroadcastStream(); broadcastStream.listen((_)&#123; print(&quot;订阅者1&quot;); &#125;); broadcastStream.listen((_)&#123; print(&quot;订阅者2&quot;); &#125;); 需要注意的是，多订阅模式如果没有及时添加订阅者则可能丢数据。 1234567891011121314151617181920//默认是单订阅 var stream = Stream.fromIterable([1, 2, 3]); //3s后添加订阅者 不会丢失数据 new Timer(new Duration(seconds: 3), () =&gt; stream.listen(print)); //创建一个流管理器 对一个stream进行管理 var streamController = StreamController.broadcast(); //添加 streamController.add(1); //先发出事件再订阅 无法接到通知 streamController.stream.listen((i)&#123; print(&quot;broadcast:$i&quot;); &#125;); //记得关闭 streamController.close(); //这里没有丢失，因为stream通过asBroadcastStream转为了多订阅，但是本质是单订阅流，并不改变原始 stream 的实现特性 var broadcastStream = Stream.fromIterable([1, 2, 3]).asBroadcastStream(); new Timer(new Duration(seconds: 3), () =&gt; broadcastStream.listen(print)); async&#x2F;await使用async和await的代码是异步的，但是看起来很像同步代码。当我们需要获得A的结果，再执行B时，你需要then()-&gt;then(),但是利用async与await能够非常好的解决回调地狱的问题： 123456789//async 表示这是一个异步方法,await必须再async方法中使用//异步方法只能返回 void和FutureFuture&lt;String&gt; readFile() async &#123; //await 等待future执行完成再执行后续代码 String content = await new File(&quot;/Users/alone/enjoy/a.txt&quot;).readAsString(); String content2 = await new File(&quot;/Users/alone/enjoy/a.txt&quot;).readAsString(); //自动转换为 future return content;&#125;","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"异步编程","slug":"Flutter/Dart/异步编程","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"}]},{"title":"消息机制","date":"2023-06-17T02:29:30.077Z","path":"wiki/Flutter/Dart/异步编程/消息机制/","text":"概述Dart在执行完main函数后，就会由Loop开始执行两个任务队列中的Event。首先Loop检查微服务队列，依次执行Event，当微服务队列执行完后，就检查Event queue队列依次执行，在执行Event queue的过程中，没执行完一个Event就再检查一次微服务队列。所以微服务队列优先级高，可以利用微服务进行插队。 event队列：包含所有外来的事件：I&#x2F;O，mouse events，drawing events，timers，isolate之间的message等。 microtask队列：在Dart中是必要的，因为有时候事件处理想要在稍后完成一些任务但又希望是在执行下一个事件消息之前。 总结 Dart事件循环执行两个队列里的事件：event队列和microtask队列。 event队列的事件来自dart（future，timer，isolate message等）和系统（用户输入，I&#x2F;O等）。 目前为止，microtask队列的事件只来自dart。 事件循环会优先清空microtask队列，然后才会去处理event队列。 当两个队列都清空后，dart就会退出。 main方法，来自event队列和microtask队列的所有事件都运行在Dart的main isolate中。 当你要安排一个任务时，请遵守以下规则： 如果可以，尽量将任务放入event队列中。 使用Future的then方法或whenComplete方法来指定任务顺序。 为了保持你app的可响应性，尽量不要将大计算量的任务放入这两个队列。 大计算量的任务放入额外的isolate中。 参考 Dart与消息循环机制翻译","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"异步编程","slug":"Flutter/Dart/异步编程","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"}]},{"title":"async and await","date":"2023-06-17T02:29:30.075Z","path":"wiki/Flutter/Dart/异步编程/async_await/","text":"async用于声明方法是异步的 await用于调用异步方法使用，表示等待异步方法执行完成后再执行后续的代码 async 和 await 关键字用于实现异步编程，并且让你的代码看起来就像是同步的一样。 必须在带有 async 关键字的 异步函数 中使用 await。 await 表达式的返回值通常是一个 Future 对象；如果不是的话也会自动将其包裹在一个 Future 对象里。 Future 对象代表一个承诺， await 表达式会阻塞直到需要的对象返回。 声明异步函数异步函数 是函数体由 async 关键字标记的函数。 将关键字 async 添加到函数并让其返回一个 Future 对象。如果函数没有返回有效值，需要设置其返回类型为 Future。 123456String lookUpVersion() =&gt; &#x27;1.0.0&#x27;;// 改成异步函数Future&lt;String&gt; lookUpVersion() async =&gt; &#x27;1.0.0&#x27;; 参考 sync* 和 async* 、yield 和yield* 、async 和 await","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"异步编程","slug":"Flutter/Dart/异步编程","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"}]},{"title":"运算符","date":"2023-06-17T02:29:30.074Z","path":"wiki/Flutter/Dart/基础/运算符/","text":"描述 运算符 一元后缀 表达式++ 表达式– () [] . ?. 一元前缀 -表达式 !表达式 ~表达式 ++表达式 –表达式 乘除法 * &#x2F; % ~&#x2F; 加减法 + - 位运算 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 二进制与 &amp; 二进制异或 ^ 二进制或 ｜ 关系和类型测试 &gt;&#x3D; &gt; &lt;&#x3D; &lt; as is is! 相等判断 &#x3D;&#x3D; !&#x3D; 逻辑与 &amp;&amp; 逻辑或 ｜｜ 空判断 ?? 条件表达式 表达式 1 ? 表达式 2 : 表达式 3 级联 .. ?.. .. ?.. 赋值 &#x3D; *&#x3D; &#x2F;&#x3D; +&#x3D; -&#x3D; &amp;&#x3D; ^&#x3D; 等等…… 赋值操作符12b ??= value; // 如果 b 是 null，则 value 赋值给 b； // 如果不是 null，则 b 的值保持不变 条件表达式12345678910- `condition ? expr1 : expr2` 如果 *condition* 是 true，执行 *expr1* (并返回执行的结果)； 否则执行 *expr2* 并返回其结果。- `expr1 ?? expr2` 如果 *expr1* 不为null，返回其值； 否则执行 *expr2* 并返回其结果。 级联操作符可以实现链式调用。 1234//StringBuffer write就是Java的appendvar sb = new StringBuffer();sb..write(&#x27;foo&#x27;)..write(&#x27;bar&#x27;); 安全操作符1234String sb;//空指针print(sb.length);print(sb?.length); 判断类型运算符 操作符 描述 as 类型转换 is 如果对象是指定类型则返回 true is! 如果对象是指定类型则返回 false 其他运算符 运算符 名字 描述 () 使用方法 代表调用一个方法 [] 访问 List 访问 List 中特定位置的元素 . 访问成员 成员访问符 ?. 条件访问成员 与上述成员访问符类似，但是左边的操作对象不能为 null，例如 foo?.bar，如果 foo 为 null 则返回 null ，否则返回 bar","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"Future","date":"2023-06-17T02:29:30.074Z","path":"wiki/Flutter/Dart/异步编程/Future/","text":"Future 是在未来某个时间获得想要对象的一种手段。Future 表示一个不会立即完成的计算过程。与普通函数直接返回结果不同的是异步函数返回一个将会包含结果的 Future。该 Future 会在结果准备好时通知调用者。 Future中除了microtask外，其他任务都是添加到Event队列中执行。 Future状态 运行状态(pending)，表示任务还未完成，也没有返回值 完成状态(completed)，表示任务已经结束（有结果或者异常） 创建Future Future() Future.microtask() Future.sync() Future.value() Future.delayed() Future.error() Future.foreach(Iterable elements, FutureOr action(T element)) Future.any（futures） Future.doWhile() 处理异步操作的结果 Future.then() 任务执行完成会进入这里，能够获得返回的执行结果。 Future.catchError() 有任务执行失败，可以在这里捕获异常。 Future.whenComplete() 当任务停止时，最后会执行这里。 参考 Flutter进阶篇（4）– Flutter的Future异步详解 Flutter中的异步编程——Future","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"异步编程","slug":"Flutter/Dart/异步编程","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"}]},{"title":"Stream","date":"2023-06-17T02:29:30.074Z","path":"wiki/Flutter/Dart/异步编程/Stream/","text":"Stream 是一系列异步事件的序列。其类似于一个异步的 Iterable，不同的是当你向 Iterable 获取下一个事件时它会立即给你，但是 Stream 则不会立即给你而是在它准备好时告诉你。 Stream的类型： Single-Subscription 最常见的类型是一个 Stream 只包含了某个众多事件序列的一个。而这些事件需要按顺序提供并且不能丢失。当你读取一个文件或接收一个网页请求时就需要使用这种类型的 Stream。 这种 Stream 只能设置一次监听。重复设置则会丢失原来的事件，而导致你所监听到的剩余其它事件毫无意义。当你开始监听时，数据将以块的形式提供和获取。 Broadcast 另一种流是针对单个消息的，这种流可以一次处理一个消息。例如可以将其用于浏览器的鼠标事件。 你可以在任何时候监听这种 Stream，且在此之后你可以获取到任何触发的事件。这种流可以在同一时间设置多个不同的监听器同时监听，同时你也可以在取消上一个订阅后再次对其发起监听。 Stream 也有同步流和异步流之分。它们的区别在于同步流会在执行 add，addError 或 close 方法时立即向流的监听器 StreamSubscription 发送事件，而异步流总是在事件队列中的代码执行完成后在发送事件。 相关类： Stream StreamController：流的控制器 StreamSink：事件输入口 StreamSubscription：用于管理事件的注册、暂停与取消等 StreamTransformer MultiStreamController 创建Stream处理Stream的方法123456789101112131415161718192021Future&lt;T&gt; get first;Future&lt;bool&gt; get isEmpty;Future&lt;T&gt; get last;Future&lt;int&gt; get length;Future&lt;T&gt; get single;Future&lt;bool&gt; any(bool Function(T element) test);Future&lt;bool&gt; contains(Object? needle);Future&lt;E&gt; drain&lt;E&gt;([E? futureValue]);Future&lt;T&gt; elementAt(int index);Future&lt;bool&gt; every(bool Function(T element) test);Future&lt;T&gt; firstWhere(bool Function(T element) test, &#123;T Function()? orElse&#125;);Future&lt;S&gt; fold&lt;S&gt;(S initialValue, S Function(S previous, T element) combine);Future forEach(void Function(T element) action);Future&lt;String&gt; join([String separator = &#x27;&#x27;]);Future&lt;T&gt; lastWhere(bool Function(T element) test, &#123;T Function()? orElse&#125;);Future pipe(StreamConsumer&lt;T&gt; streamConsumer);Future&lt;T&gt; reduce(T Function(T previous, T element) combine);Future&lt;T&gt; singleWhere(bool Function(T element) test, &#123;T Function()? orElse&#125;);Future&lt;List&lt;T&gt;&gt; toList();Future&lt;Set&lt;T&gt;&gt; toSet(); 修改Stream的方法12345678910Stream&lt;R&gt; cast&lt;R&gt;();Stream&lt;S&gt; expand&lt;S&gt;(Iterable&lt;S&gt; Function(T element) convert);Stream&lt;S&gt; map&lt;S&gt;(S Function(T event) convert);Stream&lt;T&gt; skip(int count);Stream&lt;T&gt; skipWhile(bool Function(T element) test);Stream&lt;T&gt; take(int count);Stream&lt;T&gt; takeWhile(bool Function(T element) test);Stream&lt;T&gt; where(bool Function(T event) test); StreamController1234567891011121314onListen 注册监听时回调onPause 当流暂停时回调onResume 当流恢复时回调onCancel 当监听器被取消时回调sync 当值为true时表示同步控制器SynchronousStreamController，默认值为false，表示异步控制器factory StreamController( &#123;void onListen(), void onPause(), void onResume(), onCancel(), bool sync: false&#125;) StreamTransformer123456789handleData：响应从流中发出的任何数据事件。提供的参数是来自发出事件的数据，以及EventSink&lt;T&gt;，表示正在进行此转换的当前流的实例handleError：响应从流中发出的任何错误事件handleDone：当流不再有数据要处理时调用。通常在流的close()方法被调用时回调factory StreamTransformer.fromHandlers(&#123; void handleData(S data, EventSink&lt;T&gt; sink), void handleError(Object error, StackTrace stackTrace, EventSink&lt;T&gt; sink), void handleDone(EventSink&lt;T&gt; sink)&#125;) 参考 Dart 语言异步编程之Stream 在 Dart 里使用 Stream 全面深入理解Stream","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"异步编程","slug":"Flutter/Dart/异步编程","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"}]},{"title":"泛型","date":"2023-06-17T02:29:30.072Z","path":"wiki/Flutter/Dart/基础/泛型/","text":"泛型的好处 适当地指定泛型可以更好地帮助代码生成。 使用泛型可以减少代码重复。 使用集合字面量List、Set 以及 Map 字面量也可以是参数化的。定义参数化的 List 只需在中括号前添加 ；定义参数化的 Map 只需要在大括号前添加 &lt;keyType, valueType&gt;： 1234567var names = &lt;String&gt;[&#x27;Seth&#x27;, &#x27;Kathy&#x27;, &#x27;Lars&#x27;];var uniqueNames = &lt;String&gt;&#123;&#x27;Seth&#x27;, &#x27;Kathy&#x27;, &#x27;Lars&#x27;&#125;;var pages = &lt;String, String&gt;&#123; &#x27;index.html&#x27;: &#x27;Homepage&#x27;, &#x27;robots.txt&#x27;: &#x27;Hints for web robots&#x27;, &#x27;humans.txt&#x27;: &#x27;We are people, not machines&#x27;&#125;; 使用类型参数化的构造函数12345678910var nameSet = Set&lt;String&gt;.from(names);var views = Map&lt;int, View&gt;();//Dart的泛型类型是 固化的，这意味着即便在运行时也会保持类型信息var names = &lt;String&gt;[];names.addAll([&#x27;Seth&#x27;, &#x27;Kathy&#x27;, &#x27;Lars&#x27;]);print(names is List&lt;String&gt;); // true 限制参数化类型1234class Foo&lt;T extends Object&gt; &#123; // Any type provided to Foo for T must be non-nullable.&#125; 泛型方法12345678T first&lt;T&gt;(List&lt;T&gt; ts) &#123; // Do some initial work or error checking, then... T tmp = ts[0]; // Do some additional checking or processing... return tmp;&#125; 方法 first 的泛型 T 可以在如下地方使用： 函数的返回值类型 (T)。 参数的类型 (List)。 局部变量的类型 (T tmp)。","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"类","date":"2023-06-17T02:29:30.072Z","path":"wiki/Flutter/Dart/基础/类/","text":"隐式接口每一个类都隐式地定义了一个接口并实现了该接口，这个接口包含所有这个类的实例成员以及这个类所实现的其它接口。如果想要创建一个 A 类支持调用 B 类的 API 且不想继承 B 类，则可以实现 B 类的接口。 扩展一个类使用 extends 关键字来创建一个子类，并可使用 super 关键字引用一个父类： 重写类成员子类可以重写父类的实例方法（包括 操作符）、 Getter 以及 Setter 方法。你可以使用 @override 注解来表示你重写了一个成员： 12345678910class Television &#123; // ··· set contrast(int value) &#123;...&#125;&#125;class SmartTelevision extends Television &#123; @override set contrast(num value) &#123;...&#125; // ···&#125; noSuchMethod如果调用了对象上不存在的方法或实例变量将会触发 noSuchMethod 方法，你可以重写 noSuchMethod 方法来追踪和记录这一行为： 只有下面其中一个条件成立时，你才能调用一个未实现的方法： 接收方是静态的 dynamic 类型。 接收方具有静态类型，定义了未实现的方法（抽象亦可），并且接收方的动态类型实现了 noSuchMethod 方法且具体的实现与 Object 中的不同。 扩展方法扩展方法是向现有库添加功能的一种方式。跟kotlin的扩展方法效果一样。 12345import &#x27;string_apis.dart&#x27;;...print(&#x27;42&#x27;.padLeft(5)); // Use a String method.print(&#x27;42&#x27;.parseInt()); // Use an extension method. 可调用类通过实现类的 call() 方法，允许使用类似函数调用的方式来使用该类的实例。 12345678class WannabeFunction &#123; String call(String a, String b, String c) =&gt; &#x27;$a $b $c!&#x27;;&#125;var wf = WannabeFunction();var out = wf(&#x27;Hi&#x27;, &#x27;there,&#x27;, &#x27;gang&#x27;);void main() =&gt; print(out); 抽象类 抽象类不能被实例化； 使用abstract修饰； 抽象方法不需要使用abstract，没有实现体即可，用分号结束； Dart中，extends只能继承一个类。没有interface关键字，可以把抽象类当成接口使用。 1234567891011121314151617/// 抽象类abstract class Animal&#123; late String name; //数据 void display()&#123; //普通函数 print(&quot;名字是:$&#123;name&#125;&quot;); &#125; /// 可以不用abstract修饰 void eat(); //抽象函数&#125;class Dog extends Animal&#123; /// 实现抽象方法 @override void eat() &#123; //实现抽象函数 print(&quot;eat&quot;); &#125;&#125; 函数重写12345678910111213class Animal &#123; late String name; void run() &#123; print(&#x27;run&#x27;); &#125;&#125;class Tiger extends Animal &#123; @Override void run() &#123; print(&#x27;Tiger run&#x27;); &#125;&#125; 使用Override修饰符，函数名字相同。","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"数据类型","date":"2023-06-17T02:29:30.070Z","path":"wiki/Flutter/Dart/基础/数据类型/","text":"内置类型： 数据类型：num 字符串类型：String 布尔类型：bool 列表类型：list 集合类型：Set 映射类型：Map Unicode：Runes 标识符：Symbols NumbersDart 中数字类型用于表示数字文字，Dart 中的数字类型分为整数和双精度数两种，整数值不大于64位， 具体取决于平台。 Dart支持两种Number类型： int double 123456789101112131415161718192021222324int i = 11111;double d = 123123123;// String -&gt; intvar one = int.parse(&#x27;1&#x27;);assert(one == 1);// String -&gt; doublevar onePointOne = double.parse(&#x27;1.1&#x27;);assert(onePointOne == 1.1);// int -&gt; StringString oneAsString = 1.toString();assert(oneAsString == &#x27;1&#x27;);// double -&gt; StringString piAsString = 3.14159.toStringAsFixed(2);assert(piAsString == &#x27;3.14&#x27;);assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110assert((3 | 4) == 7); // 0011 | 0100 == 0111assert((3 &amp; 4) == 0); // 0011 &amp; 0100 == 0000 StringsDart 字符串是 UTF-16 编码的字符序列。 可以使用单引号或者双引号来创建字符串，单引号和双引号可以嵌套使用，否则需要使用\\进行转义。字符串中也可以引用变量与表达式。 在字符串中，请以 ${表达式} 的形式使用表达式，如果表达式是一个标识符，可以省略掉 {}。如果表达式的结果为一个对象，则 Dart 会调用该对象的 toString 方法来获取一个字符串。 12345678910111213141516171819202122232425262728293031var name = &#x27;zhangsan&#x27;;//如果插入一个简单的标识符，而后面没有紧跟更多的字母数字文本，那么&#123;&#125;应该被省略。var a = &quot;my name is $name!&quot;;var b = &quot;my name is $&#123;name.toUpperCase()&#125;!&quot;;var a = &quot;my name is &quot; &quot;zhangsan&quot;;//多个字符串放一起拼接var c = &quot;my name is&quot; + &quot;zhangsan&quot;;//使用+拼接//使用三个单引号或者双引号可以创建多行字符串对象var s1 = &#x27;&#x27;&#x27;You can createmulti-line strings like this one.&#x27;&#x27;&#x27;;var s2 = &quot;&quot;&quot;This is also amulti-line string.&quot;&quot;&quot;;//提供一个 `r` 前缀可以创建一个 “原始 raw” 字符串print(r&quot;换行符：\\n&quot;); // 换行符：\\n r:不需要转义print(&quot;换行符：\\\\n&quot;); // 换行符：\\nvar s1 = &#x27;String &#x27; &#x27;concatenation&#x27; &quot; works even over line breaks.&quot;;assert(s1 == &#x27;String concatenation works even over &#x27; &#x27;line breaks.&#x27;);var s2 = &#x27;The + operator &#x27; + &#x27;works, as well.&#x27;;assert(s2 == &#x27;The + operator works, as well.&#x27;); 布尔类型有一个名字为 bool 的类型。 只有两个对象是布尔类型的：true 和 false 123456789101112131415// Check for an empty string.var fullName = &#x27;&#x27;;assert(fullName.isEmpty);// Check for zero.var hitPoints = 0;assert(hitPoints &lt;= 0);// Check for null.var unicorn;assert(unicorn == null);// Check for NaN.var iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); ListsDart中，数组（Array）由List对象表示常用属性： length：返回当前List的长度。 isEmpty：判断是否为空，返回bool类型的值。 isNotEmpty：判断是否为不空，返回bool类型的值。 reversed：倒序输出List中的值。输出结果并不是一个List，需要使用toList()方法将其在转换成List。 常用方法： add(VALUE)：向List中添加单个数据。 addAll([ARRAY])：以数组的形式向List中添加多个数据。 indexOf(ELEMENT)：查找ELEMENT是否在List中。如果存在，返回其索引值；如果是不存在，返回 -1。 remove(ELEMENT)：删除ELEMENT。 removeAt(INDEX)：删除索引值为INDEX的值。 fillRange(START,END,[ VALUE])：将[START,END）范围内的值改为[VALUE]的值。 insert(INDEX,VALUE)：在INDEX处插入VALUE。 insert(INDEX,LIST)：在INDEX处插入LIST。 join(SYMBOL)：以SYMBOL将LIST隔开，并以String类型返回。 STRING.split(SYMBOL)：将字符串以SYMBOL进行切割，并以List类型返回。 12345678910111213141516171819202122232425var list = [1, 2, 3,]; //这个尾随逗号并不会影响集合，但它能有效避免「复制粘贴」的错误。//Lists 的下标索引从 0 开始，第一个元素的索引是 0. list.length - 1 是最后一个元素的索引print(list[list.length-1]);//修改元素list[0] = 2;//使用new（实际上new可以省去）var list = new List(1);list[0] = 2;//在 list 字面量之前添加 const 关键字，可以定义一个不变的 list 对象（编译时常量）var list = const [1,2,3];i.add(2); ///错误，list不可变List&lt;int&gt; list2 = const [1,2,3];// error// list2.add(5);list2 = [1,2,3,4];print(list2);const List&lt;int&gt; list3 = [4,5,6];// list3.add(7);// error// list3 = [1,2,3,4];print(list3); Dart 在 2.3 引入了 扩展操作符（…）和 空感知扩展操作符（…?），它们提供了一种将多个元素插入集合的简洁方法。 例如，你可以使用扩展操作符（…）将一个 List 中的所有元素插入到另一个 List 中： 123var list = [1, 2, 3];var list2 = [0, ...list];assert(list2.length == 4); 如果扩展操作符右边可能为 null ，你可以使用 null-aware 扩展操作符（…?）来避免产生异常： 123var list;var list2 = [0, ...?list];assert(list2.length == 1); Dart 还同时引入了 集合中的 if 和 集合中的 for 操作，在构建集合时，可以使用条件判断 (if) 和循环 (for)。 12345678910111213var nav = [ &#x27;Home&#x27;, &#x27;Furniture&#x27;, &#x27;Plants&#x27;, if (promoActive) &#x27;Outlet&#x27;];var listOfInts = [1, 2, 3];var listOfStrings = [ &#x27;#0&#x27;, for (var i in listOfInts) &#x27;#$i&#x27;];assert(listOfStrings[1] == &#x27;#1&#x27;); Maps键值对相关的对象。 键和值可以是任何类型的对象。每个键只出现一次， 而一个值则可以出现多次。Dart 中 Map 提供了 Map 字面量以及 Map 类型两种形式的 Map。 Map的不同类型： HashMap是无序的，这意味着它迭代的顺序是不确定的 LinkedHashMap按key的插入顺序进行迭代 SplayTreeMap按key的排序顺序进行迭代 当Map的一个操作正在执行的时候，通常不允许修改Map（添加或删除key） 12345678910111213//直接声明，用&#123;&#125;表示，里面写key和value，每组键值对中间用逗号隔开var companys = &#123;&#x27;a&#x27;: &#x27;阿里巴巴&#x27;, &#x27;t&#x27;: &#x27;腾讯&#x27;, &#x27;b&#x27;: &#x27;百度&#x27;&#125;;var companys2 = new Map();companys2[&#x27;a&#x27;] = &#x27;阿里巴巴&#x27;;companys2[&#x27;t&#x27;] = &#x27;腾讯&#x27;;companys2[&#x27;b&#x27;] = &#x27;百度&#x27;;//添加元素companys[&#x27;j&#x27;] = &#x27;京东&#x27;;//获取与修改元素var c = companys[&#x27;c&#x27;]; ///没有对应的key返回nullcompanys[&#x27;a&#x27;] = &#x27;alibaba&#x27;; Sets在 Dart 中，set 是一组特定元素的无序集合。 12345678910111213141516171819202122//可以使用在 &#123;&#125; 前加上类型参数的方式创建一个空的 Set，或者将 &#123;&#125; 赋值给一个 Set 类型的变量：var names = &lt;String&gt;&#123;&#125;;// Set&lt;String&gt; names = &#123;&#125;; // This works, too.// var names = &#123;&#125;; // Creates a map, not a set.Set&lt;String&gt; set = &#123;&#x27;aaa&#x27;, &#x27;bbb&#x27;&#125;;for(var item in set) &#123; print(item);&#125;set.forEach((element) &#123; print(element);&#125;);//是否包含元素if (set.contains(&quot;aaa&quot;)) &#123; print(&quot;包含元素&quot;);&#125;set.clear(); Runes在 Dart 中，runes 公开了字符串的 Unicode 码位。使用 characters 包 来访问或者操作用户感知的字符，也被称为 Unicode (扩展) grapheme clusters。 如果需要获得特殊字符的Unicode编码，或者需要将32位的Unicode编码转换为字符串，就可以借助Runes类。 Dart表达Unicode代码点的常用方法是\\uXXXX，其中XXXX是4位十六进制值。要指定多于或少于4个十六进制数字，需要将值放在大括号中。 123456789101112131415161718192021222324252627var clapping = &#x27;\\u&#123;1f44f&#125;&#x27;; ///5个16进制 需要使用&#123;&#125;print(clapping);////获得 16位代码单元print(clapping.codeUnits); //[55357, 56399]//获得unicode代码print(clapping.runes.toList()); //[128079]//fromCharCode 根据字符码创建字符串print( String.fromCharCode(128079));print( String.fromCharCodes(clapping.runes));print( String.fromCharCodes([55357, 56399]));print( String.fromCharCode(0x1f44f));Runes input = new Runes( &#x27;\\u2665 \\u&#123;1f605&#125; \\u&#123;1f60e&#125; \\u&#123;1f47b&#125; \\u&#123;1f596&#125; \\u&#123;1f44d&#125;&#x27;);print(String.fromCharCodes(input));import &#x27;package:characters/characters.dart&#x27;;...var hi = &#x27;Hi 🇩🇰&#x27;;print(hi);print(&#x27;The end of the string: $&#123;hi.substring(hi.length - 1)&#125;&#x27;);print(&#x27;The last character: $&#123;hi.characters.last&#125;\\n&#x27;); SymbolsSymbol 表示 Dart 中声明的操作符或者标识符。 可以看作C中的宏。表示编译时的一个常量。 12345678910111213141516var i = #A; //常量main() &#123; print(i); switch(i)&#123; case #A: print(&quot;A&quot;); break; case #B: print(&quot;B&quot;); break; &#125; var b = Symbol(&quot;b&quot;); print(#b == b); ///true&#125; 参考","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"函数","date":"2023-06-17T02:29:30.068Z","path":"wiki/Flutter/Dart/基础/函数/","text":"Dart 是一种真正面向对象的语言，所以即便函数也是对象并且类型为 Function，这意味着函数可以被赋值给变量或者作为其它函数的参数。你也可以像调用函数一样调用 Dart 类的实例。 12345678/// bool可以省略，但最好保留，提高可读性bool isNoble(int atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125;//如果函数体内只包含一个表达式，你可以使用简写语法，称之为箭头函数bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null; 在Java中，要实现回调，需要实现一个接口，在Dart中，只需要传递一个回调函数即可。 1234567891011121314void setListener(Function listener)&#123; listener(&quot;Success&quot;);&#125;//或者void setListener(void listener(String result))&#123; listener(&quot;Success&quot;);&#125;//第三种：类型定义 将返回值为voide，参数为一个String的方法定义为一个类型。typedef void Listener(String result)；void setListener(Listener listener)&#123; listener(&quot;Success&quot;);&#125; 12345678910//也可以选择忽略返回类型(不推荐)int add(int i,int j) &#123; return i + j;&#125;//对于只有一个表达式的方法，可以选择使用缩写语法来定义：add(i, j) =&gt; i + j;//在箭头 (=&gt;) 和分号 (;) 之间只能使用一个表达式 构造函数 如果你没有声明构造函数，那么 Dart 会自动生成一个无参数的构造函数并且该构造函数会调用其父类的无参数构造方法。 子类不会继承父类的构造函数，如果子类没有声明构造函数，那么只会有一个默认无参数的构造函数。 1234567891011121314class Point &#123; double x = 0; double y = 0; Point(double x, double y) &#123; // There&#x27;s a better way to do this, stay tuned. this.x = x; this.y = y; &#125; //语法糖 Point(this.x, this.y);&#125; 默认构造函数如果未声明构造函数，则会提供默认构造函数。 默认构造函数没有参数，并调用父类无参数构造函数。 默认情况下，子类中的构造函数调用父类的未命名无参数构造函数。 父类的构造函数在子类构造函数体的开头被调用。 如果还使用初始化了列表，则会在调用父类构造函数之前执行。 执行顺序如下： 初始化列表 父类的无参数构造函数 子类的无参数构造函数 1234567891011class Parent&#123; Parent()&#123; print(&#x27;In Parent\\&#x27;s constructor.&#x27;); &#125;&#125;class Child extends Parent&#123; Child()&#123; print(&#x27;In Child\\&#x27;s constructor.&#x27;); &#125;&#125; 如果父类没有未命名的无参数构造函数，则必须手动调用父类中的一个构造函数。 在子类的构造函数体之后用冒号(:)指定父类构造函数 12345678910111213class Parent&#123; num x; num y; Parent(this.x, this.y)&#123; print(&#x27;In Parent\\&#x27;s constructor.&#x27;); &#125;&#125;class Child extends Parent&#123; Child(num x, num y) : super(x, y)&#123; print(&#x27;In Child\\&#x27;s constructor.&#x27;); &#125;&#125; 命名构造函数123456789101112131415161718192021222324class Point&#123;num x;num y;Point(this.x, this.y);//创建一个坐标原点类Point.origin()&#123; this.x = 0; this.y = 0;&#125;//创建一个坐标为(100, 100)的类Point.coordinate100()&#123; this.x = 100; this.y = 100;&#125;@overrideString toString() &#123; return (&quot;x: $x, y: $y&quot;);&#125;&#125; 重定向构造函数12345678910class Point &#123; num x, y; //类的主构造函数 Point(this.x, this.y); //重定向到主构造函数 Point.alongXAxis(num x) : this(x, 0);&#125; 初始化列表除了调用父类构造函数之外，还可以在构造函数体执行之前初始化实例变量。每个实例变量之间使用逗号分隔。 1234567// Initializer list sets instance variables before// the constructor body runs.Point.fromJson(Map&lt;String, double&gt; json) : x = json[&#x27;x&#x27;]!, y = json[&#x27;y&#x27;]! &#123; print(&#x27;In Point.fromJson(): ($x, $y)&#x27;);&#125; 常量构造函数 常量构造函数需以const关键字修饰 const构造函数必须用于成员变量都是final的类 构建常量实例必须使用定义的常量构造函数 如果实例化时不加const修饰符，即使调用的是常量构造函数，实例化的对象也不是常量实例 1234567891011121314151617181920212223242526272829class ImutablePoint &#123; final int x; final int y; //常量构造方法 const ImutablePoint(this.x, this.y);&#125;main() &#123;var ip1 = const ImutablePoint(1, 1);var ip2 = const ImutablePoint(1, 1);var ip3 = const ImutablePoint(1, 2);print(ip1.hashCode == ip2.hashCode);print(ip1 == ip2);print(ip1.hashCode == ip3.hashCode);print(ip1 == ip3);output:truetruefalsefalse&#125; 工厂构造函数由于下划线开头的变量和方法是私有的，可以运用此特性实现单例模式。 工厂构造函数不需要每次构建新的实例，且不会自动生成实例,而是通过代码来决定返回的实例对象；工厂构造函数类似于 static 静态成员，无法访问 this 指针；一般需要依赖其他类型构造函数。 123456789101112131415161718192021222324class Singleton &#123; static final Singleton _singleton = Singleton.internal(); factory Singleton() =&gt; _singleton; Singleton.internal();&#125;class CommonPrivacyScreen &#123; final String title; final String url; factory CommonPrivacyScreen.privacy() &#123; return CommonPrivacyScreen(title: &quot;title_privacy&quot;,url: &quot;url_privacy&quot;); &#125; factory CommonPrivacyScreen.agreement() &#123; return CommonPrivacyScreen(title: &quot;title_agreement&quot;,url: &quot;title_agreement&quot;); &#125; CommonPrivacyScreen(&#123;Key key, this.title, this.url&#125;) : super(key: key);&#125; 参数函数可以有两种形式的参数： 必要参数：定义在参数列表前面 可选参数：定义在必要参数后面，可选参数可以是 命名的 或 位置的 可选命名参数把方法的参数放到 &#123;&#125; 中就变成可选命名参数，命名参数默认为可选参数，除非他们被特别标记为 required。 123456789int add(&#123;int? i, int? j&#125;) &#123; if(i == null || j == null)&#123; return 0; &#125; return i + j;&#125;print(add());print(add(i: 1));print(add(i: 2, j: 4)); 可选位置参数把方法的参数放到 [] 中就变成可选位置参数，传值时按照参数位置顺序传递。 12345678910111213class SquareBracketsClass &#123; late int x; late int y; // 1、2为默认参数 SquareBracketsClass([int x=1, int y=2]) &#123; this.x = x; this.y = y; &#125;&#125;main() &#123; var squareBracketClass = SquareBracketsClass(3); var squareBracketClass2 = SquareBracketsClass(3, 6);&#125; 默认参数值Dart中没有函数重载，可以用 &#x3D; 为函数的命名参数和位置参数定义默认值，默认值必须为编译时常量，没有指定默认值的情况下默认值为 null。 12345/// Sets the [bold] and [hidden] flags ...void enableFlags(&#123;bool bold = false, bool hidden = false&#125;) &#123;...&#125;// bold will be true; hidden will be false.enableFlags(bold: true); 函数作为参数传递函数是一级对象，可以将函数作为参数传给另一个函数，也可以将函数赋值给一个变量。 1234567891011121314void printElement(int element) &#123; print(element);&#125;var list = [1, 2, 3];// Pass printElement as a parameter.list.forEach(printElement);var loudify = (msg) =&gt; &#x27;!!! $&#123;msg.toUpperCase()&#125; !!!&#x27;;assert(loudify(&#x27;hello&#x27;) == &#x27;!!! HELLO !!!&#x27;); 匿名函数可以创建一个没有名字的方法，称之为 匿名函数、 Lambda 表达式 或 Closure 闭包。你可以将匿名方法赋值给一个变量然后使用它，比如将该变量添加到集合或从中删除。 匿名方法看起来与命名方法类似，在括号之间可以定义参数，参数之间用逗号分割。 后面大括号中的内容则为函数体： 1234567891011121314([[类型] 参数[, …]]) &#123;函数体;&#125;;([Type] param1, …) &#123; codeBlock; &#125;; var list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;];list.forEach((i) &#123; print(list[i]);&#125;); 参考","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"基本语法","date":"2023-06-17T02:29:30.068Z","path":"wiki/Flutter/Dart/基础/基本语法/","text":"语言特性 一切皆对象。 Dart没有 public、protected、private 等关键字，如果一个标识符以 _开头则表示私有。 标识符以小写字母或下划线_开头，后面跟着字符和数字的任意组合。 变量变量是一个引用,未初始化的变量值是null。 var声明的变量在赋值的那一刻，决定了它是什么类型。 1234567//a已经确定为num，不能再赋值字符串，编译错误var a = 1;a = &quot;a&quot;;//正确 var b;b = 1;b = &quot;a&quot;; dynamic不是在编译时候确定实际类型的, 而是在运行时。dynamic声明的变量行为与Object一样，使用一样，关键在于运行时原理不同。 没有初始化的变量自动获取一个默认值为 null（类型为数字的变量如何没有初始化其值也是 null）。 在声明变量的时候，也可以选择加上具体 类型：int a &#x3D; 1; const、finalfinal是运行时常量，只能被设置一次，而const是编译器常量，它的值在编译期就可以确定，编译时常量能够让代码运行的更高效。 123456//正确，已经确定的值const a = 1;const b = a + 1;//错误,final不能在编译时确定值，因此const也不能确定值final a = 1;const c = a + 1; 参考 Flutter:6种构造函数详解","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"异常","date":"2023-06-17T02:29:30.068Z","path":"wiki/Flutter/Dart/基础/异常/","text":"","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"接口","date":"2023-06-17T02:29:30.068Z","path":"wiki/Flutter/Dart/基础/接口/","text":"定义使用implements关键字来使用接口，实现类必须实现接口中所有的方法。Dart中没有interface关键字，implements后可以接任意类。implements后面可以跟多个类，使用逗号隔开。 每一个类都隐式地定义了一个接口并实现了该接口，这个接口包含所有这个类的实例成员以及这个类所实现的其它接口。 Example12","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"Mixin","date":"2023-06-17T02:29:30.066Z","path":"wiki/Flutter/Dart/基础/Mixin/","text":"定义字面意思理解成混合，它可以混合多个类，达到多继承的效果。 当继承多个mixin，mixin内重写覆盖了同一个方法，则调用方法时会命中最后with的mixin对应的方法。如果需要链路调用，使用super。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mixin A &#123; test() &#123; print(&#x27;A&#x27;); &#125;&#125;mixin B &#123; test() &#123; print(&#x27;B&#x27;); &#125;&#125;class C &#123; test() &#123; print(&#x27;C&#x27;); &#125;&#125;/// 使用with关键字，后跟一个或多个mixin或者普通类class D extends C with A, B &#123;&#125;class E extends C with B, A &#123;&#125;main() &#123; D d = D(); d.test(); E e = E(); e.test();&#125;output:BAclass D extends C with A, B &#123;&#125;可以理解成：class CA = C with A;class CAB = CA with B;class D extends CAS &#123;&#125;所以输出结果为Bclass E extends C with B, A &#123;&#125;class CB = C with B;class CBA = CB with A;class E extends CBA;所以输出结果为A onon关键字用来限制mixin的使用，这个mixin只能使用在on指定的类或者其子类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071abstract class Base &#123; a() &#123; print(&quot;base a()&quot;); &#125; b() &#123; print(&quot;base b()&quot;); &#125; c() &#123; print(&quot;base c()&quot;); &#125;&#125;mixin A on Base &#123; a() &#123; print(&quot;A.a()&quot;); //super.a(); &#125; b() &#123; print(&quot;A.b()&quot;); super.b(); &#125;&#125;mixin A2 on Base &#123; a() &#123; print(&quot;A2.a()&quot;); super.a(); &#125;&#125;class B extends Base &#123; a() &#123; print(&quot;B.a()&quot;); super.a(); &#125; b() &#123; print(&quot;B.b()&quot;); super.b(); &#125; c() &#123; print(&quot;B.c()&quot;); super.c(); &#125;&#125;class G extends B with A, A2 &#123;&#125;testMixins() &#123; G t = new G(); t.a(); t.b(); t.c();&#125;output：ßA2.a()A.a()A.b()B.b()base b()B.c()base c() 参考 彻底理解 Dart mixin 机制 Dart 类的继承与混入(Mixin) extends 、 implements 、 with的用法与区别","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"Map","date":"2023-06-17T02:29:30.063Z","path":"wiki/Flutter/Dart/基础/Map/","text":"遍历1234567891011121314151617181920212223242526// 使用 forEach 进行遍历president.forEach( (key, value)&#123; print(&quot;forEach 遍历 : $key : $value&quot;);&#125; );// 2 . 通过 for 循环遍历 Map 集合// 调用 Map 对象的 keys 成员 , 返回一个由 键 Key 组成的数组for (var key in president.keys)&#123; print(&quot;for 循环遍历 : Key : $key , Value : $&#123;president[key]&#125;&quot;);&#125;// 3 . 使用 map 方法进行遍历// 遍历过程中生成新的 Map 集合// 遍历后 , 会返回一个新的 Map 集合// 传入一个回调函数 , 参数是 key value , 返回值是新的 Map 集合Map president2 = president.map( (key, value)&#123; // 这里将 Map 集合中的 Key 和 Value 进行颠倒 , 生成一个新的 Map 集合 return MapEntry(value, key); &#125;);// 打印新的 Map 集合print(president2);","tags":[{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"}]},{"title":"《万历十五年》读书笔记","date":"2023-04-14T03:07:18.813Z","path":"wiki/读书笔记/万历十五年/","text":"","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"CustomMultiChildLayout","date":"2023-03-07T01:21:45.590Z","path":"wiki/Flutter/UI/标准库/CustomMultiChildLayout/","text":"CustomMultiChildLayout从字面意思就说的很清楚了，自定义多个孩子的布局控件 基本用法1234567891011121314151617181920212223242526272829303132333435363738CustomMultiChildLayout( delegate: XXXDelegate(dataList), //委托 用于设置child的大小和位置 children: dataList.map((e) =&gt; LayoutId(id: e[&#x27;id&#x27;], child: const _FigureBlock())).toList(), //视图 对应每个child显示的样子)class _FigureBlock extends StatelessWidget &#123;&#125;class XXXDelegate extends MultiChildLayoutDelegate &#123; XXXDelegate(this.dataList); List dataList; /// 处理大小和位置 @override void performLayout(Size size) &#123; for (var element in dataList) &#123; String id = element[&#x27;id&#x27;]; Rect rect = element[&#x27;rect&#x27;]; // 约束对应id的child的消息 layoutChild(id, BoxConstraints(maxHeight: rect.height, maxWidth: size.width)); // 对应id的child的位置 positionChild(id, Offset(rect.left, rect.top)); &#125; &#125; /// 是否需要重新布局 @override bool shouldRelayout(_BlockEventMultiChildLayoutDelegate oldDelegate) &#123; return oldDelegate.dataList != dataList; &#125;&#125;","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"}]},{"title":"沉浸式处理","date":"2023-03-02T10:12:11.971Z","path":"wiki/Flutter/未分类/沉浸式处理/","text":"基本使用(全局生效)Flutter侧设置123456789101112131415// 黑色沉浸式状态栏颜色 黑色文字SystemUiOverlayStyle dark = const SystemUiOverlayStyle( // systemNavigationBarColor: Color(0xFF000000), systemNavigationBarDividerColor: null, //设置导航栏和内容区域的分割线颜色 systemNavigationBarIconBrightness：null, //设置导航栏图标的颜色，可选值为Brightness.light或Brightness.dark。 /// 注意安卓要想实现沉浸式的状态栏 需要底部设置透明色 statusBarColor: Colors.transparent, // 状态栏颜色为透明 systemNavigationBarIconBrightness: Brightness.light, statusBarIconBrightness: Brightness.dark, // 设置状态栏图标的颜色，可选值为Brightness.light或Brightness.dark。 statusBarBrightness: Brightness.light, // 设置状态栏文字的颜色，可选值为Brightness.light或Brightness.dark。);SystemChrome.setSystemUIOverlayStyle(dark); 原生侧设置123456789@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; getWindow().setStatusBarColor(0);//原生侧设置透明 &#125;&#125; 单个页面设置参考","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"资源使用","date":"2023-03-01T09:32:48.044Z","path":"wiki/Flutter/未分类/资源使用/","text":"Flutter 应用程序包含代码和 assets（也为资源）。资源是被打包到应用程序安装包中，可以在运行时访问的一种文件。常见的资源类型包括静态数据（例如 JSON 文件），配置文件，图标和图片（JPEG，WebP，GIF，动画 WebP &#x2F; GIF，PNG，BMP 和 WBMP）。 指定资源Flutter使用pubspec.yaml文件来配置所需要的资源 12345flutter: assets: - assets/my_icon.png - assets/background.png - directory/ 如果要包含一个目录下所有的assets，需要在目录名称的结尾加上/ 依赖包中的资源图片加载依赖 package 中的图像，必须给 AssetImage 提供 package 参数。 例如，你的应用程序依赖于一个名为 my_icons 的 package，它的目录结构如下： 123456789.../pubspec.yaml.../icons/heart.png.../icons/1.5x/heart.png.../icons/2.0x/heart.png...etc.// 加载image，使用packagereturn const AssetImage(&#x27;icons/heart.png&#x27;, package: &#x27;my_icons&#x27;); 如果你封装了一个库，库里面有自己的资源，那么做图片展示的时候都需要带上package 参考 添加资源和图片(官方)","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"《置身事内》读书笔记","date":"2023-02-27T08:13:00.858Z","path":"wiki/读书笔记/置身事内/","text":"","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"数据监控方案","date":"2023-02-27T07:56:31.770Z","path":"wiki/技术开发/服务端/数据监控方案/","text":"client对相关数据进行上报，服务端对数据进行处理，后台提供一个网站进行数据展示，展示可以使用各种图表。Grafana就提供了如此一套开源解决方案。 Grafana 是一个开源的数据可视化和监控平台，其原理可以分为以下几个方面： 数据源连接：Grafana 支持连接各种数据源，如 Prometheus、Elasticsearch、InfluxDB、MySQL、PostgreSQL 等，以获取数据。它通过插件机制来支持不同的数据源，并且提供了一组 API 来获取数据。 数据存储：Grafana 不会存储数据，而是通过查询数据源来获取数据。这意味着 Grafana 的性能取决于数据源的性能。 数据查询：Grafana 支持使用类 SQL 语言进行数据查询，可以查询时间序列数据、表格数据等。 数据可视化：Grafana 支持各种数据可视化方式，如折线图、柱状图、饼图等。用户可以使用 Grafana 提供的界面来创建和配置面板，选择不同的数据源和可视化方式，以满足不同的需求。 插件扩展：Grafana 提供了丰富的插件扩展机制，用户可以通过插件来扩展 Grafana 的功能，例如支持更多的数据源、可视化方式等。 总之，Grafana 的核心原理是通过连接数据源、查询数据、可视化数据等方式，提供用户友好的数据监控和可视化功能。 参考 Grafana官网","tags":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"categories":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"《现代中国的形成》读书笔记","date":"2023-02-18T11:01:53.648Z","path":"wiki/读书笔记/现代中国的形成/","text":"","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"权力结构、政治激励和经济增大","date":"2023-02-18T10:12:49.821Z","path":"wiki/读书笔记/权力结构、政治激励和经济增大/","text":"最近读了《权力结构、政治激励和经济增大》这本书。书中通过分析开国到至今浙江地区的经济发展与政治的联系，很受启发。 政治人物的首要目的在于确保其政治生存 地方政治精英常常面临不确定的政治和政策环境，为保证其政治生存，就必须向上或向下寻求政治支持。前者指向上级或更有权力的人寻求支持和保护，后者指向下级甚至更基层的支持者寻求政治支持。最终从何处获得政治支持，取决于他们在权力结构中所处的位置。如果他们在整个权力结构和网络中处于边缘地位，向上寻求政治支持和保护的渠道不存在，导致他们无法依靠上级的庇护，因而这些边缘化的政治精英就必须从更基层的力量中寻求政治支持，以最大限度地提高自己的政治生存概率。 基层支持力量对边缘化政治精英政治利益。 地方化产权保护机制能够长期有效运行的条件，即导致边缘化政治精英和基层支持者之间形成长久持续的可置信合作关系的结构性条件， 政治因素而不是其他因素是解释中国经济增长（包括地区经济增长）差异的最重要的因素 相信有远见的领导人一定会主动采取改革措施以适应时代的要求 一些思考 一个国家的决策层的每一个决定都应该慎重，如果皇帝全凭自己的喜好来制定国策，那么这个国家注定活不长久。 高层推行集体制，基层官员为了种种原因，可能会对任务层层加码，也可能“睁一只眼闭一只眼”，影响到底层人民的基本利益。看起来事事有因果；在我们的平常生活中，可以多去思考这个事情其深层次的原因，能对事物看的更透彻。 饥荒时期应该没有或者很少体制内的人饿死吧？如果可以重来，可能会选择努力进入体制内了… 参考 权力结构、政治激励和经济增长","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"证书的坑","date":"2023-02-17T10:30:29.258Z","path":"wiki/程序语言/iOS/证书的坑/","text":"","tags":[{"name":"iOS","slug":"iOS","permalink":"http://airshu.github.io/tags/iOS/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"iOS","slug":"程序语言/iOS","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/"}]},{"title":"嵌入Android原生View","date":"2023-02-10T01:27:36.057Z","path":"wiki/Flutter/Android端/嵌入Android原生View/","text":"参考","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"Android端","slug":"Flutter/Android端","permalink":"http://airshu.github.io/categories/Flutter/Android%E7%AB%AF/"}]},{"title":"人类之旅","date":"2022-11-13T11:04:27.077Z","path":"wiki/读书笔记/人类之旅/","text":"摘要共产主义革命没有在大多数社会取得成功？一种解释是，革命的威胁推动工业化国家采纳相应政策，缓和了阶级矛盾与不平等，主要是投票权的普及、财富再分配权力的扩大以及福利国家制度的兴起等 印度在2011年的贫困人口比例已经降至22%，中国在2016年已经不足1%。（我们国家的发展还是有目共睹的） 2017年，大多数发达国家民众的预期寿命超过80岁，婴儿死亡率低于5‰，全体国民都有电力供应，很大部分人有互联网连接，营养不良率仅有约2.5%。而在最不发达国家，预期寿命不足62岁，婴儿死亡率超过60‰，不到47%的人有电力供应，不足1‰的人能连上互联网，19.4%的人存在营养不良。（该庆幸自己没有出生在那些地方？） 权力会束缚自由创业，妨碍有意义的教育投资，压制经济增长与发展。（权力压制经济增长，但有时候集中力量才能办大事，国家领导人们应该也是殚精竭虑的吧，一个决定会影响千万人的生活） 1689年，威廉三世正式签署《权利法案》（Bill of Rights），废除了君王可撤销议会法案、不经议会同意而征税和动员军队的权力。英国就此变成一个君主立宪制国家。（伟人） “华盛顿共识”，它是给发展中国家提出的一整套政策建议，重点包括贸易自由化、国有企业私有化、加强产权保护、放松市场规制、降低边际税率等。（有些事情不是套用公式就行了，照搬苏联模式已经证明行不通了，可以借鉴，21世纪初的时候我们都是学习海外先进的产品然后回来复刻，而现在我们有越来越多自己出海的产品了） 无论多么高效的改革都不可能在一夜之间把贫穷国家改造成发达经济体，因为发达国家与发展中国家之间的很大差别植根于数千年以来的漫长进程。起源于遥远过去的制度、文化、地理和社会特征通过独特的历史路径驱动文明发展，导致各国财富水平走向分化。毋庸置疑，有利于经济繁荣的文化和制度可以逐渐被采纳和确立，地理因素和差异性导致的壁垒可以被削减。可是，任何干预如果忽略每个国家发展历程上出现的独有特征，则不太可能缩小财富不平等，反而容易导致挫折、动荡与长期停滞。 参考 豆瓣主页","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"通讯原理","date":"2022-10-22T05:37:30.204Z","path":"wiki/Flutter/未分类/通讯原理/","text":"Flutter定义了三种不同类型的Channel： BasicMessageChannel：用于传递字符串和半结构化的信息 MethodChannel：用于传递方法调用（method invocation） EventChannel: 用于数据流（event streams）的通信 三种Channel之间互相独立，各有用途，但它们在设计上却非常相近。每种Channel均有三个重要成员变量： name: String类型，代表Channel的名字，也是其唯一标识符。 messager：BinaryMessenger类型，代表消息信使，是消息的发送与接收的工具。 codec: MessageCodec类型或MethodCodec类型，代表消息的编解码器。 参考 深入理解Flutter的Platform Channel机制","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"Shell用法-awk","date":"2022-08-25T08:49:55.715Z","path":"wiki/技术开发/Shell/Shell用法-awk/","text":"","tags":[{"name":"Shell","slug":"Shell","permalink":"http://airshu.github.io/tags/Shell/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Shell","slug":"技术开发/Shell","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Shell/"}]},{"title":"Shell用法-sed","date":"2022-08-25T08:49:37.212Z","path":"wiki/技术开发/Shell/Shell用法-sed/","text":"","tags":[{"name":"Shell","slug":"Shell","permalink":"http://airshu.github.io/tags/Shell/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Shell","slug":"技术开发/Shell","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Shell/"}]},{"title":"Shell基本用法","date":"2022-08-25T08:41:57.975Z","path":"wiki/技术开发/Shell/Shell基本用法/","text":"basename example.tar.a.b.c.gz .c.gz &#x3D;&gt; example.tar.a.bFILE&#x3D;”example.tar.gz” echo “${FILE%%.*}” 取头 example &#x3D;&gt; exampleecho “${FILE%.*}” 去尾 example.tar.a.b.c &#x3D;&gt; example.tarecho “${FILE#*.}” 去头 tar.a.b.c.gz &#x3D;&gt; tar.gzecho “${FILE##*.}” 取尾 gz &#x3D;&gt; gz在bash中可以这么写filename&#x3D;$(basename “$fullfile”)extension&#x3D;”${filename##.}”filename&#x3D;”${filename%.}”","tags":[{"name":"Shell","slug":"Shell","permalink":"http://airshu.github.io/tags/Shell/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Shell","slug":"技术开发/Shell","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Shell/"}]},{"title":"Git hooks","date":"2022-08-24T09:46:24.206Z","path":"wiki/技术开发/Git/githooks/","text":"Git 能在特定的重要动作发生时触发自定义脚本。 有两组这样的钩子：客户端的和服务器端的。 客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 你可以随心所欲地运用这些钩子。 钩子都被存储在 Git 目录下的 hooks 子目录中。 也即绝大部分项目中的 .git&#x2F;hooks 。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。 这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或任何你熟悉的语言编写它们。 这些示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀。 把一个正确命名（不带扩展名）且可执行的文件放入 .git 目录下的 hooks 子目录中，即可激活该钩子脚本。 这样一来，它就能被 Git 调用。接下来，我们会讲解常用的钩子脚本类型。 参考 Git 钩子 官方所有钩子的解释 Git项目管理，代码规范pre-commit使用详解","tags":[{"name":"Git","slug":"Git","permalink":"http://airshu.github.io/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Git","slug":"技术开发/Git","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Git/"}]},{"title":"汽车是怎样跑起来的","date":"2022-08-06T08:31:29.574Z","path":"wiki/读书笔记/汽车是怎样跑起来的/","text":"汽车的组成动力传动 发动机中有气缸和活塞，汽油在气缸中的燃烧室内进行然后，发热后膨胀，膨胀下压活塞，从而带动活塞下的轴转动，从而使轮胎转动。 转向系统 制动系统 刹车是通过制动垫夹住与轮胎一起转动的制动盘。 发动机发动机有二冲程和四冲程之分。二冲程指活塞每上下往复一次，燃烧一次，而四冲程指活塞每上下往复两次，燃烧一次。 行驶发动机四冲程活塞气缸凸轮曲轴直接喷射吸气管喷射空燃比蓄电池起动机废气涡轮增压器 变速器利用齿轮改变力量手动变速器、自动变速器、齿轮、正齿轮、行星齿轮、离合器、扭矩、发动机功率牙嵌式离合器、同步啮合装置、差速器、液力变扭器、CVT 转向转向系统抓地力侧偏力差速器悬架悬架摆臂弹簧减震器稳定器 停车盘式制动器、鼓式制动器、制动器主气缸、制动卡钳、制动垫、真空倍力泵、抓地力、ABS、发动机制动 舒适性NVH、噪音、振动、声振粗糙、空气净化器、沟纹、平整表面、悬架、橡胶衬套 安全性主动安全技术、被动安全技术、预碰撞安全技术、ABS、ESC、制动辅助系统、雷达巡航控制系统、车道保持系统、预碰撞制动、预碰撞安全带、吸能车身、3点式安全带、安全气囊、主动式头枕技术 电动汽车电动汽车是由电而不是发动机驱动的，因此几乎没有与发动机相关的零件。在电动汽车中，不需要发动机、变速器、汽油罐、燃料管道、燃料泵、燃料喷射装置、点火装置(火花塞)、进排气管、汽车尾气净化器以及消除废气噪音的消音器等零件。代替它们的是一些电气元件，具体来说就是用电产生旋转力的电动机、储存电的蓄电池、 用于控制的变频器和充电器等零件。 电动机：电动机呈圆柱形，中心有一根旋转轴，轴周围是圆柱形的结构。旋转轴上的永 久磁铁左右是正极和负极，圆柱形结构的内侧装有电磁铁。当旋转轴上的永久磁 铁和圆柱形内侧的电磁铁同极时，就会相互排斥，带动轴旋转。旋转到一半时，轴上的磁铁 和圆柱形上的磁铁就变成异极相对了，此时它们相互吸引，轴也就停止转动了。 变频器：负责转动电动机。变频器有两个作用：1、转换直流电和交流电；2、根据电器的工作状况精准调整电功率。 电动汽车是由储存在蓄电池里的电来驱动的，蓄电池放出的电是直流电，而电动汽车上的电动机是由交流电带动的。因此，在将蓄电池放出的直流电接入电动机之前，要利用变频器将其转换成交流电。 蓄电池、充电器、 交流电、直流电： 使用交流电动机的作用是利用其“再生”功能，汽车放出的电给蓄电池充电。 调节器、再生、制动力、扭矩、轮毂电机、锂离子电池 环保型汽车燃料电池汽车(FCV:Fuel Cell Vehicle)、混合动力汽车、插入式混合动力汽车、清洁 柴油汽车、生物燃料、氢动力车","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Gerrit使用笔记","date":"2022-07-27T09:04:22.916Z","path":"wiki/工具软件/Gerrit使用笔记/","text":"Gitlab、Github的Pull Request功能可以进行Code Review，但Gerrit更强大，可以搭配Jenkins、LDAP等在企业内部搭建完善的Code Review流程。这里记录下自己对其的了解，方便在工作中使用它。 安装1234567891011# 下载war包wget https://gerrit-releases.storage.googleapis.com/gerrit-3.1.3.war# 安装java -jar gerrit*.war init --batch --dev --install-all-plugins -d ~/gerrit_testsite# —batch 默认使用一些配置# —dev 开发环境# -d 安装目录# --install-all-plugins 安装插件 文件夹结构 bin：命令存放目录 gerrit.sh：gerrit服务控制命令 cache: data: etc：配置文件保存目录 gerrit.config：端口配置，反向代理配置，等等 git：项目源码保存目录 logs：日志文件存储目录 plugins：插件存储目录 static: tmp: 基本命令1234cd $GERRIT_SITE/bingerrit.sh startgerrit.sh stopgerrit.sh restart Gerrit配置1234567891011121314151617181920212223242526[gerrit] basePath = D:\\\\Program Files (x86)\\\\PortableGit\\\\bin serverId = c08372c6-a331-4dce-a236-f4c93211f236 canonicalWebUrl = http://192.168.40.8:7001/ # 访问地址[database] type = mysql hostname = localhost database = gerrit username = root[index] type = LUCENE[auth] type = HTTP # 授权方式，可以使用HTTP的方式关联Apache、Nginx；也可以使用LDAP等[receive] enableSignedPush = false[sendemail] smtpServer = localhost[container] user = PC074 javaHome = d:\\\\Program Files\\\\Java\\\\jdk1.8.0_121\\\\jre[sshd] listenAddress = *:123 # 端口绑定[httpd] listenUrl = http://192.168.40.8:7001/ [cache] directory = cache auth类型配置反向代理配置基本使用 第一个注册的用户是超级管理员，ID为1000000 使用基本流程： 创建账号，添加ssh公钥 配置仓库 给用户分配权限 创建Change push代码进行Review流程 开发者使用1234567891011121314# 拉取代码git clone &quot;ssh://xxx@xx.xxx.201.148:12304/All-Projects&quot; &amp;&amp; scp -p -P 12304 longsj@47.113.201.148:hooks/commit-msg &quot;All-Projects/.git/hooks/&quot;##修改vim Readme.MDgit add Readme.MDgit commit -m &quot;change xxx&quot;# 推送修改，推送成功后gerrit后台会有change记录git push origin HEAD:refs/for/HEAD# origin : 是远程的库的名字# HEAD: 是一个特别的指针，它是一个指向你正在工作的本地分支的指针，可以把它当做本地分支的别名，git这样就可以知道你工作在哪个分支# refs/for :意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，for表示指向某个分支 参考 Gerrit使用说明","tags":[{"name":"效率","slug":"效率","permalink":"http://airshu.github.io/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"丰田汽车","date":"2022-07-19T03:30:02.884Z","path":"wiki/随笔/Car/丰田汽车/","text":"","tags":[{"name":"Car","slug":"Car","permalink":"http://airshu.github.io/tags/Car/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Car","slug":"随笔/Car","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/Car/"}]},{"title":"福特汽车","date":"2022-07-19T03:29:53.906Z","path":"wiki/随笔/Car/福特汽车/","text":"","tags":[{"name":"Car","slug":"Car","permalink":"http://airshu.github.io/tags/Car/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Car","slug":"随笔/Car","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/Car/"}]},{"title":"大众汽车","date":"2022-07-19T03:29:33.081Z","path":"wiki/随笔/Car/大众汽车/","text":"","tags":[{"name":"Car","slug":"Car","permalink":"http://airshu.github.io/tags/Car/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Car","slug":"随笔/Car","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/Car/"}]},{"title":"汽车发展史笔记","date":"2022-07-19T03:28:52.575Z","path":"wiki/随笔/Car/汽车发展史笔记/","text":"","tags":[{"name":"Car","slug":"Car","permalink":"http://airshu.github.io/tags/Car/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Car","slug":"随笔/Car","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/Car/"}]},{"title":"绘制原理","date":"2022-04-27T08:41:46.521Z","path":"wiki/Flutter/源码分析/绘制原理/","text":"相关类 Canvas：封装了Flutter Skia各种绘制指令，比如画线、画圆、画矩形等指令。 Layer：分为容器类和绘制类两种；暂时可以理解为是绘制产物的载体，比如调用 Canvas 的绘制 API 后，相应的绘制产物被保存在 PictureLayer.picture 对象中。 Scene：屏幕上将要要显示的元素。在上屏前，我们需要将Layer中保存的绘制产物关联到 Scene 上。 Container Layer：管理Layers，是唯一可以拥有child layer的Layer； 非Container Layer：真正用于承载渲染结果的layer，在Layer Tree中属于叶子结点。比如PictureLayer承载的是图片的渲染结果，TextureLayer承载的是纹理的渲染结果； 绘制流程大致流程 构建一个 Canvas，用于绘制；同时还需要创建一个绘制指令记录器，因为绘制指令最终是要传递给 Skia 的，而 Canvas 可能会连续发起多条绘制指令，指令记录器用于收集 Canvas 在一段时间内所有的绘制指令，因此Canvas 构造函数第一个参数必须传递一个 PictureRecorder 实例。 Canvas 绘制完成后，通过 PictureRecorder 获取绘制产物，然后将其保存在 Layer 中。 renderView.compositeFrame构建 Scene 对象，将 layer 的绘制产物和 Scene 关联起来。 上屏；调用window.render API 将Scene上的绘制产物发送给GPU。 精细流程第一次绘制时，从上到下递归绘制子节点，每当遇到一个边界节点，判断如果该节点的layer属性是否为空，是就创建一个新的OffsetLayer并赋值给它；不是则使用。然后将layer传递给子节点，接下来： 如果子节点是非边界节点，且需要绘制，则： 第一次绘制：创建一个Canvas对象和一个PictureLayer，然后将它们绑定，后续调用Canvas绘制都会落到和其绑定的PictureLayer上，接着这个PictureLayer会加入到边界节点的layer中； 不是第一次绘制：复用已有的边界节点和Canvas对象； 如果子节点是边界节点，则对子节点递归上述过程。当子树递归完成后，就要将子节点的layer添加到父级layer中。 RenderObject调用markNeedsRepaint来发起重绘： 从当前节点一直往父级查找，直到找到一个绘制边界点时终止查找，然后会将该绘制边界点添加到其PiplineOwner的_nodesNeedingPaint列表中。 在查找的过程中，会将自己到绘制边界点路径上所有节点的_needPaint属性设置为true，表示需要重绘。 请求新的frame，执行重绘流程。下一个frame就会走drawFrame流程，涉及到flushCompositingBits、flushPaint 和 compositeFrame 三个函数。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"InheritedWidget","date":"2022-04-27T06:32:44.685Z","path":"wiki/Flutter/源码分析/InheritedWidget/","text":"基本用法提供一种在widget树中从上到下共享数据的方式。 核心函数updateShouldNotify控制依赖于InheritedWidget的组件是否需要重建。如果为true，则当InheritedWidget发生变化时，依赖于它的组件会被rebuild，其Element的didChangeDependencies会被调用。 源码分析Element中，_inheritedWidgets保存了所有上级节点的InheritedElement。 1234567891011121314151617Map&lt;Type, InheritedElement&gt;? _inheritedWidgets;/// Element中void _updateInheritance() &#123; assert(_lifecycleState == _ElementLifecycle.active); _inheritedWidgets = _parent?._inheritedWidgets;&#125;/// InheritedElement中void _updateInheritance() &#123; assert(_lifecycleState == _ElementLifecycle.active); final Map&lt;Type, InheritedElement&gt;? incomingWidgets = _parent?._inheritedWidgets; if (incomingWidgets != null) _inheritedWidgets = HashMap&lt;Type, InheritedElement&gt;.of(incomingWidgets); else _inheritedWidgets = HashMap&lt;Type, InheritedElement&gt;(); _inheritedWidgets![widget.runtimeType] = this;&#125; 获取InheritedWidget的方式 12345678910111213141516T? dependOnInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;(&#123;Object? aspect&#125;) &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T]; if (ancestor != null) &#123; return dependOnInheritedElement(ancestor, aspect: aspect) as T; &#125; _hadUnsatisfiedDependencies = true; return null;&#125;InheritedElement? getElementForInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;() &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T]; return ancestor;&#125; 从根节点到子节点，以runtimeType作为key，保存最新的Element对象。getElementForInheritedWidgetOfExactType方法可以通过类型查找离自己最近的类型的对象。dependOnInheritedWidgetOfExactType方法会注册依赖，当InheritedWidget发生变化时就会更新依赖它的子组件。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"Context","date":"2022-04-27T06:31:03.354Z","path":"wiki/Flutter/源码分析/Context/","text":"BuildContextBuildContext就是Widget对应的Element。 WidgetsFlutterBinding，其在创建的时候绑定了 如果Widget有更新，需要重新布局，Framework会将需要布局的RenderObject加入PipelineOwner的_nodesNeedingLayout中，然后当下一个VSync信号来临时，Framework会遍历_nodesNeedingLayout，对其中的每一个RenderObject重新进行布局，遍历_nodesNeedingLayout的函数。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"ParentData","date":"2022-04-27T03:43:02.214Z","path":"wiki/Flutter/源码分析/ParentData/","text":"概念RenderObject有一个parentData插槽（slot）用于存储父节点的一些信息，这个插槽，就是预留一个接口或位置，由其他对象来接入或占据。 BoxParentData12345678/// Parent data used by [RenderBox] and its subclasses.class BoxParentData extends ParentData &#123; /// The offset at which to paint the child in the parent&#x27;s coordinate system. Offset offset = Offset.zero; @override String toString() =&gt; &#x27;offset=$offset&#x27;;&#125; BoxParentData用于RenderBox，对应普通视图场景。offset属性用于描述子节点在父节点中的坐标偏移，主要用于子节点的布局。 BoxParentData关键流程通过了解RenderObject，我们知道它的作用是布局、绘制、点击测试。BoxParentData的offset，在子RenderObject节点的setupParentData进行初始化，在performLayout中对offset进行赋值，在paint函数中使用offset确认子节点的绘制位置，在hitTestChildren中使用offset辅助判断是否在点击区域内。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"RenderObject","date":"2022-04-27T03:12:18.155Z","path":"wiki/Flutter/源码分析/RenderObject/","text":"概念RenderObject表示渲染树的一个对象，负责真正的渲染工作，比如基本布局和绘制。但并没有定义子节点模型，也没有定义坐标系统和布局协议，这些功能由其子类RenderBox实现。 作用： 布局，从RenderBox开始，对RenderObject Tree从上至下进行布局。 绘制，通过Canvas对象，RenderObject可以绘制自身以及其在RenderObject Tree中的子节点。 点击测试，RenderObject从上至下传递点击事件，并通过其位置和behavior来控制是否响应点击事件。 插槽（slot）：所谓插槽，就是预留一个接口或位置，由其他对象来接入或占据。 RenderObject拥有一个parent和parentData插槽（slot）： parentData：负责存储父节点所需要的子节点的布局信息。该成员只能通过setupParentData方法赋值，RenderObject的子类通过重写该方法将ParentData的子类赋值给parentData，已扩展ParentData功能。 layout()：布局阶段，父节点会调用子节点的该方法。 markNeedsLayout()：标记下一个frame重新layout。 paint()：绘制 layer： isRepaintBoundary：绘制边界点，单独的一层渲染，提升性能 needsCompositing： Dirty RenderObjectsRender Object 有4种Dirty State需要PipelineOwner维护： Needing Layout：Render Object需要重新layout Needing Compositing Bits Update：Render Object合成标志位有变化 Needing Paint：Render Object需要重新绘制 Needing Semantice：Render Object辅助信息有变化 核心函数比较 作用 Flutter RenderObject Android View 绘制 paint() draw()&#x2F;onDraw() 布局 performLayout()&#x2F;layout() measure()&#x2F;onMeasure(), layout()&#x2F;onLayout() 布局约束 Constraints MeasureSpec 布局协议1 performLayout() 的 Constraints 参数表示父节点对子节点的布局限制 measure() 的两个参数表示父节点对子节点的布局限制 布局协议2 performLayout() 应调用各子节点的 layout() onLayout() 应调用各子节点的 layout() 布局参数 parentData mLayoutParams 请求布局 markNeedsLayout() requestLayout() 请求绘制 markNeedsPaint() invalidate() 添加 child adoptChild() addView() 移除 child dropChild() removeView() 关联到窗口&#x2F;树 attach() onAttachedToWindow() 从窗口&#x2F;树取消关联 detach() onDetachedFromWindow() 获取 parent parent getParent() 触摸事件 hitTest() onTouch() 用户输入事件 handleEvent() onKey() 旋转事件 rotate() onConfigurationChanged() RenderObject子类： RenderBox：采用2D笛卡尔坐标系中的渲染对象。它实现了一个内在的尺寸调整协议，它允许您在没有完全铺设的情况下测量一个子级，以这样的方式，如果该子级改变了尺寸，父级将再次布置（考虑到子级的新尺寸）。若对坐标系统没有限制，可直接继承它来实现自定义RenderObject。size属性用来保存控件的高宽。其layout是通过在组件树中从上往下传递BoxConstraints对象实现的。 performResize()：测量 performLayout()：布局 RenderView：渲染对象的根。它有单独的子级，它必须是一个RenderBox。因此，如果你想在渲染树中有一个自定义的RenderObject子类，你有两种选择：你可能需要替换RenderView本身，或者你需要一个RenderBox作为它的子类。 RenderAbstractViewport：内部较大的渲染对象的界面。其渲染对象（如RenderViewport）显示其内容的一部分，可以通过ViewportOffset进行控制。 RenderSliver：在视图中实现滚动效果的渲染对象的基类。RenderViewport有一组子Sliver，每个Sliver依次排列，覆盖过程中的视图。而RenderSliver则控制着Sliver的绘制渲染。 RenderObjectWithChildMixin为只有一个child的RenderObject提供child管理模型，ContainerRenderObjectMixin用于为多个child的RenderObject提供child管理模型。 布局布局过程 父节点向子节点传递约束（constraints）信息，限制子节点的最大和最小宽高。 子节点根据约束信息确定自己的大小。 父节点根据特定布局规则确定每一个子节点在父节点布局控件中的位置，用偏移offset表示。 递归整个过程，确定出每一个节点的大小和位置。 layout流程 确定当前组件的布局边界。 判断是否需要重新布局，如果没必要会直接返回，反之才需要重新布局。不需要布局要同时满足以下三个条件： 当前组件没有被标记为需要重新布局。 父组件传递的约束没有发生变化。 当前组件的布局边界没有发生变化。 调用performLayout进行布局，其内部会调用子组件的layout方法。 请求绘制。 performLayout流程 如果有子组件，则对子组件进行递归布局。 确定当前组件的大小，通常会依赖子组件的大小。 确定子组件在当前组件中的起始偏移。 123456789101112131415161718192021222324252627282930313233 void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123; RenderObject? relayoutBoundary; // 先确定当前组件的布局边界 if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123; relayoutBoundary = this; &#125; else &#123; relayoutBoundary = (parent! as RenderObject)._relayoutBoundary; &#125; // _needsLayout 表示当前组件是否被标记为需要布局 // _constraints 是上次布局时父组件传递给当前组件的约束 // _relayoutBoundary 为上次布局时当前组件的布局边界 // 所以，当当前组件没有被标记为需要重新布局，且父组件传递的约束没有发生变化， // 且布局边界也没有发生变化时则不需要重新布局，直接返回即可。 if (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123; return; &#125; // 如果需要布局，缓存约束和布局边界 _constraints = constraints; _relayoutBoundary = relayoutBoundary; // sizedByParent表示当前的Widget虽然不是isTight，但是通过其他约束属性，也可以明确的知道size，比如Expanded，并不一定需要明确的size if (sizedByParent) &#123; performResize(); &#125; // 执行布局 performLayout(); // 布局结束后将 _needsLayout 置为 false _needsLayout = false; // 将当前组件标记为需要重绘（因为布局发生变化后，需要重新绘制） markNeedsPaint();&#125; 绘制大致流程： 第一次绘制时，从上到下递归绘制子节点，每当遇到一个边界节点，判断如果该节点的layer属性是否为空，是就创建一个新的OffsetLayer并赋值给它；不是则使用。然后将layer传递给子节点，接下来： 如果子节点是非边界节点，且需要绘制，则： 第一次绘制：创建一个Canvas对象和一个PictureLayer，然后将它们绑定，后续调用Canvas绘制都会落到和其绑定的PictureLayer上，接着这个PictureLayer会加入到边界节点的layer中； 不是第一次绘制：复用已有的边界节点和Canvas对象； 如果子节点是边界节点，则对子节点递归上述过程。当子树递归完成后，就要将子节点的layer添加到父级layer中。 RenderObject调用markNeedsRepaint来发起重绘： 从当前节点一直往父级查找，直到找到一个绘制边界点时终止查找，然后会将该绘制边界点添加到其PiplineOwner的_nodesNeedingPaint列表中。 在查找的过程中，会将自己到绘制边界点路径上所有节点的_needPaint属性设置为true，表示需要重绘。 请求新的frame，执行重绘流程。下一个frame就会走drawFrame流程，涉及到flushCompositingBits、flushPaint 和 compositeFrame 三个函数。 123456789101112131415161718void markNeedsPaint() &#123; if (_needsPaint) return; _needsPaint = true; if (isRepaintBoundary) &#123; // 如果是当前节点是边界节点 owner!._nodesNeedingPaint.add(this); //将当前节点添加到需要重新绘制的列表中。 owner!.requestVisualUpdate(); // 请求新的frame，该方法最终会调用scheduleFrame() &#125; else if (parent is RenderObject) &#123; // 若不是边界节点且存在父节点 final RenderObject parent = this.parent! as RenderObject; parent.markNeedsPaint(); // 递归调用父节点的markNeedsPaint &#125; else &#123; // 如果是根节点，直接请求新的 frame 即可 if (owner != null) owner!.requestVisualUpdate(); &#125;&#125; 命中测试命中测试用来判断某个组件是否需要响应一个点击事件，其入口是RenderObject Tree的根节点RenderView的hitTest函数 123456bool hitTest(HitTestResult result, &#123; Offset position &#125;) &#123; if (child != null) child.hitTest(BoxHitTestResult.wrap(result), position: position);//child为RenderView result.add(HitTestEntry(this)); return true;&#125; 查看RenderView源码 123456789bool hitTest(BoxHitTestResult result, &#123; @required Offset position &#125;) &#123; if (_size.contains(position)) &#123; if (hitTestChildren(result, position: position) || hitTestSelf(position)) &#123; result.add(BoxHitTestEntry(this, position)); return true; &#125; &#125; return false;&#125; 如果点击事件位置处于RenderObject之内，如果在其内，并且hitTestSelf或者hitTestChildren返回true，则表示RenderObject通过了命中测试，需要响应事件，此时需要将被点击的RenderObject加入BoxHitTestResult列表，同时点击事件不再向下传递。否则认为没有通过命中测试，事件继续向下传递。其中，hitTestSelf函数表示节点是否通过命中测试，hitTestChildren表示子节点是否通过命中测试。 参考 深入浅出 Flutter Framework 之 RenderObject Flutter实战-RenderObject（布局、绘制、点击测试）","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"RepaintBoundary","date":"2022-04-25T12:37:37.448Z","path":"wiki/Flutter/源码分析/RepaintBoundary/","text":"如果使用恰当，RepaintBoundary能有效提升性能。 RenderObject有一个isRepaintBoundary属性，该属性决定这个RenderObject重绘时是否独立于其父元素，如果该属性为true，则独立绘制。 如何独立绘制呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/// PainterContextvoid paintChild(RenderObject child, Offset offset) &#123; assert(() &#123; debugOnProfilePaint?.call(child); return true; &#125;()); if (child.isRepaintBoundary) &#123; stopRecordingIfNeeded(); _compositeChild(child, offset); &#125; else &#123; child._paintWithContext(this, offset); &#125;&#125; void _compositeChild(RenderObject child, Offset offset) &#123; assert(!_isRecording); assert(child.isRepaintBoundary); assert(_canvas == null || _canvas!.getSaveCount() == 1); // Create a layer for our child, and paint the child into it. // 给子节点创建一个layer，然后在上面绘制 if (child._needsPaint) &#123; repaintCompositedChild(child, debugAlsoPaintedParent: true); &#125; else &#123; assert(() &#123; // register the call for RepaintBoundary metrics child.debugRegisterRepaintBoundaryPaint(); child._layerHandle.layer!.debugCreator = child.debugCreator ?? child; return true; &#125;()); &#125; assert(child._layerHandle.layer is OffsetLayer); final OffsetLayer childOffsetLayer = child._layerHandle.layer! as OffsetLayer; childOffsetLayer.offset = offset; appendLayer(childOffsetLayer); &#125; void markNeedsPaint() &#123; assert(!_debugDisposed); assert(owner == null || !owner!.debugDoingPaint); if (_needsPaint) return; _needsPaint = true; //如果RenderObject.isRepaintBoundary 为true,则该RenderObject拥有layer，直接绘制 if (isRepaintBoundary) &#123; assert(() &#123; if (debugPrintMarkNeedsPaintStacks) debugPrintStack(label: &#x27;markNeedsPaint() called for $this&#x27;); return true; &#125;()); // If we always have our own layer, then we can just repaint // ourselves without involving any other nodes. assert(_layerHandle.layer is OffsetLayer); if (owner != null) &#123; //找到最近的layer，绘制 owner!._nodesNeedingPaint.add(this); owner!.requestVisualUpdate(); &#125; &#125; else if (parent is RenderObject) &#123;// 没有自己的layer, 会和一个祖先节点共用一个layer final RenderObject parent = this.parent! as RenderObject; parent.markNeedsPaint(); assert(parent == this.parent); &#125; else &#123; assert(() &#123; if (debugPrintMarkNeedsPaintStacks) debugPrintStack(label: &#x27;markNeedsPaint() called for $this (root of render tree)&#x27;); return true; &#125;()); // If we&#x27;re the root of the render tree (probably a RenderView), // then we have to paint ourselves, since nobody else can paint // us. We don&#x27;t add ourselves to _nodesNeedingPaint in this // case, because the root is always told to paint regardless. if (owner != null) // 如果直到根节点也没找到一个Layer，那么便需要绘制自身，因为没有其它节点可以绘制根节点。 owner!.requestVisualUpdate(); &#125; &#125; 而RepaintBoundary就是一个isRepaintBoundary为true的类。 使用场景 自定义paint的组件 会唤起输入框的界面 参考 Flutter - Using RepaintBoundary Examples","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"启动流程分析","date":"2022-04-25T07:36:59.770Z","path":"wiki/Flutter/源码分析/启动流程分析/","text":"需要的前置知识： Mixin用法 核心类和函数PlatformDispatcher平台事件转发器，单例对象。比如每一帧的渲染回调、系统语言切换等。 123456789101112131415161718192021222324252627282930313233343536/// 单例对象static PlatformDispatcher get instance =&gt; _instance;static final PlatformDispatcher _instance = PlatformDispatcher._();/// 配置信息（是否使用24小时制、文本缩放大小、语言、主题等） 发生变化时回调onPlatformConfigurationChangedPlatformConfiguration get configuration =&gt; _configuration;PlatformConfiguration _configuration = const PlatformConfiguration();/// 当前视图列表，当它们发生变化时，回调onMetricsChanged/// FlutterView对UI进行了封装Iterable&lt;FlutterView&gt; get views =&gt; _views.values;Map&lt;Object, FlutterView&gt; _views = &lt;Object, FlutterView&gt;&#123;&#125;;/// 新的一帧开启时回调FrameCallback? get onBeginFrame =&gt; _onBeginFrame;FrameCallback? _onBeginFrame;/// onBeginFrame完成后执行该回调VoidCallback? get onDrawFrame =&gt; _onDrawFrame;VoidCallback? _onDrawFrame;/// 手势交互回调，GestureBinding处理PointerDataPacketCallback? get onPointerDataPacket =&gt; _onPointerDataPacket;PointerDataPacketCallback? _onPointerDataPacket;/// 平台消息回调PlatformMessageCallback? get onPlatformMessage =&gt; _onPlatformMessage;PlatformMessageCallback? _onPlatformMessage;/// 执行后，onBeginFrame、onDrawFrame会执行，参考SchedulerBindingvoid scheduleFrame() native &#x27;PlatformConfiguration_scheduleFrame&#x27;;/// 语言切换回调VoidCallback? get onLocaleChanged =&gt; _onLocaleChanged;VoidCallback? _onLocaleChanged; FlutterViewFlutterView对象window是对PlatformDispatcher的封装，是与平台层的交互入口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/// 要被绘制的UI对象abstract class FlutterView &#123; /// 持有平台消息分发器 PlatformDispatcher get platformDispatcher; /// 被系统挡住的屏幕物理像素，比如软键盘弹起，则EdgeInsets的bottom会大于0 WindowPadding get viewInsets =&gt; viewConfiguration.viewInsets; /// 被系统UI挡住的屏幕物理像素，比如系统通知栏，iphone的底部功能键 WindowPadding get viewPadding =&gt; viewConfiguration.viewPadding; /// max(0.0, FlutterView.viewPadding - FlutterView.viewInsets) WindowPadding get padding =&gt; viewConfiguration.padding; /// 屏幕像素密度，物理像素和虚拟像素的比值 double get devicePixelRatio =&gt; viewConfiguration.devicePixelRatio; /// 通知底层进行渲染 void render(Scene scene) =&gt; _render(scene, this); void _render(Scene scene, FlutterView view) native &#x27;PlatformConfiguration_render&#x27;;&#125;class FlutterWindow extends FlutterView &#123;&#125;class SingletonFlutterWindow extends FlutterWindow &#123; /// 对platformDispatcher中的回调方法进行了一层封装 VoidCallback? get onMetricsChanged =&gt; platformDispatcher.onMetricsChanged; set onMetricsChanged(VoidCallback? callback) &#123; platformDispatcher.onMetricsChanged = callback; &#125; VoidCallback? get onLocaleChanged =&gt; platformDispatcher.onLocaleChanged; set onLocaleChanged(VoidCallback? callback) &#123; platformDispatcher.onLocaleChanged = callback; &#125; VoidCallback? get onLocaleChanged =&gt; platformDispatcher.onLocaleChanged; set onLocaleChanged(VoidCallback? callback) &#123; platformDispatcher.onLocaleChanged = callback; &#125; VoidCallback? get onLocaleChanged =&gt; platformDispatcher.onLocaleChanged; set onLocaleChanged(VoidCallback? callback) &#123; platformDispatcher.onLocaleChanged = callback; &#125; VoidCallback? get onLocaleChanged =&gt; platformDispatcher.onLocaleChanged; set onLocaleChanged(VoidCallback? callback) &#123; platformDispatcher.onLocaleChanged = callback; &#125; VoidCallback? get onLocaleChanged =&gt; platformDispatcher.onLocaleChanged; set onLocaleChanged(VoidCallback? callback) &#123; platformDispatcher.onLocaleChanged = callback; &#125; VoidCallback? get onLocaleChanged =&gt; platformDispatcher.onLocaleChanged; set onLocaleChanged(VoidCallback? callback) &#123; platformDispatcher.onLocaleChanged = callback; &#125; VoidCallback? get onLocaleChanged =&gt; platformDispatcher.onLocaleChanged; set onLocaleChanged(VoidCallback? callback) &#123; platformDispatcher.onLocaleChanged = callback; &#125;&#125; 入口函数及相关类main入口调用runApp函数： 12345678910111213void runApp(Widget app) &#123; WidgetsFlutterBinding.ensureInitialized()//初始化操作 ..scheduleAttachRootWidget(app)//将传入的Widget包装进RenderObjectToWidgetAdapter ..scheduleWarmUpFrame();//SchedulerBinding进行绘制&#125;class WidgetsFlutterBinding extends BindingBase with GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding &#123; static WidgetsBinding ensureInitialized() &#123; if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance!; &#125;&#125; BindingBase：绑定的基类 WidgetsBinding：绑定组件树，提供onLocalChanged、onBuildScheduled等回调 RendererBinding：绑定渲染树，提供window.onMetricsChanged、window.onTextScaleDactorChanged等回调 SemanticsBinding（绑定语义树） PaintingBinding（图片缓存操作） ServicesBinding：绑定平台服务消息，注册Dart层和C++层的消息传输服务，提供window.onPlatformMessage回调 SchedulerBinding：绑定帧绘制回调函数，以及widget生命周期相关事件，提供window.onBeginFrame和window.onDrawFrame回调 GestureBinding：绑定手势事件，用于检测应用的各种手势相关操作，提供window.onPointerDataPacket回调 BindingBase12345678910111213141516171819abstract class BindingBase &#123; /// 绑定的主视图 ui.SingletonFlutterWindow get window =&gt; ui.window; /// 持有平台事件分发器 ui.PlatformDispatcher get platformDispatcher =&gt; ui.PlatformDispatcher.instance; /// 混入的方式初始化不同的Binding对象 void initInstances() &#123; assert(!_debugInitialized); assert(() &#123; _debugInitialized = true; return true; &#125;()); &#125;&#125; RenderBinding123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123; @override void initInstances() &#123; super.initInstances(); _instance = this; // 管理RenderObject对象 _pipelineOwner = PipelineOwner( onNeedVisualUpdate: ensureVisualUpdate, onSemanticsOwnerCreated: _handleSemanticsOwnerCreated, onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed, ); // 监听平台事件的回调 window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; // 生成RenderView作为根节点，RenderView继承自RenderObject initRenderView(); _handleSemanticsEnabledChanged(); assert(renderView != null); // 监听帧刷新回调，Flutter侧进行布局、绘制 addPersistentFrameCallback(_handlePersistentFrameCallback); // 手势处理 initMouseTracker(); if (kIsWeb) &#123; addPostFrameCallback(_handleWebFirstFrame); &#125; &#125; void drawFrame() &#123; assert(renderView != null); pipelineOwner.flushLayout();//布局 pipelineOwner.flushCompositingBits();// pipelineOwner.flushPaint();//绘制 if (sendFramesToEngine) &#123; renderView.compositeFrame(); // this sends the bits to the GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS. _firstFrameSent = true; &#125; &#125; /// 事件传递 @override // from GestureBinding void dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) &#123; _mouseTracker!.updateWithEvent( event, // Enter and exit events should be triggered with or without buttons // pressed. When the button is pressed, normal hit test uses a cached // result, but MouseTracker requires that the hit test is re-executed to // update the hovering events. () =&gt; (hitTestResult == null || event is PointerMoveEvent) ? renderView.hitTestMouseTrackers(event.position) : hitTestResult, ); super.dispatchEvent(event, hitTestResult); &#125;&#125; PaintingBinding1234567891011121314151617181920mixin PaintingBinding on BindingBase, ServicesBinding &#123; @override void initInstances() &#123; super.initInstances(); _instance = this; _imageCache = createImageCache();//图片缓存，1000张图片，最大内存100MiB shaderWarmUp?.execute();//异步方法，初始化了一个默认的着色器，避免需要着色器的时候再初始化出现掉帧现象。 &#125; /// 内存警告回调，清理图片缓存 @override void handleMemoryPressure() &#123; super.handleMemoryPressure(); imageCache?.clear(); &#125;&#125; ServiceBinding主要用来接收MethodChannel和SystemChannels传递过来的消息 123456789101112131415161718192021222324252627282930mixin ServicesBinding on BindingBase, SchedulerBinding &#123; /// 跟平台通信的消息管理器 BinaryMessenger get defaultBinaryMessenger =&gt; _defaultBinaryMessenger; late final BinaryMessenger _defaultBinaryMessenger; @override void initInstances() &#123; super.initInstances(); _instance = this; // 创建MethodChannel _defaultBinaryMessenger = createBinaryMessenger(); // RestorationManager用于恢复界面数据的功能 _restorationManager = createRestorationManager(); // 初始化键盘 _initKeyboard(); initLicenses(); //系统消息回调监听 SystemChannels.system.setMessageHandler((dynamic message) =&gt; handleSystemMessage(message as Object)); SystemChannels.lifecycle.setMessageHandler(_handleLifecycleMessage); SystemChannels.platform.setMethodCallHandler(_handlePlatformMessage); // 读取当前的生命周期状态，处理则是在SchedulerBinding这个mixin中。 readInitialLifecycleStateFromNativeWindow(); &#125;&#125; SchedulerBinding123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/// 调度阶段 绘制调度、task调度enum SchedulerPhase &#123; idle,// 处理task、microtask、timer回调，用户输入和手势等 transientCallbacks,//处理动画状态的计算和更新 midFrameMicrotasks,//处理transientCallbacks阶段触发的microtasks persistentCallbacks,//处理build、layout、paint postFrameCallbacks,//当前阶段结束时的清理工作&#125;/// mixin SchedulerBinding on BindingBase &#123; /// 永久callback，一经添加无法移除，由WidgetsBinding.instance.addPersitentFrameCallback()注册，这个回调处理了布局与绘制工作。 final List&lt;FrameCallback&gt; _persistentCallbacks = &lt;FrameCallback&gt;[]; /// 只会调用一次，调用后会被系统移除，可由WidgetsBinding.instance.addPostFrameCallback()注册，该回调一般用于State的更新。 final List&lt;FrameCallback&gt; _postFrameCallbacks = &lt;FrameCallback&gt;[]; /// 通过Ticker的scheduleTick添加回调，一般用于动画的回调 Map&lt;int, _FrameCallbackEntry&gt; _transientCallbacks = &lt;int, _FrameCallbackEntry&gt;&#123;&#125;; /// 应用生命周期发生变化时回调 /// 可以使用WidgetsBindingObserver.didChangeAppLifecycleState监听来实现自己的业务逻辑 void handleAppLifecycleStateChanged(AppLifecycleState state) &#123; assert(state != null); _lifecycleState = state; switch (state) &#123; case AppLifecycleState.resumed: case AppLifecycleState.inactive: _setFramesEnabledState(true); break; case AppLifecycleState.paused: case AppLifecycleState.detached: _setFramesEnabledState(false);//停止刷新界面 break; &#125; &#125; bool _framesEnabled = true; void _setFramesEnabledState(bool enabled) &#123; if (_framesEnabled == enabled) return; _framesEnabled = enabled; if (enabled) scheduleFrame(); &#125; void scheduleFrame() &#123; if (_hasScheduledFrame || !framesEnabled) return; assert(() &#123; if (debugPrintScheduleFrameStacks) debugPrintStack(label: &#x27;scheduleFrame() called. Current phase is $schedulerPhase.&#x27;); return true; &#125;()); //确保向window注册了onBeginFrame和onDrawFrame ensureFrameCallbacksRegistered(); // 向平台层发送刷新请求，进行下一轮帧刷新 window.scheduleFrame(); _hasScheduledFrame = true; &#125; @protected void ensureFrameCallbacksRegistered() &#123; window.onBeginFrame ??= _handleBeginFrame; window.onDrawFrame ??= _handleDrawFrame; &#125; void handleBeginFrame(Duration? rawTimeStamp) &#123; _frameTimelineTask?.start(&#x27;Frame&#x27;, arguments: timelineArgumentsIndicatingLandmarkEvent); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) _lastRawTimeStamp = rawTimeStamp; assert(schedulerPhase == SchedulerPhase.idle); _hasScheduledFrame = false; try &#123; // TRANSIENT FRAME CALLBACKS _frameTimelineTask?.start(&#x27;Animate&#x27;, arguments: timelineArgumentsIndicatingLandmarkEvent); _schedulerPhase = SchedulerPhase.transientCallbacks; final Map&lt;int, _FrameCallbackEntry&gt; callbacks = _transientCallbacks; _transientCallbacks = &lt;int, _FrameCallbackEntry&gt;&#123;&#125;; callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) &#123; if (!_removedIds.contains(id)) _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp!, callbackEntry.debugStack); &#125;); _removedIds.clear(); &#125; finally &#123; _schedulerPhase = SchedulerPhase.midFrameMicrotasks; &#125; &#125; void handleDrawFrame() &#123; assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks); _frameTimelineTask?.finish(); // end the &quot;Animate&quot; phase try &#123; // PERSISTENT FRAME CALLBACKS _schedulerPhase = SchedulerPhase.persistentCallbacks; for (final FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp!); // POST-FRAME CALLBACKS _schedulerPhase = SchedulerPhase.postFrameCallbacks; final List&lt;FrameCallback&gt; localPostFrameCallbacks = List&lt;FrameCallback&gt;.of(_postFrameCallbacks); _postFrameCallbacks.clear(); for (final FrameCallback callback in localPostFrameCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp!); &#125; finally &#123; _schedulerPhase = SchedulerPhase.idle; _frameTimelineTask?.finish(); // end the Frame assert(() &#123; if (debugPrintEndFrameBanner) debugPrint(&#x27;▀&#x27; * _debugBanner!.length); _debugBanner = null; return true; &#125;()); _currentFrameTimeStamp = null; &#125; &#125; /// Frame即每一帧的绘制过程，engine通过VSync信号不断地触发Frame的绘制，实际上就是调用SchedulerBinding类中的_handleBeginFrame()和_handleDrawFrame()这两个方法，这个过程中会完成动画、布局、绘制等工作。 void scheduleWarmUpFrame() &#123; if (_warmUpFrame || schedulerPhase != SchedulerPhase.idle) return; _warmUpFrame = true; final TimelineTask timelineTask = TimelineTask()..start(&#x27;Warm-up frame&#x27;); final bool hadScheduledFrame = _hasScheduledFrame; // We use timers here to ensure that microtasks flush in between. Timer.run(() &#123; assert(_warmUpFrame); handleBeginFrame(null); &#125;); Timer.run(() &#123; assert(_warmUpFrame); handleDrawFrame(); resetEpoch(); _warmUpFrame = false; if (hadScheduledFrame) scheduleFrame(); &#125;); lockEvents(() async &#123; await endOfFrame; timelineTask.finish(); &#125;); &#125;&#125; GestureBinding处理用户的交互 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111mixin GestureBinding on BindingBase implements HitTestable, HitTestDispatcher, HitTestTarget &#123; @override void initInstances() &#123; super.initInstances(); _instance = this; window.onPointerDataPacket = _handlePointerDataPacket; &#125; void _handlePointerDataPacket(ui.PointerDataPacket packet) &#123; // We convert pointer data to logical pixels so that e.g. the touch slop can be // defined in a device-independent manner. _pendingPointerEvents.addAll(PointerEventConverter.expand(packet.data, window.devicePixelRatio)); if (!locked) _flushPointerEventQueue(); &#125; void _flushPointerEventQueue() &#123; assert(!locked); while (_pendingPointerEvents.isNotEmpty) handlePointerEvent(_pendingPointerEvents.removeFirst()); &#125; void handlePointerEvent(PointerEvent event) &#123; assert(!locked); if (resamplingEnabled) &#123; _resampler.addOrDispatch(event); _resampler.sample(samplingOffset, _samplingClock); return; &#125; // Stop resampler if resampling is not enabled. This is a no-op if // resampling was never enabled. _resampler.stop(); _handlePointerEventImmediately(event); &#125; void _handlePointerEventImmediately(PointerEvent event) &#123; HitTestResult? hitTestResult; if (event is PointerDownEvent || event is PointerSignalEvent || event is PointerHoverEvent) &#123; assert(!_hitTests.containsKey(event.pointer)); hitTestResult = HitTestResult();//记录事件传递所经过的节点 hitTest(hitTestResult, event.position); if (event is PointerDownEvent) &#123; _hitTests[event.pointer] = hitTestResult; &#125; assert(() &#123; if (debugPrintHitTestResults) debugPrint(&#x27;$event: $hitTestResult&#x27;); return true; &#125;()); &#125; else if (event is PointerUpEvent || event is PointerCancelEvent) &#123; hitTestResult = _hitTests.remove(event.pointer); &#125; else if (event.down) &#123; hitTestResult = _hitTests[event.pointer]; &#125; assert(() &#123; if (debugPrintMouseHoverEvents &amp;&amp; event is PointerHoverEvent) debugPrint(&#x27;$event&#x27;); return true; &#125;()); if (hitTestResult != null || event is PointerAddedEvent || event is PointerRemovedEvent) &#123; assert(event.position != null); dispatchEvent(event, hitTestResult); &#125; &#125; @override // from HitTestable void hitTest(HitTestResult result, Offset position) &#123; result.add(HitTestEntry(this)); &#125; /// 事件分发流程 /// 先调用RenderBinding中的dispatchEvent，遍历renderView的所有widget，将hitTestResult返回 void dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) &#123; assert(!locked); if (hitTestResult == null) &#123; assert(event is PointerAddedEvent || event is PointerRemovedEvent); try &#123; pointerRouter.route(event); &#125; catch (exception, stack) &#123; &#125; return; &#125; for (final HitTestEntry entry in hitTestResult.path) &#123; try &#123; entry.target.handleEvent(event.transformed(entry.transform), entry); &#125; catch (exception, stack) &#123; &#125; &#125; &#125; /// 手势竞技场进行处理 @override // from HitTestTarget void handleEvent(PointerEvent event, HitTestEntry entry) &#123; pointerRouter.route(event); if (event is PointerDownEvent) &#123; gestureArena.close(event.pointer); &#125; else if (event is PointerUpEvent) &#123; gestureArena.sweep(event.pointer); &#125; else if (event is PointerSignalEvent) &#123; pointerSignalResolver.resolve(event); &#125; &#125;&#125; WidgetsBinding处理widget树的逻辑 12345678910111213141516171819202122232425262728293031323334mixin WidgetsBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123; /// 光标管理器 FocusManager get focusManager =&gt; _buildOwner!.focusManager; /// 应用生命周期回调，回到App、回到桌面、内存不足、语言切换、主题切换、文字大小切换等 final List&lt;WidgetsBindingObserver&gt; _observers = &lt;WidgetsBindingObserver&gt;[]; @override void initInstances() &#123; super.initInstances(); _instance = this; assert(() &#123; _debugAddStackFilters(); return true; &#125;()); // Initialization of [_buildOwner] has to be done after // [super.initInstances] is called, as it requires [ServicesBinding] to // properly setup the [defaultBinaryMessenger] instance. // 初始化BuildOwner，用来执行widget树的build任务 _buildOwner = BuildOwner(); buildOwner!.onBuildScheduled = _handleBuildScheduled; //语言切换回调 window.onLocaleChanged = handleLocaleChanged; window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged; SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);//系统路由监听？ &#125;&#125; scheduleAttachRootWidget123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186 void scheduleAttachRootWidget(Widget rootWidget) &#123; Timer.run(() &#123; attachRootWidget(rootWidget); &#125;); &#125; void attachRootWidget(Widget rootWidget) &#123; final bool isBootstrapFrame = renderViewElement == null; _readyToProduceFrames = true; _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;( container: renderView,//RenderBinding构建的根节点 debugShortDescription: &#x27;[root]&#x27;, child: rootWidget,//rootWidget是我们自己的AppWidget ).attachToRenderTree(buildOwner!, renderViewElement as RenderObjectToWidgetElement&lt;RenderBox&gt;?); if (isBootstrapFrame) &#123; SchedulerBinding.instance!.ensureVisualUpdate(); &#125; &#125;class RenderObjectToWidgetAdapter&lt;T extends RenderObject&gt; extends RenderObjectWidget &#123; RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt;? element ]) &#123; if (element == null) &#123; owner.lockState(() &#123; element = createElement();//创建RenderObjectElement的子类RenderObjectToWidgetElement assert(element != null); element!.assignOwner(owner); &#125;); //BuildOwner owner.buildScope(element!, () &#123; element!.mount(null, null); &#125;); &#125; else &#123; element._newWidget = this; element.markNeedsBuild(); &#125; return element!; &#125;&#125;class RenderObjectToWidgetElement&lt;T extends RenderObject&gt; extends RootRenderObjectElement &#123; void mount(Element? parent, Object? newSlot) &#123; assert(parent == null); super.mount(parent, newSlot); _rebuild(); assert(_child != null); &#125; void _rebuild() &#123; try &#123; _child = updateChild(_child, widget.child, _rootChildSlot); &#125; catch (exception, stack) &#123; final FlutterErrorDetails details = FlutterErrorDetails( exception: exception, stack: stack, library: &#x27;widgets library&#x27;, context: ErrorDescription(&#x27;attaching to the render tree&#x27;), ); FlutterError.reportError(details); final Widget error = ErrorWidget.builder(details); _child = updateChild(null, error, _rootChildSlot); &#125; &#125; Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) &#123; if (newWidget == null) &#123; if (child != null) deactivateChild(child);//新widget为空，旧的存在，则需要销毁 return null; &#125; final Element newChild; if (child != null) &#123; bool hasSameSuperclass = true; if (hasSameSuperclass &amp;&amp; child.widget == newWidget) &#123; if (child.slot != newSlot) updateSlotForChild(child, newSlot); newChild = child; &#125; else if (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) &#123; if (child.slot != newSlot) updateSlotForChild(child, newSlot); if (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled) &#123; Map&lt;String, String&gt; debugTimelineArguments = timelineArgumentsIndicatingLandmarkEvent; Timeline.startSync( &#x27;$&#123;newWidget.runtimeType&#125;&#x27;, arguments: debugTimelineArguments, ); &#125; child.update(newWidget); if (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled) Timeline.finishSync(); newChild = child; &#125; else &#123; deactivateChild(child); assert(child._parent == null); if (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled) &#123; Map&lt;String, String&gt; debugTimelineArguments = timelineArgumentsIndicatingLandmarkEvent; Timeline.startSync( &#x27;$&#123;newWidget.runtimeType&#125;&#x27;, arguments: debugTimelineArguments, ); &#125; newChild = inflateWidget(newWidget, newSlot); if (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled) Timeline.finishSync(); &#125; &#125; else &#123; if (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled) &#123; Map&lt;String, String&gt; debugTimelineArguments = timelineArgumentsIndicatingLandmarkEvent; Timeline.startSync( &#x27;$&#123;newWidget.runtimeType&#125;&#x27;, arguments: debugTimelineArguments, ); &#125; newChild = inflateWidget(newWidget, newSlot);//child为null，则需要填充新视图 if (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled) Timeline.finishSync(); &#125; return newChild; &#125; Element inflateWidget(Widget newWidget, Object? newSlot) &#123; final Key? key = newWidget.key; if (key is GlobalKey) &#123; final Element? newChild = _retakeInactiveElement(key, newWidget); if (newChild != null) &#123; newChild._activateWithParent(this, newSlot); final Element? updatedChild = updateChild(newChild, newWidget, newSlot); assert(newChild == updatedChild); return updatedChild!; &#125; &#125; final Element newChild = newWidget.createElement();//创建新的Element newChild.mount(this, newSlot);//递归mount return newChild; &#125;&#125;abstract class RenderObjectElement extends Element &#123; @override void mount(Element? parent, Object? newSlot) &#123; super.mount(parent, newSlot); assert(() &#123; _debugDoingBuild = true; return true; &#125;()); _renderObject = widget.createRenderObject(this); attachRenderObject(newSlot);//挂载到RenderObject树 _dirty = false; &#125;&#125;abstract class Element extends DiagnosticableTree implements BuildContext &#123; void mount(Element? parent, Object? newSlot) &#123; assert(_lifecycleState == _ElementLifecycle.initial); assert(widget != null); assert(_parent == null); assert(parent == null || parent._lifecycleState == _ElementLifecycle.active); assert(slot == null); _parent = parent;//Element树当前节点的父节点 _slot = newSlot;//插槽 _lifecycleState = _ElementLifecycle.active; _depth = _parent != null ? _parent!.depth + 1 : 1;//节点深度 if (parent != null) &#123; // Only assign ownership if the parent is non-null. If parent is null // (the root node), the owner should have already been assigned. // See RootRenderObjectElement.assignOwner(). _owner = parent.owner; &#125; assert(owner != null); final Key? key = widget.key; if (key is GlobalKey) &#123; owner!._registerGlobalKey(key, this); &#125; _updateInheritance(); &#125;&#125; scheduleWarmUpFrameScheduleBinding中调用handleBeginFrame和handleDrawFrame绘制一帧并传递给GPU去渲染。 参考 深入理解Flutter引擎启动","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"生命周期","date":"2022-04-18T01:53:34.812Z","path":"wiki/Flutter/未分类/生命周期/","text":"setState调用setState()之后，它所有的子节点调用updateChild(Element child, Widget newWidget, dynamic newSlot)： 如果之前的位置child为null 如果newWidget为null的话，说明这个位置始终没有子节点，直接返回null即可。 如果newWidget不为null，说明这个位置新增加了子节点调用inflateWidget(newWidget, newSlot)生成一个新的Element返回 如果之前的child不为null 如果newWidget为null的话，说明这个位置需要移除以前的节点，调用deactivateChild(child)移除并且返回nullD、如果newWidget不为null的话，先调用Widget.canUpdate(child.widget, newWidget)对比是否能更新。这个方法会对比两个Widget的runtimeType和key， 如果一致则说明子Widget没有改变，只是需要根据newWidget(配置清单)更新下当前节点的数据child.update(newWidget)； 如果不一致说明这个位置发生变化，则deactivateChild(child)后返回inflateWidget(newWidget, newSlot); 参考 面试官问我State的生命周期，该怎么回答","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"RepaintBoundary","date":"2022-04-07T10:10:10.289Z","path":"wiki/Flutter/UI/标准库/widgets/RepaintBoundary/","text":"参考 说说Flutter中的RepaintBoundary","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"}]},{"title":"布局管理","date":"2022-03-09T05:53:25.126Z","path":"wiki/Flutter/未分类/布局管理/","text":"基本概念Widget的大小通过constraints来约束，它有minWidth、maxWidth、minHeight、maxHeight几个属性。 Tight constraints：紧约束，最大值和最小值相等的情况 Loose constraints：松约束，最大值和最小值不相等的情况 Unbounded constraints：maxWidth、maxHeight都设置为double.infinity Flutter 中的 widget 由在其底层的 RenderBox 对象渲染而成。渲染框由其父级 widget 给出约束，并根据这些约束调整自身尺寸大小。约束是由最小宽度、最大宽度、最小高度、最大高度四个方面构成；尺寸大小则由特定的宽度和高度两个方面构成。 一般来说，从如何处理约束的角度来看，有以下三种类型的渲染框： 尽可能大。比如 Center 和 ListView 的渲染框。 与子 widget 一样大，比如 Transform 和 Opacity 的渲染框。 特定大小，比如 Image 和 Text 的渲染框。 布局Flutter 中有两种布局模型： 基于 RenderBox 的盒模型布局。 基于 Sliver ( RenderSliver ) 按需加载列表布局。 两种布局方式在细节上略有差异，但大体流程相同，布局流程如下： 上层组件向下层组件传递约束（constraints）条件。 下层组件确定自己的大小，然后告诉上层组件。注意下层组件的大小必须符合父组件的约束。 上层组件确定下层组件相对于自身的偏移和确定自身的大小（大多数情况下会根据子组件的大小来确定自身的大小）。 首先，上层 widget 向下层 widget 传递约束条件；然后，下层 widget 向上层 widget 传递大小信息。最后，上层 widget 决定下层 widget 的位置。 Widget 会通过它的 父级 获得自身的约束。约束实际上就是 4 个浮点类型的集合：最大&#x2F;最小宽度，以及最大&#x2F;最小高度。然后，这个 widget 将会逐个遍历它的 children 列表。向子级传递 约束（子级之间的约束可能会有所不同），然后询问它的每一个子级需要用于布局的大小。然后，这个 widget 就会对它子级的 children 逐个进行布局。（水平方向是 x 轴，竖直是 y 轴）。最后，widget 将会把它的大小信息向上传递至父 widget（包括其原始约束条件）。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"《网络是如何连接的》读书笔记","date":"2022-03-08T02:25:29.755Z","path":"wiki/读书笔记/网络是如何连接的/","text":"","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《计算机是怎么跑起来的》读书笔记","date":"2022-03-08T02:25:29.755Z","path":"wiki/读书笔记/计算机是怎样跑起来的/","text":"计算机三个根本性基础： 计算机是执行输入、运算、输出的机器； 程序是指令和数据的集合； 计算机的处理方式有时与人们的思维习惯不同。 计算机的硬件由大量集成电路组成。每块集成电路上都带有许多引脚。这些引脚有些用于输入，有些用于输出。 时钟发生器 操作数：操作数笔试是已存储在CPU寄存器中的数字。操作码 机器语言是唯一一种cpu能直接理解的编程语言。 CPU内部存储数据的地方也具备对数据进行计算的能力。有些寄存器中存储着接下来要执行的指令的地址。程序就是依靠着不断变花的寄存器的值运行起来的。 cpu信息cpu的种类：不同的CPU对于二进制的理解是不一样的。时钟信号的频率：时钟发生器发送给cpu的电信号的频率。表示时钟信号频率的单位是MHz（兆赫兹&#x3D;100万回&#x2F;秒）。时钟信号是在0和1之间反复变换的电信号。通常把发出一次滴答的时间称作一个时钟周期。 内存信息地址空间每个地址中可以存储多少比特的信息 I&#x2F;O信息I&#x2F;O的种类地址空间连接着何种周边设备 最低限度所需的流程图符号 网卡地址前半部分表示生产商，后半部分表示编号。 子网掩码的作用是标识出在32比特的IP地址中，从哪一位到哪一位是网络地址，从哪一位到哪一位是主机地址。255.255.255.240用二进制表示：11111111.11111111.11111111.11110000值为1的那些位对应着IP地址中的网络地址，后面为0的那些则对应着主机地址。 DHCP：Dynamic Host Configuration Protocol 动态主机设置协议 tracert ARP：Address Resolution Protocol，地址解析协议，用于实现由IP地址到MAC地址的转换arp -a 查询apr缓存表 硬件商发送数据的是网卡，网卡之上是设备驱动程序，之上是实现了IP协议的程序，之上是实现了TCP协议的程序，再之上才是应用程序。TCP协议使用“TCP端口号”的数字识别上层的应用程序。TCP端口中有一些是预先定义好的，比如Web使用80端口，电子邮件使用25端口（用于发送）","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《大明王朝1566》经典语录","date":"2022-03-08T02:25:29.755Z","path":"wiki/随笔/《大明王朝1566》经典语录/","text":"朝野都知道，我是严阁老提携的人。千秋万代以后，史书上我胡宗宪还会是严阁老的人。可你谭纶，还有朝里那些清流为什么还会看重我？就是我胡某在大事上从来上不误国，下不误民。 孔子说的“知不可为而为之”是什么本意！孔子是告诉世人，做事时不问可不可能，但问应不应该！ 你中有我，我中有你，天下事坏就坏在这里。 事未经历不知难。 官场之中无朋友。 凡事都当作两面想。 你是个刚正的人，敢说话，敢抗上。可真要抗上，你这个七品能抗得过谁？在浙江你能做些事情撼动朝廷，那是因为你背后有人要撼动朝廷。到了江西分宜，凭你一个人又能震动谁？皇上要用的人谁也推不倒，皇上不用的人谁也保不了。 两句话你要记住，一句是文官们说的‘做官要三思’，什么叫三思，三思就是思危、思退、思变。知道了危险就能躲开危险，这就叫思危；躲到人家都不注意到你的地方，这就叫思退；退了下来就有了机会，再慢慢看、慢慢想，自己以前哪儿错了，往后该怎么做，这就叫思变。我再教你武官们说的那一句‘置之死地而后生’，看我大明朝的气数，这皇位迟早有一天是裕王的，到了那一天你才真是个死呢。 文官的衣服上绣的是禽，武官的衣服上绣的是兽。披上了这身皮，我们哪一个不是衣冠禽兽。 任何人答应你的事都不算数，只有自己能做主的才算数。 这个世上，真靠得住的就两种人，一种是笨人，一种是直人。笨人没有心眼，直人不使心眼。 世间万事万物都只有一个理，各人站的位置不同，看法不同而已。 历来造反的都是种田的人，没听说商人能闹翻了天。 裕王: 大明朝谁是贤臣? 嘉靖: 没有谁是真正的贤臣,贤时用之,不贤黜之。","tags":[],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"工程师的成长","date":"2022-03-08T02:25:29.755Z","path":"wiki/随笔/工程师的成长/","text":"原文地址：https://limboy.me/2021/06/29/eng-growth/ 这是libboy博客上的一篇文章，看了之后深有同感。也会反思自己在平常的工作中是否有”做到位”。顺过来贴到自己的Blog中，并加上自己的一些想法。 要点 积累信用货币（先把手头的事情做好，再聊你想做什么） 提升影响力（注重输出；做能够影响更多部门&#x2F;使用方的事，并把它做好） 把工作当成内部创业（多研究手头&#x2F;部门的事情，寻找问题&#x2F;机会，把其他部门当作潜在合作伙伴） 清楚自己的强项（将自己的强项和正确的事情结合起来，才能发挥最大的作用） 环境 与优秀的人共事（学习他们的技能和做事方式，不要成为最聪明的那个） 做符合大趋势的事（ Focus 在某个领域可能是把双刃剑，多结合一些通用技能） 做事情有足够的空间（可以发挥自己的创造力，而不是偏流程化、对着操作手册就能做的事） 一个好的 Mentor（用旁观者视角给你反馈，指出问题和改进方案，帮助成长） 作为个体的基本素质 自驱力（想在前头，不需要别人来 Push） 好奇心（不局限于自己的 Scope，多了解同事、Lead、行业的事情） 高标准（仅仅做完是不够的，一个问题往往有很多可以挖掘的点） 时间管理（不会疲于应付各种需求和问题，有优先级和 Plan） 作为工程师的基本素质 良好的编码能力（1 个月后的自己依然可以维护，出问题可以快速定位） 享受解决问题的乐趣，具备化繁为简的能力（抽象，分解，分层，分模块） 抗压能力（压力下，不变形） 数据意识（好了，坏了，用数据说话） 注重效率（不吝啬在工具上的投入） 看问题的角度 如果现状让我不舒服，我可以做什么来改变，而不是逃避和埋冤 如果觉得当前没什么问题，一定是了解得还不够深入 如果是Ta（某个你欣赏的人）来做你手头的事，Ta 会怎么做 做事情的方法 设计方案时要考虑周到：竞品调研、上线策略、降级方案、回滚方案、出问题时如何排查等 事情推不动就上升，但要提供充足的上下文以便 Lead 做决策，Context not Control 汇报时要切换视角，有条理，把要点说清楚，同时提供了解细节的入口 总结 自己的技能水平一定要过”硬”，先要把自己手上的事情做好，做到优秀，再去考虑其他。作为技术人员，是一定要耐得住寂寞，花时间和精力去学习相关技术的。 做事情的方式，多从不同角度思考问题，深入问题的本质，用客观数据表达一个事情是否达到预期。讲究做事效率。 优秀的人之所以优化，是因为他聪明+勤奋+一丢丢的运气。如果当下的状态不是自己期望的，那么只有努力去改变他。","tags":[],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"火车票黄牛","date":"2022-03-08T02:25:29.755Z","path":"wiki/随笔/火车票黄牛/","text":"今天“长见识”了。 开始以为回广州的高铁票应该很容易买到，所以，并没有提前买票。然而，在家用某行火车票刷票到7点也没买到票。明天可还要上班呢。想着要不去人工售票处碰碰运气。然后来到了高铁站。先去了人工售票窗口，售票的这个小姐姐用非常冷淡的表情回答说没有，然后我就再次问了一次，请问今晚往广州方向的车的票有没有，只要能上车的都行？结果是她再次肯定的说了一句没有！哎，既然这样说了… 然后，我想去售票机上碰碰运气。当我到了一台售票机前，打算查询的时候，旁边来了一位小哥，跟我说：兄Dai，需要票吗？一个小时以内的都可以搞定。我当时就有点懵逼了，黄牛难道可以变出票来？想着还是要回去的，于是说：我需要的。他说：你跟我来这边吧，这边的机器快一些。然后我们来到了旁边的一台机器旁，只见他迅速的在售票机前点击。操作也就是查询是否有余票，然后一下子就出现了，请刷身份证的提示。然后跟我说：快把身份证放上来。我一下子看傻了，然后迅速冷静下来，问他需要给他多少钱。结果，等了十几秒吧，票就没了。他表现的有点懊恼。想想还是要回去的，于是跟他谈价钱，然后又看他操作了一遍，太神奇了。不到一分钟，他又刷出来一张，然后我拿出身份证支付了。 事后想想，难道这是售票机的漏洞吗？难道售票机上的查询接口跟人工售票厅里的不一样？黄牛的这个钱也太好赚了吧。","tags":[],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"读书笔记6：存储器层次结构","date":"2022-03-08T02:25:29.755Z","path":"wiki/读书笔记/深入理解计算机/读书笔记6-存储器层次结构/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记7：链接","date":"2022-03-08T02:25:29.755Z","path":"wiki/读书笔记/深入理解计算机/读书笔记7-链接/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记8：异常流控制","date":"2022-03-08T02:25:29.755Z","path":"wiki/读书笔记/深入理解计算机/读书笔记8-异常流控制/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记9：虚拟内存","date":"2022-03-08T02:25:29.755Z","path":"wiki/读书笔记/深入理解计算机/读书笔记9-虚拟内存/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记10：系统级I/O","date":"2022-03-08T02:25:29.754Z","path":"wiki/读书笔记/深入理解计算机/读书笔记10-系统级IO/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记11：网络编程","date":"2022-03-08T02:25:29.754Z","path":"wiki/读书笔记/深入理解计算机/读书笔记11-网络编程/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记12：并发编程","date":"2022-03-08T02:25:29.754Z","path":"wiki/读书笔记/深入理解计算机/读书笔记12-并发编程/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程 现代操作系统提供三种基本的构造并发程序的方法： 进程 I&#x2F;O多路复用（select、poll、epoll） 线程 基于进程的并发编程基于I&#x2F;O多路复用的并发编程基于线程的并发编程多线程程序中的共享变量用信号量同步线程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记2：信息的表示和处理","date":"2022-03-08T02:25:29.754Z","path":"wiki/读书笔记/深入理解计算机/读书笔记2-信息的表示和处理/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程 原码、反码、补码","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记3：程序的机器级表示","date":"2022-03-08T02:25:29.754Z","path":"wiki/读书笔记/深入理解计算机/读书笔记3-程序的机器级表示/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记3：处理器体系结构","date":"2022-03-08T02:25:29.754Z","path":"wiki/读书笔记/深入理解计算机/读书笔记4-处理器体系结构/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记5：优化程序性能","date":"2022-03-08T02:25:29.754Z","path":"wiki/读书笔记/深入理解计算机/读书笔记5-优化程序层次结构/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解Android卷2》读书笔记","date":"2022-03-08T02:25:29.753Z","path":"wiki/读书笔记/深入理解Android卷2/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"读书笔记1：计算机系统漫游","date":"2022-03-08T02:25:29.753Z","path":"wiki/读书笔记/深入理解计算机/读书笔记1-计算机系统漫游/","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I&#x2F;O 网络编程 并发编程 计算机系统漫游本章只是对整个计算机体系进行概要的介绍，很多主题扩展开来又可以写一本很厚的书了。在阅读此章时，有个大概了解即可。 hello world源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。系统中所有的信息–包括磁盘文件、内存中的程序、内存中存放用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方式是我们读到这些数据对象时的上下文。 下图描述了一个c程序是如何被编译运行的。 关于计算机的构成 关于存储器 分层，高层提供给低层高速缓存，越高层性能越好，价格越贵。 计算机抽象的表示 关于shellshell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。 操作系统的两个基本功能： 防止硬件被失控的应用程序滥用； 向应用程序提成简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对I&#x2F;O设备的抽象表示，虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，进程则是对处理器、主存和I&#x2F;O设备的抽象表示。 Posix的由来20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使他们的程序与众不同，为了阻止这种趋势，IEEE开始标准化Unix的开发，后来由Richard Stallman命名为“Posix”。结果就得到了一些列的标准，称作Posix标准。 并发运行一个进程的指令和另一个进程的指令是交错执行的。 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文。 进程间切换的交错执行的机制称为上下文切换。 Amdahl定律 a表示可以提升部分的比例 k表示可提升部分性能提升的比例","tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"收集的电子书","date":"2022-03-08T02:25:29.747Z","path":"wiki/读书笔记/收集的电子书/","text":"如何阅读一本书 ActionScript、Flex Actionscript 3 image effects ActionScript 3 ActionScript Graphing Cookbook ActionScript ActionScript大型网页游戏开发 AdvancED ActionScript Animation动画高级编程 AdvancED Game Design with Flash air_buildingapps Flash Cinematic Techniques Flash Game Development by Example Flex4权威指南 FLEX企业应用开发实战 Foundation Game Design with Flash FriendsofED The Essential Guide to Flash Games(flash游戏编程指南) 优化Flash性能 AIR_Android应用开发实战 Developing Android Applications with Flex 4 Flash+Flex+Air移动开发入门经典 mobile-encoding-android-v2_7 Packt Publishing Flash Development for Android Cookbook (2011) 使用Flex4 ABCStructure amf0_spec_121207 amf3_spec_121207 avm2overview swf_file_format_spec_v10 video_file_format_spec_v10_1 Android Android 4高级编程(第3版) Android Developer Tools Essentials Android Native Development Kit Cookbook Android内核剖析(完整版) Android多媒体开发高级编程 Android应用开发详解 Android开发精要 ANDROID框架揭秘 Android系统源代码情景分析 Android软件安全与逆向分析 Dalvik-Bytecode embedded_android Fragments for All Presentation Google Android SDK开发范例大全(第3版) Groovy in Action Groovy中文教程 Kotlin in Action kotlin-for-android-developers-zh Kotlin官方参考文档中文版 Practical practical_android_4_games_development Smashing_Android_UI The Busy Coder’s Guide to Android Development, Version 4 [Gradle [www 深入理解Android(卷2) 深入理解android 疯狂Android讲义 精通Android3 C# C#入门经典第5版中文高清版 C#高级编程(中文第七版) C、C++ Accelerated C++中文版 Andrew Koenig：C 陷阱与缺陷@2002 (扫描版) An_Introduction_to_GCC_中文 c++ Primer 第5版 C+++GUI+QT3编程_11774607 C++STL标准程序库开发指南 PDF电子书下载 带书签目录 C++标准程序库 C++模板元编程 C++沉思录(Ruminations on C++)中文第2版 C++程序设计原理与实践(中文完整版) C++编程规范-101条规则准则与最佳实践 C++语言的设计和演化 C专家编程 C和指针(第二版)高清全版469页 C程序设计(第四版)谭浩强 C程序设计语言(第2版_新版) C程序设计语言(第2版_新版)习题解答 C程序设计语言(第2版_新版)非扫描版&amp;详细书签版 C语言入门经典(第四版) C语言范例开发大全 Effective C 中文版第三版 高清PDF Effective STL 中文版 Essential C++中文版 Head STL源码剖析简体中文完整版(清晰扫描带目录) 你必须知道的495个C语言问题 像计算机科学家一样思考C++ 嗨翻C语言_13421426(jb51 易学C++ English 无敌初中必考语法 新编英语语法教程+学生用书+第5版_PDF 无敌英语语法：全范围 History 乔治·奥威尔：一九八四 何清涟：现代化的陷阱 吴思：潜规则——中国历史中的真实游戏 吴思：血酬定律——中国历史中的生存游戏 威廉·夏伊勒：第三帝国的兴亡 (上) 威廉·夏伊勒：第三帝国的兴亡 (下) 威廉·夏伊勒：第三帝国的兴亡 (中) 学会提问-批判性思维指南 弗洛伊德：梦的解析 弗洛伊德：精神分析引论 徐中约《中国近代史》（PDF-港版完整无删减）上 徐中约《中国近代史》（PDF-港版完整无删减）下 斯科特·派克：少有人走的路 罗伯特·西奥迪尼：影响力 金观涛 &amp; 刘青峰：兴盛与危机——论中国社会超稳定结构 阿利安：亚历山大远征记 高华：在历史的风陵渡口 黄仁宇：中国大历史 剑桥中国历史 中华人民共和国史 (上卷 扫描版) 明史 (扫描版) 晚清史 (上卷 扫描版) 晚清史 (下卷 扫描版) 民国史 (上卷 扫描版) 民国史 (下卷 扫描版) 秦汉史 (扫描版) 辽西夏金元史 (扫描版) 隋唐史 (扫描版) iOS AppDistributionGuide Effective Objective-C 2 iOS应用逆向工程 分析与实战 iOS编程+第4版 Objective C 编程之道 Objective C程序设计 Objective-C编程全解 第3版 Objective-C高级编程 iOS与OS X多线程和内存管理 OSX与iOS内核编程 Java advancedservletsjsp Effective Enterprise Java(Chinese) Head First Servlets and JSP 中文版 第2版 Head First Servlets and JSP 2nd Head First Web设计 (中文版) JAVA并发编程实践（中文） Java并发编程实践（英文版） Java本地接口(JNI)编程指南和规范2 JAVA案例开发集锦 Java编程思想_第4版_中文完整版 Java虚拟机规范中文版 Java迷题 JAVA面试题解惑系列 servlet-2_5-mrel2-spec Think In Java 4完美高清中文版 《Java网络编程(第4版)》 深入浅出数据分析（美）米尔顿著 Effective Java（第2版） Javascript HTML5高级程序设计 javascript dom 编程艺术 JavaScript权威指南(第6版)(中文版) JavaScript高级程序设计(中文)-第3版 kinect 51CTO下载-kinect应用开发实战（全书） Kinect人机交互开发实践 Linux bash Cookbook Solutions and Examples for bash Users Linux Shell Scripting Cookbook 2nd Edition May 2013 Linux 与 UNIX Shell 编程指南 Linux linux内核源代码情景分析(上) linux内核源代码情景分析(下) Linux命令行与Shell脚本编程大全 第2版 Understanding The Linux Kernel UNIX操作系统基础使用手册 精通UNIXShell脚本编程 高级Bash脚本编程指南(Advanced Bash-Scripting 鸟哥的Linux私房菜服务器架设篇(第三版) Music 五线谱入门 基本乐理 PHP PHP和MySQL PHP开发实战1200例 symfony权威指南 深入PHP面向对象模式与实践 白帽子讲 Web 安全 高性能mysql第三版 PHP核心技术与最佳实践 PHP内核剖析 深入理解PHP内核 Python Beginning Game Development with Python and Pygame Dive into Python Effective Expert Python Programming(2nd) make game with python &amp; pyGame Python 3 Python Cookbook Python参考手册(第4版) Python基础教程(第2版) python标准库中文版PDF(带章节书签) Python核心编程第二版-习题答案 Python源码剖析 Python灰帽子 黑客与逆向工程师的Python编程之道 Python灰帽子：黑客与逆向工程师的Python编程之道(英文版) The Django Book 2 The Python Standard Library by Example 深入学习Python 3 编写高质量代码 改善Python程序的91个建议 Qt C++ Qt设计模式（第2版） QmlBook-In-Chinese Qt Creator快速入门 Qt Quick核心编程 13678855 Qt5开发及实例 Qt及Qt Quick开发实战精解 QT学习之路(全) QT高级编程_chs the_art_of_building_qt_applications 《C++设计模式–基于Qt4开源跨平台开发框架》 PyQt pyqt-book PyQt5 tutorial pyqt5__pythonGui入门教程 PyQt5入门 Rapid GUI Programming with Python and Qt Temp 51CTO下载-ffmpeg教程 CMake Practice design-patterns FFMPEG教程完美排版 GarageBand使用指南 growth全栈增长工程师指南 InstallationGuide kotlin-in-action-in-chinese OpenSL_ES_Specification_1 SDL+GUIDE+中文译本 SWIGDocumentation TCP-IP详解(卷一、二、三) Wireshark 数据包分析实战(第2版)最新中文版 Wireshark 数据包分析实战详解 《图解TCP IP(第5版)》 图解设计模式 程序是怎样跑起来的_PDF电子书下载 带书签目录 高清完整版 网络是怎样连接的 计算机是怎样跑起来的 设计模式 设计模式之禅(完整高清版) Java加密与解密的艺术 一个证券分析师的醒悟 张化桥的股市真话 游戏之旅-我的编程感悟 游戏设计-原理与实践 荣辱二十年-我的股市人生 计算机程序的构造和解释 产品、设计、思想 A Pattern Language Head First 设计模式 Java与模式 Java夜未眠 java设计模式 人件（原书第3版） 人月神话 代码之美 你的灯亮着吗 启示录：打造用户喜爱的产品（英文） 大话设计模式 学会提问-批判性思维指南 建筑的永恒之道 数据结构经典问题和算法分析 浪潮之巅 漫谈设计模式 编码的奥秘 设计心理学 设计模式-可复用面向对象软件的基础 设计模式精解 设计模式：Java语言中的应用 高效程序的奥秘 黑客与画家 硅谷创业之父Paul Graham文集 产品经理 互联网产品经理改变世界 产品经理手册 第3版 产品经理方法论 区块链将如何改变世界 用户体验要素 用户体验面面观-方法、工具与实践 德州扑克 let there be range(中文) 加注的优势：当今锦标赛激进策略 哈灵顿在现金上2中文版 扑克蓝图 摄影 数码单反摄影从入门到精通第一卷 美国纽约摄影学院摄影教材 服务端 docker_practice Docker从入门到实践 PHP-Debug-Manual-public Redis开发运维实践指南 Redis源代码分析 云计算架构技术与实践 亿级流量网站架构核心技术 伊甸园之河 大型网站技术架构核心原理与案例分析 实用负载均衡技术网站性能优化攻略 极客与团队 深入分布式缓存从原理到实践 精通正则表达式 软件架构设计 高扩展性网站的50条原则 算法、数据结构 《大话数据结构》 程杰 程序员实用算法 算法之道 算法导论(第二版)习题答案(英文版) 算法导论 管理 MBA教不了的创富课 股票 与庄共舞（股票实战操作） 从零开始学炒股 价值投资系列之25《上市公司财报解读》 你不知道的中国股事那些事(高清) 投资正途 日本蜡烛图技术 江恩投资几何学原理 江恩测市法则（经典之作） 海龟交易法则 看盘细节(精选) 看盘细节 短线炒股就这几招（操盘必读） 短线点金：揭开市场的底牌 短线点金：破解股价的运行轨迹 短线点金：道破股价涨跌之玄机 缠中说禅《教你炒股票》1-108课图文全版 缠论解析 缠中说禅技术理论图解(清晰版) 聪明的投资者（高质量） 胡立阳股票投资100招（清晰） 证券市场基础知识 【投资艺术】作者：查尔斯 艾里斯 巴菲特教你读财报 股票作手回忆录 超越金融 索罗斯的哲学 (美)乔治·索罗斯 2 金融炼金术(高质量） 高胜算操盘 股市操练大全12345 计算机基础 深入理解计算机系统(原书第2版) 编译、链接、装载 程序员的自我修养—链接、装载与库 linker and loader 现代编译原理：Ｃ语言描述 编译原理及实践 编译原理基础 编译原理（龙书）中文版 编译原理及实践 音视频相关 FFmpeg Tutorial FFmpegBasics ffmpeg基础库编程开发 OpenCV 2 计算机视觉编程手册_中文版 学习OpenCV 项目管理 Project 2016项目管理自学经典_王菁_清华大学_2016","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《深入理解Android卷1》读书笔记","date":"2022-03-08T02:25:29.747Z","path":"wiki/读书笔记/深入理解Android卷1/","text":"概要《深入理解Android卷1》这本书在刚出来的时候就已经买了，当时应该也是看过的，但忘得很快，里面很多的源码分析，且多数是native层的，虽然作者也会在分析完一段时间后就做一个总结。最近又把他拿出来看了看，这次看的时候，已经对Android体系有一个认识了，所以理解起来还算好。但对于native层的点，光看这一本书是远远不够的。 还是将一些自己觉得重要的点都记录下来吧！ 个人觉得本书的阅读顺序应该是： 第一章了解Android系统的架构 熟悉JNI，了解Java跟native通讯的机制 第三、四章，了解Android启动流程 第五章了解线程通信机制Handler 六、七章以源码的角度来熟悉Binder机制，这里我觉得一定要扩展阅读，光看这些很难深入理解Binder 理解Surface系统，阅读这章最好能先熟悉四大组件的启动流程，UI绘制流程，事件传递机制 剩下的两章算扩展吧 第一章介绍了整个Android体系，从底层的硬件设备到上面的应用层。 具体的可以参考Android系统架构 第二章JNI是Java Native Interface的缩写，通过JNI可以做到： Java程序中的函数可以调用Native语言写的函数 Native程序中的函数可以调用Java层的函数 我们在Java中调用C、C++代码的一般做法是使用System.loadLibrary(“xxx.so”)，然后声明native方法，即可使用。在Android中，JNI函数有两种注册方式： 静态方法 编写java文件，编译生成.class文件 使用javah命令，比如javah -o ouput packagename.classname，会生成一个output.h的头文件，里面会有对应的JNI层函数 动态注册 由于是不同语言之间的调用，每种语言的基本类型有所差异，所以JNI会进行类型转换。 JNI提供三种类型的引用： Local Reference：本地引用。一旦JNI层函数返回，这些jobject就可能被垃圾回收 Global Reference：全局引用，不主动释放，就不会被回收 Weak Global Reference： 弱全局引用 第三章、第四章 大致流程： 开机，初始化zygote（app_process）进程 创建虚拟机 注册JNI函数 注册zygote用的socket，用于跟system_server进程通信 预加载资源（比如加载Android相关的java类、so库） 启动system_server进程 初始化ams、wms、pms等等 第五章RefBase、sp、wp实现了一套通过引用计数的方法控制对象生命周期的机制。这一块看得有点懵，因为C、C++中是没有垃圾回收机制的，需要自己手动释放对象。这几个东西应该是为了方便对象释放而设计出来的吧？ 介绍了一些同步类，这块如果对Java的锁机制有了解的话，看起来很轻松。 Mutex：互斥锁 AutoLock：Mutex的封装 Condition：条件锁 接下来讲Looper和Handler，可以参考Handler原理 第八章个人觉得这章很重要，可以让你了解整个绘制的流程和内部实现机制。","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《图解TCP/IP》读书笔记","date":"2022-03-08T02:25:29.745Z","path":"wiki/读书笔记/图解TCPIP/","text":"OSI参考模型 名字 描述 网卡 使计算机联网的设备 中继器（Repeater） 从物理层上延长网络的设备 2 网桥（Bridge） 从数据链路层上延长网络的设备 3 路由器 通过网络层转发分组数据的设备 4~7 交换机 处理传输层以上各层网络传输的设备 网管（Gateway） 转换协议的设备 数据链路名 通信媒介 传输速率 主要用途 以太网 同轴电缆 10Mbps LAN _ 双绞线电缆 10Mbps~100Gbps LAN _ 光纤电缆10Mbps~100Gbps LAN 无线 电磁波 数个Mbps LAN~WAN ATM 双绞线电缆光纤电缆 25Mbps155Mbps622Mbps LAN~WAN FDDI 光纤电缆双绞线电缆 100Mbps LAN~-WAN 帧中继 双绞线电缆光纤电缆 约64~1.5Mbps WAN ISDBN 双绞线电缆光纤电缆 64~1.5Mbps WAN 在数据传输过程中，两个设备之间数据流动的物理速度称为传输速率，单位为bps（Bits Per Second），传输速率高指单位时间内传输的数据量有多少。传输速率又称为带宽（Bandwidth） 协议规范https://www.rfc-editor.org/rfc 以太网协议https://www.iana.org/assignments/ethernet-numbers/ethernet-numbers.xhtml 分类 通信距离 标准化组织 相关其他组织及技术 短距离无线 数米 个别组织 RF-ID 无线PAN 10米左右 IEEE802.15 蓝牙 无线LAN 100米左右 IEEE802.11 Wi-Fi 无线MAN 数千米~100千米 IEEE802.16IEEE802.20 WiMAX 无线RAN 200千米~700千米 IEEE802.22 无线WAN GSM、CDMA2000、W-CDMA 3G、LTE、4G http://grouper.ieee.org/groups/802/11/Reports/802.11_Timelines.htm PPP：Point to Point ProtocolATM：Asynchronous Transfer Mode IP寻址路由IP分包和组包 IP是面向无连接的","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《Kotlin实战》读书笔记","date":"2022-03-08T02:25:29.744Z","path":"wiki/读书笔记/Kotlin实战/","text":"基本规则 不需要分号 函数 fun声明函数 函数可以定义在文件的最外层 123fun max(a: Int, b: Int): Int &#123; return if(a&gt;b) a else b&#125; 表达式函数体 fun max(a: Int, b: Int): Int = if(a&gt;b) a else b 表达式函数体可以省略返回类型，Kotlin会进行类型推导 fun max(a: Int, b: Int)= if(a&gt;b) a else b 数组就是类 变量 var表示可写属性 val表示只读属性 1234567val answer = 42 //这个变量永不为nullvar answer1:Int? = 40 // 这个变量可以为nullval answer:Int = 42val表示不可变引用，使用val声明的变量不能在初始化之后再次赋值。var可变引用，可以改变值，但不能改变类型。var answer = 13answer = &quot;no &quot; 这样是错误的 字符串模板 12$name$&#123;name&#125; 类 123class Person(val name:String)class Person(val name:String, var isMarried:Boolean) 自定义访问器 12345678class Rectangle(val height:Int, val width:Int) &#123; val isSquare:Boolean get() &#123; return height == width &#125; //或者 get() = height == width&#125; 包层级结构不需要遵守目录层级结构 枚举 12345678910111213enum class Color(val r:Int, val g:Int, val b:Int) &#123;RED(255,0,0),GREEN(0,255,0);fun rgb() = (r*256 + g)*256 + b&#125;println(Color.GREEN.rgb())fun getMnumonic(color: Color) = when(color) &#123; Color.RED -&gt; &quot;Richard&quot; Color.GREEN -&gt; &quot;Gave&quot; &#125; @JvmOverloads， 会生成Java重载函数 顶层属性和函数 扩展函数不能被重写 扩展属性vararg 修饰符 可变参数 中缀调用局部函数 kotlin类声明默认是final和public，要想声明不是final的，将其标记为open open、final、abstract lateinit object 定义一个类并同时创建一个实例，使用场景： 对象声明是定义单例的一种方式 伴生对象可以持有工厂方法和其他与整个类相关，但在调用时并不依赖类实例的方法。 对象表达式用来替代Java的匿名内部类 1234567object DataProviderManager &#123; fun registarDataProvider(provider: DataProvider) &#123; ... &#125;&#125;DataProviderManager.registarDataProvider(...) 伴生对象companion 1234567891011121314class MyClaa &#123; companion object Factory&#123; fun create():MyClass = MyClass() &#125;&#125;//该伴生对象的成员可通过只使用类名作为限定符来调用val instance = MyClass.create()//可以省略伴生对象的名称，在这种情况下将使用名称 Companionclass MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion 在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段 直接通过容器类名来访问整个对象的方法和属性的能力 匿名对象可以实现多个接口或者不实现接口 lamdba表达式始终用花括号包围 val sum = &#123;x: Int, y: Int -&gt; x+y&#125; println(sum(1,2)) 允许lamdba内部访问非final变量甚至修改它们 成员引用 val getAge = Person::age all any count find 对集合应用判断式 with函数apply 类型系统 可空性 12fun strLen(s:String) = s.lengthfun strLen(s:String?) = s.length 安全调用运算符 ?.，只要链式中一个值为null，则整个表达式都返回null 12345s?.toUpperCase()val testStr : String? = nullval result = testStr?.length?.plus(5)?.minus(10)println(result) ?: 当一个函数有返回值时，如果方法中的代码使用?.去返回一个值，那么方法的返回值的类型后面也要加上?符号 1234fun funNullMethod() : Int? &#123; val str : String? = &quot;123456&quot; return str?.length&#125; as? 非空断言 “!!” 显示地抛出异常 let函数作用：使用符号?.验证的时候忽略掉null 用法：变量?.let{…} 1234567891011121314val arrTest : Array&lt;Int?&gt; = arrayOf(1,2,null,3,null,5,6,null)// 传统写法for (index in arrTest) &#123; if (index == null)&#123; continue &#125; println(&quot;index =&gt; $index&quot;)&#125;// let写法for (index in arrTest) &#123; index?.let &#123; println(&quot;index =&gt; $it&quot;) &#125;&#125; Evils操作符?: 判断一个可空类型时，会返回一个我们自己设定好的默认值 12345val testStr : String? = nullvar length = 0// ?: 写法length = testStr?.length ?: -1println(length) !! 判断一个可空类型时，会显示的抛出空引用异常 12val testStr : String? = nullprintln(testStr!!.length) as? 安全的类型转换 12val num2 : Int? = &quot;Koltin&quot; as? Intprintln(&quot;nun2 = $num2) 基本类型、包装类型的转换需要通过API Any kotlin基类Unit kotlin中的voidNothing 这个函数永不返回 List listOf mutableListOf、arrayListOfSet setOf mutableSetOf、hashSetOf、linkedSetOf、sortedSetOfMap mapOf mutableMapOf、hashMapOf、linkedMapOf、sortedMapOf 重载二元算术运算operator 委托属性 by lazy() kotlin允许使用对应名称的函数来重载一些标准的数学运算，但不能定义自己的运算符。 函数类型 内联函数 注解@JvmName@JvmStatic@JvmOverloads@JvmField 注解类：用来定义关联到声明和表达式的元数据的结构，它们不能包含任何代码 元注解@Retention 说明你声明的注解是否会存储到.class文件，以及在运行时是否可以通过反射来访问它。 kotlin反射API invoke","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"设计原则","date":"2022-03-08T02:25:29.744Z","path":"wiki/设计模式/设计原则/","text":"单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】： 一个类负责一项职责。 里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】： 继承与派生的规则。 依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】： 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。 接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】： 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 隔离的定义: 客户端不应该依赖它不需要的接口。 类间的关系应该建立在最小的接口上。 迪米特原则【LOW OF DEMETER】： 也叫“最少知识”原则，低耦合，高内聚。 开闭原则【OPEN CLOSE PRINCIPLE】： 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 组合&#x2F;聚合复用原则【Composition&#x2F;Aggregation Reuse Principle(CARP) 】： 尽量使用组合和聚合少使用继承的关系来达到复用的原则。 参考","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"《Java编程思想》读书笔记","date":"2022-03-08T02:25:29.744Z","path":"wiki/读书笔记/Java编程思想/Java编程思想/","text":"final finally finalize finalize()主要是给其他调用而创建的空间在对象回 收时页同步回收而设置的。 比如，你调用了C语言，使用了mallow()开辟了一段内存空间。在你释放java对象的时候，虚拟机只能释放java对象占用的空间，而不能释放C开辟的内存空间，所你 你在释放此对象之前要先回收你在C语言中开辟的空间。 这各时候才用到finalize()方法。平时的 时候不要随便使用finalize()方法。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java编程思想","slug":"读书笔记/Java编程思想","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"第15章：泛型","date":"2022-03-08T02:25:29.744Z","path":"wiki/读书笔记/Java编程思想/第15章：泛型/","text":"一般的类和方法，只能使用具体的类型，要么是基本类型，要么是自定义的类，如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。 泛型实现了参数化类型的概念，使代码可以应用于多种类型。 容器类是引入泛型的一个重要原因 Java中，return语句只允许返回单个对象，通过泛型，则可以返回多个对象。这个概念成为元祖（tuple），它将一组对象直接打包存储于其中一个单一对象。 元祖可以具有任意长度，任意类型。 泛型方法使用泛型方法时，会进行类型参数推断，如果传入基本类型，则会自动打包 1234567891011public class GenericMethods &#123; public &lt;T&gt; void f(T x) &#123; System.out.println(x.getClass().getName()); &#125; /* public static T f(T a)&#123; //编译不通过 return a; &#125; */&#125; 普通static方法无法访问泛型类的类型参数，如果要是使用泛型就要定义成泛型静态方法。类的泛型要在创建对象时才确定，而类内的静态方法，静态域在类加载时初始化，因此如果使用类的泛型类型则初始化时无法知道具体类型是什么，此时使用泛型方法这样就和类的泛型无关了，这样静态方法初始化时类型只和自身的泛型相关。 泛型方法返回值是泛型，那么就返回一个泛型，不能是具体类型，反之亦然。 123public static &lt;T&gt; Set&lt;T&gt; set()&#123; // return new HashSet&lt;String&gt;(); //不能返回具体类型&#125; 泛型的一个重要好处是能够简单而安全的创建复杂的模型 可变参数泛型方法 擦除 jvm并不认识泛型因此需要将泛型擦除。 ArrayList 和 ArrayList很容易被认为是不同类型。因为他们有不同的行为，但程序却认为他们是相同的，正是因为擦除的存在。 擦除的结果就是把一个对象变为它的原生类 泛型只是用来检查类型正确性，泛型部分的代码不会参与运行，这是由于泛型的擦除作用。 泛型代码内部无法获得有关泛型参数的类型的信息。 泛型擦除到第一个边界 上界 意思就是T 只能为HasF或者其子类。 泛型只是在静态类型检查期间出现来验证类型正确性，程序一但运行后泛型都将被擦除，替换成他们的非泛型上界，如List被擦除为List，List被擦除为List, 擦除为 擦除动机 擦除使得泛化的代码变得具体，因此泛化客户端可以使用非泛化类库，非泛化客户端也可以使用泛化类库。 擦除的代价 泛型不能当做一个类去操作，如Foo&lt;Cat&gt; cat不能代表Cat这个类，因为它会被擦除为Object. 边界处的动作 边界就是对象进入和离开方法的地方，编译期执行类型检查和插入转型代码就是在边界处。 编译期执行了类型检查确保了数据一致性，在离开方法时由编译器为你插入转型代码执行转型，此时转型是安全的。 由于擦除kind实际被存储为Class，因此创建数组无法后知道要转型成什么类型，因此必须强转。但创建容器就不需要强转了，编译期可以保证类型的一致性，如果类型不一致不通过编译。 边界 强制泛型可以使用什么类型 按边界类型调用方法其方法，无边界的只能调用从Objec继承的方法。 通配符 通配符可以允许某种类型向上转型,与普通边界对比: List first &#x3D; new ArrayList(); 只能使用TList&lt;? extends Fruit&gt; first &#x3D; new ArrayList(); &#x2F;&#x2F;可以使用各种Fruit的子类。List&lt;? extends Fruit&gt; 读作具有任何从Fruit继承的类型列表。 上界 ？是Fruit 的子类，但具体是什么不知道，因此当调用get方法时返回的对象可以赋值给Fruit引用,而add添加对象时由于不清楚具体要添加什么子类所以无法使用add方法。 超类型通配符 下界 也称 逆变？是Apple的父类，但具体是什么类型不得而知，因此当调用add方法添加对象时可以添加Apple和其子类对象，但调用get方法时无法确定要返回什么类型，因此不能调用get方法返回具体类型，只能返回Object。 无界通配符 与上下界之间的区别 - 一个方法的参数的类型如是 List ，List ，则可以接收任何形式的List参数，参数是不是泛型无所谓。 参数的类型如果是List&lt;? extends&#x2F;super A &gt; ，则只能接收泛型的List参数. 如果参数的类型是 &lt;?&gt; 或者 &lt;? extends A&gt;，则该方法无法调用 可以向上转型 多个泛型参数下只有全为？时编译器无法与原生类区分，但只要有过一个参数不是？就会有所区分如Map&lt;String, ?&gt;必须传入map&lt;String,?&gt;类型的参数，而Map可以传入new HashMap();","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java编程思想","slug":"读书笔记/Java编程思想","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"第20章：注解","date":"2022-03-08T02:25:29.744Z","path":"wiki/读书笔记/Java编程思想/第20章：注解/","text":"参考","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java编程思想","slug":"读书笔记/Java编程思想","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"迭代器模式","date":"2022-03-08T02:25:29.744Z","path":"wiki/设计模式/行为型模式/迭代器模式/","text":"定义Iterator Pattern：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。 类图 角色 Iterator（抽象迭代器）：接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。 ConcreteIterator（具体迭代器）：实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。 IterableCollections：接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。 ConcreteCollections（具体集合）：实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。 优缺点 单一职责原则 开闭原则 使用场景 Java集合类 数据库操作Cursor 参考 https://refactoringguru.cn/design-patterns/iterator","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"访问者模式","date":"2022-03-08T02:25:29.743Z","path":"wiki/设计模式/行为型模式/访问者模式/","text":"定义封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 类图 角色 Visitor：接口或者抽象类，定义了对每个 Element 访问的行为，它的参数就是被访问的元素，它的方法个数理论上与元素的个数是一样的，因此，访问者模式要求元素的类型要稳定，如果经常添加、移除元素类，必然会导致频繁地修改 Visitor 接口，如果出现这种情况，则说明不适合使用访问者模式。 ConcreteVisitor：具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。 Element：元素接口或者抽象类，它定义了一个接受访问者（accept）的方法，其意义是指每一个元素都要可以被访问者访问。 ElementA、ElementB：具体的元素类，它提供接受访问的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 ObjectStructure：定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素提供访问者访问。 优缺点 各角色职责分离，符合单一职责原则 高扩展性 使用场景参考 https://www.jianshu.com/p/1f1049d0a0f4 https://refactoringguru.cn/design-patterns/visitor","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","date":"2022-03-08T02:25:29.743Z","path":"wiki/设计模式/行为型模式/责任链模式/","text":"定义免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 类图 角色 抽象处理者(Handler)角色：声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。 具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。 优缺点 单一职责原则。 开闭原则。可以在不更改现有代码的情况下在程序中新增处理者。 使用场景 OkHttp框架中，分析参考OkHttp GUI中的事件流，某个view如果要处理就会进行拦截，如果不处理，则传给后续的view。 参考 https://refactoringguru.cn/design-patterns/chain-of-responsibility","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"状态模式","date":"2022-03-08T02:25:29.742Z","path":"wiki/设计模式/行为型模式/状态模式/","text":"定义State Pattern：允许一个对象在其内部状态改变的时候改变其行为。 状态模式的状态是不可替换的而且是兄弟关系，但是策略模式是可以替换的彼此独立的。他们执行完之后的行为也不同，状态模式会更改状态但是策略模式执行完就是执行完。 类图 跟策略模式的类图一样… 角色 State: 抽象状态类，定义一个接口以封装与context的一个状态相关的行为 ConcreteState: 具体状态，每一子类实现一个与Context的一个状态相关的行为 Context: 状态上下文，维护一个ConcreteState子类的实例，这个实例定义当前的状态。 优缺点 单一职责原则 开闭原则 封装了转换规则 使用场景 播放器的不同状态 参考 http://ifeve.com/state-design-pattern-in-java-example-tutorial/ https://juejin.cn/post/6844903455492931598 https://refactoringguru.cn/design-patterns/state/java/example","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","date":"2022-03-08T02:25:29.742Z","path":"wiki/设计模式/行为型模式/策略模式/","text":"定义Strategy Pattern：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类Context中，抽象策略Strategy一般是一个接口，目的只是为了定义规范，里面一般不包含逻辑。 类图 角色 Context（环境类）：维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。目的是避免高层模块对策略的直接调用。 Strategy（抽象策略类）：通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。 ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。 优缺点 开闭原则 多重if&#x2F;else的解决方式之一 使用场景 Arrays.sort() 参考 https://refactoringguru.cn/design-patterns/strategy","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"观察者模式","date":"2022-03-08T02:25:29.742Z","path":"wiki/设计模式/行为型模式/观察者模式/","text":"定义Observer Pattern：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 类图 角色 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 优缺点 满足开闭原则 设计原则 多用组合，少用继承 针对接口编程 为交互对象之间的松耦合努力 使用场景 java.util包中 在Java中，GUI的按钮等UI的事件响应 Java中提供了Observable，给我们快速实现观察者模式。但由于单继承的原因，使用这个类还是会有些限制 参考 《Head First 设计模式》","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"解释器模式","date":"2022-03-08T02:25:29.742Z","path":"wiki/设计模式/行为型模式/解释器模式/","text":"定义Interpreter Patttern：给定一个语言，定义它的文法的一种表示，并定义一个解释器。 类图 角色 AbstractExpression（抽象表达式）：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。 TerminalExpression（终结符表达式）：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R&#x3D;R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 NonterminalExpression（非终结符表达式）：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R&#x3D;R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。 Context（环境类）：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R&#x3D;R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。 优缺点使用场景参考 https://www.cnblogs.com/java-my-life/archive/2012/06/19/2552617.html https://juejin.cn/post/6844903760376889358","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"备忘录模式","date":"2022-03-08T02:25:29.741Z","path":"wiki/设计模式/行为型模式/备忘录模式/","text":"定义Memento Pattern：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 类图 角色 原发器 （Originator） ：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。 备忘录 （Memento） ：负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。 负责人 （Caretaker）：对备忘录进行管理，保存和提供备忘录。 优缺点 提供一种状态恢复机制 使用场景 游戏的当前状态 回滚操作 参考 https://xmuxiaomo.github.io/2015/05/25/设计模式学习（五）——备忘录模式/ https://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html https://refactoringguru.cn/design-patterns/memento","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"模板方法模式","date":"2022-03-08T02:25:29.741Z","path":"wiki/设计模式/行为型模式/模板方法模式/","text":"定义Template Method Pattern：定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。 类图 角色 抽象类 （AbstractClass）：会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为抽象类型， 也可以提供一些默认实现。 具体类 （ConcreteClass）：可以重写所有步骤， 但不能重写模板方法自身。 优缺点使用场景参考 https://refactoringguru.cn/design-patterns/template-method https://www.liaoxuefeng.com/wiki/1252599548343744/1281319636041762","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"命令模式","date":"2022-03-08T02:25:29.741Z","path":"wiki/设计模式/行为型模式/命令模式/","text":"定义Command Pattern：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式的别名为动作(Action)模式或事务(Transaction)模式。 类图 角色 客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。 命令(Command)角色：声明了一个给所有具体命令类的抽象接口。 具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法，会调用Receiver的action方法。 请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。 接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。 优缺点优点 命令模式将调用操作的请求对象与执行该操作的接收对象解耦。 具体命令角色可以被不同的请求者角色重用。 使用场景 开源库EventBus中 开源库puremvc中 参考 《Head First设计模式》","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"中介者模式","date":"2022-03-08T02:25:29.740Z","path":"wiki/设计模式/行为型模式/中介者模式/","text":"定义用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。 类图 角色 抽象中介者(Mediator)：定义出同事对象到中介者对象的接口，其中主要方法是一个（或多个）事件方法。 具体中介者(ConcreteMediator)：实现了抽象中介者所声明的事件方法。具体中介者知晓所有的具体同事类，并负责具体的协调各同事对象的交互关系。 抽象同事类(Colleague)：定义出中介者到同事对象的接口。同事对象只知道中介者而不知道其余的同事对象。同事类行为分为两种： 自发行为（self-Method）：一种同事本身的行为，例如改变对象本身的状态，处理自己的行为等。与其他同事类或中介者没有任何。 依赖方法(Dep-Method)：必须依赖中介者才能完成的行为。 具体同事类(ConcreteColleague)：所有的具体同事类均从抽象同事类继承而来。实现自己的业务，在需要与其他同事通信的时候，就与持有的中介者通信，中介者会负责与其他的同事交互。 优缺点 松散耦合 将对象间一对多的关联转变为一对一的关联 单一职责原则 开闭原则 使用场景 java.util.Timer中 参考 https://juejin.cn/post/6844903699643383821 https://refactoringguru.cn/design-patterns/mediator","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","date":"2022-03-08T02:25:29.736Z","path":"wiki/设计模式/创建型模式/单例模式/","text":"单例模式应该是最常见的设计模式了 定义定义：单例对象的类必须保证只有一个实例存在。 为了实现一个健壮的单例，我们应该思考需要做哪些事情？ 不能随意的让用户new出对象，所以构造函数应该是私有的 既然不能直接new，就应该有一个方法专门用来返回实例对象 不能clone 不能被反序列化 多线程使用时，如何保证线程安装 Java的实现方式根据上面的思考，我们可以一步步的来实现单例模式。 懒汉式12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 使用的时候才进行初始化，但此种写法是线程不安全的。那么是否把getInstance方法加一个锁就可以了呢？ 线程安全的懒汉式12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 嗯，这种写法确实安全了，可是效率低，因为有更好的方式啊 饿汉式12345678910111213public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125;public class Singleton &#123; private static Singleton instance = null; static &#123; instance = new Singleton(); &#125; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 为什么叫饿汉呢？因为在类加载的时候对象就被创建了啊！这也是该方式不太好的地方，需要的实例应该要在需要用到的时候才初始化呢!所以应该想想怎样才能延迟加载呢？ 静态内部类实现方式123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。完美！！ 枚举123456789101112131415161718192021222324//方式一public enum Singleton &#123; INSTANCE; public void whoAmI() &#123; System.out.println(this.toString()); &#125; &#125;//方式二public class Singleton &#123; private Singleton()&#123; &#125; public void whoAmI() &#123; System.out.println(this.toString()); &#125; public static enum SingletonEnum &#123; SINGLETON; private Singleton instance = null; private SingletonEnum()&#123; instance = new Singleton(); &#125; public Singleton getInstance()&#123; return instance; &#125; &#125;&#125; Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次 双重检查锁模式12345678910111213141516public class Singleton &#123; private Singleton()&#123;&#125; private volatile static Singleton instance = null; public static Singleton getInstance() &#123; if(instance == null) &#123; synchronized (Singleton.class) &#123; if(instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 为什么要这样写呢？ 其实这是懒汉式的升级版。懒汉式中所有线程在访问getInstance都会锁住，但实际情况中，很多时候只是读操作，我们没有必要让每个线程都锁住才调用它。 为什么要加volatile呢？ 因为JVM指令可重排，具体可以看看volatile这篇文档 为什么要进行两次非空判断呢？ 第一次校验： 也就是第一个if(singleton&#x3D;&#x3D;null)，这个是为了代码提高代码执行效率，由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getInstance方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。 第二次校验： 也就是第二个if(singleton&#x3D;&#x3D;null)，这个校验是防止二次创建实例，假如有一种情况，当singleton还未被创建时，线程t1调用getInstance方法，由于第一次判断singleton&#x3D;&#x3D;null，此时线程t1准备继续执行，但是由于资源被线程t2抢占了，此时t2页调用getInstance方法。 同样的，由于singleton并没有实例化，t2同样可以通过第一个if，然后继续往下执行，同步代码块，第二个if也通过，然后t2线程创建了一个实例singleton。 此时t2线程完成任务，资源又回到t1线程，t1此时也进入同步代码块，如果没有这个第二个if，那么，t1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。 AtomicReference实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.shjlone.singleton;import java.util.concurrent.atomic.AtomicReference;/** * 使用AtomicReference的单例 */public class AtomicReferenceSingleton &#123; private static final AtomicReference&lt;Object&gt; instance; private AtomicReferenceSingleton() &#123; &#125; static &#123; instance = new AtomicReference&lt;&gt;(); &#125; public static AtomicReferenceSingleton getInstance() &#123; Object value = AtomicReferenceSingleton.instance.get(); if (value == null) &#123; synchronized (AtomicReferenceSingleton.instance) &#123; value = AtomicReferenceSingleton.instance.get(); if (value == null) &#123; final AtomicReferenceSingleton actualValue = new AtomicReferenceSingleton(); value = ((actualValue == null)) ? AtomicReferenceSingleton.instance : actualValue; AtomicReferenceSingleton.instance.set(value); &#125; &#125; &#125; return (AtomicReferenceSingleton)((value == AtomicReferenceSingleton.instance) ? null : value); &#125; public static void main(String[] args) &#123; System.out.println(AtomicReferenceSingleton.getInstance()); System.out.println(AtomicReferenceSingleton.getInstance()); System.out.println(AtomicReferenceSingleton.getInstance()); for(int i=0; i&lt;10; i++) &#123; new Thread() &#123; @Override public void run() &#123; super.run(); System.out.println(AtomicReferenceSingleton.getInstance()); &#125; &#125;.start(); &#125; &#125;&#125; 相较于synchronize，CAS的实现性能更高。 Kotlin的实现方式由于kotlin的语言特性，有些写法还是有别于Java的。 饿汉式1object Singleton &#123;&#125; 对！就是这么简单。以上代码转换成Java后，就是在静态代码块中初始化了Singleton。 懒汉式1234567891011121314151617class Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null get() &#123; if (field == null) &#123; field = Singleton() &#125; return field &#125; fun get(): Singleton &#123; //这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字 return instance!! &#125; &#125;&#125; 线程安全的懒汉式123456789101112131415class Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null get() &#123; if (field == null) field = Singleton() return field &#125; @Synchronized fun instance(): Singleton &#123; return instance!! &#125; &#125;&#125; 双重锁校验12345class Singleton private constructor() &#123; companion object &#123; val instance by lazy &#123; Singleton() &#125; &#125;&#125; 静态内部类的实现123456789101112131415class Singleton private constructor() &#123; companion object &#123; @JvmStatic //方便Java中使用 fun getInstance() &#123; return Holder.instance &#125; &#125; private object Holder &#123; val instance = Singleton() &#125;&#125; 1234enum class Singleton &#123; INSTANCE;&#125; 如何处理反序列化最开始的分析指出，为了不让别人直接new，构造函数需要设置成私有的。除此之外，还可能被反序列化。那么怎么解决这个问题呢？ 1234567public class Singleton implements Serializable &#123; private final static Singleton instance; private Object readResolve() &#123; return instance; &#125;&#125; 这样就行了？可以参考https://www.jianshu.com/p/ea1d9bc40341这篇文章了解原理。 如何防止反射可以在私有构造函数中加一些限制条件，比如判断静态变量是否已经存在了 参考 https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F https://www.jianshu.com/p/ea1d9bc40341 https://blog.csdn.net/c10WTiybQ1Ye3/article/details/108806203 Java设计模式（一）：单例模式，防止反射和反序列化漏洞","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"UML知识","date":"2022-03-08T02:25:29.735Z","path":"wiki/设计模式/UML知识/","text":"继承关系使用带空心箭头带实线 实现关系使用带空心箭头带虚线 聚合关系使用带空心菱形箭头的直线 聚合关系表示实体对象之间的关系，表示整体有部分构成。与组合关系有所不同，整体和部分不是强依赖的。比如：部门撤销了，人员还在。 组合关系使用带实心菱形箭头直线 组合关系是强依赖的，比如：公司不存在了，部门也就不存在了。 关联关系使用带箭头带实线 关联关系是一种静态关系，通常与运行状态无关。关联对象通常是以成员变量的形式实现的 依赖关系使用带箭头带虚线 描述一个对象在运行期间会用到另一个对象的关系。在代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是使用对方的方法和属性 参考 https://test-design-patterns.readthedocs.io/zh/latest/read_uml.html","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"开始学习iOS","date":"2022-03-08T02:25:29.732Z","path":"wiki/程序语言/iOS/开始学习iOS/","text":"由于种种原因，有机会全面接触iOS、Mac、OS X了。这里记录下自己的学习过程。 首先是了解下苹果操作系统的历史，推荐看深入解析Mac OS X &amp; iOS操作系统。要想开发iOS应用，ObjectiveC是一定要学的，Objective-C基础教程、Objective-C编程全解、Objective-C高级编程。对OC有了一定的了解后，就需要开始熟悉iOS系统和开发了，iOS编程（第4版）。 入门之后，就需要掌握更具体的知识点了。 Block绘制机制GCD","tags":[{"name":"iOS","slug":"iOS","permalink":"http://airshu.github.io/tags/iOS/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"iOS","slug":"程序语言/iOS","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/"}]},{"title":"Symfony使用记录","date":"2022-03-08T02:25:29.732Z","path":"wiki/程序语言/PHP/symfony使用记录/","text":"Symfony中请求的流程如何在新接口部署的时候平稳的切换缓存使用php console cache:warmup命令，进行缓存预热，当缓存文件全部生成好后，即可平稳当切换。而不是手动删除缓存文件，待请求来之后再生成缓存。 参考 https://blog.whiteoctober.co.uk/index.html%3Fp=1751.html","tags":[{"name":"PHP","slug":"PHP","permalink":"http://airshu.github.io/tags/PHP/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"}]},{"title":"理解打包流程","date":"2022-03-08T02:25:29.732Z","path":"wiki/程序语言/iOS/理解打包流程/","text":"首先理解一下基本的概念 https://help.apple.com/developer-account 一些常用的名词App ID：Product ID，用于标识一个或一组App。App ID应该和Xcode的Bundle Identifier是一致（Explicit）或匹配（Wildcard）。 Certificates证书用来证明iOS App内容的合法性和完整性。iOS证书分为： Development：用于开发和调试应用程序。 Production（Distribution）：用于分发应用程序。 iOS或Mac系统自动安装AppleWWDRCA.cer这个根证书. IdentifiersDevicesProfiles供应配置文件，其包含的内容：证书、App ID和设备。 Profile也分为Development和Distribution两类，有效期同Certificate一样。Distribution版本的ProvisioningProfile主要用于提交App。 Profile文件的构成大致如下： Name：该mobileprovision的文件名。 UUID：该mobileprovision文件的真实文件名。 TeamName：Apple ID账号名。 TeamIdentifier：Team Identity。 AppIDName：explicit&#x2F;wildcard App ID name（ApplicationIdentifierPrefix）。 ApplicationIdentifierPrefix：完整App ID的前缀（TeamIdentifier.*）。 DeveloperCertificates：包含了可以为使用该配置文件应用签名的所有证书。Keys 证书配置流程 官网新增应用、证书； 下载证书文件（.p12）、配置文件（.mobileprovision）； Mac安装相应证书，Xcode关联配置文件、填写对应bundle ID； 编译脚本1234567891011121314151617181920MWProjectName=&quot;Loneqd&quot;#scheme名字MWScheme=&quot;Loneqd_appstore&quot;#Release还是DebugMWConfiguration=&quot;Release&quot;#日期MWDate=`date +%Y%m%d_%H%M`#工程路径MWWorkspace=&quot;$&#123;WORKSPACE&#125;/src&quot;#build路径MWBuildDir=&quot;/Users/loneqd/alone/Loneqd-for-iOS/build&quot;#导出ipa的配置文件MBPlistName=&quot;/Users/loneqd/alone/Loneqd-for-iOS/lieyou_appstore.plist&quot;xcodebuild archive -workspace &quot;$&#123;WORKSPACE&#125;/src/$MWProjectName.xcworkspace&quot; -scheme &quot;$MWScheme&quot; -configuration &quot;$MWConfiguration&quot; -archivePath &quot;$MWBuildDir/$MWProjectName$MWDate&quot; -quietxcodebuild -exportArchive -archivePath &quot;$MWBuildDir/$MWProjectName$MWDate.xcarchive&quot; -exportPath &quot;$MWBuildDir/$MWProjectName$MWDate&quot; -exportOptionsPlist &quot;$MBPlistName&quot; -quietecho &quot;结束了======&quot;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://airshu.github.io/tags/iOS/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"iOS","slug":"程序语言/iOS","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/"}]},{"title":"reified","date":"2022-03-08T02:25:29.731Z","path":"wiki/程序语言/Kotlin/reified/","text":"参考 推荐使用 Kotlin 关键字 Reified","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://airshu.github.io/tags/Kotlin/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Kotlin","slug":"程序语言/Kotlin","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Kotlin/"}]},{"title":"PHP中opcodes的原理","date":"2022-03-08T02:25:29.731Z","path":"wiki/程序语言/PHP/PHP中opcodes的原理/","text":"PHP代码的生命周期不启用OPcache的流程 启用OPcache的流程 Scanning：将PHP代码转换为语言片段（Tokens） Parsingg：将Tokens转换成简单而有意义的表达式 Compilation：将表达式编译成opcodes Execution:执行opcodes，每次一条，从而实现PHP脚本的功能 opcodes当一个 PHP 文件被解释执行的时候，首先是被编译成名为 opcode （CPU专用的机器语言指令）的中间代码，然后才被底层的虚拟机执行。 如果PHP文件没有被修改过，opcode 始终是一样的。这就意味着编译步骤白白浪费了 CPU 的资源。此时 opcode 缓存就派上用场了。通过将 opcode 缓存在内存中，它能防止冗余的编译步骤，并且在下次调用执行时得到重用。一般执行过程是先检查文件的签名（signature）或者修改时间，以防文件有改动。 PHP 5.5 以后的所有版本都内置了一个 opcode 缓存工具，叫做 Zend OPcache。 根据你所使用的 PHP 安装包&#x2F;发行版的不同，一般情况下是默认开启的，请查看 OPcache.enable phpinfo() 和 phpinfo() 输出的信息确认是否已经开启。 Operate Code：当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码。 OPcacheopcode cache的目地是避免重复编译，减少CPU和内存开销。 PHP配置PHP5.5以上默认有OPcache，如果需要安装，则使用以下脚本： 123456wget http://pecl.php.net/get/zendOPcache-7.0.3.tgztar zxvf zendOPcache-7.0.3.tgz &amp;&amp; cd zendOPcache-7.0.3/usr/local/php/bin/phpize./configure --with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install php.ini配置说明 123456789101112131415161718192021222324252627282930[Zend Opcache]zend_extension = OPcache.so#比较常用的配置OPcache.enable=1 #是否启用操作码缓存OPcache.enable_cli=1 #仅针对CLI环境启用操作码缓存OPcache.revalidate_freq=60 #检查文件的修改的时间周期, 定位为秒，即缓存后60秒去检查代码文件是否被修改过OPcache.fast_shutdown=1 #打开快速关闭, 一次释放全部请求变量的内存，打开这个在PHP Request Shutdown的时候回收内存的速度会提高;OPcache.error_log=&quot;&quot; #OPcache模块的错误日志文件;OPcache.log_verbosity_level=1 #将错误信息写入到服务器的日志级别。致命（0）错误（1) 警告（2）信息（3）调试（4）#其它不常用的配置OPcache.memory_consumption=128 #共享内存大小，单位MBOPcache.interned_strings_buffer=8 #存储临时字符串的内存大小，单位MBOPcache.max_accelerated_files=4000 #哈希表中可存储的脚本文件数量上限;OPcache.max_wasted_percentage=5 #浪费内存的上限，以百分比计;OPcache.use_cwd=1 #附加改脚本的工作目录,避免同名脚本冲突OPcache.validate_timestamps=1 #每隔revalidate_freq 设定的秒数 检查脚本是否更新;OPcache.revalidate_path=0 #如果禁用此选项，在同一个 include_path 已存在的缓存文件会被重用;OPcache.save_comments=1 #禁用后将也不会加载注释内容OPcache.enable_file_override=0 #如果启用，则在调用函数file_exists()， is_file() 以及 is_readable() 的时候， 都会检查操作码缓存;OPcache.optimization_level=0xffffffff #控制优化级别的二进制位掩码。;OPcache.inherited_hack=1 #PHP 5.3之前做的优化;OPcache.dups_fix=0 #仅作为针对 “不可重定义类”错误的一种解决方案。;OPcache.blacklist_filename=&quot;&quot; #黑名单文件为文本文件，包含了不进行预编译优化的文件名;OPcache.max_file_size=0 #以字节为单位的缓存的文件大小上限;OPcache.consistency_checks=0 #如果是非 0 值，OPcache 将会每隔 N 次请求检查缓存校验和OPcache.force_restart_timeout=180 #如果缓存处于非激活状态，等待多少秒之后计划重启。;OPcache.preferred_memory_model=&quot;&quot; #OPcache 首选的内存模块。可选值包括： mmap，shm, posix 以及 win32。;OPcache.protect_memory=0 #保护共享内存，以避免执行脚本时发生非预期的写入。 仅用于内部调试。;OPcache.mmap_base=null #在Windows 平台上共享内存段的基地址 监测OPcache 可视化显示：https://github.com/PeeHaa/OpCacheGUI **简易的显示缓存信息(PHP7+)**：https://github.com/rlerdorf/opcache-status 相关PHP的API使用12345opcache_is_script_cached(string $filename):bool 是否缓存opcache_get_configuration(): array 获取缓存的配置信息opcache_invalidate(string $script , boolean $force = false):boolean 废除脚本缓存opcache_reset():boolean 重置字节码缓存的内容 参考 Understanding OPCode OPcache运行时配置 PHP Opcache工作原理 PHP内核探索：操作码OpCode OPcache安装配置及链接生效配置 OPcache 函数 Opcode是啥以及如何使用好Opcache","tags":[{"name":"PHP","slug":"PHP","permalink":"http://airshu.github.io/tags/PHP/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"}]},{"title":"C++学习笔记","date":"2022-03-08T02:25:29.729Z","path":"wiki/程序语言/C++/C++学习笔记/","text":"函数重载（Function Overloading）定义：函数名相同，函数的参数列表包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。 12345// 解析XML字符串的函数族，支持int、char *和double三种类型。// 返回值：0-成功，-1-失败。int GetXMLBuffer(const char *in_XMLBuffer,const char *in_FieldName,int *out_Value);int GetXMLBuffer(const char *in_XMLBuffer,const char *in_FieldName,char *out_Value);int GetXMLBuffer(const char *in_XMLBuffer,const char *in_FieldName,double *out_Value); C++编译器在编译的时候会根据参数列表的类型对函数进行重命名，比如： 1int GetXMLBuffer_char_char_int(const char *in_XMLBuffer,const char *in_FieldName,int *out_Value); 结构体新特征在C++中，结构体的成员可以有函数。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct st_girl &#123; char name[50]; // 姓名 int age; // 年龄 int height; // 身高，单位：厘米cm char sc[30]; // 身材，火辣；普通；飞机场。 char yz[30]; // 颜值，漂亮；一般；歪瓜裂枣。 int show(); // 声明结构体成员函数show，用于显示其它成员变量的值。&#125;;int main() &#123; st_girl stgirl; // struct关键定可以不书写 memset(&amp;stgirl, 0, sizeof(stgirl)); strcpy(stgirl.name, &quot;西施&quot;); stgirl.age = 22; stgirl.height = 168; strcpy(stgirl.sc, &quot;火辣&quot;); strcpy(stgirl.yz, &quot;漂亮&quot;); stgirl.show(); // 调用结构体的成员函数&#125;int st_girl::show() // 结构体st_girl成员函数的定义&#123; printf(&quot;name=%s,age=%d,height=%d,sc=%s,yz=%s\\n&quot;, name, age, height, sc, yz);&#125; 类详解构造函数 构造函数必须是 public 属性。 构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。 构造函数可以有参数，允许重载。一个类可以有多个重载的构造函数，创建对象时根据传递的参数来判断调用哪一个构造函数。 构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，对成员变量进行初始化等，注意，不能用memset对整个类进行初始化。 析构函数 析构函数必须是 public 属性的。 析构函数没有参数。 析构函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。 析构函数不允许重载的。一个类只能有一个析构函数。 1234567891011121314151617181920212223242526272829303132//头文件class CFile&#123;private: FILE *m_fp; // 文件指针 bool m_bEnBuffer; // 是否启用缓冲区，true-启用；false-不启用 public: CFile(); // 类的构造函数 CFile(bool bEnBuffer); // 类的构造函数 ~CFile(); // 类的析构函数 void EnBuffer(bool bEnBuffer=true); // 启、禁用缓冲区 // 打开文件，参数与fopen相同，打开成功true，失败返回false bool Open(const char *filename,const char *openmode); // 调用fprintf向文件写入数据 void Fprintf(const char *fmt, ... ); // 调用fgets从文件中读取一行 bool Fgets(char *strBuffer,const int ReadSize); // 关闭文件指针 void Close();&#125;; 12345678910111213141516171819//实现文件CFile::CFile() // 类的构造函数&#123; m_fp=0; m_bEnBuffer=true;&#125; CFile::CFile(bool bEnBuffer) // 类的构造函数&#123; m_fp=0; m_bEnBuffer=bEnBuffer; &#125;CFile::~CFile() // 类的析构函数&#123; Close(); // 调用Close释放资源&#125; C++引用引用就是变量的别名，对引用的操作与对变量直接操作完全一样。 12345//数据类型 &amp;引用名=目标变量名；int ii;int &amp;rii=ii; // 定义引用rii，它是变量ii的引用，即别名。rii=1; 等价于 ii=1; &amp;在此不是求地址运算，而是声明引用。 数据类型可以是C语言的基本数据类型，也可以是结构体和类等构造类型。 引用在声明的时候必须对其进行初始化（指向目标变量名），否则编译器会报错。 引用初始化之后，不能再用作其他变量名的别名。 引用声明后，相当于目标变量名有两个名称。 不能建立数组的引用，因为数组是多个变量的集合。 引用可以用const修饰，表示只读，用这种方式声明的引用，不能通过引用名对目标变量的值进行修改。 运算符重载123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt; class CGirl // 定义类&#123;public: char m_name[50]; // 姓名 char m_sc[30]; // 身材，火辣；普通；飞机场。 bool operator==(const CGirl &amp;Girl); // 重载==运算符&#125;; int main()&#123; CGirl Girl1,Girl2; strcpy(Girl1.m_name,&quot;西施&quot;); strcpy(Girl2.m_name,&quot;东施&quot;); if (Girl1 == Girl2) printf(&quot;Girl1和Girl2是同一个人。\\n&quot;); else printf(&quot;Girl1和Girl2不是同一个人。\\n&quot;);&#125; bool CGirl::operator==(const CGirl &amp;Girl) // 重载==运算符&#123; // 如果两个类的姓名相同，就相等 if (strcmp(m_name,Girl.m_name)== 0) return true; return false;&#125; string类123456789101112131415#include &lt;string&gt;//string是一个模板类，位于std命名空间内，为方便使用还需要在程序中增加：using namespace std; // 指定缺省的使名空间。string str; // 创建string对象。//如果不指定命名空间std::string str;const char *c_str();//c_str函数返回这个字符串的地址int size(); // 返回当前字符串的大小。int length(); // 返回当前字符串的长度，注意和size的区别。void clear(); // 清空字符串。 vector类12345678910111213141516171819202122232425262728iterator begin()：返回容器头的指针，指向容器第一个元素的位置。iterator end()：返回容器尾的指针，指向容器最后一个元素的下一个位置。void push_back(const T&amp; x)：向容器的尾部增加一个元素x。iterator insert(iterator it,const T&amp; x)：向容器中指定位置（it）前插入一个元素x。iterator erase(iterator it)：删除容器中指定位置（it）的元素。bool empty()：判断容器是否为空。int size()：返回容器中元素的个数。sort(begin,end,cmp);/**sort函数包含在头文件为#include &lt;algorithm&gt;的c++标准库中，调用排序方法不必知道其内部是如何实现的，只要出现我们想要的结果就行。sort函数有三个参数：（1）第一个是要排序的数组的起始地址。（2）第二个是结束的地址。（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时缺省的排序方法是从小到大排序。如果vector容器中元素的数据类型不是基本数据类型，sort函数必须指定排序方法函数。**/ C++动态内存123456789101112datatype *pointer = new datatype; // 其它代码delete pointer;//datatype可以是C语言的基本数据类型，也可以是结构体，还可以是类。//pointer是一个指针，指向new返回的地址。int *pi= new int; // 动态分配一个整数大小的内存(*pi)=10;delete pi; // 释放pi指向的内存 继承和派生123456789101112class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&#123; // 派生类类体&#125;;class CGirl // 定义超女类&#123;&#125;class CKCon:public CGirl // 定义王妃类，从超女类继承&#123;&#125; 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种方式，当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当类派生以public方式继承时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当类派生以protected方式继承时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当类派生以private方式继承时，基类的公有和保护成员将成为派生类的私有成员。 多态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;string.h&gt;class CGirl // 定义超女类&#123;public: char m_name[50]; // 姓名 int m_age; // 年龄 int m_height; // 身高，单位：厘米cm char m_sc[30]; // 身材，火辣；普通；飞机场。 char m_yz[30]; // 颜值，漂亮；一般；歪瓜裂枣。 int Show() // 显示超女基本信息的成员函数体 &#123; printf(&quot;CGirl 姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s\\n&quot;, m_name, m_age, m_height, m_sc, m_yz); &#125;&#125;;class CKCon : public CGirl // 定义王妃类，从超女类继承&#123;public: char m_ch[50]; // 称号 char m_palace[50]; // 居住的宫殿 int m_sal; // 奉禄 int Show() // 显示王妃的称号、宫殿和奉禄 &#123; printf(&quot;CKCon 姓名：%s，称号：%s，栖：%s，奉禄：%d两银子。\\n&quot;, m_name, m_ch, m_palace, m_sal); &#125;&#125;;int main() &#123; CKCon KCon; strcpy(KCon.m_name, &quot;杨玉环&quot;); KCon.m_age = 28; KCon.m_height = 168; strcpy(KCon.m_sc, &quot;火辣&quot;); strcpy(KCon.m_yz, &quot;漂亮&quot;); strcpy(KCon.m_ch, &quot;杨贵妃&quot;); strcpy(KCon.m_palace, &quot;华清宫&quot;); KCon.m_sal = 10000; CGirl *pGirl; // 基类的指针 CKCon *pCon; // 派生类的指针 pGirl = pCon = &amp;KCon; // 都指向派生类 pGirl-&gt;Show(); // 将调用的是基类的Show方法 pCon-&gt;Show(); // 将调用的是派生类的Show方法&#125; 动态多态 动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。在CGirl类中，Show方法的声明前放置关键字 virtual，则pGirl-&gt;Show()会打印出CKCon中的show方法内容。 虚函数 虚函数是在基类中使用关键字 virtual 声明的函数，在派生类中重新定义虚函数。我们想要的是在程序中可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 纯虚函数 只声明，具体实现在派生类中实现 1234567891011class CGirl // 定义超女类&#123;public: char m_name[50]; // 姓名 int m_age; // 年龄 int m_height; // 身高，单位：厘米cm char m_sc[30]; // 身材，火辣；普通；飞机场。 char m_yz[30]; // 颜值，漂亮；一般；歪瓜裂枣。 virtual int Show()=0; // 申明一个纯虚函数。&#125;;","tags":[{"name":"C++","slug":"C","permalink":"http://airshu.github.io/tags/C/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"C语言学习笔记","date":"2022-03-08T02:25:29.729Z","path":"wiki/程序语言/C++/C语言学习笔记/","text":"Hello World1234567891011121314//文件名hello.c//预处理指令#include &lt;stdio.h&gt;//入口函数int main() &#123; printf(&quot;hello world&quot;); return 0;&#125;gcc hello.c./a.out //输出hello world C语言数据类型 字符型（char）：描述单个字符（一个字节），用半角的单引号包含起来，如’a’、’A’、’1’、’$’等，键盘能输入的英文和半角的符号都是字符。中文的汉字和标点符号是两个字节（GBK编码），不能算一个字符。 整型（int）：描述整数。 浮点型（float）：描述实数。 字符串：描述多个字符，用半角的双引号包含起来，可以是英文、数字、中文、标点符号，半角全角的都可以。 结构体（struct）：由基本类型通过一定的构造方法构造出来的类型，包括数组和结构体。 指针类型：指针可以存放内存变量和常量地址。 其他类型：如复数类型（_Complex）、虚数类型（_Imaginary）、布尔型（_bool）等。 变量变量的命名变量名属于标识符，需要符合标识符的命名规范，具体如下： 变量名的第一个字符必须是字母或下划线，不能是数字和其它字符。 变量名中的字母是区分大小写的。比如a和A是不同的变量名，num和Num也是不同的变量名。 变量名绝对不可以是C语言的关键字。 变量的定义和初始化变量在定义后，操作系统为它分配了一块内存，但并不会把这块内存打扫干静，也就是说内存中可能有垃圾数据，建议在使用之间对其初始化（打扫干静）。 1234567891011121314151617181920212223242526int ii; // 定义整数型变量，用于存放整数。char cc; // 定义字符型变量，用于存放字符。double money; // 定义浮点型变量，用于存放浮点数。char name[21]; // 定义一个可以存放20字符的字符串。//对整数型、字符型、浮点型变量来说，初始化就是给它们赋0值。int ii=0; // 定义整数型变量并初始化char cc=0; // 定义字符型变量并初始化double money=0; // 定义浮点型变量并初始化 //也可以先定义，然后再初始化。int ii; // 定义整数型变量char cc; // 定义字符型变量double money; // 定义浮点型变量ii=0; // 初始化ii为0cc=0; // 初始化cc为0money=0; // 初始化money为0//对字符串变量来说，初始化就是把内容清空，本质上也是赋0值。char name[21]; // 定义一个可以存放20字符的字符串memset(name,0,sizeof(name)); // 清空字符串name中的内容//声明常量const double pi = 3.1415926; C语言中的关键字1234567891011121314151617181920212223242526272829303132auto：声明自动变量break：跳出当前循环case：开关语句分支char：声明字符型变量或函数返回值类型const：声明只读变量continue：结束当前循环，开始下一轮循环default：开关语句中的“默认”分支do：循环语句的循环体double：声明双精度浮点型变量或函数返回值类型else：条件语句否定分支（与if连用）enum：声明枚举类型extern：声明变量或函数是在其它文件或本文件的其他位置定义float：声明浮点型变量或函数返回值类型for：一种循环语句goto：无条件跳转语句if：条件语句int：声明整型变量或函数long：声明长整型变量或函数返回值类型register：声明寄存器变量return：子程序返回语句（可以带参数，也可不带参数）short：声明短整型变量或函数signed：声明有符号类型变量或函数sizeof：计算数据类型或变量长度（即所占字节数）static：声明静态变量struct：声明结构体类型switch：用于开关语句typedef：用以给数据类型取别名unsigned：声明无符号类型变量或函数union：声明共用体类型void：声明函数无返回值或无参数，声明无类型指针volatile：说明变量在程序执行中可被隐含地改变while：循环语句的循环条件 输入和输出12345678910111213141516171819202122232425262728293031getchar：输入单个字符，保存到字符变量中。gets：输入一行数据，保存到字符串变量中。scanf：格式化输入函数，一次可以输入多个数据，保存到多个变量中。putchar：输出单个字符。puts：输出字符串。printf：格式化输出函数，可输出常量、变量等。int age=18;char xb=&#x27;x&#x27;;double weight=62.5;char name[21];memset(name,0,sizeof(name));strcpy(name, &quot;西施&quot;);printf(&quot;我的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\\n&quot;,name,xb,age,weight);int age=0;char xb=0;double weight=0;char name[21];memset(name,0,sizeof(name));printf(&quot;请输入您的姓名、姓别（x-男；y-女），年龄和体重，中间用空格分隔：&quot;);scanf(&quot;%s %c %d %lf&quot;,name,&amp;xb,&amp;age,&amp;weight); printf(&quot;您的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\\n&quot;,name,xb,age,weight); 运算符 算术运算符； 赋值运算符； sizeof运算符； 关系运算符； 逻辑运算符； 位运算符。 算术运算符 运算符 描述 实例 + 两个数相加 A+B 将得到 23 - 一个数减另一个数 A-B 将得到 13 * 两个数相乘 A*B 将得到 90 &#x2F; 分子除以分母 A&#x2F;B 将得到 3.6 % 余数运算符，整除后的余数 B%A 将得到 3 ++ 自增运算符，整数值增加 1 A++ 将得到 19 – 自减运算符，整数值减少 1 A– 将得到 17 赋值运算符 运算符 描述 实例 &#x3D; 简单的赋值运算符，把右边操作数的值赋给左边操作数 C &#x3D; A + B 将把 A + B 的值赋给 C +&#x3D; 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C +&#x3D; A 相当于 C &#x3D; C + A -&#x3D; 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -&#x3D; A 相当于 C &#x3D; C - A *&#x3D; 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *&#x3D; A 相当于 C &#x3D; C * A &#x2F;&#x3D; 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A %&#x3D; 求余数且赋值运算符，求两个操作数的模赋值给左边操作数，浮点数不适用取余数。 C %&#x3D; A 相当于 C &#x3D; C % A sizeof运算符用来计算变量（或数据类型）在当前系统中占用内存的字节数。sizeof不是函数，产生这样的疑问是因为sizeof的书写确实有点像函数，sizeof有两种写法： 1234567891011121314//用于数据类型，数据类型必须用括号括住。sizeof(数据类型);printf(&quot;字符型变量占用的内存是=%d\\n&quot;,sizeof(char)); // 输出：字符型变量占用的内存是=1printf(&quot;整型变量占用的内存是=%d\\n&quot;,sizeof(int)); // 输出：整型变量占用的内存是=4//用于变量sizeof(变量名);sizeof 变量名;int ii;printf(&quot;ii占用的内存是=%d\\n&quot;,sizeof(ii)); // 输出：ii占用的内存是=4printf(&quot;ii占用的内存是=%d\\n&quot;,sizeof ii); // 输出：ii占用的内存是=4 关系运算符 关系 数学中的表示 C语言的表示 小于 &lt; &lt; 小于等于 ≤ &lt;&#x3D; 大于 &gt; &gt; 大于等于 ≥ &gt;&#x3D; 等于 &#x3D; &#x3D;&#x3D; 不等于 ≠ !&#x3D; 逻辑运算符 运算符 描述 实例 &amp;&amp; 逻辑与 true &amp;&amp; false 等于false || 逻辑或 true &amp;&amp; false 等于true ! 逻辑非 true的逻辑非为真 三目运算符 表达式1?表达式2:表达式3; 先执行表达式1，如果表达式1的结果如果为真，那么执行表达式2，并且这个整体的运算式的结果是表达式2的结果；如果表达式1的结果如果为假，执行表达式3，运算式的结果是表达式3的结果。 12int year;year=(year%100==0)?(year%400==0?1:0):(year%4==0?1:0); if、switch语句1234567891011121314151617if(表达式)&#123;&#125; else &#123;&#125;switch (表达式)&#123;case 整型数值1: 语句1;case 整型数值2: 语句2;......case 整型数值n: 语句n;default: 语句n+1;&#125;//注意//1. case后面必须是整数和字符，或者是结果为整数和字符的表达式，但不能包含任何变量//2. default不是必须的。当没有 default时，如果所有case都匹配失败，那么就什么都不执行。 程序结构while循环123456789101112131415161718192021222324252627282930while (表达式)&#123; if(表达式)语句块; if(表达式)break;//跳出当前循环 if(表达式)continue; //跳转到循环的首部&#125;do&#123; 语句块&#125; while (表达式)int times=0; // 记录用户输入数据的次数int value=0; // 用户每次从键盘输入的数据int sum=0; // 记录用户输入数据的和while (sum&lt;5000) // 如果sum的值小于5000，进入循环&#123;printf(&quot;请输入数字：&quot;); // 提示用户输入scanf(&quot;%d&quot;,&amp;value); // 接受用户从键盘输入的数据times++; // 用户输入数据的次数自增1sum=sum+value; // 记录用户输入数据的和&#125;printf(&quot;您一共输入了%d个数据，和为%d。\\n&quot;,times,sum); for循环12345for (语句1;表达式;语句2) &#123; 语句块 &#125; for循环开始时，会先执行语句1，而且在整个循环过程中只执行一次语句1。 接着判断表达式的条件，如果条件成立，就执行一次循环体中的语句块。 语句块执行完后，接下来会执行语句2。 重复第2）步和第3），直到表达式的条件不成立才结束for循环。 注意： 在for循环中，语句1、表达式和语句2都可以为空，for (;;)等同于while (1)。 continue和break两个关键字也可以用在for循环体中。 123456789int ii=1; // 用于for循环的计数器 int sum=0; // 记录1到100的累积值 for (ii=1;ii&lt;=100;ii++) &#123; sum=sum+ii; &#125; printf(&quot;1到100的累积值为%d。\\n&quot;,sum); 数组数组（array）是一组数据类型相同的变量，可以存放一组数据，它定义的语法是： 数据类型 数组名[数组长度]; 定义数组的时候，数组的长度必须是整数，可以是常量，也可以是变量。数据的下标也必须是整数，可以是常量，也可以是变量。 1234567int ii[10]; // 定义一个整型数组变量printf(&quot;sizeof(ii)=%d\\n&quot;,sizeof(ii)); // 输出结果：sizeof(ii)=40//数组初始化int no[10];memset(no,0,sizeof(no)); //第一个参数是数组名，第二个参数填0，第三个参数是数组占用的内存总空间，用sizeof(变量名)获取。 二维数组 数据类型 数组名[第一维的长度][第二维的长度]; 1234567891011121314151617181920int ii=0; // 用于组别循环的计数器int jj=0; // 用于超女人数循环的计数器int class=3; // 小组总数，初始化为3int total=5; // 每个组超女的总人数，初始化为5double weight[class][total]; // 定义二维数组，存放超女的体重double sum[class]; // 定义一维数组存放超女体重的和memset(weight,0,sizeof(weight)); // 初始化数组为0memset(sum,0,sizeof(sum)); // 初始化数组为0// 采用两个循环，第一级循环为小组数，第二级循环为超女人数for (ii=0;ii&lt;class;ii++)&#123;for (jj=0;jj&lt;total;jj++)&#123; printf(&quot;请输入第%d组第%d名超女的体重：&quot;,ii+1,jj+1); scanf(&quot;%lf&quot;,&amp;weight[ii][jj]); // 接受从键盘输入的体重 sum[ii]=sum[ii]+weight[ii][jj]; // 计算小组超女体重的和&#125;&#125; 字符串字符串就是一个以空字符’\\0’结束的字符数组，是一个特别的字符数组，这是约定，是规则。空字符’\\0’也可以直接写成0。 1234567891011121314151617//初始化， 因为字符串需要用0结束，所以在定义字符串的时候，要预留多一个字节来存放0。char name[21]; // 定义一个最多存放20个字符或10个汉字的字符串//字符串是数组，当然可以用初始化数组的方法来初始化字符串。memset(strname,0,sizeof(strname));//字符串的赋值strcpy(strword,&quot;hello&quot;);// 或者用以下代码char strword[21];memset(strword,0,sizeof(strword));strword[0]=&#x27;h&#x27;;strword[1]=&#x27;e&#x27;;strword[2]=&#x27;l&#x27;;strword[3]=&#x27;l&#x27;;strword[4]=&#x27;o&#x27;;strword[5]=&#x27;\\0&#x27;; // 或者 name[5]=0; 函数函数声明 return_type function_name( parameter list ); 返回值的数据类型return_type：函数执行完任务后的返回值，可以是int、char、double或其它自定义的数据类型。如果函数只执行任务而不返回值，return_type用关键字 void表示，如下： 1void function_name( parameter list ); 函数名function_name：函数名是标识符，命名规则与变量相同。 参数列表parameter list：当函数被调用时，调用者需要向函数传递参数。参数列表包括参数的数据类型和书写顺序。参数列表是可选的，也就是说，函数可以没有参数，如下： 1return_type function_name(); 函数定义12345//函数定义的return_type、function_name和parameter list必须与函数声明一致。return_type function_name( parameter list ) // 注意，不要在函数定义的最后加分号。 &#123; // 实现函数功能的代码 &#125; 注意： #include &lt;&gt; 用于包含系统提供的头文件，编译的时候，gcc在系统的头文件目录中寻找头文件。 #include “” 用于包含程序员自定义的头文件，编译的时候，gcc先在当前目录中寻找头文件，如果找不到，再到系统的头文件目录中寻找。 库函数C语言标准库函数的声明的头文件存放在&#x2F;usr&#x2F;include目录中，如下： 123&lt;asset.h&gt; &lt;ctype.h&gt; &lt;errno.h&gt; &lt;float.h&gt; &lt;limits.h&gt;&lt;locale.h&gt; &lt;math.h&gt; &lt;setjmp.h&gt; &lt;signal.h&gt; &lt;stdarg.h&gt;&lt;stddef.h&gt; &lt;stdlib.h&gt; &lt;stdio.h&gt; &lt;string.h&gt; &lt;time.h&gt; 变量的作用域作用域是程序中定义的变量存在（或生效）的区域，超过该区域变量就不能被访问。C 语言中有四种地方可以定义变量。 在所有函数外部定义的是全局变量。 在头文件中定义的是全局变量。 在函数或语句块内部定义的是局部变量。它们只能在该函数或语句块内部的语句使用。 函数的参数是该函数的局部变量。 注意 局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，就会屏蔽全局变量而使用局部变量。 指针变量 内存变量简称变量，在C语言中，每定义一个变量，系统就会给变量分配一块内存，而内存是有地址的。如果把计算机的内存区域比喻成一个大宾馆，每块内存的地址就像宾馆房间的编号。 12345678 int ii=10; char cc=&#x27;A&#x27;; double dd=100.56;//在printf函数中，输出内存地址的格式控制符是%p，地址采用十六进制的数字显示。 printf(&quot;变量ii的地址是：%p\\n&quot;,&amp;ii); printf(&quot;变量cc的地址是：%p\\n&quot;,&amp;cc); printf(&quot;变量dd的地址是：%p\\n&quot;,&amp;dd); 指针 指针是一种特别变量，全称是指针变量，专用于存放其它变量在内存中的地址编号，指针在使用之前要先声明，语法是： 123456789101112131415161718192021222324252627282930313233343536datatype *varname;datatype 是指针的基类型，它必须是一个有效的C数据类型（int、char、double或其它自定义的数据类型），varname 是指针的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。int *ip; // 一个整型的指针char *cp; // 一个字符型的指针double *dp; // 一个 double 型的指针int ii = 10;int *pii = 0; // 定义整数型指针并初始化pii = &amp;ii; // 数型指针指向变量ii// 通过指针操作内存变量，改变内存变量的值*pii = 20; // 同ii=20;printf(&quot;pii的值是：%p\\n&quot;, pii);printf(&quot;*pii的值是：%d\\n&quot;, *pii);printf(&quot;ii的值是：%d\\n&quot;, ii);//空指针int *pi=0; // 定义一个指针*pi=10; // 试图对空指针进行赋值操作，必将引起程序的崩溃//地址的运算char cc[4]; // 字符数组int ii[4]; // 整数数组double dd[4]; // 浮点数组// 用地址相加的方式显示数组全部元素的的址printf(&quot;%p %p %p %p\\n&quot;,cc,cc+1,cc+2,cc+3);printf(&quot;%p %p %p %p\\n&quot;,ii,ii+1,ii+2,ii+3);printf(&quot;%p %p %p %p\\n&quot;,dd,dd+1,dd+2,dd+3);//指针也是一种内存变量，是内存变量就要占用内存空间，在C语言中，任何类型的指针占用8字节的内存（32位操作系统4字节）。printf(&quot;sizeof(int *) is %d.\\n&quot;,sizeof(int *)); // 输出：sizeof(int *) is 8printf(&quot;sizeof(char *) is %d.\\n&quot;,sizeof(char *)); // 输出：sizeof(char *) is 8printf(&quot;sizeof(double *) is %d.\\n&quot;,sizeof(double *)); // 输出：sizeof(double *) is 8 整数在定义整型变量的时候，可以在int关键字之前加signed、unsigned、short和long四种修饰符。 signed：有符号的，可以表示正数和负数。 unsigned：无符号的，只能表示正数，例如数组的下标、人的身高等。 short：短的，现在主流的64位操作系统下，整数占用内存4个字节。 long：长的，更长的整数。 整数的取值范围整数的取值范围与计算机操作系统和C语言编译器有关，没有一个固定的数值，我们可以根据它占用的内存大小来推断它的取值范围。 12345678910111213一个字节有8个位，表示的数据的取值范围是28-1，即255。如果占用的内存是两个字节，无符号型取值范围是2**8ⅹ2**8-1。如果占用的内存是四个字节，无符号型取值范围是2**8ⅹ2**8ⅹ2**8ⅹ2**8-1。如果占用的内存是八个字节，无符号型取值范围是2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8-1。如果是有符号，取值范围减半，因为符号占一个位。short si; // 短整数int ii; // 整数long li; // 长整数printf(&quot;sizeof short is %d\\n&quot;,sizeof(short));printf(&quot;sizeof int is %d\\n&quot;,sizeof(int));printf(&quot;sizeof long is %d\\n&quot;,sizeof(long)); 类型简写 类型全称 长度 取值范围 short [signed] short [int] 2字节 -32768~32767 unsigned short unsigned short [int] 2字节 0~65535 int [signed] int 4字节 -2147483648~2147483647 unsigned int unsigned [int] 4字节 0~4294967295 long [signed] long [int] 8字节 -9223372036854775808~9223372036854775807 unsigned long unsigned long [int] 8字节 0~18446744073709551615 注意： 计算机用最高位1位来表达符号（0-正数，1-负数），unsigned修饰过的正整数不需要符号位，在表达正整数的时候比signed修饰的正整数取值大一倍。 在写程序的时候，上表中括号[]的单词可以省略不书写。 在写程序的时候，给整数变量赋值不能超出变量的取值范围，编译的时候会出现类似以下的错误，程序运行也可能产生不可预后的后果。 常用的库函数 1234int atoi(const char *nptr); // 把字符串nptr转换为int整数long atol(const char *nptr); // 把字符串nptr转换为long整数int abs(const int j); // 求int整数的绝对值long labs(const long int j); // 求long整数的绝对值 数据类型的别名 12typedef unsigned int size_t;size_t ii; 等同于 unsigned int ii; 类型转换自动类型转换整型类型级别从低到高依次为： signed char-&gt;unsigned char-&gt;short-&gt;unsigned short-&gt;int-&gt;unsigned int-&gt;long-&gt;unsigned long 浮点型级别从低到高依次为： float-&gt;double 操作数中没有浮点型数据时 当 char、unsigned char、short 或 unsigned short 出现在表达式中参与运算时，一般将其自动转换为 int 类型。int 与 unsigned int混合运算时，int自动转换为unsigned int型。int、unsigned int 与 long 混合运算时，均转换为 long 类型。 操作数中有浮点型数据时 当操作数中含有浮点型数据时，所有操作数都将转换为 double 型。 赋值运算符两侧的类型不一致时 当赋值运算符的右值（可能为常量、变量或表达式）类型与左值类型不一致时，将右值类型提升&#x2F;降低为左值类型。 右值超出左值类型范围时 赋值运算符右值的范围超出了左值类型的表示范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。 强制类型转换 (目标类型) 表达式; 结构体结构体（struct）来存放一组不同类型的数据。语法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct 结构体名&#123; 结构体成员变量一的声明; 结构体成员变量二的声明; 结构体成员变量三的声明; ...... 结构体成员变量四的声明;&#125;;struct st_girl&#123; char name[51]; // 姓名 int age; // 年龄 int height; // 身高，单位：cm int weight; // 体重，单位：kg char sc[31]; // 身材，火辣；普通；飞机场 char yz[31]; // 颜值，漂亮；一般；歪瓜裂枣&#125;;//结构体是一种程序员自定义的数据类型，是模板，可以用它来定义变量struct st_girl queen, princess, waiting, workers;struct st_girl queen;printf(&quot;sizeof(struct st_girl) %d\\n&quot;,sizeof(struct st_girl));printf(&quot;sizeof(queen) %d\\n&quot;,sizeof(queen)); //C语言提供了结构体成员内存对齐的方法，在定义结构体之前，增加以下代码可以使结构体成员变量之间的内存没有空隙。#pragma pack(1)//和数组不一样，结构体变量名不是结构体变量的地址，结构体变量名就是变量名，就象int ii一样，只是不能直接输出，直接输出没有意义。取地址要用&amp;struct st_girl stgirl;printf(&quot;%d\\n&quot;,stgirl); // 没有意义。printf(&quot;%p\\n&quot;,stgirl); // 没有意义，结构体变量名不是结构体变量的地址。printf(&quot;%p\\n&quot;,&amp;stgirl); // 这才是结构体的地址。//结构体的初始化memset(&amp;queen,0,sizeof(struct st_girl));//或memset(&amp;queen,0,sizeof(queen));//注意事项，如果把一个结构体的地址传给子函数，子函数用一个结构体指针（如struct st_girl *pst）来存放传入的结构体的地址，那么，在子函数中只能用以下方法来初始化结构体memset(pst,0,sizeof(struct st_girl));//结构体指针struct st_girl queen;struct st_girl *pst=&amp;queen; //结构体指针使用成员变量(*pointer).memberNamepointer-&gt;memberName//结构体复制struct st_girl girl1,girl2;strcpy(girl1.name,&quot;西施&quot;); // 对girl1的成员赋值girl1.age=18;memcpy(&amp;girl2,&amp;girl1,sizeof(struct st_girl));//结构体是多个变量集合，作为函数参数时就可以传递整个集合，也就是所有成员。如果结构体成员较多，函数参数的初始化和赋值的内存开销会很大，影响程序的运行效率。所以最好的办法就是传递结构体变量的地址。// 对结构体赋值的函数void setvalue(struct st_girl *pst);struct st_girl queen; // 定义结构体变量 // 初始化结构体变量memset(&amp;queen,0,sizeof(struct st_girl)); 格式化输出1234567int printf(const char *format, ...);int sprintf(char *str, const char *format, ...);int snprintf(char *str, size_t size, const char *format, ...);//printf是把结果输出到屏幕，sprintf把格式化输出的内容保存到字符串str中，snprintf的n类似于strncpy中的n，意思是只获取输出结果的前n-1个字符，不是n个字符。 格式说明符 %[flags][width][.prec]type 类型符type：表示输出数据的类型 %hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数。 %hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数 %c 输出字符。 %lf 以普通方式输出double（float弃用，long doube无用）。 %e 以科学计数法输出double。 %s 输出字符串。 %p 输出内存的地址。 宽度width：用于控制输出内容的宽度 123printf(&quot;=%12s=\\n&quot;,&quot;abc&quot;); // 输出= abc=printf(&quot;=%12d=\\n&quot;,123); // 输出= 123=printf(&quot;=%12lf=\\n&quot;,123.5); // 输出= 123.500000= 对其标志flags：用于控制输出内容的对齐方式 不填或+：输出的内容右对齐，这是缺省的方式 -：输出的内容左对齐。 12345678printf(&quot;=%-12s=\\n&quot;,&quot;abc&quot;); // 输出=abc =printf(&quot;=%-12d=\\n&quot;,123); // 输出=123 =printf(&quot;=%-12f=\\n&quot;,123.5); // 输出=123.500000 =printf(&quot;=%012s=\\n&quot;,&quot;abc&quot;); // 输出= abc=printf(&quot;=%012d=\\n&quot;,123); // 输出=000000000123=printf(&quot;=%012f=\\n&quot;,123.5); // 输出=00123.500000= 精度prec：如果输出的内容是浮点数，它用于控制输出内容的精度，也就是说小数点后面保留多少位，后面的数四舍五入。 1234printf(&quot;=%12.2lf=\\n&quot;,123.5); // 输出= 123.50=printf(&quot;=%.2lf=\\n&quot;,123.5); // 输出=123.50=printf(&quot;=%12.2e=\\n&quot;,123500000000.0); // 输出= 1.24e+11=printf(&quot;=%.2e=\\n&quot;,123500000000.0); // 输出=1.24e+11= main函数12345678910int main(int argc,char *argv[],char *envp[])//int argc，存放了命令行参数的个数。//char *argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。//char *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。//envp存放了当前程序运行环境的参数。 动态内存管理1234567void *malloc(unsigned int size)；//malloc的作用是向系统申请一块大小为size的连续内存空间，如果申请失败，函数返回0，如果申请成功，返回成功分配内存块的起始地址。malloc(100)； // 申请 100 个字节的临时分配域，返回值为其第一个字节的地址void free(void *p);//free的作用是释放指针p指向的动态内存空间，p是调用malloc函数时返回的地址，free函数无返回值。 野指针 内存指针变量未初始化 内存释放后之后指针未置空 1234567int *pi=0;int i;int *pi=&amp;i;free(pi);pi=0; 文件操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//操作文件的时候，C语言为文件分配一个信息区，该信息区包含文件描述信息、缓冲区位置、缓冲区大小、文件读写到的位置等基本信息，这些信息用一个结构体来存放（struct _IO_FILE），这个结构体有一个别名FILE（typedef struct _IO_FILE FILE），FILE结构体和对文件操作的库函数在 stdio.h 头文件中声明的。//打开文件的时候，fopen函数中会动态分配一个FILE结构体大小的内存空间，并把FILE结构体内存的地址作为函数的返回值，程序中用FILE结构体指针存放这个地址。//关闭文件的时候，fclose函数除了关闭文件，还会释放FILE结构体占用的内存空间。//FILE结构体指针习惯称为文件指针。FILE *fopen( const char * filename, const char * mode );//参数filename 是字符串，表示需要打开的文件名，可以包含目录名，如果不包含路径就表示程序运行的当前目录。实际开发中，采用文件的全路径。//参数mode也是字符串，表示打开文件的方式（模式），打开方式可以是下列值中的一个。//r 只读 文件必须存在，否则打开失败//w 只写 如果文件存在，则清除原文件内容；如果文件不存在，则新建文件。//a 追加只写 如果文件存在，则打开文件，如果文件不存在，则新建文件。//r+ 读写 文件必须存在。在只读 r 的基础上加 &#x27;+&#x27; 表示增加可写的功能。//w+ 在只写w的方式上增加可读的功能。//a+ 在追加只写a的方式上增加可读的功能。/*注意了，不同教材中对文件打开的方式有不同的说法。有的说打开文本文件的方式要用&quot;rt&quot;、&quot;wt&quot;、&quot;at&quot;、&quot;rt+&quot;、&quot;wt+&quot;、&quot;at+&quot;，&quot;t&quot;是text的简写，&quot;t&quot;可以省略不写。有的说打开二进制文件的方式要用&quot;rb&quot;、&quot;wb&quot;、&quot;ab&quot;、&quot;rb+&quot;、&quot;wb+&quot;、&quot;ab+&quot;，&quot;b&quot;是binary的简写。准确的说，在Linux平台下，打开文本文件和二进制文件的方式没有区别。在windows平台下，如果以“文本”方式打开文件，当读取文件的时候，系统会将所有的&quot;\\r\\n&quot;转换成&quot;\\n&quot;；当写入文件的时候，系统会将&quot;\\n&quot;转换成&quot;\\r\\n&quot;写入， 如果以&quot;二进制&quot;方式打开文件，则读和写都不会进行这样的转换，真是罗嗦。*/int fclose(FILE *fp);int fprintf(FILE *fp, const char *format, ...);char *fgets(char *buf, int size, FILE *fp);/*fgets的功能是从文件中读取一行。参数buf是一个字符串，用于保存从文件中读到的数据。参数size是打算读取内容的长度。参数fp是待读取文件的文件指针。如果文件中将要读取的这一行的内容的长度小于size，fgets函数就读取一行，如果这一行的内容大于等于size，fgets函数就读取size-1字节的内容。调用fgets函数如果成功的读取到内容，函数返回buf，如果读取错误或文件已结束，返回空，即0。如果fgets返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。*/ 二进制文件处理 12345678910111213141516size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);//ptr：为内存区块的指针，存放了要写入的数据的地址，它可以是数组、变量、结构体等。//size：固定填1。//nmemb：表示打算写入数据的字节数。//fp：表示文件指针。//函数的返回值是本次成功写入数据的字节数size_t fread(void *ptr, size_t size, size_t nmemb, FILE *fp);//ptr：用于存放从文件中读取数据的变量地址，它可以是数组、变量、结构体等。//size：固定填1。//nmemb：表示打算读取的数据的字节数。//fp：表示文件指针。//调用fread函数如果成功的读取到内容，函数返回读取到的内容的字节数，如果读取错误或文件已结束，返回空，即0。如果fread返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。 文件定位12345678910111213141516171819202122//ftell函数用来返回当前文件位置指针的值，这个值是当前位置相对于文件开始位置的字节数。long ftell(FILE *fp);//rewind函数用来将位置指针移动到文件开头void rewind ( FILE *fp );//fseek() 用来将位置指针移动到任意位置int fseek ( FILE *fp, long offset, int origin );//fp 为文件指针，也就是被移动的文件。//offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。//origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为：0-文件开头；1-当前位置；2-文件末尾。fseek(fp,100,0); // 从文件的开始位置计算，向后移动100字节。fseek(fp,100,1); // 从文件的当前位置计算，向后移动100字节。fseek(fp,-100,2); // 从文件的尾部位置计算，向前移动100字节。/**当offset是向文件尾方向偏移的时候，无论偏移量是否超出文件尾，fseek都是返回0，当偏移量没有超出文件尾的时候，文件指针式指向正常的偏移地址的，当偏移量超出文件尾的时候，文件指针是指向文件尾的，不会返回偏移出错-1值。当offset是向文件头方向偏移的时候，如果offset没有超出文件头，是正常偏移，文件指针指向正确的偏移地址，fseek返回值为0，当offset超出文件头时，fseek返回出错-1值，文件指针还是处于原来的位置。**/ 文件缓冲区在操作系统中，存在一个内存缓冲区，当调用fprintf、fwrite等函数往文件写入数据的时候，数据并不会立即写入磁盘文件，而是先写入缓冲区，等缓冲区的数据满了之后才写入文件。还有一种情况就是程序调用了fclose时也会把缓冲区的数据写入文件。 1int fflush(FILE *fp); 标准输入、标准输出、标准错误Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。 目录操作1234567891011121314151617181920212223242526272829303132333435363738//获取当前目录char strpwd[301];memset(strpwd,0,sizeof(strpwd));getcwd(strpwd,300);printf(&quot;当前目录是：%s\\n&quot;,strpwd);//切换工作目录int chdir(const char *path);//目录的创建和删除int mkdir(const char *pathname, mode_t mode);int rmdir(const char *pathname);//获取目录中的文件列表#include &lt;dirent.h&gt;//打开目录DIR *opendir(const char *pathname);//读取目录struct dirent *readdir(DIR *dirp);//关闭目录int closedir(DIR *dirp);//目录指针DIR *目录指针名;//每调用一次readdir函数会返回一个struct dirent的地址，存放了本次读取到的内容，它的原理与fgets函数读取文件相同。struct dirent&#123; long d_ino; // inode number 索引节点号 off_t d_off; // offset to this dirent 在目录文件中的偏移 unsigned short d_reclen; // length of this d_name 文件名长 unsigned char d_type; // the type of d_name 文件类型 char d_name [NAME_MAX+1]; // file name文件名，最长255字符&#125;; 时间操作123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef long time_t;time_t tnow;tnow =time(0); // 将空地址传递给time函数，并将time返回值赋给变量tnowtime(&amp;tnow); // 将变量tnow的地址作为参数传递给time函数struct tm&#123; int tm_sec; // 秒：取值区间为[0,59] int tm_min; // 分：取值区间为[0,59] int tm_hour; // 时：取值区间为[0,23] int tm_mday; // 日期：一个月中的日期：取值区间为[1,31] int tm_mon; // 月份：（从一月开始，0代表一月），取值区间为[0,11] int tm_year; // 年份：其值等于实际年份减去1900 int tm_wday; // 星期：取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 int tm_yday; // 从每年的1月1日开始的天数：取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 int tm_isdst; // 夏令时标识符，该字段意义不大，我们不用夏令时。&#125;;struct tm * localtime(const time_t *);//函数用于把struct tm表示的时间转换为time_t表示的时间time_t mktime(struct tm *tm);//unsigned int sleep(unsigned int seconds);int usleep(useconds_t usec);struct timeval&#123; long tv_sec; // 1970年1月1日到现在的秒。 long tv_usec; // 当前秒的微妙，即百万分之一秒。&#125;;struct timezone&#123; int tz_minuteswest; // 和UTC（格林威治时间）差了多少分钟。 int tz_dsttime; // type of DST correction，修正参数据，忽略&#125;;//gettimeofday是获得当前的秒和微秒的时间，其中的秒是指1970年1月1日到现在的秒，微秒是指当前秒已逝去的微秒数int gettimeofday(struct timeval *tv, struct timezone *tz ) 编译预处理 C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件 预处理指令 包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。 宏定义指令：#define指令定义一个宏，#undef指令删除一个宏定义。 条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。 12345678910111213141516171819202122232425262728//如果使用尖括号&lt;&gt;括起文件名，则编译程序将到C语言开发环境中设置好的 include文件中去找指定的文件（/usr/include）//#include包含文件，可以是 “.h”,表示C语言程序的头文件，也可以是“.c”,表示包含普通C语言源程序。#include &lt;文件名&gt;#include &quot;文件名&quot;//宏定义#define 宏名 字符串/*define 关键字“define”为宏定义命令。宏名 是一个标示符，必须符合C语言标示符的规定，一般以大写字母标识宏名。字符串 可以是常数，表达式，格式串等。在前面使用的符号常量的定义就是一个无参数宏定义。*/#define PI 3.141592/*宏定义是宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，编译预处理时不会对它进行语法检查，如有错误，只能在编译已被宏展开后的源程序时发现。 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层替换。建议不要这么做，会把程序复杂化。 习惯上宏名用大写字母表示，以方便与变量区别。但也可以用小写字母。*///带参数的宏#define 宏名(形参表) 字符串#define MAX(x,y) ((x)&gt;(y) ? (x) : (y)) 条件编译123456789101112131415#ifdef 标识符 程序段 1#else 程序段 2#endif#ifndef 标识符 程序段 1#else 程序段 2 #endif//取消已定义的标志符#undef 系统错误我们在写程序的时候需要调用C语言提供的库函数，并通过函数的返回值判断调用是否成功。其实在C语言中，还有一个全局变量errno，存放了函数调用过程中产生的错误码。 为防止和正常的返回值混淆，库函数的调用一般并不直接返回错误码，而是将错误码（是一个整数值，不同的值代表不同的含义）存入一个名为 errno 的全局变量中，errno 不同数值所代表的错误消息定义在 &lt;errno.h&gt; 文件中。如果库函数调用失败，可以通过读出 errno 的值来确定问题所在，推测程序出错的原因，这也是调试程序的一个重要方法。 配合 strerror和perror两个库函数，可以很方便地查看出错的详细信息。 strerror 在 &lt;string.h&gt; 中声明，用于获取错误码对应的消息描述。 perror 在 &lt;stdio.h&gt; 中声明，用于在屏幕上最近一次系统错误码消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。 1234char *strerror(int errno);//strerror()用来依参数errno 的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。 参考 https://freecplus.net/3e27bfb1a810493d9a0550131e2a1633.html","tags":[{"name":"C++","slug":"C","permalink":"http://airshu.github.io/tags/C/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"cef笔记","date":"2022-03-08T02:25:29.729Z","path":"wiki/程序语言/C++/cef/","text":"官网：https://github.com/chromiumembedded/cef下载地址：http://opensource.spotify.com/cefbuilds/index.html Python版： https://github.com/cztomczak/cefpython","tags":[{"name":"C++","slug":"C","permalink":"http://airshu.github.io/tags/C/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"socket编程笔记","date":"2022-03-08T02:25:29.729Z","path":"wiki/程序语言/C++/socket编程笔记/","text":"API介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int socket(int af, int type, int protocol);af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。type 为数据传输方式，常用的有 SOCK_STREAM 和 SOCK_DGRAMprotocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDPint bind(int sock, struct sockaddr *addr, socklen_t addrlen); //Linuxint bind(SOCKET sock, const struct sockaddr *addr, int addrlen); //Windowssock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。struct sockaddr_in&#123; sa_family_t sin_family; //地址族（Address Family），也就是地址类型 uint16_t sin_port; //16位的端口号 struct in_addr sin_addr; //32位IP地址 char sin_zero[8]; //不使用，一般用0填充&#125;;int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); //Linuxint connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen); //Windows让套接字进入被动监听状态，所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。 int listen(int sock, int backlog); //Linuxint listen(SOCKET sock, int backlog); //Windowssock 为需要进入监听状态的套接字backlog 为请求队列的最大长度请求队列当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是10或者20。如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。int accept(int sock, struct sockaddr *addr, socklen_t *addrlen); //LinuxSOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen); //Windows返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字Linux下的数据接收和发送会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。ssize_t write(int fd, const void *buf, size_t nbytes);fd 为要写入的文件的描述符，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。 会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。ssize_t read(int fd, void *buf, size_t nbytes);Windows下的数据接收和发送int send(SOCKET sock, const char *buf, int len, int flags);int recv(SOCKET sock, char *buf, int len, int flags); 基本概念socket缓冲区每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。 write()&#x2F;send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。 TCP协议独立于 write()&#x2F;send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 这些I&#x2F;O缓冲区特性可整理如下： I&#x2F;O缓冲区在每个TCP套接字中单独存在； I&#x2F;O缓冲区在创建套接字时自动生成； 即使关闭套接字也会继续传送输出缓冲区中遗留的数据； 关闭套接字将丢失输入缓冲区中的数据。 输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取： 12345unsigned optVal;int optLen = sizeof(int);getsockopt(servSock, SOL_SOCKET, SO_SNDBUF, (char*)&amp;optVal, &amp;optLen);printf(&quot;Buffer length: %d\\n&quot;, optVal); 阻塞模式对于TCP套接字（默认情况下），当使用 write()&#x2F;send() 发送数据时： 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()&#x2F;send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()&#x2F;send() 函数继续写入数据。 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()&#x2F;send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()&#x2F;send() 才会被唤醒。 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。 直到所有数据被写入缓冲区 write()&#x2F;send() 才能返回。 当使用 read()&#x2F;recv() 读取数据时： 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()&#x2F;recv() 函数再次读取。 直到读取到数据后 read()&#x2F;recv() 函数才会返回，否则就一直被阻塞。 这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。 TCP数据报结构以及三次握手TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。 客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。 TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话： [Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。” [Shake 2] 套接字B：“好的，我这边已准备就绪。” [Shake 3] 套接字A：“谢谢你受理我的请求。” TCP数据报结构 带阴影的几个字段需要重点说明一下： 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack &#x3D; Seq + 1。 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：建立一个新连接。 FIN：断开一个连接。 Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。 连接的建立（三次握手） 客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。 这个时候，客户端开始发起请求： 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。 服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。服务器将数据包发出，进入SYN-RECV状态。 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。 数据的传输过程 上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。 为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。 此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号： Ack号 &#x3D; Seq号 + 传递的字节数 + 1，与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。 下面分析传输过程中数据包丢失的情况，如下图所示： 上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。 为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。 重传超时时间（RTO, Retransmission Time Out） 这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。 往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。 重传时间 TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。 TCP四次握手断开连接建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话： [Shake 1] 套接字A：“任务处理完毕，我希望断开连接。” [Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。” 等待片刻后…… [Shake 3] 套接字B：“我准备好了，可以断开连接了。” [Shake 4] 套接字A：“好的，谢谢合作。” 建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求： 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。 关于 TIME_WAIT 状态的说明 客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？ TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。 客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？ 数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。 窗口协议ARQ协议ARQ协议主要包含：停等ARQ协议、连续ARQ协议，其中连续ARQ协议是为了解决停等ARQ协议信道利用率低的问题，目前传统的连续ARQ协议有回退N帧ARQ协议、选择性重传ARQ协议。 连续ARQ协议（Continuous ARQ） 回退N帧ARQ协议（Go-Back-N） 接收端丢弃从第一个没有收到的数据包开始的所有数据包 发送端收到NACK后，从NACK中指明的数据包开始重新发送 选择性重传ARQ协议（Selective Repeat） 发送端连续发送数据包但对每个数据包都设有个一个计时器 当在一定时间内没有收到某个数据包的ACK时，发送端只重新发送那个没有ACK的数据包","tags":[{"name":"C++","slug":"C","permalink":"http://airshu.github.io/tags/C/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"多线程","date":"2022-03-08T02:25:29.716Z","path":"wiki/操作系统/线程/多线程/","text":"线程的概念引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。 线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。 线程的状态 新建状态: 线程对象已经创建，还没有在其上调用start()方法。 可运行状态: 当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。 运行状态: 就绪状态的线程获取了CPU，执行程序代码。 阻塞状态: 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入可运行状态，才有机会转到运行状态。 阻塞的情况分三种： 等待阻塞:运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒. (注意:当调用wait()后，线程会释放掉它所占有的’锁’，所以线程只有在持有’锁’才能进入可运行状态.) 同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。 其他阻塞:运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。 死亡状态: 线程执行完了或者因异常退出了run()时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 线程的实现方式线程间通讯参考","tags":[{"name":"技术","slug":"技术","permalink":"http://airshu.github.io/tags/%E6%8A%80%E6%9C%AF/"}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"线程","slug":"操作系统/线程","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/"}]},{"title":"基础概念","date":"2022-03-08T02:25:29.716Z","path":"wiki/操作系统/进程/基础概念/","text":"协程：是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用 了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一 个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。 协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。 协程的特点在于是一个线程执行，那和多线程比，协程有何优势? 极高的执行效率:因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显; 不需要多线程的锁机制:因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。","tags":[],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"操作系统/进程","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/"}]},{"title":"字符编码","date":"2022-03-08T02:25:29.715Z","path":"wiki/技术开发/杂项/字符编码/","text":"ASCII 码计算机内部，所有信息最终都是一个二进制值。每一个二进制位(bit)有 0 和 1 两种 状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000 到 11111111 。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32(二进制 00100000 )，大写的字母 A 是65(二进制 01000001 )。这128个符号(包括32个不能打印出来的控制符号)，只占用了一个字节的后面7位，最前面的一位统一规定为 0 。 UnicodeUnicode 只是一个符号集。Unicode可以容纳100多万个符号。他规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。比如，汉字严的Unicode是十六进制数 4E25 ，转换成二进制数足足有15位( 100111000100101 )，也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 UTF-8UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号， 根据不同的符号而变化字节长度。 UTF-8 的编码规则： 对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于n字节的符号(n&gt;1)，第一个字节的前n位都设为1，第n+1 位设为0，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 严 的 Unicode 是 4E25 (100111000100101 )，根据上表，可以发现 4E25 处在第三行的范围内 ( 0000 0800 - 0000 FFFF)，因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 一个utf8数字占1个字节，一个utf8英文字母占1个字节，少数是汉字每个占用3个字节，多数占用4个字节。 编程转换一般的文件编辑器（比如notepad）中保存时会有编码选项： ANSI：对于英文文件是 ASCII 编码，对于简体中文文件是 GB2312 编码 Unicode：notepad使用的 UCS-2 编码方式，即直接用两个字节存入字符 的 Unicode 码，这个选项用的 little endian 格式（如果一个文本文件的头两个字节是 FE FF ，就表示该文件采用大头方式;如果头两个字节是 FF FE ，就表示该文件采用小头方式。） Unicode big endian UTF-8","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://airshu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"按键精灵的使用记录","date":"2022-03-08T02:25:29.715Z","path":"wiki/技术开发/杂项/按键精灵的使用记录/","text":"最近因为工作需要，研究了下按键精灵和相关生态。按键精灵的主要功能是模拟用户行为，可以导出Android、iOS的包。直接在手机上运行。大致猜测下实现原理： 电脑上通过用户的脚本，转换成相关指令，在电脑上的脚本应该通过adb相关指令来控制模拟器或者手机，到处的apk应该是通过调用系统的相关命令（sendevent等）来实现的。 图片检测像素检测应该是通过opencv相关库来实现的。 脚本的编写也是蹲守基本的编程规则，基本的运算、流程控制、多线程，不过还不够完善。 基本的脚本编写方式也比较傻瓜式，得到具体的坐标，模拟用户点击、输入。哪怕没学过编程的，上手也比较容易。 因为有了这样自动化的工具，再加上大量的需求（用户想刷游戏里的金币、自动完成任务），从而衍生出了许多贩售脚本的。根据这几天的调查，从事这一行的并不少。有依赖按键精灵开发脚本卖钱的，有根据用户需求定制脚本的，还有自己自主开发脚本卖VIP的（如：http://hm.hy6665.cn）。说明这个市场还是蛮大的。 按键精灵的使用按键精灵分为PC版和移动版，移动版在脚本开发完成后，可以导出相应App，在手机和模拟器直接安装即可使用。启动后，会有一个悬浮窗来控制脚本的运行。手机助手还有一个抓抓的功能，可以对模拟器进行截图，截图后可以使用像素点点颜色判断或者图片判断位置。 按键精灵的命令分类： 基本命令 界面命令 悬浮窗命令 扩展命令 标准库命令 运算符命令 插件命令 如何发送语音文件模拟用户按下开始录音，录音过程中替换音频文件使用e2eSoft vsc，将扬声器声音转到麦克风中。当用户按下时，播放提前准备好的音频文件，直接录制改声音。wwww.e2esoft.cn/record-music-with-vsc JSDROID实例 王者荣耀大厅自动喊话和给好友发送语音消息脚本","tags":[{"name":"按键精灵","slug":"按键精灵","permalink":"http://airshu.github.io/tags/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"FFMpeg常用命令","date":"2022-03-08T02:25:29.715Z","path":"wiki/技术开发/杂项/常用ffmpeg命令/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#格式转换ffmpeg -i input.avi output.mp4ffmpeg -i input.mp4 output.ts#提取音频ffmpeg -i input.mp4 -acodec copy -vn output.aac#提取视频ffmpeg -i input.mp4 -vcodec copy -an output.mp4#视频剪切 -ss表示开始时间 -t表示长度ffmpeg -ss 00:00:00 -t 00:00:10 -i input.mp4 -vcodec copy -acodec copy output.mp4#码率控制 bitrate=filesize/duration，比如一个文件20.8M，时长1分钟，那么，码率就是：biterate = 20.8M bit/60s = 20.8*1024*1024*8 bit/60s= 2831Kbps一般音频的码率只有固定几种，比如是128Kbps，那么，video的就是：video biterate = 2831Kbps -128Kbps = 2703Kbps。ffmpeg -i input.mp4 -b:v 2000k output.mp4ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4 # 官方建议加上-bufsize，用于设置码率控制缓冲器的大小ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4 # -minrate -maxrate 最小最大范围#视频编码格式转换ffmpeg -i input.mp4 -vcodec h264 output.mp4 #使用h264编码ffmpeg -i input.mp4 -vcodec mpeg4 output.mp4 #使用mpeg4编码#视频大小修改ffmpeg -i input.mp4 -vf scale=960:540 output.mp4 //ps: 如果540不写，写成-1，即scale=960:-1, 那也是可以的，ffmpeg会通知缩放滤镜在输出时保持原始的宽高比#添加水印ffmpeg -i input.mp4 -i logo.png -filter_complex overlay output.mp4ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4 #右上角ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4 #左下角ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4 #右下角#去掉logo有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。语法：-vf delogo=x:y:w:h[:t[:show]]x:y 离左上角的坐标w:h logo的宽和高t: 矩形边缘的厚度默认值4show：若设置为1有一个绿色的矩形，默认值0。ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4#从视频中获取指定尺寸的缩略图， -ss参数要在-i参数之前ffmpeg.exe -ss 2672 -i input.mkv -y -f mjpeg -t 0.01 -s 96x54 U:/xiaodao/src/temp/xxx.jpg#将gif转成mp4ffmpeg -f gif -i origin.gif -pix_fmt yuv420p output.mp4#使用基于GDI的抓屏设备ffmpeg -f gdigrab -i desktop out.mpg#从屏幕的（10,20）点处开始，抓取640x480的屏幕，设定帧率为5ffmpeg -f gdigrab -framerate 5 -offset_x 10 -offset_y 20 -video_size 640x480 -i desktop out.mpg#设置帧率ffmpeg -i input.avi -r 29.97 output.mpg#码率 ABR、CBR、VBRffmpeg -i film.avi -b 1.5M film.mp4ffmpeg -i file.avi -b:v 1500k output.mp4设置输出文件最大大小ffmpeg -i input.avi -fs 10MB output.mp4文件大小计算video_size = video_bitrate * time_in_seconds / 8如果音频没有压缩：audio_size = sampling_rate * bit_depth * channels * time_in_seconds / 8压缩音频的文件：audio_size = bitrate * time_in_seconds / 8缩放视频ffmpeg -i input_file -s 320x240 output_file高级缩放 scale=width:height[:interl=&#123;1|-1&#125;]ffmpeg -i input.mpg -vf scale=320:240 output.mp4根据输入来设置缩放大小ffmpeg -i input.mpg -vf scale=iw/2:ih*0.9 裁剪视频 crop=ow[:oh[:x[:y[:keep_aspect]]]]从左上角裁剪，宽度为原始尺寸的一半，高宽跟原始尺寸一样ffmpeg -i input -vf crop=iw/2:ih:0:0 output移动视频 pad=width[:height[:x[:y[:color]]]]ffmpeg -i photo.jpg -vf pad=860:660:30:30:pink framed_photo.jpg将视频比例从4:3转为16:9ffmpeg -i input -vf pad=ih*16/9:ih:(ow-iw)/2:0:color output翻转和旋转视频水平翻转ffplay -f lavfi -i testsrc -vf hflip旋转 transpose=&#123;0, 1, 2, 3&#125;ffplay -f lavfi -i smptebars -vf transpose=2, vflip画中画ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output水印在右下角ffmpeg -i pair.mp4 -i logo.png -filter_complex overlay=W-w:H-h pair1.mp4指定水印开始的时间ffmpeg -i video_width_timer.mp4 -itsoffset 5 -i logo.png -filter_complex overlay timer_width_logo.mp4修改速度ffplay -i input.mpg -vf setpts=PTS/3快放2倍，取值范围0.5-2.0ffplay -i speech.mp3 -af atempo=2创建元数据 -metadata 后面跟键值对ffmpeg -i input -metadata artist=FFmpeg -metadata title=&quot;test&quot; output保存元数据到文件ffmpeg -i video.wmv -f ffmetadata data.txt删除元数据ffmpeg -i input.avi -map_metadata -l output.mp4截图ffmpeg -i videoclip.avi -ss 01:23:45 image.jpg获取gif动画ffmpeg -i promotion.swf -pix_fmt rgb24 promotion.gif根据图片创建视频ffmpeg -loop l -i photo.jpg -t 10 photo.mp4根据多张图片生成视频ffmpeg -f image2 -i img%d.jpg -r 25 video.mp4播放rtmpffplay &quot;rtmp://live.hkstv.hk.lxdns.com/live/hks&quot;保存直播流ffmpeg -i http://60.199.188.151/HLS/WG_ETTV-N/index.m3u8 -c:v copy -c:a copy -bsf:a aac_adtstoasc d:\\cap.mp4从视频中抽离部分生成webpffmpeg -t 3 -ss 00:00:01 -i $&#123;video_path&#125; -vf scale=320:-1 -q:v 50 -r 10 -compression_level 6 -vcodec libwebp -loop 0 $&#123;output_path&#125;从视频中提取关键帧图片ffmpeg -i video_name.mp4 -vf select=&#x27;eq(pict_type\\,I)&#x27; -vsync 2 -s 1920*1080 -f image2 keyframe-%02d.jpeg计算视频的时长ffmpeg -i source.mp4 2&gt;&amp;1 | grep &#x27;Duration&#x27; | cut -d &#x27; &#x27; -f 4 | sed s/,//合并两个视频实用文件的方式：1. 编写filetext.txt文件file ‘a.mp4’file ‘b.mp4’2. 执行命令ffmpeg -f concat -i filelist.txt -c copy output.mp4直接用命令行ffmpeg -i “concat:a.mp4|b.mp4&quot; -c copy output.mp4","tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://airshu.github.io/tags/ffmpeg/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"IO多路复用","date":"2022-03-08T02:25:29.715Z","path":"wiki/操作系统/未分类/IO多路复用/","text":"发展史开始的时候，为了实现一个服务器可以支持多个客户端连接，人们想出了fork&#x2F;thread等办法，当一个连接来到的时候，就fork&#x2F;thread一个进程&#x2F;线程去接收并且处理请求。 到了80年代，计算机网络开始成型，越来越多的用户进行网络连接，但是之前的fork&#x2F;thread模型在高并发场景快不行了。1983年，发明了select。 对应的编程模型就是：一个连接来了，就必须遍历所有已经注册的文件描述符，来找到那个需要处理信息的文件描述符，如果已经注册了几万个文件描述符，那会因为遍历这些已经注册的文件描述符，导致cpu爆炸。 到2002年，epoll出现了，于Linux 2.5.44首度登场。 基本概念用户空间&#x2F;内核空间操作系统的核心是内核，为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分。 针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。 同步与异步 同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。 异步：异步就是发一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时可以处理其他的请求，被调用者通常依靠事件、回调等机制来通知调用者其返回结果。 阻塞和非阻塞 阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。 非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他的事情。 进程切换挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 文件描述符File descriptor：表述指向文件的引用的抽象化概念。在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 在实际编程中，不管是进行文件操作还是Socket编程，都是操作文件描述符。 缓存I&#x2F;O缓存I&#x2F;O又称为标准I&#x2F;O，大多数文件系统的默认I&#x2F;O操作都是缓存I&#x2F;O。在Linux的缓存I&#x2F;O机制中，操作系统会将I&#x2F;O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 具体实现select它仅仅知道了，有I&#x2F;O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。 缺点 单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ; 每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大； 对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发） pollpoll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。 缺点它没有最大连接数的限制，但是同样有缺点： 每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大； 对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时） epollepoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I&#x2F;O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)） 参考 五种IO模型 彻底理解 IO 多路复用实现机制 https://zh.wikipedia.org/wiki/Epoll https://baike.baidu.com/item/poll/3643578 https://mp.weixin.qq.com/s/Ok7SIROXu1THUbWsFu-UYw","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://airshu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"未分类","slug":"操作系统/未分类","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"Linux常用操作","date":"2022-03-08T02:25:29.712Z","path":"wiki/技术开发/杂项/Linux常用操作/","text":"添加用户并赋予权限#添加用户 adduser -m xxx vim /etc/sudoers 添加：%sudo ALL=(ALL:ALL) ALL 将用户添加到sudo组 gpasswd -a xxx sudo ssh操作配置 ssh -p 端口号 用户名@ip地址 ssh -p 22 root@192.168.1.1 #设置私钥的权限 chmod 666 id_rsa","tags":[{"name":"linux","slug":"linux","permalink":"http://airshu.github.io/tags/linux/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"PC客户端技术方案分析","date":"2022-03-08T02:25:29.712Z","path":"wiki/技术开发/杂项/PC客户端技术方案分析/","text":"不同PC客户端技术方案的比较Qt官网：https://www.qt.io/ Qt具有跨平台的特性，可选择QWidget、QQuick。整个包比较大。虽然可以根据实际情况去掉一部分动态库和文件，还是比较大。 CEF（Chromium Embedded Framework）官网：https://bitbucket.org/chromiumembedded/cef/src/master/ 是一个基于Google Chromium 的开源项目。Google Chromium项目主要是为Google Chrome应用开发的，而CEF的目标则是为第三方应用提供可嵌入浏览器支持。CEF隔离底层Chromium和Blink的复杂代码，并提供一套产品级稳定的API，发布跟踪具体Chromium版本的分支，以及二进制包。通过封装接口, 然后由chromium回调到自己的程序, 驱动整个程序运行。 个人认为选择CEF的主要原因有以下几点： 基于JS、Html这一套Web技术，开发速度快； 能做出高性能的动画效果 Electron官网：http://www.electronjs.org/ 使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。Electron是在chromium的基础之上, 再嵌入一了个js执行的v8引擎, 由此v8引擎与chromium内部的v8进行信号的交互, 驱动程序运行。 duilib官网：https://github.com/duilib/duilib 开源，小巧灵活，容易扩展，界面与业务逻辑分离。国内有许多大厂都在用这个库，不过应该都进行过深入的定制，官方版本的更新并不频繁，文档跟其他几个比起来差距较大。 教程： https://blog.oo87.com/cpp/6868.html WPF（Windows Presentation Foundation）微软推出的基于Windows Vista的用户界面框架，属于.NET Framework 3.0的一部分。基于Direct3D创建，使用GPU，拥有更好的性能。 UMP（Universal Windows Platform）官方介绍：https://docs.microsoft.com/zh-cn/windows/uwp/get-started/universal-application-platform-guide 在 Windows 10 中，微软首次引入了 UWP（通用 Windows 平台）的概念，让开发者只需一次编写，就能让程序在电脑和手机等多种设备上运行。 PyQt下载地址： https://pypi.org/project/PyQt5/ 基于Qt的Python封装，由于Python的简易特性，开发效率极高。 不同软件的技术实现方案： yy：Qt+CEF 钉钉：CEF+Qt5+duilib 斗鱼：Qt+声网SDK+CrashRpt 虎牙：.Net+Qt4 刀锋电竞：Electron 微信PC端：duilib 网易CC：Qt4+PyQt4+ActionScript(Flex) 参考 https://www.dazhuanlan.com/2019/09/29/5d8f936a633a2/?cf_chl_jschl_tk&#x3D;ef7184070e28df4b7ee98496aa8b8ff50c47dcd7-1602323919-0-ASFIF35e3NpZNuU7Ndt3pR36r7hlqGch5EsER64Huxe0jFolt_H3NQYXXDmvjWl_m8WVlRnkeLLk1CpX-mLzObrx_mpJIWdumnG8N-g4L7RCf1XxZyM3Ucv6EPDJhAfJSexUlyeoz-AzeC4nE10bcWsW6MyJjhJRQfvo2ABHsoKcu0RLGe4_PIkvL8ox7CchII1vJKWNus0JBvjUiLa0TWyWOGE2WLCwUAwYSEIRE5vqTnW4bMP0C5MTZnjw6sk7Je9gHmAM79oqXilMJdJrVonFl3oItVG8fPn-iwqZbFdBK3iqj7xjlstE8HSgJ7ZEdQ","tags":[{"name":"PC","slug":"PC","permalink":"http://airshu.github.io/tags/PC/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"Connection reset by peer) while reading response header from upstream","date":"2022-03-08T02:25:29.711Z","path":"wiki/技术开发/服务端/Connection reset by peer/","text":"问题：Connection reset by peer) while reading response header from upstream描述：某些请求一直返回502 Bad Gateway的错误，查看服务端的error日志，显示Connection reset by peer。当时的场景是一个每隔一分钟的定时脚本每次运行时，获取需要处理的数据，同步请求某个服务端接口进行文件上传。猜测是这个接口请求响应很慢，一分钟后又再次请求同样的接口而出现问题。 处理：修改接口对应的逻辑，让这个接口能快速响应；此问题消失。查阅资料，Nginx的响应有几个参数设置： keepalive_timeout：设置客户端的长连接超时时间，如果超过这个时间客户端没有发起请求，则Nginx服务器会主动关闭长连接。 keepalive_requests：设置与客户端的建立的一个长连接可以处理的最大请求次数，如果超过这个值，则Nginx会主动关闭该长连接。 对于此类问题，也可以尝试将keepalive_timeout的时间设置的长一些。","tags":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"Linux常用命令","date":"2022-03-08T02:25:29.711Z","path":"wiki/技术开发/服务端/Linux常用命令/","text":"grep常用命令12345678910111213141516171819202122232425# 查找进程中所有跟nginx匹配的ps -ef | grep nginx# 查看进程数ps -ef | grep nginx -c # 搜索某个文件夹下，哪些文件包含关键字grep -r &quot;关键字&quot; 文件夹# 根据字符串搜索grep “被查找的字符串” 文件名 # 根据正则搜索grep –e “正则表达式” 文件名# 搜索不区分大小写grep –i “被查找的字符串” 文件名# 显示搜索出来的信息所在的行数grep -c “被查找的字符串” 文件名 find常用命令1234567891011# 查看当前目录下所有php文件find . &quot;*.php&quot;find . -name &quot;*.php&quot;# 查找当前目录下，最近120分钟修改过的文件find . -mmin -120# 查看当前目录下，是否有名字叫“通讯录”的文件夹，-type：表示设定类型，d表示文件夹类型，可以替换为f(普通文件)、l(链接文件)find . -type d -name 通讯录","tags":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"MySQL知识点","date":"2022-03-08T02:25:29.711Z","path":"wiki/技术开发/服务端/MySQL知识点/","text":"explain 使用 列名 说明 id 执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 select_type 显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT） table 访问引用哪个表（引用某个查询，如“derived3”） type 数据访问&#x2F;读取操作类型（ALL、index、range、ref、eq_ref、const&#x2F;system、NULL） possible_keys 揭示哪一些索引可能有利于高效的查找 key 显示mysql决定采用哪个索引来优化查询 key_len 显示mysql在索引里使用的字节数 ref 显示了之前的表在key列记录的索引中查找值所用的列或常量 rows 为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数 Extra 额外信息，如using index、filesort等 select_type 类型 说明 simple 简单子查询，不包含子查询和union primary 包含union或者子查询，最外层的部分标记为primary subquery 一般子查询中的子查询被标记为subquery，也就是位于select列表中的查询 derived 派生表——该临时表是从子查询派生出来的，位于form中的子查询 union 位于union中第二个及其以后的子查询被标记为union，第一个就被标记为primary如果是union位于from中则标记为derived union result 用来从匿名临时表里检索结果的select被标记为union result dependent union 顾名思义，首先需要满足UNION的条件，及UNION中第二个以及后面的SELECT语句，同时该语句依赖外部的查询 subquery 子查询中第一个SELECT语句 dependent subquery 和DEPENDENT UNION相对UNION一样 type type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。 类型 说明 All 最坏的情况,全表扫描 index 和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多 range 范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用&#x3D;、 &lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、IS NULL、&lt;&#x3D;&gt;、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range ref 一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟eq_ref不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY。ref可以用于使用&#x3D;或&lt;&#x3D;&gt;操作符的带索引的列。 eq_ref 最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效） const 当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入where子句时，mysql把这个查询转为一个常量（高效） system 这是const连接类型的一种特例，表仅有一行满足条件。 Null 意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效） Extra Extra是EXPLAIN输出中另外一个很重要的列，该列显示MySQL在查询过程中的一些详细信息，MySQL查询优化器执行查询的过程中对查询计划的重要补充信息。 类型 说明 Using filesort MySQL有两种方式可以生成有序的结果，通过排序操作或者使用索引，当Extra中出现了Using filesort 说明MySQL使用了后者，但注意虽然叫filesort但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是ordery by，group by语句的结果，这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。 Using temporary 用临时表保存中间结果，常用于GROUP BY 和 ORDER BY操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。 Not exists MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行， 就不再搜索了。 Using index 说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现using where，表明索引被用来执行索引键值的查找，没有using where，表明索引用来读取数据而非执行查找动作。这是MySQL服务层完成的，但无需再回表查询记录。 Using index condition 这是MySQL 5.6出来的新特性，叫做“索引条件推送”。简单说一点就是MySQL原来在索引上是不能执行如like这样的操作的，但是现在可以了，这样减少了不必要的IO操作，但是只能用在二级索引上。 Using where 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。注意：Extra列出现Using where表示MySQL服务器将存储引擎返回服务层以后再应用WHERE条件过滤。 Using join buffer 使用了连接缓存：Block Nested Loop，连接算法是块嵌套循环连接;Batched Key Access，连接算法是批量索引连接 impossible where where子句的值总是false，不能用来获取任何元组 select tables optimized away 在没有GROUP BY子句的情况下，基于索引优化MIN&#x2F;MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 distinct 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作 慢查询分析查询日志设置1234567show variables like &#x27;general_log&#x27;; #查询是否开启查询日志set global general_log = on; # 开启查询日志show variables like &#x27;log_output&#x27;; # 查看日志写入类型set global log_output = &#x27;table&#x27;; #修改日志写入类型select *from mysql.slow_loglimit 100; # 慢查询日志记录表 mysql.slow_log 表字段意义 123456query_time： SQL语句的查询时间(在 MySQL 中所有类型的 SQL 语句执行的时间都叫做 query_time,而在 Oracle 中则仅指 select)lock_time: 锁的时间rows_sent: 返回了多少行,如果做了聚合就不准确了rows_examined: #执行这条 SQL 处理了多少行数据db: 使用了哪个数据库sql_text： 执行的sql语句 存疑的点 什么情况下需要开启查询缓存？ 常见问题","tags":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"RabbitMQ笔记","date":"2022-03-08T02:25:29.711Z","path":"wiki/技术开发/服务端/RabbitMQ笔记/","text":"安装安装PHP扩展amqp12345678910111213141516PHP &lt; 7.3#install some base extensionsRUN apt-get install -y \\ libzip-dev \\ zip \\ &amp;&amp; docker-php-ext-configure zip --with-libzip \\ &amp;&amp; docker-php-ext-install zipPHP &gt;= 7.3#install some base extensionsRUN apt-get install -y \\libzip-dev \\zip \\&amp;&amp; docker-php-ext-install zip 安装RabbitMQdocker安装，使用localhost:5672访问其后台 123456789101112rabbitmq: image:rabbitmq:management restart: always environment: RABBITMQ_DEFAULT_USER: &quot;root&quot; RABBITMQ_DEFAULT_PASS: &quot;root&quot; volumes: - ./code/rabbitmq/rabbitmq:/var/lib/rabbitmq - ./code/rabbitmq/log:/log/rabbitmq/log ports: - 15672:15672 - 5672:5672 Symfony安装扩展https://github.com/php-amqplib/RabbitMqBundle Symfony中的composer中添加 1&quot;php-amqplib/rabbitmq-bundle&quot;: &quot;1.14.4&quot; 执行更新命令 1php composer update php-amqplib/rabbitmq-bundle 使用参考 https://rabbitmq.com https://blog.csdn.net/whoamiyang/article/details/54954780","tags":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"Redis笔记","date":"2022-03-08T02:25:29.711Z","path":"wiki/技术开发/服务端/redis笔记/","text":"","tags":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"对于服务端开发的理解","date":"2022-03-08T02:25:29.711Z","path":"wiki/技术开发/服务端/对于服务端开发的理解/","text":"最近一段时间，开始了解并完成了一些后端需求。大致的过程如下： 熟悉PHP，看了《PHP核心技术与最佳实践》、《PHP内核剖析》、《深入理解PHP内核》； 熟悉MySQL，看了《MySQL必知必会》，接下来会看《高性能MySQL》； 熟悉Redis，看了《Redis实战》； 阅读Symfony官网文档，了解其基本原理； 由于本地使用docker开发环境，所以对docker相关知识点也进行了一轮复习； 整体来看，想使用PHP相关技术栈进行后端开发，经过上面的学习后，写写业务代码，一点问题都没有。公司使用PHP这一套技术栈，也是基于人力成本、开发效率各方面因素综合考虑而定的。在现有体量下也确实是比较好的选择。因为自己本身有其他语言的底子在，学习的过程中还是蛮顺利的。现在回过头看看，后端的整体架构设计也是根据体量的大小一步步进化来的。 当一个（小）项目刚开始时，使用Nginx+Symfony+MySQL，当业务量有所增长，这个时候需要加上缓存Redis；当业务继续增长，这个时候需要多台机器部署了，需要使用负载均衡，Nginx进行反向代理，将流量分发到不同的机器；当业务继续增长，这个时候需要考虑部署多个数据库，进行主从同步；当业务继续增长，这个时候Redis也要考虑使用集群。随着业务继续增长，数据库表的设计，如何分表。如何分库，业务代码如何写效率高，等等问题都要进行考虑了。当业务还在继续增长，可能有些事情用PHP来干已经不是最优解了！ 除了上面所说的一些技术选择外，为了保证服务器的稳定，还有很多事情要做的，比如要对服务器相关数据进行监控，比如请求数、慢请求数、服务器流量消耗情况等；要有一套完善的日志系统；对数据库的监控；容灾机制等等。 这些知识的获取途径无外乎两种，一是业务增长喜人，给了你机会把这些坑都踩一遍；二是在大公司，现成的解决方案供你学习。所以，刚毕业的小菜鸟们，还是建议能去大公司就尽量去大公司，做大做强的小公司太少了，不一定能被你撞上。 服务端需要用到的技术或软件： 开发框架：Symfony、ThinkPHP等 消息队列：RabbitMQ等 服务器：Nginx、Apache等 缓存：Redis、MemCached等 数据存储：MySQL、PostgreSQL等 代码部署：Walle等 数据监控：Zabbix等 日志分析系统：elk等","tags":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"categories":[{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"Windows下Charles支持HTTPS","date":"2022-03-08T02:25:29.711Z","path":"wiki/技术开发/杂项/Charles SSL证书/","text":"SSL握手过程客户端发出加密通信请求提供： 协议版本(如 TSL1.0) 随机数 1(用于生成对话密钥) 支持的加密方法(如 RSA 公钥加密) 支持的压缩方法 服务器回应回应内容: 确认使用的加密通信协议版本(TSL1.0) 随机数 2(用于生成对话密钥) 确认加密方法(RSA) 服务器证书(包含非对称加密的公钥) (可选)要求客户端提供证书的请求 客户端验证证书如果证书不是可信机构颁布，或证书域名与实际域名不符，或者证书已经过期，就会向访问者显示一个警告，是否继续通信 客户端回应证书没有问题，就会取出证书中的服务器公钥然后发送: 随机数 3(pre-master key，此随机数用服务器公钥加密，防止被窃听) 编码改变通知(表示随后的信息都将用双方商定的方法和密钥发送) 客户端握手结束通知 双方生成会话密钥双方同时有了三个随机数，接着就用事先商定的加密方法，各自生成同一把“会 话密钥” 服务器端用自己的私钥(非对称加密的)获取第三个随机数，会计算生成本次所 用的会话密钥(对称加密的密钥)，如果前一步要求客户端证书，会在这一步验证。 服务器最后响应服务器生成会话密钥后，向客户端发送: 编码改变通知(后面的信息都用双方的加密方法和密钥来发送) 服务器握手结束通知 Charles 设置SSL设置点击 Proxy -&gt; SSL Proxy Settings -&gt; SSLProxy -&gt; Add 添加SSL代理规则 Host:* Port:443 证书配置(不用设置)点击 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate -&gt; 安装证书 选择将所有的证书都放入受信任的根证书颁发机构 Mac需要在钥匙链中将证书设置为永久信任 手机配置连接跟电脑一样的网络，配置代理连接charles。浏览器访问chls.pro/ssl，下载安装证书 注意事项Android7及以上无法抓取https，因为”Network Security Configuration”的新安全功能。这个功能运行开发人员在不修改应用程序的情况下自定义他们的网络安全设置。如果应用程序运行的系统版本高于或等于24，并且targetSdkVersion&gt;&#x3D;24，则只有系统证书才被信任。 参考 https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/ https://juejin.im/post/5b4f005ae51d45191c7e534a","tags":[{"name":"charles","slug":"charles","permalink":"http://airshu.github.io/tags/charles/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"Docker笔记","date":"2022-03-08T02:25:29.711Z","path":"wiki/技术开发/杂项/Docker笔记/","text":"容器生态系统： 容器核心技术： 容器规范： OCI（Open Container Initiative）： runtime spec image format spec 容器runtime： lxc：Linux上老牌的容器runtime，Docker最初也是用lxc作为runtime runc：Docker自己开发的容器runtime，符合oci规范，也是现在Docker默认的runtime rkt：CoreOS开发的容器runtime 容器管理工具： lxd：lxc对应的管理工具 runc：docker engine，包含后台deamon和cli两部分。 rkt cli：rkt对应的管理工具 容器定义工具：允许用户定义容器的内容和属性，这样容器就能够被保存、共享和重建 docker image：Docker容器的模板，runtime依据docker image创建容器。 dockerfile：包含若干命令的文本文件，可以通过这些命令创建出docker image。 ACI(App Container Image)：CoreOS开发的rkt容器的image格式。 Registries：存放image的仓库 Docker Registry：企业可以用Docker Registry构建私有的Registry Docker Hub：Docker为公众提供的托管Registry Quay.io 容器OS：专门运行容器的操作系统，与常规OS相比，容器OS体积更小，启动更快。 coreos atomic ubuntu core 容器平台技术： 容器编排引擎： docker swarm：Docker开发的容器编排引擎。 kubernetes：Google领导开发的，同时支持Docker和CoreOS容器。 mesos+marathon：通用的集群资源调度平台，mesos与marathon一起提供容器编排引擎。 容器管理平台：在容器编排引擎之上的一个更为通用的平台。 Rancher ContainerShip 基于容器的Paas： Deis Flynn Dokku 容器支持技术： 容器网络： docker network: none host bridge joined container overlay macvian flannel weave calico 服务发现： etcd consul zookeeper 监控： docker ps&#x2F;top&#x2F;stats：Docker原生命令行监控工具 docker stats API sysdig cAvisor&#x2F;Heapster Weave Scope 数据管理： Rex-Ray 日志管理： docker logs logspout 安全性： OpenSCAP 特性 集装箱 Docker 打包对象 几乎任何物品 任何软件及其依赖 标准形状和接口允许集装箱被卸载到 各种交通工具，整个运输过程无需打开 容器无需修改便可运行在几乎所有的平台 隔离性 可以重叠起来一起运输 资源、网络、库都是隔离的，不会出现依赖问题 自动化 标准接口使集装箱很容易自动装卸和移动 提供run、start、stop等标准化操作 高效性 无须开箱 轻量级 职责分工 货主只需要考虑把什么放到集装箱 开发人员只需要考虑怎么写代码，运维只需关心如何配置基础环境 Docker核心组件 Docker客户端：Client Docker服务器：Docker daemon，负责创建、运行、监控容器，构建、存储镜像。 Docker镜像：Image Registry：镜像仓库 Docker容器：Container 镜像（Image）一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后不会改变。 常用镜像 1234Docker 图形管理工具docker run -d -p 9001:9000 -v &quot;/var/run/docker.sock:/var/run/docker.sock&quot; portainer/portainer 容器（Container）镜像和容器的关系，就像是面对对象程序设计中的类和实例一一样，镜像是静态的定义，容器是镜像运行的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。 基本用法12345678910拉取最小的镜像docker pull hello-world查看镜像docker image ls运行镜像docker run hello-world hello-world镜像的内容 123FROM scratch # 从0开始构建COPY hello /CMD [&quot;/hello&quot;] base镜像：提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。 不依赖其他镜像，从scratch构建； 其他镜像可以以之为基础进行扩展。 能称为base镜像的通常是各种Linux发行版的Docker镜像，比如Ubuntu、Debian、CentOS等。 构建镜像：docker commit包含三个步骤： 运行容器 修改容器 将容器保存为新的镜像 Dockerfile构建镜像的步骤： 从base镜像运行一个容器 执行一条指令，对容器做修改 执行类似docker commit的操作，生成一个新的镜像层 Docker再基于刚刚提交的镜像运行一个新容器 重复2-4步，直到Dockerfile中的所有指令执行完毕。 Dockerfile实例 12FROM ubuntuRUN apt-get update &amp;&amp; apt-get install -y vim Dockerfile常用命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051指定base镜像FROM设置镜像的作者MAINTSINER从src目录复制文件到容器的dest，其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL。如果src是归档文件，文件会被自动解压到destADD &lt;src&gt;... &lt;dest&gt;设置构建时的环境变量，在容器运行时是不会存在这些变量的。ARG &lt;name&gt;[=&lt;default value&gt;]CMD指令指定容器启动运行指定的命令，* 如果docker run指定了其他命令，CMD指定的默认命令将被忽略。* 每个Dockerfile可以有多个CMD，但只有最后一个生效。CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off&quot;]复制文件COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]设置容器启动时运行的命令，可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当做参数传递给ENTRYPOINT。ENTRYPOINT设置环境变量ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...声明在运行时容器提供服务的端口EXPOSE &lt;port&gt; [&lt;port&gt;...]LABEL 为镜像添加元数据LABEL version=&quot;1.0&quot;运行指定的命令，并创建新的镜像层，经常用于安装软件包。RUN &lt;command&gt;RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]USER设置用户VOLUME指定挂载点指定工作目录WORKDIR容器暴露端口EXPOSE 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104* attach：依附到一个正在运行的容器中；* build：从一个 Dockerfile 创建一个镜像；* commit：从一个容器的修改中创建一个新的镜像；* cp：在容器和本地宿主系统之间复制文件中；* create：创建一个新容器，但并不运行它；* diff：检查一个容器内文件系统的修改，包括修改和增加；* events：从服务端获取实时的事件；* exec：在运行的容器内执行命令；* export：导出容器内容为一个 tar 包；* history：显示一个镜像的历史信息；* images：列出存在的镜像；* import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；* info：显示一些相关的系统信息；* inspect：显示一个容器的具体配置信息；* kill：关闭一个运行中的容器 (包括进程和所有相关资源)；* load：从一个 tar 包中加载一个镜像；* login：注册或登录到一个 Docker 的仓库服务器；* logout：从 Docker 的仓库服务器登出；* logs：获取容器的 log 信息；* network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；* node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；* pause：暂停一个容器中的所有进程；* port：查找一个 nat 到一个私有网口的公共口；* ps：列出主机上的容器；* pull：从一个Docker的仓库服务器下拉一个镜像或仓库；* push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；* rename：重命名一个容器；* restart：重启一个运行中的容器；* rm：删除给定的若干个容器；* rmi：删除给定的若干个镜像；* run：创建一个新容器，并在其中运行给定命令；* save：保存一个镜像为 tar 包文件；* search：在 Docker index 中搜索一个镜像；* service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；* start：启动一个容器；* stats：输出（一个或多个）容器的资源使用统计信息；* stop：终止一个运行中的容器；* swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；* tag：为一个镜像打标签；* top：查看一个容器中的正在运行的进程信息；* unpause：将一个容器内所有的进程从暂停状态中恢复；* update：更新指定的若干容器的配置信息；* version：输出 Docker 的版本信息；* volume：管理 Docker volume，包括查看、创建、删除等；* wait：阻塞直到一个容器终止，然后输出它的退出符。进入容器的方式：docker attach：直接进入容器启动命令的终端，不会启动新的进程。docker exec -it &lt;container&gt; bash|shdocker run参数：-d：后台运行-P：随机端口映射-p：指定端口映射，有以下四种格式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort-network:指定网络模式，有以下可选参数： -network=brigde 默认选项，表示连接默认的网桥。 -network=host 容器使用宿主主机的网络 -network=container:NAME_or_ID 告诉DOcker让新建的容器使用以有容器的网络配置 -network=none 不配置该容器的网络，用户可自定义网络配置查看运行的容器docker ps停止容器docker stop强制停止容器docker kill进入容器docker attach进入启动的容器交互界面docker exec -it container-id bash删除容器docker rm导出容器docker export red_panda &gt; lastest.tar导入容器docker import nignx2.tar nginxdocker rm $(docker ps -q -f status=exited)docker rmi $(docker images -q -f dangling=true)进入正在运行的容器，39表示容器id前面几位docker exec -it 39 /bin/bash","tags":[],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}]},{"title":"关于KPI","date":"2022-03-08T02:25:29.709Z","path":"wiki/技术开发/技术管理/关于KPI/","text":"","tags":[{"name":"技术管理","slug":"技术管理","permalink":"http://airshu.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"技术管理","slug":"技术开发/技术管理","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}]},{"title":"关于建设技术团队的思考","date":"2022-03-08T02:25:29.709Z","path":"wiki/技术开发/技术管理/关于建设技术团队的思考/","text":"一个好的技术领导者真的可以为公司省很多钱，可以保障产品的质量。自己在这条路上还有很多路要走，现将自己的一些感悟记录下来。 一个优秀的团队，首先要有靠谱的成员，至少核心成员要靠谱，要有主见，要想当“将军”，这样他才能带好手下的兵。一个优秀的团队，需要好的规范，无规矩不成方圆，有了规矩，大家都按照规矩来做事，能减少很多不必要的麻烦，不会让成员觉得无所适从。 开发流程需要的工具：文档管理工具团队的产品、设计、技术文档进行整理归档，随着版本不停的迭代，团队成员进进出出若干，如果没有这些文档，会需要很多时间跟新同事交代哪里哪里是干嘛的，哪里哪里需要注意什么。有了这些文档，一方面方便新来的同事，一方面也是对现有技术的沉淀。 文档分为： 公共文档：用来存放团队所有成员都应知晓的事情，比如团队的开发流程，各个岗位的指责，一些规范注意事项等； 产品文档：用来存放产品的版本迭代详细文案，使用说明等； 设计文档：用来存放PS源文件，sketch源文件，sketch导出的html文件，设计规范等； 技术接口文档：存放不同端的API Docs，方便其他端同事查阅，特别是后端接口文档，非常必要； 技术博客，技术上的沉淀能反映出一家公司的技术底蕴； 各种release包的存放，方便以后使用，有时候需要找到很老的版本找不到的时候会很痛苦的。 如何进行管理：目前的做法是将文档统一存放到服务器上，服务器通过配置Nginx指向不同的文件夹，配置不同的域名分别表示各种类型的文档。 项目管理工具 项目整个周期的时间规划； 任务的分派，所有人都应该把自己的任务规划好计划开始、结束时间，实际开始、结束时间； 项目需要一个人来跟踪进度，每天汇总、统计，同步给项目相关的所有人，发现问题及时调整；（这样做的目的是让大家彼此知道大家的进展，督促自己按时完成自己的任务，管理人员也好根据实际情况调配） 自动构建、持续集成工具Jenkins自动构建，比起本地构建，不依赖个人机器的环境，相应有权限的人都可以进行构建。 Bug统计、管理工具友盟等第三方统计 持续部署工具Docker Kubernetes 技术管理OKRs制定目标，目标拆分，制定关键节点，核对结果。 Review Code代码Review，提升代码质量 Unit Test单元测试，减少bug数 技术分享技术沉淀 一些感悟金无足赤、人无完人，想要团队内所有的人都积极主动，把工作当成自己生命中很重要的东西是很困难的。所以才需要管理，需要规则。让大家努力工作的几个核心： 赏罚分明。且要加大力度，如果做的很好，才奖励几百块，出了事故就批评一下；会让大家变的不在乎。所以一定要加大赏罚力度。让大家感觉有奔头，比如如果能完成全年KPI，奖金就能超过基本工资，那大家一定会想尽办法来完成它。如果出现严重的bug，会严厉批评，扣奖金；更严重的会让你直接走人。那么大家就会重视自己的每一行代码了。 比较强势的团队文化。一个好的团队，是需要狼性的，为了目标就应该全力以赴。而不是拖拖拉拉。当然，适当的调整也是有必要的，如果一直在强压力工作下，人也会受不了的。这是相辅相成的。 关于需求变动在日常开发中，需求的变动是很正常的。但因此带来的影响则需要好好分析，而不是一味的来了需求就安排。正常情况下，每个周期的需求定好之后，团队中所有人的工作安排应该都是100%满负荷的。如果在开发过程中，有需求要修改或者新增，则要么版本的周期进行调整，要么大家加班加点把它做完。在这里，我会先评估改动对整个周期造成的影响，如果影响并不大，则会安排人员在周期内进行消化；如果消化不了，也是不建议修改版本周期的。如果因为个别的改动，造成大部分人的影响是不值得的。比如，开发团队30人，新增的需求需要3个人开发3天，如果将周期延后3天，则其他27人是要重新安排工作的。如果经常出现需求变动的时候，就应该思考需求提出者是不是没有把本职工作做好。 按职能还是按业务来分配子团队不同人数的团队 如何进行良好的沟通所有事情有开始有结束。当你把一件事情交代给某一个人时，首先要描述清楚自己想要的结果，然后让对方明确是否明白，再确认最后完成时间。作为收到任务的一方，也应该把自己的理解表达清楚，双方达成一致；最好能在deadline之前就找需求方告知结果，而不是踩着时间线甚至延期告知。 如何带新人对于刚进来的同事，应该准备一份详细的注意事项。比如我们的开发流程是怎样的；有那些账号需要申请，申请流程；常用的工具，工具的使用文档、下载地址；还有许多平常开发中常见的问题。有这样一份文档，新人也不需要一遇到问题就来找你，也节省了你的时间。","tags":[{"name":"技术管理","slug":"技术管理","permalink":"http://airshu.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"技术管理","slug":"技术开发/技术管理","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}]},{"title":"Proxifier使用","date":"2022-03-08T02:25:29.707Z","path":"wiki/工具软件/Proxifier使用/","text":"Proxifier的作用：让电脑上的软件的网络请求先经过代理，可用于翻墙、接口抓取等。 设置Proxies设置Server设置为代理对应的IP地址，本地使用localhost&#x2F;127.0.0.1 Protocol可设置为Socks或https Rules设置可以做一些个性化设置，比如某些应用不走代理 参考 https://xiandan.in/posts/mac-global-proxy.html https://www.hizxc.com/1546.html","tags":[],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"屏幕截图工具","date":"2022-03-08T02:25:29.707Z","path":"wiki/工具软件/屏幕截图工具/","text":"平时工作中有很多场景需要使用屏幕截图，原来一直使用QQ自带的截图功能。虽然功能不是很全，但也够了。但由于其是QQ的一个子功能，每次一定要启动QQ才能使用。于是想看有木有更加方便好用的截图软件。 这里推荐两款自认为不错的工具： Snagit主要功能： 捕获窗口截图 区域截图 全屏幕截图 抓取文字 屏幕录像 捕获滚动窗口 FSCapture主要功能： 捕获窗口截图 区域截图 全屏幕截图 抓取文字 屏幕录像 捕获滚动窗口 捕获手绘区域 QQ截屏独立版包含所需的基本功能，且可执行文件很小，不到800K。添加桌面快捷方式，配置好快捷键后，使用非常方便。 下载地址：","tags":[{"name":"效率","slug":"效率","permalink":"http://airshu.github.io/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"文本编辑工具Sublime Text","date":"2022-03-08T02:25:29.707Z","path":"wiki/工具软件/文本编辑工具Sublime Text/","text":"Markdown环境搭建安装扩展MarkdownEditing下载地址： https://github.com/SublimeText-Markdown/MarkdownEditing 快捷键 Windows&#x2F;Linux 描述 CtrlAltV Creates or pastes the contents of the clipboard as an inline link on selected text. CtrlAltR Creates or pastes the contents of the clipboard as a reference link. ShiftWinK Creates or pastes the contents of the clipboard as an inline image on selected text. AltB AltI These are bound to bold and italic. They work both with and without selections. If there is no selection, they will just transform the word under the cursor. These keybindings will unbold&#x2F;unitalicize selection if it is already bold&#x2F;italic. Ctrl1...6 These will add the corresponding number of hashmarks for headlines. Works on blank lines and selected text in tandem with the above headline tools. If you select an entire existing headline, the current hashmarks will be removed and replaced with the header level you requested. This command respects the mde.match_header_hashes preference setting. AltShift6 Inserts a footnote. ShiftTab Fold&#x2F;Unfold current section. CtrlShiftTab Fold all sections under headings of a certain level. CtrlAltShiftPageUp CtrlAltShiftPageDown Go to the previous&#x2F;next heading of the same or higher level CtrlShiftPageUp CtrlShiftPageDown Go to the previous&#x2F;next heading CtrlShiftH Open home page CtrlShiftD Open wiki page under the cursor CtrlShiftJ Open journal page for today CtrlShiftB List back links 表格编辑插件下载地址： https://packagecontrol.io/packages/Table%20Editor PHP环境搭建Python环境搭建安装Anaconda插件(代码提示、自动补全、格式化)//快捷键配置 [ &#123; &quot;command&quot;: &quot;anaconda_goto&quot;, &quot;keys&quot;: [&quot;ctrl+alt+g&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_find_usages&quot;, &quot;keys&quot;: [&quot;ctrl+alt+f&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_doc&quot;, &quot;keys&quot;: [&quot;ctrl+alt+d&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, //格式化 &#123; &quot;command&quot;: &quot;anaconda_auto_format&quot;, &quot;keys&quot;: [&quot;ctrl+alt+r&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_fill_funcargs&quot;, &quot;keys&quot;: [&quot;tab&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125;, &#123;&quot;key&quot;: &quot;anaconda_insert_funcargs&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_fill_funcargs&quot;, &quot;keys&quot;: [&quot;ctrl+tab&quot;], &quot;args&quot;: &#123;&quot;all&quot;: true&#125;, &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125;, &#123;&quot;key&quot;: &quot;anaconda_insert_funcargs&quot;&#125; ]&#125; ] 配置Python解释器打开Preferences--&gt;Package Settings--&gt;Anaconda--&gt;Settings-User &#123; //设置python解释器路径 &quot;python_interpreter&quot;: &quot;D:\\\\Python\\\\Python364-64\\\\python.exe&quot;, &quot;suppress_word_completions&quot;: true, &quot;suppress_explicit_completions&quot;: true, &quot;complete_parameters&quot;: true, &quot;anaconda_linting&quot;: false &#125; Sublime中console交互，安装SublimeREPL配置SUblimeREPL快捷键1. Preferences--&gt;Browse Packages--&gt;SublimeREPL文件夹--&gt;config文件夹--&gt;Python文件夹--&gt;Default.sublime-commands 2. 找到对应的command，添加到Preferences--&gt;Key Bindings User中。 &#123; &quot;keys&quot;: [&quot;f5&quot;], &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot; &#125; &#125;, 如何设置快捷键打开Preferences--&gt;Key Bindings，对于向要定义自己喜好的快捷键的操作，复制左边默认的配置到用户栏，进行修改。 如何修改默认配置打开Preferences--&gt;Settings，重写默认配置即可。 Sublime 插件Anaconda:Python插件 CodeFormatter：代码提示插件 ConvertToUTF8 SublimeCodeIntel Markdown Preview：Markdown预览插件 Emmet：HTML/CSS代码快速编写插件 SublimeLinter：代码检测插件 SideBarEnhancements：侧边栏扩展 PackageResourceViewer：Sublime配置管理插件,选择Open Resource,选择对应的配置进行修改 Boxy Theme:样式插件 Terminal：在Sublime中打开终端 CTags：[代码跳转](https://my.oschina.net/u/1024767/blog/495282) http://ctags.sourceforge.net/ Sublime PHP Companion All Autocomplete DocBlockr SublimeAStyleFormatter：C, C++, C#, 和 Java文件格式化 如何备份插件备份Preferences–&gt;Browse Packages的内容 属性配置&#123; //默认字体大小 &quot;font_size&quot;: 10, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], //是否检查更新 &quot;update_check&quot;: &quot;false&quot;, //显示空格符号 // &quot;draw_white_space&quot;: &quot;all&quot;, &#125; 常用快捷键配置[ //跳转到定义 &#123; &quot;keys&quot;: [&quot;f3&quot;], &quot;command&quot;: &quot;goto_definition&quot; &#125;, //删除当前行 &#123; &quot;keys&quot;: [&quot;ctrl+d&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;, //back &#123; &quot;keys&quot;: [&quot;alt+left&quot;], &quot;command&quot;: &quot;jump_back&quot; &#125;, //forward &#123; &quot;keys&quot;: [&quot;alt+right&quot;], &quot;command&quot;: &quot;jump_forward&quot; &#125;, //移动当前行到上一行 &#123; &quot;keys&quot;: [&quot;alt+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;, //移动当前行到下一行 &#123; &quot;keys&quot;: [&quot;alt+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+alt+f&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;, // 自动提示、补全 &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;auto_complete&quot;&#125;, //代码提示 &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;replace_completion_with_auto_complete&quot;, &quot;context&quot;: [&#123; &quot;key&quot;: &quot;last_command&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;insert_best_completion&quot; &#125;, &#123; &quot;key&quot;: &quot;auto_complete_visible&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: false &#125;, &#123; &quot;key&quot;: &quot;setting.tab_completion&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true &#125;] &#125;, //Ctrl+l 选中当前行 //编译当前脚本 &#123; &quot;keys&quot;: [&quot;ctrl+b&quot;], &quot;command&quot;: &quot;build&quot; &#125;, //隐藏Side Bar开关 &#123; &quot;keys&quot;: [&quot;ctrl+k&quot;], &quot;command&quot;: &quot;toggle_side_bar&quot; &#125;, //向左缩进 &#123; &quot;keys&quot;: [&quot;ctrl+]&quot;], &quot;command&quot;: &quot;indent&quot; &#125;, //向右缩进 &#123; &quot;keys&quot;: [&quot;ctrl+[&quot;], &quot;command&quot;: &quot;unindent&quot; &#125;, //列出当前打开的文件 &#123; &quot;keys&quot;: [&quot;ctrl+p&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;show_files&quot;: true&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+p&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;command_palette&quot;&#125; &#125;, //跳转到符号 &#123; &quot;keys&quot;: [&quot;ctrl+r&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;@&quot;&#125; &#125;, //跳转到行 &#123; &quot;keys&quot;: [&quot;ctrl+g&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+;&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;#&quot;&#125; &#125;, //快速在起始括号和结尾括号间切换 &#123; &quot;keys&quot;: [&quot;ctrl+m&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;, //选择括号间的内容 &#123; &quot;keys&quot;: [&quot;ctrl+shift+m&quot;], &quot;command&quot;: &quot;expand_selection&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;, //当前行下面新增一行并跳至该行 &#123; &quot;keys&quot;: [&quot;ctrl+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Add Line.sublime-macro&quot;&#125; &#125;, //当前行上面新增一行并调至该行 &#123; &quot;keys&quot;: [&quot;ctrl+shift+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Add Line Before.sublime-macro&quot;&#125; &#125;, //进行逐词移动 &#123; &quot;keys&quot;: [&quot;ctrl+left&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;words&quot;, &quot;forward&quot;: false&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+right&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;word_ends&quot;, &quot;forward&quot;: true&#125; &#125;, //逐词选择 &#123; &quot;keys&quot;: [&quot;ctrl+shift+left&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;words&quot;, &quot;forward&quot;: false, &quot;extend&quot;: true&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+right&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;word_ends&quot;, &quot;forward&quot;: true, &quot;extend&quot;: true&#125; &#125;, //上下移动当前显示区域 &#123; &quot;keys&quot;: [&quot;ctrl+up&quot;], &quot;command&quot;: &quot;scroll_lines&quot;, &quot;args&quot;: &#123;&quot;amount&quot;: 1.0 &#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+down&quot;], &quot;command&quot;: &quot;scroll_lines&quot;, &quot;args&quot;: &#123;&quot;amount&quot;: -1.0 &#125; &#125;, //移动当前行 &#123; &quot;keys&quot;: [&quot;ctrl+shift+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;, //删除当前 &#123; &quot;keys&quot;: [&quot;ctrl+shift+k&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;, //Ctrl + D选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl + D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl + K进行跳过，使用Ctrl + U进行回退，使用Esc退出多重编辑。 &#123; &quot;keys&quot;: [&quot;ctrl+d&quot;], &quot;command&quot;: &quot;find_under_expand&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+k&quot;, &quot;ctrl+d&quot;], &quot;command&quot;: &quot;find_under_expand_skip&quot; &#125;, //打散所选区域 &#123; &quot;keys&quot;: [&quot;ctrl+shift+l&quot;], &quot;command&quot;: &quot;split_selection_into_lines&quot; &#125;, //将选中区域合并为一行 &#123; &quot;keys&quot;: [&quot;ctrl+j&quot;], &quot;command&quot;: &quot;join_&lt;l&gt;&lt;/l&gt;ines&quot; &#125;, //选择行 &#123; &quot;keys&quot;: [&quot;ctrl+l&quot;], &quot;command&quot;: &quot;expand_selection&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;line&quot;&#125; &#125;, //把选区分割 &#123; &quot;keys&quot;: [&quot;ctrl+shift+l&quot;], &quot;command&quot;: &quot;split_selection_into_lines&quot; &#125;, ] 如何自定义插件 如何自定义代码块 如何自定义语法 参考官方文档 Sublime Text非官方文档 Sublime Text3文档","tags":[{"name":"效率","slug":"效率","permalink":"http://airshu.github.io/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"Windows优秀的工具软件","date":"2022-03-08T02:25:29.707Z","path":"wiki/工具软件/Windows优秀的工具软件/","text":"文件解锁工具 魔方解锁独立版 内存、CPU监控工具TrafficMonitor 介绍：https://www.appinn.com/trafficmonitor/ Github地址：https://github.com/zhongyang219/TrafficMonitor 文件管理工具TotalCommand 官网地址：https://www.ghisler.com/ 文件搜索工具Everything 官网地址：http://www.voidtools.com/ 剪切板增强工具Ditto 官网地址：https://ditto-cp.sourceforge.io/ 屏幕截图工具 Snagit FSCapture 相关介绍 颜色吸取工具getcolor! 下载地址： https://www.wincatalog.com/getcolor.html","tags":[{"name":"效率","slug":"效率","permalink":"http://airshu.github.io/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"Chrome插件推荐","date":"2022-03-08T02:25:29.706Z","path":"wiki/工具软件/Chrome插件推荐/","text":"Proxy SwitchyOmegaVPN代理 Clear Cache清理缓存 DJSON ViewerJSON格式化显示 Gitlab TreeViewGitlab文件夹树形显示 Last Pass记录密码 Extensity扩展显示管理 LighthouseLighthouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 当为 Lighthouse提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。","tags":[{"name":"效率","slug":"效率","permalink":"http://airshu.github.io/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"tushare","date":"2022-03-08T02:25:29.696Z","path":"wiki/Python/tushare/","text":"股票数据抓取框架使用TuShare。 http://tushare.org/","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"Alfred使用技巧","date":"2022-03-08T02:25:29.696Z","path":"wiki/工具软件/Alfred使用技巧/","text":"基本操作 使用Alt+空格启动，在输入框中输入相应命令进行操作。以下根据其设置界面的布局，按照相应的目录进行介绍。 General General界面主要是以下几个功能： Startup：是否在系统启动时自启动Alfred。 Alfred Hotkey：调出Alfred操作界面的热键。默认为Alt + 空格。 Where are you：你在哪个国家。Alfred内置了常用网站搜索功能，在搜索时打开对应国家的网站。 Features 这里包含了Alfred自己开发的功能，接下来一个一个介绍它们。有些功能在我们日常使用中非常有用！ Defalut Result 打开输入框后，按一下空格，即可在Finder中搜索相应文件。 Essentials： 基本的搜索设置 Extras： 额外的搜索设置 Search Scope： 搜索的范围，可以自定义一些常用文件夹 Fallbacks： 若上面的查询搜索不到结果时，就会调用这里设置的网站或搜索引擎来进行进一步的查询。 File Search SearchOpening Files open+文件名直接打开某个文件。 Revealing Files find+文件名则表示在Finder中打开该文件。 Inside Files in+内容可以把文件中包含内容的文件找出来。 File Tags tag+标签名字可以把打上标签的文件或文件夹搜索出来。 Don’t Show: 不显示某类型的文件 Result Limit： 搜索条数限制 NavigationBufferAdvancedActions顾名思义，Actions指你要对文件执行的动作。先搜索到你要处理的文件，然后点击Ctrl键。 Web Search 网络搜索，也可以自定义自己的搜索。比如使用百度搜索 Web Bookmarks搜索浏览器书签，目前只支持safari、chrome。 Clipboard History剪切板历史，可以自定义快捷键，打开历史面板。非常实用的一个功能。 Snippets短语设置，配置一些常用的短语，设置简短的关键字。还可以设置自动替换。 添加CollectionAffix表示当前集合的前缀，该类型下所有的短语都需要前缀+关键字来展示。 Calculator可以直接在aflred搜索框中使用计算功能 Workflows有了工作流，我们的效率会得到很大的提高。比如，可以迅速切换软件，快速查询自己想看的书评、电影评价，快速查询当前ip地址，快速查询当前股票的价格等。 AppLauncher设置快捷键快速打开软件 douban豆瓣搜索，dbb+书名和dbm+电影名进行相关搜索 Githubgithub搜索 Gitlabgitlab搜索 IP Address当前内网和外网ip查询 中国股票行情 进行股票查询，gp+股票号码进行实时股价查询，gp add xxxxxx把相应股票添加到自选股，gp list查看所有自选股的股价。 AppearanceAlfred主题 RemoteAdvanced","tags":[],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]},{"title":"Python环境配置管理","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/Python环境配置/","text":"类似Java中的jenv、Flutter的fvm工具，Python也有多版本管理工具，这里推荐使用pyenv。 先记录下Mac m1的默认python环境 Mac OS 12.3之后系统去掉了Python2，Mac上的默认Python环境可能有： |python版本|Python路径|支持的架构｜备注|—|—|—|—-|Python3.x|&#x2F;usr&#x2F;bin&#x2F;python3|x86_64 arm64|Xcode自带的Python环境,&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Library&#x2F;Frameworks&#x2F;Python3.framework&#x2F;Versions目录两种可能有多个版本Python3.x｜​​&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.8​​｜​​x86_64​​｜Rosetta2转译版brew安装的Python​​Python3.10.9​​｜​​&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;python3​​｜​​arm64​​｜本地编译brew安装的Python (原生支持m1)​​Python3.9.15​​｜​​&#x2F;opt&#x2F;homebrew&#x2F;Caskroom&#x2F;​​​​miniforge&#x2F;base&#x2F;bin&#x2F;python​​|通过本地编译brew安装的mini-forge中base环境的Python 在做版本管理的时候建议使用pyenv，使用brew安装后的目录查找起来很麻烦 pyenv使用123456789101112131415161718#安装pyenvbrew install pyenv#配置环境变量 echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.zshrcecho &#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrcecho &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc#安装某个python版本pyenv install 3.10.4# 查看所有版本pyenv versions#切换python版本pyenv global 3.10.4#当前shell切换python版本pyenv shell 3.10.4 #卸载pyenv uninstall 3.10.4 同一个python版本不同环境1234567891011121314151617#安装pyenv-virtualenvgit clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenvecho &#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27; &gt;&gt; ~/.zshrcpyenv virtualenv 3.10.4 frida16# 查看工作环境列表pyenv virtualenvs #对应的工作环境目录为~/.pyenv/versions/3.10.4/envs/frida16# 激活环境pyenv activate frida16#退出环境pyenv deactivate# 删除工作环境pyenv virtualenv-delete frida16 参考 https://www.jianshu.com/p/dcb281ee564e https://virtualenv.pypa.io/en/latest/ 谈谈MacOS下的Python版本管理问题 原创","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"RxPY学习笔记","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/RxPy学习笔记/","text":"基本概念参考这里，Python的版本也是根据这些概念，通过使用自己的特性实现。但由于种种原因，Python的不同版本间变化很大。可以参考这里。 基本的用法可以参考文档和源码中的test，这里只记录一些自己遇到的问题和解决方案 官方使用文档翻译 安装如果使用V3.x版本： 1pip install rx 如果使用1.6的版本 1pip install rx==1.6.1 基本概念RXPY，使用可观察序列，查询操作符组合，可异步化，基于事件的一套Python库。使用Rx，开发者可以使用Observables来表示异步数据流，使用operators查询异步数据流，使用Schedulers对数据&#x2F;事件流进行异步参数化。 使用Rx，你可以表示多个异步数据流，使用观察者（Observer）对象来订阅（subscribe）事件流。当事件发生时可观察者（Observable）通知订阅者。你可以在Observable和Observer之间放置各种转换。 因为Observable队列是数据流，你可以使用相关操作符进行链式操作。你可以filter，map，reduce，compose，基于时间的操作，等等。除此之外，还有许多其他特定于响应流的操作符允许编写功能强大的查询。取消、异常和同步也可以通过专用的操作符处理。 开始Observable是ReactiveX的核心类型。它串行的添加元素，像排放系统一样，通过一系列的操作直到最后传递到Observer，在那里它们被消费。 基于推(而不是基于拉)的迭代为表达代码和并发提供了强大的新可能性。因为一个Observable将事件当作数据，也将数据当作事件。 有很多种方式创建Obserable，你可以使用create（）工厂方法，传递一个函数给他。 - on_next在Observable发射一个元素时被调用 - on_completed在Obserable完成时被调用 - on_error在Obserable发生错误时被调用 这三个回调是可选的。 让我们看一个例子： 123456789101112131415161718from rx import createdef push_five_strings(observer, scheduler): observer.on_next(&quot;Alpha&quot;) observer.on_next(&quot;Beta&quot;) observer.on_next(&quot;Gamma&quot;) observer.on_next(&quot;Delta&quot;) observer.on_next(&quot;Epsilon&quot;) observer.on_completed()source = create(push_five_strings)source.subscribe( on_next = lambda i: print(&quot;Received &#123;0&#125;&quot;.format(i)), on_error = lambda e: print(&quot;Error Occurred: &#123;0&#125;&quot;.format(e)), on_completed = lambda: print(&quot;Done!&quot;),) Observable通过create创建，push_five_strings被调用。这个函数发射了五个元素。subscribe中实现了三个回调函数。输出结果为： 123456Received AlphaReceived BetaReceived GammaReceived DeltaReceived EpsilonDone! of工厂函数，接收list参数，会依此发射它们，如果忽略completion和error，subscribe可以支传一个参数 12345678910111213141516from rx import ofsource = of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;)source.subscribe( on_next = lambda i: print(&quot;Received &#123;0&#125;&quot;.format(i)), on_error = lambda e: print(&quot;Error Occurred: &#123;0&#125;&quot;.format(e)), on_completed = lambda: print(&quot;Done!&quot;),)输出结果：Received AlphaReceived BetaReceived GammaReceived DeltaReceived Epsilon 操作符和链接你可以使用超过130个操作符来导出新的Observables，每个操作符会生产一个Observable，它会以管道的形式改变原来的Observable。比如，我们使用map()处理每个字符串的长度，然后filter()来过滤长度超过5的元素。 123456789101112131415from rx import of, operators as opsource = of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;)composed = source.pipe( op.map(lambda s: len(s)), op.filter(lambda i: i &gt;= 5))composed.subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value)))Received 5Received 5Received 5Received 7 还可以使用以下方式将整个操作链接起来，还能减少临时变量的产生 123456from rx import of, operators as opof(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( op.map(lambda s: len(s)), op.filter(lambda i: i &gt;= 5)).subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value))) 自定义操作符随着操作符链的发展，为了提高代码的可读性，须对链进行拆分。新的操作符被实现为函数，可以直接在管道操作符中使用。当一个操作符被实现为其他操作符的组合时，由于管道函数的存在，实现非常简单 123456789101112import rxfrom rx import operators as opsdef length_more_than_5(): return rx.pipe( ops.map(lambda s: len(s)), ops.filter(lambda i: i &gt;= 5), )rx.of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( length_more_than_5()).subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value))) 也可以自己创建一个操作符，以下操作符实现了将字符串转换为小写的功能 12345678910111213141516171819import rxdef lowercase(): def _lowercase(source): def subscribe(observer, scheduler = None): def on_next(value): observer.on_next(value.lower()) return source.subscribe( on_next, observer.on_error, observer.on_completed, scheduler) return rx.create(subscribe) return _lowercaserx.of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( lowercase() ).subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value))) 并发控制为了实现并发，你要使用两个操作符：subscribe_on和observe_on。两者都需要Scheduler来提供线程给订阅者工作。ThreadPoolScheduler是一个重用线程的好选择。 GIL可能会破坏并发性能，因为它阻止多个线程同时访问同一行代码。像NumPy这样的库可以在释放GIL时减轻这种并行密集计算的负担。RxPy还可以在某种程度上减少线程重叠。一定要用并发性测试您的应用程序，并确保有性能增益. subscribe_on()指示链开始处的源Observable序使用哪个调度器(不管您将该操作符放在哪里)。不过，observe_on()会在这个时候切换到不同的调度程序，有效地将发射从一个线程转移到另一个线程。一些工厂函数和操作符，如interval()和delay()，已经有了默认的调度程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import multiprocessingimport randomimport timefrom threading import current_threadimport rxfrom rx.scheduler import ThreadPoolSchedulerfrom rx import operators as opsdef intense_calculation(value): # sleep for a random short duration between 0.5 to 2.0 seconds to simulate a long-running calculation time.sleep(random.randint(5, 20) * 0.1) return value# calculate number of CPUs, then create a ThreadPoolScheduler with that number of threadsoptimal_thread_count = multiprocessing.cpu_count()pool_scheduler = ThreadPoolScheduler(optimal_thread_count)# Create Process 1rx.of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( ops.map(lambda s: intense_calculation(s)), ops.subscribe_on(pool_scheduler)).subscribe( on_next=lambda s: print(&quot;PROCESS 1: &#123;0&#125; &#123;1&#125;&quot;.format(current_thread().name, s)), on_error=lambda e: print(e), on_completed=lambda: print(&quot;PROCESS 1 done!&quot;),)# Create Process 2rx.range(1, 10).pipe( ops.map(lambda s: intense_calculation(s)), ops.subscribe_on(pool_scheduler)).subscribe( on_next=lambda i: print(&quot;PROCESS 2: &#123;0&#125; &#123;1&#125;&quot;.format(current_thread().name, i)), on_error=lambda e: print(e), on_completed=lambda: print(&quot;PROCESS 2 done!&quot;),)# Create Process 3, which is infiniterx.interval(1).pipe( ops.map(lambda i: i * 100), ops.observe_on(pool_scheduler), ops.map(lambda s: intense_calculation(s)),).subscribe( on_next=lambda i: print(&quot;PROCESS 3: &#123;0&#125; &#123;1&#125;&quot;.format(current_thread().name, i)), on_error=lambda e: print(e),)input(&quot;Press any key to exit\\n&quot;) IO异步 许多异步框架都支持IO异步，RxPY中使用相关连的schedulers。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from collections import namedtupleimport asyncioimport rximport rx.operators as opsfrom rx.subject import Subjectfrom rx.scheduler.eventloop import AsyncIOSchedulerEchoItem = namedtuple(&#x27;EchoItem&#x27;, [&#x27;future&#x27;, &#x27;data&#x27;])def tcp_server(sink, loop): def on_subscribe(observer, scheduler): async def handle_echo(reader, writer): print(&quot;new client connected&quot;) while True: data = await reader.readline() data = data.decode(&quot;utf-8&quot;) if not data: break future = asyncio.Future() observer.on_next(EchoItem( future=future, data=data )) await future writer.write(future.result().encode(&quot;utf-8&quot;)) print(&quot;Close the client socket&quot;) writer.close() def on_next(i): i.future.set_result(i.data) print(&quot;starting server&quot;) server = asyncio.start_server(handle_echo, &#x27;127.0.0.1&#x27;, 8888, loop=loop) loop.create_task(server) sink.subscribe( on_next=on_next, on_error=observer.on_error, on_completed=observer.on_completed) return rx.create(on_subscribe)loop = asyncio.get_event_loop()proxy = Subject()source = tcp_server(proxy, loop)aio_scheduler = AsyncIOScheduler(loop=loop)source.pipe( ops.map(lambda i: i._replace(data=&quot;echo: &#123;&#125;&quot;.format(i.data))), ops.delay(5.0)).subscribe(proxy, scheduler=aio_scheduler)loop.run_forever()print(&quot;done&quot;)loop.close() 默认的Scheduler 有多种方式选额scheduler。第一种是给操作符提供scheduler。但当有多个操作符时，可能会被忽略。所以第二种方式时提供默认的scheduler。 123source.pipe( ...).subscribe(proxy, scheduler=my_default_scheduler) 操作符选择scheduler的方式如下： 如果给操作符提供了scheduler，选择它 如果默认scheduler有提供，选择它 否则选择自带的 迁移https://rxpy.readthedocs.io/en/latest/migration.html 从RxPY v1迁移到v3 操作符创建Observable 操作符 描述 create 创建一个Observable empty 创建空的Obserbale，发射空元素，马上结束 never throw 创建一个立马抛出错误的Observable from_ 转换其他数据或对象给Observable interval 创建一个间隔执行的Observable just range 创建一个整数队列的Observable repeat_value 重复发送特殊元素或队列元素 start timer 转换Observables 操作符 描述 buffer flat_map group_by map scan window 过滤Observables 操作符 描述 debounce distinct element_at filter first ignore_elements last sample skip skip_last take take_last 结合Observables 操作符 描述 combine_latest join merge start_with switch_latest zip 错误处理 操作符 描述 catch retry 实用操作符 操作符 描述 delay do materizlize dematerialize observe_on subscribe subscribe_on time_interval timeout timestamp 条件和布尔操作符 操作符 描述 all amb contains default_if_empty sequence_equal skip_until skip_while take_until take_while 数学相关操作符 操作符 描述 average concat count max min reduce sum 可连接Observable操作符 操作符 描述 connect publish ref_count replay 额外的阅读RxPY源码仓库包含实例notebooks ReactiveX官方地址和文档： Introduction Tutorials Operators 一些商业内容可以免费获得它们相关联的示例代码 Packt Reactive Programming in Python RxPY 3.0.0取消了对backpressure的支持，以下是已知的支持backpress的社区项目 rxbackpressure rxpy extension rxpy_backpressure observer decorators 商业资源 O’Reilly Video O’Reilly has published the video Reactive Python for Data Science which is available on both the O’Reilly Store as well as O’Reilly Safari. This video teaches RxPY from scratch with applications towards data science, but should be helpful for anyone seeking to learn RxPY and reactive programming. Packt Video Packt has published the video Reactive Programming in Python, available on Packt store. This video teaches how to write reactive GUI and network applications. 如何在PyQt5中使用scheduler，在非主线程中执行某个操作，然后回到UI线程执行另一个操作。12345rx.from_list([1, 2, 3, 4]).pipe(operators.map(add), operators.subscribe_on(pool_scheduler), operators.observe_on(QtThreadSafeScheduler(QtCore))).subscribe( on_next=lambda i: print(&quot;PROCESS 3: &#123;0&#125; &#123;1&#125;&quot;.format(threading.current_thread().name, i)), on_error=lambda e: print(e), on_completed=lambda: print(&quot;Done!&quot;) ) 其中的QtThreadScheduler来自于https://github.com/jcafhe/RxPY 参考 Github官方地址 文档 https://rxmarbles.com","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"ctypes模块","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/ctypes/","text":"ctypes 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。 Hello World 编写C文件 编译C文件 编写Python文件、测试 1. 编写C文件1234567#include &lt;stdio.h&gt;int hello(const char* name) &#123; printf(&quot;~~~hello %s ! \\n&quot;, name); return 0;&#125; 2. 编译C文件不同平台生成不同格式的动态库，windows下为dll，linux下为so gcc -fPIC -shared hello_module.c -o hello_module.dylib 3. 编写Python文件123456import ctypesfrom ctypes import c_char_plib = ctypes.cdll.LoadLibrary(&quot;hello_module.dylib&quot;)lib.hello(c_char_p(bytes(&quot;world&quot;, &quot;utf-8&quot;))) 类型映射关系 ctypes C 类型 Python类型 c_bool _Bool bool (1) c_char char 单字符字节对象 c_wchar wchar_t 单字符字符串 c_byte char int c_ubyte unsigned char int c_short short int c_ushort unsigned short int c_int int int c_uint unsigned int int c_long long int c_ulong unsigned long int c_longlong __int64 或 long long int c_ulonglong unsigned __int64 或 unsigned long long int c_size_t size_t int c_ssize_t ssize_t 或 Py_ssize_t int c_float float float c_double double float c_longdouble long double float c_char_p char * (NUL terminated) 字节串对象或 None c_wchar_p wchar_t * (NUL terminated) 字符串或 None c_void_p void * int 或 None 回调函数1234567891011121314151617181920212223242526272829############## main.c ###############include &lt;stdint.h&gt;#include &lt;stdio.h&gt;struct mes_t&#123; uint32_t field1; uint32_t field2; void* data;&#125;;typedef int function_callback(struct mes_t* message );function_callback* my_callback;int function_one(function_callback fcb)&#123; //Set to a global variable for later use my_callback = fcb; //Declare object in stack struct mes_t mes; mes.field1 = 132; mes.field2 = 264; mes.data = NULL; //Pass pointer of object in stack, and print the return value printf(&quot;Got from python: %d\\n&quot;, my_callback( &amp;mes ) );&#125; 123456789101112131415161718192021222324252627282930313233############ main.py ################import ctypestestlib = ctypes.CDLL(&#x27;./testlib.so&#x27;)#Declare the data structureclass mes_t(ctypes.Structure): _fields_ = ( (&#x27;field1&#x27;, ctypes.c_uint32), (&#x27;field2&#x27;, ctypes.c_uint32), (&#x27;data&#x27;, ctypes.c_void_p))#Declare the callback type, since that is not stored in the librarycallback_type = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(mes_t) )def the_callback(mes_p): #dereference the pointer my_mes = mes_p[0] print &quot;I got a mes_t object! mes.field1=%r, mes.field2=%r, mes.data=%r&quot; \\ % (my_mes.field1, my_mes.field2, my_mes.data) #Return some random value return 999#Let the library know about the callback function by calling &quot;function_one&quot;result = testlib.function_one(callback_type(the_callback) )#########################gcc -shared -o testlib.so -fPIC main.cpython main.py 参考：http://blog.sina.com.cn/s/blog_6e22d8fb0102y462.html 线程状态和GILPython解释器不是完全线程安全的。为了支持多线程Python程序，有一个全局锁，称为global interpreter lock或GIL，它必须由当前线程持有才能安全访问Python对象。没有锁，即使最简单的操作也可能导致多线程程序中的问题：例如，当两个线程同时增加同一对象的引用计数时，引用计数可能最终只增加一次而不是两次。 释放GIL123Py_BEGIN_ALLOW_THREADS... Do some blocking I/O operation ...Py_END_ALLOW_THREADS 非Python创建的线程当使用专用的Python API（例如threading模块）创建线程时，线程状态会自动关联到它们，因此上面显示的代码是正确的。但是，当从C创建线程时（例如由具有自己的线程管理的第三方库），它们不持有GIL，也没有线程状态结构。 如果你需要从这些线程调用Python代码（通常这将是上述第三方库提供的回调API的一部分），你必须首先通过创建线程状态数据结构来注册这些线程和解释器，然后获取GIL，最后存储他们的线程状态指针，然后才能开始使用Python &#x2F; C API。当你完成后，你应该重置线程状态指针，释放GIL，最后释放线程状态数据结构。 123456789PyGILState_STATE gstate;gstate = PyGILState_Ensure();/* Perform Python actions here. */result = CallSomeFunction();/* evaluate result or handle exception *//* Release the thread. No Python API allowed beyond this point. */PyGILState_Release(gstate); 释放GIL和非python创建的线程中调用python函数都没有测试成功… 参考 http://icejoywoo.github.io/2018/12/10/intro-python-ctyps.html https://anribras.github.io/tech/2019/01/03/python-ctypes%E6%80%BB%E7%BB%93/","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"CFFI笔记","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/cffi笔记/","text":"","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"json解析库选择和使用","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/json解析库选择和使用/","text":"比较 simplejson：django的内置模块，如果没有C扩展加速，效率极其低下。 rapidjson： ujson：使用C语言实现 orjson：使用Rust语言实现 测试代码 12345678910111213141516171819202122232425262728from time import timeimport sysimport string num = int(sys.argv[1])lib = sys.argv[2] items = []for i in range(num): items.append(&#123;c:c for c in string.ascii_letters&#125;) start = time()if lib == &#x27;ujson&#x27;: import ujson ujson.dumps(items)elif lib == &#x27;rapidjson&#x27;: import rapidjson rapidjson.dumps(items)elif lib == &#x27;orjson&#x27;: import orjson orjson.dumps(items)else: import json json.dumps(items) print(time() - start)&gt;&gt;python 1000|10000|100000|1000000 json|ujson|rapidjson|orjson orjsongithub地址 安装 首先安装rust，从rust官网下载rustup-init.exe安装程序。选择安装nightly类型。参考。 安装orjson，pip install orjson 注意 orjson is tested for amd64 and aarch64 on Linux, macOS, and Windows. It may not work on 32-bit targets. ujson安装需要依赖C&amp;C++编译环境，参考https://github.com/statsmodels/statsmodels/issues/4160 参考 https://yanbin.blog/python-json-choose-ujson-if-necessary/","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"win32模块","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/pywin32模块/","text":"Python提供了调用系统级别API的功能，ctype、sip等都可以用来调用C++代码，以此来和系统交互。win32模块提供了调用本地win32 GUI API的接口，使得我们可以更方便的调用系统级别的API。可以做诸如监听全局快捷键、操作任务栏系统图标等功能。 在使用之前，先了解下WIndows常用的API。 1. WIndows API1.1 API之消息函数 函数 作用 BroadcastSystemMessage 将一条系统消息广播给系统中所有的顶级窗口 GetMessagePos 取得消息队列中上一条消息处理完毕时的鼠标指针屏幕位置 GetMessageTime 取得消息队列中上一条消息处理完毕时的时间 PostMessage 将一条消息投递到指定窗口的消息队列 PostThreadMessage 将一条消息投递给应用程序 RegisterWindowMessage 获取分配给一个字串标识符的消息编号 ReplyMessage 答复一个消息 SendMessage 调用一个窗口的窗口函数，将一条消息发给那个窗口 SendMessageCallback 将一条消息发给窗口 SendMessageTimeout 向窗口发送一条消息 SendNotifyMessage 向窗口发送一条消息 1.2 API之控件与消息函数 函数名 作用 AdjustWindowRect 给定一种窗口样式，计算获得目标客户区矩形所需的窗口大小 AnyPopup 判断屏幕上是否存在任何弹出式窗口 ArrangeIconicWindows 排列一个父窗口的最小化子窗口 AttachThreadInput 连接线程输入函数 BeginDeferWindowPos 启动构建一系列新窗口位置的过程 BringWindowToTop 将指定的窗口带至窗口列表顶部 CascadeWindows 以层叠方式排列窗口 ChildWindowFromPoint 返回父窗口中包含了指定点的第一个子窗口的句柄 ClientToScreen 判断窗口内以客户区坐标表示的一个点的屏幕坐标 CloseWindow 最小化指定的窗口 CopyRect 矩形内容复制 DeferWindowPos 该函数为特定的窗口指定一个新窗口位置 DestroyWindow 清除指定的窗口以及它的所有子窗口 DrawAnimatedRects 描绘一系列动态矩形 EnableWindow 指定的窗口里允许或禁止所有鼠标及键盘输入 EndDeferWindowPos 同时更新DeferWindowPos调用时指定的所有窗口的位置及状态 EnumChildWindows 为指定的父窗口枚举子窗口 EnumThreadWindows 枚举与指定任务相关的窗口 EnumWindows 枚举窗口列表中的所有父窗口 EqualRect 判断两个矩形结构是否相同 FindWindow 寻找窗口列表中第一个符合指定条件的顶级窗口 FindWindowEx 在窗口列表中寻找与指定条件相符的第一个子窗口 FlashWindow 闪烁显示指定窗口 GetActiveWindow 获得活动窗口的句柄 GetCapture 获得一个窗口的句柄，这个窗口位于当前输入线程，且拥有鼠标捕获（鼠标活动由它接收） GetClassInfo 取得WNDCLASS结构（或WNDCLASSEX结构）的一个副本，结构中包含了与指定类有关的信息 GetClassLong 取得窗口类的一个Long变量条目 GetClassName 为指定的窗口取得类名 GetClassWord 为窗口类取得一个整数变量 GetClientRect 返回指定窗口客户区矩形的大小 GetDesktopWindow 获得代表整个屏幕的一个窗口（桌面窗口）句柄 GetFocus 获得拥有输入焦点的窗口的句柄 GetForegroundWindow 获得前台窗口的句柄 GetLastActivePopup 获得在一个给定父窗口中最近激活过的弹出式窗口的句柄 GetParent 判断指定窗口的父窗口 GetTopWindow 搜索内部窗口列表，寻找隶属于指定窗口的头一个窗口的句柄 GetUpdateRect 获得一个矩形，它描叙了指定窗口中需要更新的那一部分 GetWindow 获得一个窗口的句柄，该窗口与某源窗口有特定的关系 GetWindowContextHelpId 取得与窗口关联在一起的帮助场景ID GetWindowLong 从指定窗口的结构中取得信息 GetWindowPlacement 获得指定窗口的状态及位置信息 GetWindowRect 获得整个窗口的范围矩形,窗口的边框、标题栏、滚动条及菜单等都在这个矩形内 GetWindowText 取得一个窗体的标题（caption）文字，或者一个控件的内容 GetWindowTextLength 调查窗口标题文字或控件内容的长短 GetWindowWord 获得指定窗口结构的信息 InflateRect 增大或减小一个矩形的大小 IntersectRect 这个函数在 lpDestRect 里载入一个矩形, 它是lpSrc1Rect与lpSrc2Rect两个矩形的交集 InvalidateRect 屏蔽一个窗口客户区的全部或部分区域 IsChild 判断一个窗口是否为另一窗口的子或隶属窗口 IsIconic 判断窗口是否已最小化 IsRectEmpty 判断一个矩形是否为空 IsWindow 判断一个窗口句柄是否有效 IsWindowEnabled 判断窗口是否处于活动状态 IsWindowUnicode 判断一个窗口是否为Unicode窗口。这意味着窗口为所有基于文本的消息都接收Unicode文字 IsWindowVisible 判断窗口是否可见 IsZoomed 判断窗口是否最大化 LockWindowUpdate 锁定指定窗口，禁止它更新 MapWindowPoints 将一个窗口客户区坐标的点转换到另一窗口的客户区坐标系统 MoveWindow 改变指定窗口的位置和大小 OffsetRect 通过应用一个指定的偏移，从而让矩形移动起来 OpenIcon 恢复一个最小化的程序，并将其激活 PtInRect 判断指定的点是否位于矩形内部 RedrawWindow 重画全部或部分窗口 ReleaseCapture 为当前的应用程序释放鼠标捕获 ScreenToClient 判断屏幕上一个指定点的客户区坐标 ScrollWindow 滚动窗口客户区的全部或一部分 ScrollWindowEx 根据附加的选项，滚动窗口客户区的全部或部分 SetActiveWindow 激活指定的窗口 SetCapture 将鼠标捕获设置到指定的窗口 SetClassLong 为窗口类设置一个Long变量条目 SetClassWord 为窗口类设置一个条目 SetFocusAPI 将输入焦点设到指定的窗口。如有必要，会激活窗口 SetForegroundWindow 将窗口设为系统的前台窗口 SetParent 指定一个窗口的新父 SetRect 设置指定矩形的内容 SetRectEmpty 将矩形设为一个空矩形 SetWindowContextHelpId 为指定的窗口设置帮助场景（上下文）ID SetWindowLong 在窗口结构中为指定的窗口设置信息 SetWindowPlacement 设置窗口状态和位置信息 SetWindowPos 为窗口指定一个新位置和状态 SetWindowText 设置窗口的标题文字或控件的内容 SetWindowWord 在窗口结构中为指定的窗口设置信息 ShowOwnedPopups 显示或隐藏由指定窗口所有的全部弹出式窗口 ShowWindow 控制窗口的可见性 ShowWindowAsync 与ShowWindow相似 SubtractRect 装载矩形lprcDst，它是在矩形lprcSrc1中减去lprcSrc2得到的结果 TileWindows 以平铺顺序排列窗口 UnionRect 装载一个lpDestRect目标矩形，它是lpSrc1Rect和lpSrc2Rect联合起来的结果 UpdateWindow 强制立即更新窗口 ValidateRect 校验窗口的全部或部分客户区 WindowFromPoint 返回包含了指定点的窗口的句柄。忽略屏蔽、隐藏以及透明窗口 1.3 API之文本和字体函数 函数名 作用 AddFontResource 在Windows系统中添加一种字体资源 CreateFont 用指定的属性创建一种逻辑字体 CreateFontIndirect 用指定的属性创建一种逻辑字体 CreateScalableFontResource 为一种TureType字体创建一个资源文件，以便能用API函数AddFontResource将其加入Windows系统 DrawText 将文本描绘到指定的矩形中 DrawTextEx 与DrawText相似，只是加入了更多的功能 EnumFontFamilies 列举指定设备可用的字体 EnumFontFamiliesEx 列举指定设备可用的字体 EnumFonts 列举指定设备可用的字体 ExtTextOut 经过扩展的文本描绘函数。也请参考SetTextAlign函数 GetAspectRatioFilterEx 用SetMapperFlags要求Windows只选择与设备当前纵横比相符的光栅字体时，本函数可判断纵横比大小 GetCharABCWidths 判断TureType字体中一个或多个字符的A-B-C大小 GetCharABCWidthsFloat 查询一种字体中一个或多个字符的A-B-C尺寸 GetCharacterPlacement 该函数用于了解如何用一个给定的字符显示一个字串 GetCharWidth 调查字体中一个或多个字符的宽度 GetFontData 接收一种可缩放字体文件的数据 GetFontLanguageInfo 返回目前选入指定设备场景中的字体的信息 GetGlyphOutline 取得TureType字体中构成一个字符的曲线信息 GetKerningPairs 取得指定字体的字距信息 GetOutlineTextMetrics 接收与TureType字体内部特征有关的详细信息 GetRasterizerCaps 了解系统是否有能力支持可缩放的字体 GetTabbedTextExtent 判断一个字串占据的范围，同时考虑制表站扩充的因素 GetTextAlign 接收一个设备场景当前的文本对齐标志 GetTextCharacterExtra 判断额外字符间距的当前值 GetTextCharset 接收当前选入指定设备场景的字体的字符集标识符 GetTextCharsetInfo 获取与当前选定字体的字符集有关的详细信息 GetTextColor 判断当前字体颜色。通常也称为“前景色” GetTextExtentExPoint 判断要填入指定区域的字符数量。也用一个数组装载每个字符的范围信息 GetTextExtentPoint 判断一个字串的大小（范围） GetTextFace 获取一种字体的字样名 GetTextMetrics 获取与选入一种设备场景的物理字体有关的信息 GrayString 描绘一个以灰色显示的字串。通常由Windows用于标识禁止状态 PolyTextOut 描绘一系列字串 RemoveFontResource 从Windows系统中删除一种字体资源 SetMapperFlags Windows 对字体进行映射时，可用该函数选择与目标设备的纵横比相符的光栅字体 SetTextAlign 设置文本对齐方式，并指定在文本输出过程中使用设备场景的当前位置 SetTextCharacterExtra 描绘文本的时候，指定要在字符间插入的额外间距 SetTextColor 设置当前文本颜色。这种颜色也称为“前景色” SetTextJustification 通过指定一个文本行应占据的额外空间，可用这个函数对文本进行两端对齐处理 TabbedTextOut 支持制表站的一个文本描绘函数 TextOut 文本绘图函数 1.4 API之位图、图标和光栅运算函数 函数名 作用 BitBlt 将一幅位图从一个设备场景复制到另一个 CopyIcon 制作指定图标或鼠标指针的一个副本。这个副本从属于发出调用的应用程序 CopyImage 复制位图、图标或指针，同时在复制过程中进行一些转换工作 CreateBitmap 按照规定的格式创建一幅与设备有关位图 CreateBitmapIndirect 创建一幅与设备有关位图 CreateCompatibleBitmap 创建一幅与设备有关位图，它与指定的设备场景兼容 CreateCursor 创建一个鼠标指针 CreateDIBitmap 根据一幅与设备无关的位图创建一幅与设备有关的位图 CreateDIBSection 创建一个DIBSection CreateIcon 创建一个图标 CreateIconIndirect 创建一个图标 DestroyCursor 清除指定的鼠标指针，并释放它占用的所有系统资源 DestroyIcon 清除图标 DrawIcon 在指定的位置画一个图标 DrawIconEx 描绘一个图标或鼠标指针。与DrawIcon相比，这个函数提供了更多的功能 ExtractAssociatedIcon 判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联并提取之 ExtractIcon 判断一个可执行文件或DLL中是否有图标存在，并将其提取出来 GetBitmapBits 将来自位图的二进制位复制到一个缓冲区 GetBitmapDimensionEx 取得一幅位图的宽度和高度 GetDIBColorTable 从选入设备场景的DIBSection中取得颜色表信息 GetDIBits 将来自一幅位图的二进制位复制到一幅与设备无关的位图里 GetIconInfo 取得与图标有关的信息 GetStretchBltMode 判断StretchBlt 和 StretchDIBits函数采用的伸缩模式 LoadBitmap 从指定的模块或应用程序实例中载入一幅位图 LoadCursor 从指定的模块或应用程序实例中载入一个鼠标指针 LoadCursorFromFile 在一个指针文件或一个动画指针文件的基础上创建一个指针 LoadIcon 从指定的模块或应用程序实例中载入一个图标 LoadImage 载入一个位图、图标或指针 MaskBlt 执行复杂的图象传输，同时进行掩模（MASK）处理 PatBlt 在当前选定的刷子的基础上，用一个图案填充指定的设备场景 PlgBlt 复制一幅位图，同时将其转换成一个平行四边形。利用它可对位图进行旋转处理 SetBitmapBits 将来自缓冲区的二进制位复制到一幅位图 SetBitmapDimensionEx 设置一幅位图的宽度。以一毫米的十分之一为单位 SetDIBColorTable 设置选入设备场景的一个DIBSection的颜色表信息 SetDIBits 将来自与设备无关位图的二进制位复制到一幅与设备有关的位图里 SetDIBitsToDevice 将一幅与设备无关位图的全部或部分数据直接复制到一个设备 SetStretchBltMode 指定StretchBlt 和 StretchDIBits函数的伸缩模式 StretchBlt 将一幅位图从一个设备场景复制到另一个 StretchDIBits 将一幅与设备无关位图的全部或部分数据直接复制到指定的设备场景 1.5 API之菜单函数 函数名 作用 AppendMenu 在指定的菜单里添加一个菜单项 CheckMenuItem 复选或撤消复选指定的菜单条目 CheckMenuRadioItem 指定一个菜单条目被复选成“单选”项目 CreateMenu 创建新菜单 CreatePopupMenu 创建一个空的弹出式菜单 DeleteMenu 删除指定的菜单条目 DestroyMenu 删除指定的菜单 DrawMenuBar 为指定的窗口重画菜单 EnableMenuItem 允许或禁止指定的菜单条目 GetMenu 取得窗口中一个菜单的句柄 GetMenuCheckMarkDimensions 返回一个菜单复选符的大小 GetMenuContextHelpId 取得一个菜单的帮助场景ID GetMenuDefaultItem 判断菜单中的哪个条目是默认条目 GetMenuItemCount 返回菜单中条目（菜单项）的数量 GetMenuItemID 返回位于菜单中指定位置处的条目的菜单ID GetMenuItemInfo 取得（接收）与一个菜单条目有关的特定信息 GetMenuItemRect 在一个矩形中装载指定菜单条目的屏幕坐标信息 GetMenuState 取得与指定菜单条目状态有关的信息 GetMenuString 取得指定菜单条目的字串 GetSubMenu 取得一个弹出式菜单的句柄，它位于菜单中指定的位置 GetSystemMenu 取得指定窗口的系统菜单的句柄 HiliteMenuItem 控制顶级菜单条目的加亮显示状态 InsertMenu 在菜单的指定位置处插入一个菜单条目，并根据需要将其他条目向下移动 InsertMenuItem 插入一个新菜单条目 IsMenu 判断指定的句柄是否为一个菜单的句柄 LoadMenu 从指定的模块或应用程序实例中载入一个菜单 LoadMenuIndirect 载入一个菜单 MenuItemFromPoint 判断哪个菜单条目包含了屏幕上一个指定的点 ModifyMenu 改变菜单条目 RemoveMenu 删除指定的菜单条目 SetMenu 设置窗口菜单 SetMenuContextHelpId 设置一个菜单的帮助场景ID SetMenuDefaultItem 将一个菜单条目设为默认条目 SetMenuItemBitmaps 设置一幅特定位图，令其在指定的菜单条目中使用，代替标准的复选符号（√） SetMenuItemInfo 为一个菜单条目设置指定的信息 TrackPopupMenu 在屏幕的任意地方显示一个弹出式菜单 TrackPopupMenuEx 与TrackPopupMenu 相似，只是它提供了额外的功能 1.6 API之设备场景函数 函数名 作用 CombineRgn 将两个区域组合为一个新区域 CombineTransform 驱动世界转换。它相当于依顺序进行两次转换 CreateCompatibleDC 创建一个与特定设备场景一致的内存设备场景 CreateDC 为专门设备创建设备场景 CreateEllipticRgn 创建一个椭圆 CreateEllipticRgnIndirect 创建一个内切于特定矩形的椭圆区域 CreateIC 为专用设备创建一个信息场景 CreatePolygonRgn 创建一个由一系列点围成的区域 CreatePolyPolygonRgn 创建由多个多边形构成的区域。每个多边形都应是封闭的 CreateRectRgn 创建一个矩形区域 CreateRectRgnIndirect 创建一个矩形区域 CreateRoundRectRgn 创建一个圆角矩形 DeleteDC 删除专用设备场景或信息场景，释放所有相关窗口资源 DPtoLP 将点阵从设备坐标转换到专用设备场景逻辑坐标 EqualRgn 确定两个区域是否相等 ExcludeClipRect 从专用设备场景的剪裁区中去掉一个矩形区。矩形内不能进行绘图 ExcludeUpdateRgn 从专用设备场景剪裁区去掉指定窗口的刷新区域 ExtCreateRegion 根据世界转换修改区域 ExtSelectClipRgn 将指定区域组合到设备场景的当前剪裁区 FillRgn 用指定刷子填充指定区域 FrameRgn 用指定刷子围绕指定区域画一个外框 GetBoundsRect 获取指定设备场景的边界矩形 GetClipBox 获取完全包含指定设备场景剪裁区的最小矩形 GetClipRgn 获取设备场景当前剪裁区 GetDC 获取指定窗口的设备场景 GetDCEx 为指定窗口获取设备场景。相比GetDC，本函数提供了更多的选项 GetDCOrgEx 获取指定设备场景起点位置（以屏幕坐标表示） GetDeviceCaps 根据指定设备场景代表的设备的功能返回信息 GetGraphicsMode 确定是否允许增强图形模式（世界转换） GetMapMode 为特定设备场景调入映象模式 GetRegionData 装入描述一个区域信息的RgnData结构或缓冲区 GetRgnBox 获取完全包含指定区域的最小矩形 GetUpdateRgn 确定指定窗口的刷新区域。该区域当前无效，需要刷新 GetViewportExtEx 获取设备场景视口（viewport）范围 GetViewportOrgEx 获取设备场景视口起点 GetWindowDC 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景 GetWindowExtEx 获取指定设备场景的窗口范围 GetWindowOrgEx 获取指定设备场景的逻辑窗口的起点 GetWindowRgn 获取窗口区域 GetWorldTransform 如果有世界转换，为设备场景获取当前世界转换 IntersectClipRect 为指定设备定义一个新的剪裁区 InvalidateRgn 使窗口指定区域不活动，并将它加入窗口刷新区，使之可随后被重画 InvertRgn 通过颠倒每个像素值反转设备场景指定区域 LPtoDP 将点阵从指定设备场景逻辑坐标转换为设备坐标 ModifyWorldTransform 根据指定的模式修改世界转换 OffsetClipRgn 按指定量平移设备场景剪裁区 OffsetRgn 按指定偏移量平移指定区域 OffsetViewportOrgEx 平移设备场景视口区域 OffsetWindowOrgEx 平移指定设备场景窗口起点 PaintRgn 用当前刷子背景色填充指定区域 PtInRegion 确定点是否在指定区域内 PtVisible 确定指定点是否可见（即，点是否在设备场景剪裁区内） RectInRegion 确定矩形是否有部分在指定区域内 RectVisible 确定指定矩形是否有部分可见（是否在设备场景剪裁区内） ReleaseDC 释放由调用GetDC或GetWindowDC函数获取的指定设备场景 RestoreDC 从设备场景堆栈恢复一个原先保存的设备场景 SaveDC 将指定设备场景状态保存到Windows设备场景堆栈 ScaleViewportExtEx 缩放设备场景视口的范围 ScaleWindowExtEx 缩放指定设备场景窗口范围 ScrollDC 在窗口（由设备场景代表）中水平和（或）垂直滚动矩形 SelectClipRgn 为指定设备场景选择新的剪裁区 SetBoundsRect 设置指定设备场景的边界矩形 SetGraphicsMode 允许或禁止增强图形模式，以提供某些支持（包括世界转换） SetMapMode 设置指定设备场景的映射模式 SetRectRgn 设置区域为指定的矩形 SetViewportExtEx 设置设备场景视口范围 SetViewportOrgEx 设置设备场景视口起点 SetWindowExtEx 设置指定设备场景窗口范围 SetWindowOrgEx 设置指定设备场景窗口起点 SetWindowRgn 设置窗口区域 SetWorldTransform 设置世界转换 ValidateRgn 激活窗口中指定区域，把它从刷新区移走 WindowFromDC 取回与某一设备场景相关的窗口的句柄 1.7 API之进程和线程函数 函数名 作用 CancelWaitableTimer 这个函数用于取消一个可以等待下去的计时器操作 CallNamedPipe 这个函数由一个希望通过管道通信的一个客户进程调用 ConnectNamedPipe 指示一台服务器等待下去，直至客户机同一个命名管道连接 CreateEvent 创建一个事件对象 CreateMailslot 创建一个邮路。返回的句柄由邮路服务器使用（收件人） CreateMutex 创建一个互斥体（MUTEX） CreateNamedPipe 创建一个命名管道。返回的句柄由管道的服务器端使用 CreatePipe 创建一个匿名管道 CreateProcess 创建一个新进程（比如执行一个程序） CreateSemaphore 创建一个新的信号机 CreateWaitableTimer 创建一个可等待的计时器对象 DisconnectNamedPipe 断开一个客户与一个命名管道的连接 DuplicateHandle 在指出一个现有系统对象当前句柄的情况下，为那个对象创建一个新句柄 ExitProcess 中止一个进程 FindCloseChangeNotification 关闭一个改动通知对象 FindExecutable 查找与一个指定文件关联在一起的程序的文件名 FindFirstChangeNotification 创建一个文件通知对象。该对象用于监视文件系统发生的变化 FindNextChangeNotification 重设一个文件改变通知对象，令其继续监视下一次变化 FreeLibrary 释放指定的动态链接库 GetCurrentProcess 获取当前进程的一个伪句柄 GetCurrentProcessId 获取当前进程一个唯一的标识符 GetCurrentThread 获取当前线程的一个伪句柄 GetCurrentThreadId 获取当前线程一个唯一的线程标识符 GetExitCodeProces 获取一个已中断进程的退出代码 GetExitCodeThread 获取一个已中止线程的退出代码 GetHandleInformation 获取与一个系统对象句柄有关的信息 GetMailslotInfo 获取与一个邮路有关的信息 GetModuleFileName 获取一个已装载模板的完整路径名称 GetModuleHandle 获取一个应用程序或动态链接库的模块句柄 GetPriorityClass 获取特定进程的优先级别 GetProcessShutdownParameters 调查系统关闭时一个指定的进程相对于其它进程的关闭早迟情况 GetProcessTimes 获取与一个进程的经过时间有关的信息 GetProcessWorkingSetSize 了解一个应用程序在运行过程中实际向它交付了多大容量的内存 GetSartupInfo 获取一个进程的启动信息 GetThreadPriority 获取特定线程的优先级别 GetTheardTimes 获取与一个线程的经过时间有关的信息 GetWindowThreadProcessId 获取与指定窗口关联在一起的一个进程和线程标识符 LoadLibrary 载入指定的动态链接库，并将它映射到当前进程使用的地址空间 LoadLibraryEx 装载指定的动态链接库，并为当前进程把它映射到地址空间 LoadModule 载入一个Windows应用程序，并在指定的环境中运行 MsgWaitForMultipleObjects 等侯单个对象或一系列对象发出信号。如返回条件已经满足，则立即返回 SetPriorityClass 设置一个进程的优先级别 SetProcessShutdownParameters 在系统关闭期间，为指定进程设置他相对于其它程序的关闭顺序 SetProcessWorkingSetSize 设置操作系统实际划分给进程使用的内存容量 SetThreadPriority 设定线程的优先级别 ShellExecute 查找与指定文件关联在一起的程序的文件名 TerminateProcess 结束一个进程 WinExec 运行指定的程序 1.7 API之网络函数 函数名 作用 WNetAddConnection 创建同一个网络资源的永久性连接 WNetAddConnection2 创建同一个网络资源的连接 WNetAddConnection3 创建同一个网络资源的连接 WNetCancelConnection 结束一个网络连接 WNetCancelConnection2 结束一个网络连接 WNetCloseEnum 结束一次枚举操作 WNetConnectionDialog 启动一个标准对话框，以便建立同网络资源的连接 WNetDisconnectDialog 启动一个标准对话框，以便断开同网络资源的连接 WNetEnumResource 枚举网络资源 WNetGetConnection 获取本地或已连接的一个资源的网络名称 WNetGetLastError 获取网络错误的扩展错误信息 WNetGetUniversalName 获取网络中一个文件的远程名称以及&#x2F;或者UNC（统一命名规范）名称 WNetGetUser 获取一个网络资源用以连接的名字 WNetOpenEnum 启动对网络资源进行枚举的过程 2. 安装和基本使用2.1 安装1python -m pip install pypiwin32 2.2 基本使用123456789101112131415161718192021hwnd = win32gui.FindWindow(&quot;类名&quot;, &quot;标题名&quot;) # 使用spy++查询窗口句柄的信息# 修改窗口大小win32gui.MoveWindow(hwnd, 100, 100, 200, 200, True) # 设置前台后台win32gui.SetForegroundWindow(hwnd)win32gui.SetBkMode(hwnd, win32con.TRANSPARENT)# 获取鼠标当前坐标win32api.GetCursorPos()# 将鼠标移动到某坐标处win32api.SetCursorPos((100,100))# 通过坐标获取句柄win32api.WindowFromPoint(win32api.GetCursorPos())# 根据窗口句柄id获取ClassNamewin32gui.GetClassName(hwnd)# 获取窗口标题win32gui.GetWindowText(hwnd)# 获取窗口坐标win32gui.GetWindowRect(hwnd)# 模拟点击win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 200, 200, 0, 0) 使用管理员权限启动python脚本12345678910111213141516171819202122232425262728def admin(func): def wrap(): def is_admin(): try: return ctypes.windll.shell32.IsUserAnAdmin() except: return False if is_script(): func() elif is_admin(): func() else: params = &#x27; &#x27;.join([&#x27;&quot;&#123;&#125;&quot;&#x27;.format(x) for x in sys.argv]) # 将启动参数传递给脚本 ctyps.windll.shell32.ShellExecuteW(None, &#x27;runas&#x27;, sys.executable, params, None, 1) return wrap### main.py@admindef main(): print(&#x27;init&#x27;)if __name__ == &#x27;__main__&#x27;: main() 参考 http://timgolden.me.uk/pywin32-docs/contents.html https://www.cnblogs.com/zoro-robin/p/5591185.html Shell_NotifyIcon Windows常用API","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"pandas","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/pandas/","text":"数据分析清洗使用pandas，numpy。 http://pandas.pydata.org/ https://www.pypandas.cn/ Series 是带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。轴标签统称为索引。调用 pd.Series 函数即可创建 Series 1s = pd.Series(data, index=index) 上述代码中，data 支持以下数据类型： Python 字典 多维数组 标量值（如，5） index 是轴标签列表。不同数据可分为以下几种情况： 多维数组 data 是多维数组时，index 长度必须与 data 长度一致。没有指定 index 参数时，创建数值型索引，即 [0, …, len(data) - 1]。 12345678910111213141516171819202122In [3]: s = pd.Series(np.random.randn(5), index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;])In [4]: sOut[4]: a 0.469112b -0.282863c -1.509059d -1.135632e 1.212112dtype: float64In [5]: s.indexOut[5]: Index([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], dtype=&#x27;object&#x27;)In [6]: pd.Series(np.random.randn(5))Out[6]: 0 -0.1732151 0.1192092 -1.0442363 -0.8618494 -2.104569dtype: float64 字典 12345678In [7]: d = &#123;&#x27;b&#x27;: 1, &#x27;a&#x27;: 0, &#x27;c&#x27;: 2&#125;In [8]: pd.Series(d)Out[8]: b 1a 0c 2dtype: int64 标量值 data 是标量值时，必须提供索引。Series 按索引长度重复该标量值。 12345678In [12]: pd.Series(5., index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;])Out[12]: a 5.0b 5.0c 5.0d 5.0e 5.0dtype: float64 Series类似多维数组 1234567891011121314151617181920212223242526272829303132In [13]: s[0]Out[13]: 0.4691122999071863In [14]: s[:3]Out[14]: a 0.469112b -0.282863c -1.509059dtype: float64In [15]: s[s &gt; s.median()]Out[15]: a 0.469112e 1.212112dtype: float64In [16]: s[[4, 3, 1]]Out[16]: e 1.212112d -1.135632b -0.282863dtype: float64In [17]: np.exp(s)Out[17]: a 1.598575b 0.753623c 0.221118d 0.321219e 3.360575dtype: float64 矢量操作与对齐 Series 标签 名称属性 12345678910111213In [32]: s = pd.Series(np.random.randn(5), name=&#x27;something&#x27;)In [33]: sOut[33]: 0 -0.4949291 1.0718042 0.7215553 -0.7067714 -1.039575Name: something, dtype: float64In [34]: s.nameOut[34]: &#x27;something&#x27; DataFrame 是由多种类型的列构成的二维标签数据结构，类似于 Excel 、SQL 表，或 Series 对象构成的字典。DataFrame 是最常用的 Pandas 对象，与 Series 一样，DataFrame 支持多种类型的输入数据： 一维 ndarray、列表、字典、Series 字典 二维 numpy.ndarray 结构多维数组或记录多维数组 Series DataFrame 除了数据，还可以有选择地传递 index（行标签）和 columns（列标签）参数。传递了索引或列，就可以确保生成的 DataFrame 里包含索引或列。Series 字典加上指定索引时，会丢弃与传递的索引不匹配的所有数据。 没有传递轴标签时，按常规依据输入数据进行构建。","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"sqlalchemy","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/sqlalchemy/","text":"为什么要使用ORM框架？ 为了方便，降低出错概率，可读性更好。 基本操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152连接数据#Unix/Mac - 4 initial slashes in totalengine = create_engine(&#x27;sqlite:////absolute/path/to/foo.db&#x27;)#Windowsengine = create_engine(&#x27;sqlite:///C:\\\\path\\\\to\\\\foo.db&#x27;)#Windows alternative using raw stringengine = create_engine(r&#x27;sqlite:///C:\\path\\to\\foo.db&#x27;)创建引擎engine = create_engine(&#x27;sqlite:///foo.db?check_same_thread=False&#x27;, echo=True)定义映射from sqlalchemy.ext.declarative import declarative_baseBase = declarative_base()创建实体类from sqlalchemy import Column, Integer, String# 定义映射类User，其继承上一步创建的Baseclass User(Base): # 指定本类映射到users表 __tablename__ = &#x27;users&#x27; # 如果有多个类指向同一张表，那么在后边的类需要把extend_existing设为True，表示在已有列基础上进行扩展 # 或者换句话说，sqlalchemy允许类是表的字集 # __table_args__ = &#123;&#x27;extend_existing&#x27;: True&#125; # 如果表在同一个数据库服务（datebase）的不同数据库中（schema），可使用schema参数进一步指定数据库 # __table_args__ = &#123;&#x27;schema&#x27;: &#x27;test_database&#x27;&#125; # 各变量名一定要与表的各字段名一样，因为相同的名字是他们之间的唯一关联关系 # 从语法上说，各变量类型和表的类型可以不完全一致，如表字段是String(64)，但我就定义成String(32) # 但为了避免造成不必要的错误，变量的类型和其对应的表的字段的类型还是要相一致 # sqlalchemy强制要求必须要有主键字段不然会报错，如果要映射一张已存在且没有主键的表，那么可行的做法是将所有字段都设为primary_key=True # 不要看随便将一个非主键字段设为primary_key，然后似乎就没报错就能使用了，sqlalchemy在接收到查询结果后还会自己根据主键进行一次去重 # 指定id映射到id字段; id字段为整型，为主键，自动增长（其实整型主键默认就自动增长） id = Column(Integer, primary_key=True, autoincrement=True) # 指定name映射到name字段; name字段为字符串类形， name = Column(String(20)) fullname = Column(String(32)) password = Column(String(32)) # __repr__方法用于输出该类的对象被print()时输出的字符串，如果不想写可以不写 def __repr__(self): return &quot;&lt;User(name=&#x27;%s&#x27;, fullname=&#x27;%s&#x27;, password=&#x27;%s&#x27;)&gt;&quot; % ( self.name, self.fullname, self.password)# 查看映射对应的表User.__table__# 创建数据表。一方面通过engine来连接数据库，另一方面根据哪些类继承了Base来决定创建哪些表# checkfirst=True，表示创建表前先检查该表是否存在，如同名表已存在则不再创建。其实默认就是TrueBase.metadata.create_all(engine, checkfirst=True)# 上边的写法会在engine对应的数据库中创建所有继承Base的类对应的表，但很多时候很多只是用来则试的或是其他库的# 此时可以通过tables参数指定方式，指示仅创建哪些表# Base.metadata.create_all(engine,tables=[Base.metadata.tables[&#x27;users&#x27;]],checkfirst=True)# 在项目中由于model经常在别的文件定义，没主动加载时上边的写法可能写导致报错，可使用下边这种更明确的写法# User.__table__.create(engine, checkfirst=True)# 另外我们说这一步的作用是创建表，当我们已经确定表已经在数据库中存在时，我完可以跳过这一步# 针对已存放有关键数据的表，或大家共用的表，直接不写这创建代码更让人心里踏实创建会话# engine是2.2中创建的连接Session = sessionmaker(bind=engine)# 创建Session类实例session = Session()新增# 创建User类实例ed_user = User(name=&#x27;ed&#x27;, fullname=&#x27;Ed Jones&#x27;, password=&#x27;edspassword&#x27;)# 将该实例插入到users表session.add(ed_user)# 一次插入多条记录形式session.add_all( [User(name=&#x27;wendy&#x27;, fullname=&#x27;Wendy Williams&#x27;, password=&#x27;foobar&#x27;), User(name=&#x27;mary&#x27;, fullname=&#x27;Mary Contrary&#x27;, password=&#x27;xxg527&#x27;), User(name=&#x27;fred&#x27;, fullname=&#x27;Fred Flinstone&#x27;, password=&#x27;blah&#x27;)])# 当前更改只是在session中，需要使用commit确认更改才会写入数据库session.commit()查询our_user = session.query(User).filter_by(name=&#x27;ed&#x27;).first()our_user# 比较ed_user与查询到的our_user是否为同一条记录ed_user is our_user# 只获取指定字段# 但要注意如果只获取部分字段，那么返回的就是元组而不是对象了# session.query(User.name).filter_by(name=&#x27;ed&#x27;).all()# like查询# session.query(User).filter(User.name.like(&quot;ed%&quot;)).all()# 正则查询# session.query(User).filter(User.name.op(&quot;regexp&quot;)(&quot;^ed&quot;)).all()# 统计数量# session.query(User).filter(User.name.like(&quot;ed%&quot;)).count()# 调用数据库内置函数# 以count()为例，都是直接func.func_name()这种格式，func_name与数据库内的写法保持一致# from sqlalchemy import func# session.query(func.count(User3.name)).one()# 字段名为字符串形式# column_name = &quot;name&quot;# session.query(User).filter(User3.__table__.columns[column_name].like(&quot;ed%&quot;)).all()# 获取执行的sql语句# 获取记录数的方法有all()/one()/first()等几个方法，如果没加这些方法，得到的只是一个将要执行的sql对象，并没真正提交执行# from sqlalchemy.dialects import mysql# sql_obj = session.query(User).filter_by(name=&#x27;ed&#x27;)# sql_command = sql_obj.statement.compile(dialect=mysql.dialect(), compile_kwargs=&#123;&quot;literal_binds&quot;: True&#125;)# sql_result = sql_obj.all()修改# session.query(User).filter_by(name=&#x27;ed&#x27;).update(&#123;User.password: &#x27;modify_passwd&#x27;&#125;)# session.commit()删除# 要删除需要先将记录查出来del_user = session.query(User).filter_by(name=&#x27;ed&#x27;).first()# 打印一下，确认未删除前记录存在del_user# 将ed用户记录删除session.delete(del_user)# 确认删除session.commit()# 遍历查看，已无ed用户记录for user in session.query(User): print(user)# 但上边的写法，先查询再删除，相当于给mysql服务端发了两条语句，和我们印象中的delete语句不一致# 可直接使用下边的写法，传给服务端的就是delete语句# session.query(User).filter_by(name=&#x27;ed&#x27;).first().delete() 参考 github官方地址：https://github.com/sqlalchemy/sqlalchemy 官方文档地址：https://docs.sqlalchemy.org/en/13/ https://docs.sqlalchemy.org/en/13/orm/tutorial.html","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"stockstats","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/stockstats/","text":"对pandas进行了封装 https://github.com/jealous/stockstats","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"struct模块","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/struct模块/","text":"struct模块主要二进制和结构体之间的互相转化。在业务场景中，socket数据的处理会使用到。纯文本是无法进行传输到，因为不同系统硬件的存储方式是不一样的。这个时候使用struct可以按照某种规则进行pack处理成二进制数据，另一端接收到时按照约定进行unpack成相应数据。 常用API 函数 return explain pack(fmt,v1,v2…) string 按照给定的格式(fmt),把数据转换成字符串(字节流),并将该字符串返回. pack_into(fmt,buffer,offset,v1,v2…) None 按照给定的格式(fmt),将数据转换成字符串(字节流),并将字节流写入以offset开始的buffer中.(buffer为可写的缓冲区,可用array模块) unpack(fmt,v1,v2…..) tuple 按照给定的格式(fmt)解析字节流,并返回解析结果 pack_from(fmt,buffer,offset) tuple 按照给定的格式(fmt)解析以offset开始的缓冲区,并返回解析结果 calcsize(fmt) size of fmt 计算给定的格式(fmt)占用多少字节的内存，注意对齐方式 Hello Worldvalues = (1, b&#39;abc&#39;, 2.5) s = struct.Struct(&#39;I3sf&#39;) # 声明每个值的类型，I表示整型、3s表示长度为3的字符串、f表示浮点型 packed_data = s.pack(*values) print(packed_data) unpacked_data = s.unpack(packed_data) print(type(unpacked_data), unpacked_data) 字节顺序，大小，对齐默认情况下，C语言类型以机器的本地格式和字节顺序表示。 Character（字符） Byte order（字节顺序） Size Alignment @(默认) 本机 本机 本机,凑够4字节 &#x3D; 本机 标准 none,按原字节数 &lt; 小端 标准 none,按原字节数 &gt; 大端 标准 none,按原字节数 ! network(大端) 标准 none,按原字节数 格式字符 文件格式 C 类型 Python数据类型 Standard size 注释 x pad byte no value c char bytes of length 1 1 b signed char integer 1 (1),(3) B unsigned char integer 1 (3) ? _Bool bool 1 (1) h short integer 2 (3) H unsigned short integer 2 (3) i int integer 4 (3) I unsigned int integer 4 (3) l long integer 4 (3) L unsigned long integer 4 (3) q long long integer 8 (2), (3) Q unsigned long long integer 8 (2), (3) n ssize_t integer (4) N size_t integer (4) e (7) float 2 (5) f float float 4 (5) d double float 8 (5) s char[] bytes p char[] bytes P void * integer (6) 实例：12 参考 https://docs.python.org/zh-cn/3.7/library/struct.html https://docs.python.org/3/library/struct.html","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"tornado","date":"2022-03-08T02:25:29.695Z","path":"wiki/Python/tornado/","text":"基本API使用Application RequestHandler 参考https://tornado-zh.readthedocs.io/zh/latest/","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"Pillow","date":"2022-03-08T02:25:29.694Z","path":"wiki/Python/Pillow/","text":"Pillow是用于图像处理的库，可用于图像存储、图像显示、图像处理（改变大小、旋转等）。 基本使用123456789from PIL import Imageim = Image.open(&quot;test.png&quot;)print(im.format, im.size, im.mode)# format 这个属性标识了图像来源。如果图像不是从文件读取它的值就是None。# size属性是一个二元tuple，包含width和height（宽度和高度，单位都是px）。 # mode 属性定义了图像bands的数量和名称，以及像素类型和深度。常见的modes 有 “L” (luminance) 表示灰度图像, “RGB” 表示真彩色图像, and “CMYK” 表示出版图像。im.show() # 显示图像 转换文件格式到JPEG12345678910111213from __future__ import print_functionimport os, sysfrom PIL import Imagefor infile in sys.argv[1:]: f, e = os.path.splitext(infile) outfile = f + &quot;.jpg&quot; if infile != outfile: try: Image.open(infile).save(outfile) # save方法第二个参数可以指定文件格式 except IOError: print(&quot;cannot convert&quot;, infile) 创建 JPEG 缩略图12345678910111213141516from __future__ import print_functionimport os, sysfrom PIL import Imagesize = (128, 128)for infile in sys.argv[1:]: outfile = os.path.splitext(infile)[0] + &quot;.thumbnail&quot; if infile != outfile: try: im = Image.open(infile) im.thumbnail(size) im.save(outfile, &quot;JPEG&quot;) except IOError: print(&quot;cannot create thumbnail for&quot;, infile) 重要的一点是这个库不会直接解码或者加载图像栅格数据。当你打开一个文件，只会读取文件头信息用来确定格式，颜色模式，大小等等，文件的剩余部分不会主动处理。这意味着打开一个图像文件的操作十分快速，跟图片大小和压缩方式无关。 剪切，粘贴，合并图像1234567891011121314151617181920212223242526272829303132# 从图像中复制出一个矩形选区¶box = (100, 100, 400, 400)region = im.crop(box)# 矩形选区有一个4元元组定义，分别表示左、上、右、下的坐标。这个库以左上角为坐标原点，单位是px，所以上诉代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。# 处理复制的矩形选区并粘贴到原图region = region.transpose(Image.ROTATE_180)im.paste(region, box)# 分离和合并颜色通道r, g, b = im.split()im = Image.merge(&quot;RGB&quot;, (b, g, r))out = im.resize((128, 128)) # 缩放out = im.rotate(45) # 旋转# 过滤器from PIL import ImageFilterout = im.filter(ImageFilter.DETAIL)# 读取多帧im = Image.open(&quot;animation.gif&quot;)im.seek(1) # skip to the second frametry: while 1: im.seek(im.tell()+1) # 这里seek后，可显示当前帧，可转换成Qt中的QPixmap或者QIamge # do something to imexcept EOFError: pass # end of sequence 概念Bands（通道）每张图像都是由一个或者多个数据通道构成，PIL可以在单张图片中合成相同维数和深度的多个通道，如RGB有三个通道，而灰度图像则只有一个通道。getbands方法返回通道名字。 Mode（模式）图像的模式定义了图像中像素的类型和深度，它在图像中定义mode模式的概念，如： 1:1位像素，表示黑和白，占8bit，在图像表示中称为位图 L：表示黑白之间的灰度，占8bit像素 p：8位像素，使用调色版映射 RGB：为真彩色，占用3x8位像素，其中R为red红色，G为green绿色，B为blue蓝色，三原色叠加形成的色彩变化，如三通道都为0则代表黑色，都为255则代表白色 RGBA：为带透明蒙版的真彩色，其中的A为alpha透明度，占用4x8位像 CMYK (4x8-bit 像素, color separation) YCbCr (3x8-bit 像素, color video format) I (32-bit signed integer 像素) F (32-bit floating point 像素) Size（大小）size属性表达大小，返回一个元祖，分别为高、宽值。 Coordinates System（坐标系统）PIL使用笛卡尔像素坐标系统，图像的坐标从左上角开始（0,0），坐标值表示像素的角，它实际上位于（0.5,0.5）；python中坐标通常以2元组(X,Y)的形式传递，矩形表示为4元组（l_x,t_y,r_x,b_y），X轴从左到右，Y轴从上到下，顺序是从左上右下表示，从左上角开始，如一个800X600像素的图像矩形表示为（0,0,800,600），它实际上时左上角锁定，向右下延伸的。 Palatte（调色板）定义每一个像素的真实颜色 Info（信息）info属性包含了图片的一些信息，是一个字典对象。如果是一个动画类型的图片，则里面可包含duration，表示一帧画面的现实时间。 Filters（过滤器）提供不同类型的过滤器 NEAREST Pick the nearest pixel from the input image. Ignore all other input pixels. 最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。 BILINEAR Use linear interpolation over a 2x2 environment in the input image. Note that in the current version of PIL, this filter uses a fixed input environment when downsampling. 双线性滤波。在输入图像的2x2矩阵上进行线性插值，，做下采样时该滤波器使用了固定输入模板 BICUBIC Use cubic interpolation over a 4x4 environment in the input image. Note that in the current version of PIL, this filter uses a fixed input environment when downsampling. 双立方滤波。在输入图像的4x4矩阵上进行立方插值，做下采样时该滤波器使用了固定输入模板 ANTIALIAS Calculate the output pixel value using a high-quality resampling filter (a truncated sinc) on all pixels that may contribute to the output value. In the current version of PIL, this filter can only be used with the resize and thumbnail methods. 平滑滤波，对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值，这个滤波器只用于改变尺寸和缩略图方法。ANTIALIAS滤波器是下采样，将大图转换为小图或左缩略图时唯一正确的滤波器，BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的 解析动画Gif、Webp12345678910image = Image.open(path)while image.tell() &lt; image.n_frames: image.seek(image.tell() + 1) # image.toqpixmap() 获取当前画面 # duration 表示一帧的显示时间 if &#x27;duration&#x27; in image.info.keys(): duration = image.info[&#x27;duration&#x27;] else: duration = 100 time.sleep(duration/1000) 参考 https://github.com/python-pillow/Pillow https://www.osgeo.cn/pillow/handbook/tutorial.html","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"Pyhon2跟Python3的区别","date":"2022-03-08T02:25:29.694Z","path":"wiki/Python/Python2跟Python3的区别/","text":"str和bytes基本概念 字节（Byte ）：是计算机信息技术用于计量存储容量的一种计量单位，作为一个单位来处理的一个二进制数字串，是构成信息的一个小单位。最常用的字节是八位的字节，即它包含八位的二进制数; 位(bit)：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数; 字节(byte)：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示,1B(byte,字节)&#x3D; 8bit(位); 字符：指计算机中使用的字母、数字、字和符号，包括：1、2、3、A、B、C、~！·#￥%……—*（）——+等等。 字符串：字符串是字符序列，它是一种抽象的概念，不能直接存储在硬盘 – 字节串是给计算机看的 ，给计算机传输或者保存的， 在Python中，程序中的文本都用字符串表示。 字节串：字节串是字节序列，它可以直接存储在硬盘， 字节串是给计算机看的 。它们之间的映射被称为编码&#x2F;解码 – 字符串是给人看的，用来操作的。 字符集：为每一个字符分配一个唯一的ID（码位&#x2F;码点&#x2F;Code Point）。Unicode是字符集。 编码规则：将码位转换为字节序列的规则（编码&#x2F;解码 可以理解为 加密&#x2F;解密 的过程）。utf-8是编码规则。 12341 KB = 1024 B(字节)；1 MB = 1024 KB; (2^10 B)1 GB = 1024 MB; (2^20 B)1 TB = 1024 GB; (2^30 B) Python2中的str和unicode str:表示由bytes序列的字符串。 unicode:表示unicode码点序列的字符串。 12345678910111213141516171819202122&gt;&gt;&gt; a=&#x27;你好&#x27;&gt;&gt;&gt; a&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27;&gt;&gt;&gt; b=u&#x27;你好&#x27;&gt;&gt;&gt; bu&#x27;\\u4f60\\u597d&#x27;&gt;&gt;&gt; print(a)你好&gt;&gt;&gt; print(b)你好&gt;&gt;&gt; a.__class__&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; b.__class__&lt;type &#x27;unicode&#x27;&gt;&gt;&gt;&gt; len(a)6&gt;&gt;&gt; len(b)2&gt;&gt;&gt; a.decode(&#x27;utf-8&#x27;)u&#x27;\\u4f60\\u597d&#x27;&gt;&gt;&gt; b.encode(&#x27;utf-8&#x27;)&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27; 总结： string直接用引号来表示，unicode在引号前加一个u。 直接输入的string常量会用系统缺省编码方式来编码。 len(string)返回string的字节数，len(unicode)返回的是字符数。 encode和decode使得str和unicode之间进行相互转换。 Python3中的str和byte str：str格式的定义变更为”Unicode类型的字符串“，也就是说在默认情况下，被引号框起来的字符串，是使用Unicode编码的。也就是说unicode类型在python3中没有了，python3中的str就相当于python2中的unicode。 bytes：bytes 函数返回一个新的 bytes 对象，该对象是一个 0 &lt;&#x3D; x &lt; 256 区间内的整数不可变序列。它是 bytearray 的不可变版本。bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。 bytearray：可变的子节数组。 1234567891011121314&gt;&gt;&gt; a=&#x27;你好&#x27;&gt;&gt;&gt; a&#x27;你好&#x27;&gt;&gt;&gt; type(a)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; b = bytes(a, encoding=&#x27;utf-8&#x27;)&gt;&gt;&gt; bb&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27;&gt;&gt;&gt; type(b)&lt;class &#x27;bytes&#x27;&gt;&gt;&gt;&gt; a.encode()b&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27;&gt;&gt;&gt; b.decode()&#x27;你好&#x27;","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"Python多线程","date":"2022-03-08T02:25:29.694Z","path":"wiki/Python/Python多线程编程/","text":"Python代码的执行由虚拟机来控制。Python再主循环中，同时只有一个线程再执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序再CPU中运行。 对Python虚拟机的访问由全局解释器锁（global interpreter lock）来控制，正是这个锁能保证同一时刻只有一个线程在运行。 参考 https://docs.python.org/zh-cn/3/library/threading.html","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"Python扩展","date":"2022-03-08T02:25:29.694Z","path":"wiki/Python/Python Extending/","text":"官方文档：https://docs.python.org/zh-cn/3/extending/extending.html ** 什么时候要用扩展 性能瓶颈：比如某些计算在Python中很慢，比如GIL导致CPU只能使用单核。 代码保护：将核心代码放到更低层，增加反编译难度。 ** Hello World 步骤 编写C文件 编写包装文件 编写setup文件 编译、测试 1. 编写C文件12345678910//fib.c文件long long _fib(long long n)&#123; if(n &lt; 2) return n; else return _fib(n-1) + _fib(n-2);&#125;; 2. 编写包装文件12345678910111213141516171819202122232425262728293031323334353637383940414243//speedup_fib.c#include &lt;Python.h&gt; //导入基础的头文件//封装函数static PyObject *fib(PyObject *self, PyObject *args) &#123; // Arguments long long n; long long res; if (!PyArg_ParseTuple(args, &quot;l&quot;, &amp;n)) //转换输入参数类型给C return NULL; res = _fib(n);//调用函数 return Py_BuildValue(&quot;l&quot;, res);//结果转换成Python类型&#125;;//模块方法表static PyMethodDef SpeedupFibMethods[] = &#123; &#123;&quot;speedup_fib&quot;, (PyCFunction) fib, METH_VARARGS, &quot;fast fib&quot;&#125;, &#123;NULL, NULL, 0, NULL&#125;&#125;;static struct PyModuleDef speedup_fib_module = &#123; PyModuleDef_HEAD_INIT, &quot;speedup_fib&quot;,//模块名字 &quot;A module containing methods with faster fib.&quot;, -1, SpeedupFibMethods&#125;;//创建模块PyMODINIT_FUNC PyInit_speedup_fib() &#123; return PyModule_Create(&amp;speedup_fib_module);&#125; 3. 编写setup.py文件12345678910from distutils.core import setup, Extensionspeedup_fib_module = Extension(&#x27;speedup_fib&#x27;, sources=[&#x27;speedup_fib.c&#x27;])setup( name=&#x27;SpeedupFoo&#x27;, description=&#x27;A package containing modules for speeding up fib.&#x27;, ext_modules=[speedup_fib_module],) 4. 编译、测试 python setup.py build 编译成功后会在build文件夹生成动态库，windows下为pyd，linux下为so 编写测试脚本 123456789101112131415161718import timedef fib_recursive(n): if n &lt;= 1: return n return fib_recursive(n - 1) + fib_recursive(n - 2)start_ts = time.time()print(fib_recursive(35))print(time.time() - start_ts)from speedup_fib import speedup_fibstart_ts = time.time()print(speedup_fib(35))print(time.time() - start_ts) 基本概念实例代码","tags":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"}]},{"title":"Synchronized与ReentrantLock的区别","date":"2022-03-08T02:25:29.692Z","path":"wiki/Java/面试题/Synchronized与ReentrantLock的区别/","text":"底层原理区别 底层实现上来说，synchronized 是JVM层面的锁，是Java关键字，通过monitor对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait&#x2F;notify方法， ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的API层面的锁。 synchronized 的实现涉及到锁的升级，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁， ReentrantLock实现则是通过利用CAS（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。 是否可手动释放 synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try&#x2F;finally语句块来完成，使用释放更加灵活。 是否可中断 synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。 是否公平锁 synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。 锁是否可绑定条件Condition synchronized不能绑定； ReentrantLock通过绑定Condition结合await()&#x2F;singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()&#x2F;notify()&#x2F;notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。 锁的对象 synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁&#x2F;争抢锁； ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得&#x2F;争抢。","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"面试题","slug":"Java/面试题","permalink":"http://airshu.github.io/categories/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Java笔试题收集","date":"2022-03-08T02:25:29.691Z","path":"wiki/Java/面试题/Java笔试题收集/","text":"TCP、UDP区别 TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的,UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） TCP首部开销20字节;UDP的首部开销小，只有8个字节 TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 三次握手、四次挥手三次握手 第一次握手：客户端想跟服务器进行连接，所以状态变为主动打开，同时发送一个连接请求报文给服务器端SYN&#x3D;1，并且会携带x个字节过去。发送完请求连接报文后，客户端的状态就变为SYN_SENT,这个状态等待发送确认。 第二次握手：服务端接收到连接请求报文后，从LISTEN状态变为被动打开状态，然后给客户端返回一个报文。这个报文有两层意思，一是确认报文，二是可以达到告诉客户端，我也打开连接了。发送完毕后，变为SYN_RCVD状态。 第三次握手：客户端得到服务端的确认和知道服务端已经准备好连接后，还会发一个确认报文到服务端，发送完后客户端进入ESTABLISHED状态，当服务端接收后，状态也变为ESTABLISHED。 四次挥手 第一次挥手：从ESTABLISHED变为主动关闭状态，客户端主动发送释放连接请求给服务器端，FIN&#x3D;1。发送完之后就变为FIN_WAIT_1状态，这个状态可以说是等待确认状态。 第二次挥手：服务器接收到客户端发来的释放连接请求后，状态变为CLOSE_WAIT，然后发送确认报文给客户端，告诉他我接收到了你的请求。为什么变为CLOSE_WAIT，原因是客户端发送的释放连接请求，可能自己这端还有数据没有发送完呢，所以这个时候整个TCP连接的状态就变为了半关闭状态。服务器端还能发送数据，并且客户端也能接收数据，但是客户端不能在发送数据了，只能够发送确认报文。客户端接到服务器的确认报文后，就进入了FIN_WAIT_2状态。也可以说这是等待服务器释放连接状态。 第三次挥手：服务器端所有的数据度发送完了，认为可以关闭连接了，状态变为被动关闭，所以向客户端发送释放连接报文，发完之后自己变为LAST_WAIT状态，也就是等待客户端确认状态。 第四次挥手：客户端接到释放连接报文后，发送一个确认报文，然后自己变为TIME_WAIT,而不是立马关闭，因为客户端发送的确认报文可能会丢失，丢失的话服务器就会重传一个FIN，也就是释放连接报文，这个时候客户端必须还没关闭。 当服务器接受到确认报文后，服务器就进入CLOSE状态，也就是关闭了。但是由于上面说的这个原因，客户端必须等待一定的时间才能够进入CLOSE状态。 volatile执行控制：目的是控制代码执行（顺序）及是否可以并行执行。 内存可见：线程执行结果在内存中对其他线程的可见性。 volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化 内存模型 定义 为什么要有内存模型 为什么要重排序，重排序在什么时候排 如何约束重排序规则 happens-before 什么是顺序一致性 CAS 实现的原理，是阻塞还是非阻塞方式？什么时候用，使用时需要考虑的问题 处理器和 Java 分别怎么保证原子操作 保证了原子性就能保证可见性吗？ final 内存语义？什么时候用，使用时需要考虑的问题 volatile 内存语义，什么时候用，用的时候需要考虑什么问题 synchronized 内存语义，什么时候用，和锁比较一下优缺点 synchronized 中涉及的锁升级流程 锁的内存语义，举例说明，加锁失败时候的处理流程 比较下 CAS 、volatile 、synchronized、Lock 区别 原子操作类底层实现机制？自增操作是怎么保证原子性的？ 线程 线程的状态有哪些 如何在 Java 中实现线程？ 如何在 Java 中启动一个线程？ 设计线程中断的意义是什么 Java 中 interrupted 和 isInterrupted 方法的区别？ 如何停止一个线程？ 线程 join 方法干什么用？ 有三个线程 T1，T2，T3，怎么确保它们按顺序执行？ 线程的等待通知机制实现机制？ 为什么应该在循环中检查等待条件? 为什么 wait 和 notify 方法要在同步块中调用？ 为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？ ThreadLocal 是什么，怎么实现的 线程池是什么，提交一个任务进去，处理流程？ Executor 框架介绍 JUC 包中提供了哪些配置好的线程池，差异化是什么 什么是 FutureTask？ 锁 Lock 接口提供了哪些实现类 AQS 是什么，提供了哪些方法 AQS 中独占锁和共享锁的操作流程大体描述一下 重入锁有什么好处，什么时候考虑用 读写锁有什么好处，什么时候考虑用？读锁是什么类型的锁，写锁呢？ 说下读写锁里的锁降级流程，什么时候可以考虑用这个机制 park 方法是怎么实现的 锁的等待通知机制 Condition 是怎么实现的，有了线程的等待通知机制为什么还要设计 Condition？ 死锁怎么产生的，如何避免 说说 Java 中有哪些锁 sleep、wait、park、Condition 都能让线程等待，有什么区别？ 容器与工具 阻塞和非阻塞有什么区别，他们可以用什么方式实现 队列（Queue）提供哪些操作 阻塞队列提供了哪些获取元素的方法，有什么区别？ 阻塞队列有哪些实现？为什么要分有界无界？ CountDownLatch 怎么实现的，什么时候考虑用？ CyclicBarrier 怎么实现的，什么时候考虑用？ Semaphore 怎么实现的，什么时候考虑用？ 如何在两个线程间共享数据？ Exchanger 怎么实现的，什么时候考虑用？ ConcurrentHashMap 实现？ fork&#x2F;join 框架是什么？ 内存管理 为什么需要 JVM？ 简单描述 JMM 和 JVM 两个概念 JVM 内存管理 永久代、元空间、方法区的关系 类加载过程 双亲委派模式有什么好处 如何覆盖 JDK 提供的组件，比如覆盖 ArrayList 的实现 new 一个对象的过程发生了什么（类加载、变量初始化、内存分配） 对象的死亡过程 JVM 可能会抛出哪些 OOM 垃圾回收算法有哪些？优缺点比较 熟知的垃圾回收器有哪些，简单描述每个应用场景 CMS 和 G1 的垃圾回收步骤是？ G1 相对于 CMS 的优缺点 性能监控与调优 如何监控 GC 常见 OutOfMemoryError 有哪些 常见的 JDK 诊断命令有哪些，应用场景？ CPU 较高，如何定位问题 内存占用较高，如何定位大对象 内存泄漏时，如何实时跟踪内存变化情况 内存泄漏时，如何定位问题代码 大型项目如何进行性能瓶颈调优？虚拟机子系统 字节码是如何在 JVM 中进行流转的（栈帧） 方法调用的底层实现 方法重写和重载的实现过程 invokedynamic 指令实现 如何修改字节码 JIT 参数配置如何影响程序运行？ 虚拟机有哪些性能优化策略 Java基础 1.JAVA 中的几种数据类型是什么，各自占用多少字节。2.String 类能被继承吗，为什么。3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？4. String 属于基础的数据类型吗？5.Java 中操作字符串都有哪些类？它们之间有什么区别？6.Java 中 IO 流分为几种？7.BIO、NIO、AIO 有什么区别？8.用过哪些 Map 类，都有什么区别，HashMap 时线程安全的吗，并发下使用的 Map 是什么，他们的内部原理分别是什么，比如存储方法，hashcode，扩容，默认容量等。9. 如何将字符串反转？10.抽象类必须要有抽象方法吗？11.普通类和抽象类有哪些区别？12.抽象类能使用 final 修饰吗？13.ArrayList 和 LinkedList 有什么区别？14.ConcurrentHashMap的数据结构15.volatile作用16.Atomic类如何保证原子性（CAS操作）17.为什么要使用线程池 JVM 运行时数据区域（内存模型） 垃圾回收机制 垃圾回收算法 Minor GC和Full GC触发条件 GC中Stop the world（STW） 各垃圾回收器的特点及区别 双亲委派模型 JDBC和双亲委派模型关系 JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数 操作系统篇 进程和线程的区别 进程同步的几种方式 线程间同步的方式 什么是缓冲区溢出。有什么危害，其原因是什么 进程中有哪几种状态 分页和分段有什么区别","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"面试题","slug":"Java/面试题","permalink":"http://airshu.github.io/categories/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"LinkedList","date":"2022-03-08T02:25:29.690Z","path":"wiki/Java/集合/LinkedList/","text":"概述 LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 使用场景 需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 参考 https://www.cnblogs.com/skywang12345/p/3308807.html","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://airshu.github.io/categories/Java/%E9%9B%86%E5%90%88/"}]},{"title":"类加载","date":"2022-03-08T02:25:29.689Z","path":"wiki/Java/进阶/类加载/","text":"类加载过程加载，验证，准备，解析，初始化，使用，卸载 加载 使用 new 关键字实例化对象，读取或者设置一个类的静态变量(被 final修饰的除外，已经在编译器被加入常量池)，以及调用一个类的静态方法的 时候 对类进行反射调用的时候 当初始化一个类时，如果其父类没有被加载，则先对其父类进行加载 当虚拟机启动的时候，用户指定的(包含 main 方法)的类会被加载 在类的加载阶段，虚拟机会完成以下三件事情: 通过一个类的全限定名获取定义类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在 Java 堆中生成一个代表这个类的 Class 对象，作为方法区这些数据的访问入口。 验证这一阶段是为了确保 class 文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。主要包括以下几个过程: 文件格式验证 元数据验证 字节码验证 符号引用验证 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在 方法区中进行分配。这个阶段中进行内存分配的变量只有被 static 修饰的变量，并将其设置为默认值，而真正的赋值则在初始化阶段。另外，被 final static 字段 修饰的常量在编译器就已经被赋值。 解析解析阶段主要是虚拟机将常量池内的符号引用替换为直接引用的过程。 初始化初始化阶段是执行类构造器&lt;cinit&gt;()方法的过程。 &lt;cinit&gt;()与类的构造方法不同，&lt;cinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并而成的。编译器收集的顺序是按语句在源文件中出现的顺序决定的，静态语句块中只能访问定义在它之前的静态变 量，定义在它之后的静态变量，只可以赋值，不可以访问。 虚拟机会保证子类的&lt;cinit&gt;()方法执行之前，其父类的&lt;cinit&gt;()方法一定被执行 (父类先与子类完成加载过程)","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"注解","date":"2022-03-08T02:25:29.689Z","path":"wiki/Java/进阶/注解/","text":"Java从1.5引入了注解(Annotation)，使得Java具有动态语言的特性。 Java中常用的注解有： @Override @Deprecated @SuppressWarnings 元注解用来修饰注解的注解 @Documented @Retention @Target @Inherited @Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。 @Retention SOURCE:源文件保留，在编译器进行编译时它将被丢弃忽视； CLASS:class保留，并不会被加载到 JVM 中； RUNTIME:运行时保留； @Target CONSTRUCTOR:构造器； FIELD:实例； LOCAL_VARIABLE:局部变量； METHOD:方法； PACKAGE:包； PARAMETER:参数; TYPE:类、接口(包括注解类型) 或enum声明。 @Inherited用于描述某个被标注的类型是可被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 自定义注解注意事项12345678910111213141516171819202122package com.shjlone.anno;enum Lamp &#123; RED, GREEN, YELLOW&#125;public @interface MyAnno &#123;//基本数据类型 int num() default 1; //String类型 String value(); //枚举类型 Lamp lamp(); //注解类型 MyAnno2 myAnno2(); //以上类型的数组 String[] values(); Lamp[] lamps(); MyAnno2[] myAnno2s(); int[] nums();&#125; 注解属性的返回值类型必须是以下几种： 基本数据类型 String类型 枚举类型 注解 以上类型的数组 如果返回值没有默认值，则在使用注解时必须显示设置 APTAPT 即为 Annotation Processing Tool，它是 javac 的一个工具，中文意思为编译 时注解处理器。APT 可以用来在编译时扫描和处理注解。获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT 的核心是 AbstractProcessor 类。 RoundEnvironmentprocessingOver如果当前轮次不是最后一轮，则processingOver()返回false，否则返回true。 getElementsAnnotatedWith返回值是一个Element类型的Set集合，入参有两种类型，一种是Class类型，这里就是自定义的某种注解类型，一种是TypeElement类型，TypeElement位于javax.lang.model.element包下，是Element的子类型，代表了一种类或者接口类型。 ProcessingEnvironmentProcessingEnvironment相当于一个工具类集合，它可以通过该工具类进行写入文件、打印日志以及查找其它元素类型。 参考 https://bbs.huaweicloud.com/blogs/173996 https://www.jianshu.com/p/5cac4cb9be54 Java进阶–编译时注解处理器（APT）详解","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"ArrayDeque","date":"2022-03-08T02:25:29.689Z","path":"wiki/Java/集合/ArrayDeque/","text":"ArrayDeque不是线程安全的。 ArrayDeque不可以存取null元素 当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。 参考 https://blog.jrwang.me/2016/java-collections-deque-arraydeque/","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://airshu.github.io/categories/Java/%E9%9B%86%E5%90%88/"}]},{"title":"Java容器","date":"2022-03-08T02:25:29.689Z","path":"wiki/Java/集合/Java_Collections/","text":"容器类图 Java 中常用的存储容器就是数组和容器，二者有以下区别： 存储大小是否固定 数组的长度固定； 容器的长度可变。 数据类型 数组可以存储基本数据类型，也可以存储引用数据类型； 容器只能存储引用数据类型，基本数据类型的变量要转换成对应的包装类才能放入容器类中。 Java 容器框架主要分为 Collection 和 Map 两种。其中，Collection 又分为 List、Set 以及 Queue。 Collection - 一个独立元素的序列，这些元素都服从一条或者多条规则。 List - 必须按照插入的顺序保存元素。 Set - 不能有重复的元素。 Queue - 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。 Map - 一组成对的“键值对”对象，允许你使用键来查找值。 基础接口Iterator、IterableIterator：可迭代接口，迭代对象Iterable：Collection 接口扩展了 Iterable 接口 123456789101112131415public class IteratorDemo &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); Iterator it = list.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; Comparable 和 ComparatorComparable：排序接口。若一个类实现了 Comparable 接口，表示该类的实例可以比较，也就意味着支持排序。实现了 Comparable 接口的类的对象的列表或数组可以通过 Collections.sort 或 Arrays.sort 进行自动排序。 Comparator：比较接口。在 Java 容器中，一些可以排序的容器，如 TreeMap、TreeSet，都可以通过传入 Comparator，来定义内部元素的排序规则。 CloneableJava 中 一个类要实现 clone 功能 必须实现 Cloneable 接口，否则在调用 clone() 时会报 CloneNotSupportedException 异常。Java 中所有类都默认继承 java.lang.Object 类，在 java.lang.Object 类中有一个方法 clone()，这个方法将返回 Object 对象的一个拷贝。Object 类里的 clone() 方法仅仅用于浅拷贝（拷贝基本成员属性，对于引用类型仅返回指向改地址的引用）。如果 Java 类需要深拷贝，需要覆写 clone() 方法。 fail-fast机制Java 容器的一种错误检测机制。例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历容器 A 中的元素，在某个时候线程 2 修改了容器 A 的结构（是结构上面的修改，而不是简单的修改容器元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。 List特征 元素可重复 常用List ArrayList：数组实现，随机访问速度快，插入删除较慢 LinkedList：链表实现，插入、删除较快，但查找需要遍历整个链表，速度较慢 Vector：和 ArrayList 类似，但它是线程安全的 Set特征 元素不能重复 常用Set HashSet：基于哈希实现，支持快速查找，但不支持有序性操作，例如根据一个范围查找元素的操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator遍历 HashSet 得到的结果是不确定的。 TreeSet：底层使用红黑树，支持有序性操作，但是查找效率不如 HashSet，HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logn)； LinkedHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。 Map特征 使用键值对存储 键值对都可以为null 常用Map HashMap：在JDK1.8中，基于数组+链表+红黑树。需要自动装箱，有hash碰撞问题 HashTable：哈希表实现，本身是同步的，put操作直接锁住，不支持null键和值。 ConcurrentHashMap：线程安全的HashMap，使用synchronized锁住了链表，性能强于HashTable LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 SortedMap： TreeMap：基于红黑树的一种提供顺序访问的Map SparseArray：Android平台专有，避免自动装箱，k、v都使用数组实现，k为整型。使用二分查找。删除时将v设置为DELETE。 Queue LinkedList：可以用它来支持双向队列； PriorityQueue 是基于堆结构实现，可以用它来实现优先级队列。 常见面试题ArrayList与LinkedList的实现和区别？ ArrayList由动态数组实现，LinkedList由链表实现 ArrayList随机访问快，LinkedList插入删除快","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://airshu.github.io/categories/Java/%E9%9B%86%E5%90%88/"}]},{"title":"HashMap","date":"2022-03-08T02:25:29.689Z","path":"wiki/Java/集合/HashMap/","text":"概要在JDK1.6，JDK1.7中，HashMap采用位桶+链表实现，即使用链表处理冲突,同一hash值的键值对会被放在同一个位桶里，当桶中元素较多时，通过key值查找的效率较低。 在极端情况下可能会存在某个链表很长，整个时候整个查找效率就变低了，于是有了1.8的改进方式。使用红黑树，提升查询效率。 而JDK1.8中，HashMap采用位桶+链表+红黑树实现，如果哈希表单向链表中元素超过8个，那么单向链表这种数据结构会变成红黑树数据结构。当红黑树上的节点数量小于6个，会重新把红黑树变成单向链表数据结构。 数组存储区间是连续，且占用内存严重，空间复杂也很大，时间复杂为O（1）。 优点：是随机读取效率很高，原因数组是连续（随机访问性强，查找速度快）。 缺点：插入和删除数据效率低，因插入数据，这个位置后面的数据在内存中要往后移的，且大小固定不易动态扩展。 链表区间离散，占用内存宽松，空间复杂度小，时间复杂度O(N)。 优点：插入删除速度快，内存利用率高，没有大小固定，扩展灵活。 缺点：不能随机查找，每次都是从第一个开始遍历（查询效率低）。 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253//基于jdk1.8.0.121public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //默认初始容量为16，0000 0001 右移4位 0001 0000为16，主干数组的初始容量为16，而且这个数组 //必须是2的倍数 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 //最大容量为int的最大值除2 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认加载因子为0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; //阈值，如果主干数组上的链表的长度大于8，链表转化为红黑树 static final int TREEIFY_THRESHOLD = 8; //hash表扩容后，如果发现某一个红黑树的长度小于6，则会重新退化为链表 static final int UNTREEIFY_THRESHOLD = 6; //当hashmap容量大于64时，链表才能转成红黑树 static final int MIN_TREEIFY_CAPACITY = 64; //临界值=主干数组容量*负载因子 int threshold; public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; //initialCapacity为初始容量，loadFactor为负载因子 public HashMap(int initialCapacity, float loadFactor) &#123; //初始容量小于0，抛出非法数据异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); //初始容量最大为MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //负载因子必须大于0，并且是合法数字 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; //如果传入A，当A大于0，小于定义的最大容量时， //如果A是2次幂则返回A，否则将A转化为一个比A大且差距最小的2次幂。 //例如传入7返回8，传入8返回8，传入9返回16 static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; //默认构造方法，负载因子为0.75，初始容量为DEFAULT_INITIAL_CAPACITY=16，初始容量在第一次put时才会初始化 public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; //传入map的构造方法 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); //设置临界值 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize();//初始化或扩充table //遍历map，添加每个元素 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; //添加键值对 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; //integer类型的hashcode都是他自身的值，即h=key；h &gt;&gt;&gt; 16为无符号右移16位，低位挤走，高位补0； //^ 为按位异或，即转成二进制后，相异为1，相同为0，由此可发现，当传入的值小于 2的16次方-1 时，调用这个方法返回的值，都是自身的值。 static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; //onlyIfAbsent是true的话，不要改变现有的值 //evict为true的话，表处于创建模式 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果主干上的table为空，长度为0，调用resize方法，调整table的长度 //如果是通过传入map的方式创建的HashMap，则在相应构造函数中就会调用resize if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //将数组长度与计算得到的hash值比较 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null);//位置为空，将i位置上赋值一个node对象 else &#123; Node&lt;K,V&gt; e; K k; //如果这个位置的old节点与new节点的key完全相同 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) // 如果p已经是树节点的一个实例，既这里已经是树了 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //p与新节点既不完全相同，p也不是treenode的实例 for (int binCount = 0; ; ++binCount) &#123; //e=p.next,如果p的next指向为null if ((e = p.next) == null) &#123; //指向一个新的节点 p.next = newNode(hash, key, value, null); // 如果链表长度大于等于8 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); //将链表转为红黑树 break; &#125; //如果遍历过程中链表中的元素与新添加的元素完全相同，则跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e;//将p中的next赋值给p,即将链表中的下一个node赋值给p，继续循环遍历链表中的元素 &#125; &#125; //如果添加的元素产生了hash冲突，那么调用 //put方法时，会将他在链表中他的上一个元素的值返回 if (e != null) &#123; // existing mapping for key V oldValue = e.value; //判断条件成立的话，将oldvalue替换 //为newvalue，返回oldvalue；不成立则不替换，然后返回oldvalue if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e);//用于LinkedHashMap回调 return oldValue; &#125; &#125; ++modCount;//记录修改次数 if (++size &gt; threshold)//如果元素数量大于临界值，则进行扩容 resize(); afterNodeInsertion(evict); return null; &#125; // 扩容 final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //最大容量 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //扩容两倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr;//新的临界点 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab;//新的数组 if (oldTab != null) &#123; //通过原容量遍历原数组 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125;&#125; 参考","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://airshu.github.io/categories/Java/%E9%9B%86%E5%90%88/"}]},{"title":"ConcurrentHashMap","date":"2022-03-08T02:25:29.689Z","path":"wiki/Java/集合/ConcurrentHashMap/","text":"ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和用同步包装器包装的HashMap(Collections.synchronizedMap(new HashMap()))，ConcurrentHashMap 拥有更高的并发性。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争: 减小请求同一个锁的频率。减少持有锁的时间。 ConcurrentHashMap 的高并发性主要来自于三个方面: 用分离锁实现多个线程间的更深层次的共享访问。 用HashEntery对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的求。 通过对同一个 volatile 变量的写 &#x2F; 读访问，协调不同线程间读 &#x2F; 写操作的内存可见性。 使用分离锁，减小了请求同一个锁的频率。 通过 HashEntery 对象的不变性及对同一个 volatile 变量的 读 &#x2F; 写来协调内存可见性，使得读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。通过减小请求同一个锁的频率和尽量减少持有锁的时间，使得 ConcurrentHashMap 的并发性相对于 HashTable 和用同步包装器包装的 HashMap有了质的提高。","tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://airshu.github.io/tags/Java%E9%9B%86%E5%90%88/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://airshu.github.io/categories/Java/%E9%9B%86%E5%90%88/"}]},{"title":"反射","date":"2022-03-08T02:25:29.688Z","path":"wiki/Java/进阶/反射/","text":"反射（Reflection）的作用： 反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。 反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。 测试时可以利用反射API访问类的私有成员，以保证测试代码覆盖率。 API 获取Class对象12345678910//获取Class的方法Class clz = Class.forName(&quot;java.lang.String&quot;);Class clz = String.class;String str = new String(&quot;Hello&quot;);Class clz = str.getClass(); 创建对象如果默认无参构造函数是public，则可以直接使用class.newInstance()，而如果没有，则需要使用getDeclaredConstructor。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Rectangle &#123; public int x; public int y;&#125;class User &#123; private String name; private int age; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class TestPerformance &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; Class c1 = Rectangle.class; c1.newInstance(); Class user = User.class; //需要填充参数 user.getDeclaredConstructor(String.class, int.class).newInstance(&quot;zhangsan&quot;, 19); &#125;&#125; 获取属性、方法123456789101112131415161718//获取方法Method[] methods = user.getDeclaredMethods();for (Method method : methods) &#123; System.out.println(method.getName());&#125;//获取属性Field[] fields = user.getDeclaredFields();for (Field field : fields) &#123; System.out.println(field.getName());&#125;//调用方法User user1 = new User(&quot;lisi&quot;, 20);Method method = user1.getClass().getMethod(&quot;setAge&quot;, int.class);method.setAccessible(true); //如果是私有方法，需要执行这样语句method.invoke(user1, 88);System.out.println(user1); 这里需要注意的是，getDeclaredFields方法可以拿到私有属性，而getFields不行。 性能分析虽然反射功能很强大，但在使用过程中要注意效率问题。因为： 因为接口的通用性，Java的invoke方法是传object和object[]数组的。基本类型参数需要装箱和拆箱，产生大量额外的对象和内存开销，频繁促发GC。 编译器难以对动态调用的代码提前做优化，比如方法内联。 反射需要按名检索类和方法，有一定的时间开销。 我们可以进行简单的测试： 123456789101112131415Class c1 = User.class;long duration = 0;duration = System.currentTimeMillis();for(int i=0; i&lt;999999999;i++) &#123; c1.newInstance();&#125;long current = System.currentTimeMillis();System.out.println(current - duration);for(int i=0; i&lt;999999999;i++) &#123; new User(&quot;zhangsan&quot;, 20);&#125;System.out.println(System.currentTimeMillis() - current); 以上代码的输出结果，两者差距有近千倍！！！ 参考 https://www.jianshu.com/p/356e1d7a9d11","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"泛型","date":"2022-03-08T02:25:29.688Z","path":"wiki/Java/进阶/泛型/","text":"概述范型的设计参考了C++中的模版，目的是写出更加通用的代码。泛型将代码安全性检查提前到编译期。添加了范型特性后，解决了Java中容器的类型安全问题。 泛型的本质是参数化类型。也就是说，泛型就是将所操作的数据类型作为参数的一种语法。 Java泛型为了向前兼容，采取运行期类型擦出泛型参数的方式来实现。这就意味着，你在使用泛型的时候，任何具体的类型都已经被擦除。 12345public class Paly&lt;T&gt;&#123; T play()&#123;&#125;&#125;Play&lt;Integer&gt; playInteger=new Play&lt;&gt;();//这里 T 就会被实例化为 Integer 泛型类型自定义泛型接口1interface Observer&lt;T&gt; 泛型类12345678910111213class ImplObserver&lt;T&gt; implements Observer&lt;T&gt;interface BaseDongXi&lt;T&gt; &#123;&#125;class Dongxi&lt;A, T, M&gt; implements BaseDongXi&lt;T&gt; &#123; public T get(T t) &#123; return t; &#125; public void set(M m) &#123; &#125;&#125; 泛型方法 一个类中多个泛型123456789101112131415161718192021222324252627282930313233343536373839404142434445package book; class Notepad&lt;N, A, H&gt; &#123; private N name; private A age; private H height; public N getName() &#123; return name; &#125; public void setName(N name) &#123; this.name = name; &#125; public A getAge() &#123; return age; &#125; public void setAge(A age) &#123; this.age = age; &#125; public H getHeight() &#123; return height; &#125; public void setHeight(H height) &#123; this.height = height; &#125;&#125; public class JiOu &#123; public static void main(String args[]) &#123; Notepad&lt;String, Integer, Float&gt; t = null; t = new Notepad&lt;String, Integer, Float&gt;(); t.setName(&quot;smc&quot;); t.setAge(22); t.setHeight(170.0f); System.out.println(&quot;姓名:&quot; + t.getName()); System.out.println(&quot;年龄:&quot; + t.getAge()+&quot;岁&quot;); System.out.println(&quot;身高:&quot; + t.getHeight()+&quot;cm&quot;); &#125;&#125; 泛型作用域 如果将泛型声明放在泛型接口,泛型类上,则该泛型在该类中就是确定的了。 如果将泛型声明放在了泛型方法上,则该泛型只在该方法中有效。 如果泛型方法上声明的泛型类型和类或接口中声明的泛型一致,则会在该方法中隐藏类或接口上的泛型。 通配符与嵌套通配符?:表示类型不确定，只能用于声明变量或者形参上，不能用在创建泛型类，泛型方法和接口上 123456public static void main(String[] args) &#123; List&lt;?&gt; list=new ArrayList&lt;Integer&gt;(); list=new ArrayList&lt;String&gt;(); test(list);&#125;public static void test(List&lt;?&gt; list)&#123; &#125; 泛型嵌套1234567891011121314151617181920212223242526272829303132class Student&lt;T&gt;&#123; private T score; public T getScore()&#123; return score; &#125; public void setScore(T score)&#123; this.score=score; &#125;&#125;class MyClass&lt;T&gt; &#123; private T cls; public T getCls() &#123; return cls; &#125; public void setCls(T cls) &#123; this.cls = cls; &#125;&#125;public static void main(String[] args) &#123; Student&lt;String&gt; stu = new Student&lt;String&gt;(); stu.setScore(&quot;great&quot;); //泛型嵌套 MyClass&lt;Student&lt;String&gt;&gt; cls = new MyClass&lt;Student&lt;String&gt;&gt;(); cls.setCls(stu); Student&lt;String&gt; stu2 = new Student&lt;String&gt;(); stu2 = cls.getCls(); System.out.println(stu2.getScore());//great&#125; 定义两个泛型类 ，Myclass类的泛型就是Student类 ，而Student类的泛型是String类 泛型上下边界? extends E 是泛型的上边界List &lt; ? extends A &gt;表示这个 list 里面存的是 A 的子类，具体是啥不知道，只知道范围! ? super T 是泛型的下边界List &lt; ? super C &gt; 表示 list 里面存的是 C 和其父类，具体是啥不确定，只知道范围。","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"引用类型","date":"2022-03-08T02:25:29.688Z","path":"wiki/Java/进阶/引用类型/","text":"概要介绍Java中的几种引用类型： 强引用: 强引用指的是在程序代码之中普遍存在的，类似于”Object obj &#x3D; new Object()”这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象实例。 软引用: 软引用是用来描述一些还有用但是不是必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围 之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢 出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。 弱引用: 弱引用也是用来描述非必需对象的。但是它的强度要弱于软引用。被弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾回收 器开始进行工作时，无论当前内容是否够用，都会回收掉只被弱引用关联的 对象。在 JDK1.2 之后提供了 WeakReference 类来实现弱引用。 虚引用: 虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是 能在这个对象被收集器回收时收到一个系统通知。在 JDK1.2 之后，提供了PhantomReference 类来实现虚引用。 参考资料","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"动态代理","date":"2022-03-08T02:25:29.687Z","path":"wiki/Java/进阶/动态代理/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.shjlone.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 动态代理demo */public class ProxyClient &#123; public static void main(String[] args) &#123; Shape realSubject = new Circle(); InvocationHandler handler = new DynamicProxy(realSubject); Shape subject = (Shape) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); subject.draw(); &#125;&#125;interface Shape &#123; void draw();&#125;class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;draw cicle&quot;); &#125;&#125;class DynamicProxy implements InvocationHandler &#123; private Object subject; public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(subject, args); &#125;&#125; 参考 https://allenwu.itscoder.com/use-of-proxy","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"双亲委派机制","date":"2022-03-08T02:25:29.687Z","path":"wiki/Java/进阶/双亲委派机制/","text":"Bootstrap ClassLoader:使用 C++实现，是虚拟机的一部分。它主要负责 加载存放在%JAVAHOME%&#x2F;lib 目录中的，或者被-Xbootclasspath 指定的类库到虚拟机内存中，Bootstrap ClassLoader 无法被 java 程序直接引用。 Extension ClassLoader:主要负责加载%JAVAHOME%&#x2F;lib&#x2F;ext 目录中的， 或者被 java.ext.dirs 系统变量指定路径的所有类。 Application ClassLoader:也被称为系统类加载器(因为其实 getSystemClassLoader 的返回对象)，主要负责加载用户类路径(ClassPath) 下的类库 工作流程讲解12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized(this.getClassLoadingLock(name)) &#123; Class var4 = this.findLoadedClass(name); // 检查需要加载的类是否已经被加载过 if (var4 == null) &#123; long var5 = System.nanoTime(); try &#123; // 若没有加载，则调用父加载器的 loadClass()方法 if (this.parent != null) &#123; var4 = this.parent.loadClass(name, false); &#125; else &#123; var4 = this.findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException name0) &#123; // 若父类加载器加载失败会抛出 ClassNotFoundException， //说明父类加载器无法完成加载请求 &#125; if (var4 == null) &#123; long var7 = System.nanoTime(); // 在父类加载器无法加载时 // 再调用本身的 findClass 方法进行类加载 var4 = this.findClass(name); PerfCounter.getParentDelegationTime().addTime(var7 - var5); PerfCounter.getFindClassTime().addElapsedTimeFrom(var7); PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; this.resolveClass(var4); &#125; return var4; &#125;&#125; 若一个类加载器收到了类加载请求： 把该类加载请求委派给父类加载器去完成，而不会自己去加载该类每层的类加载器都是如此，因此所有的加载请求最终都应传送到顶层的启动类加载器中 只有当父类加载器反馈自己无法完成该加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会自己去加载","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"虚拟机是如何装载一个类的","date":"2022-03-08T02:25:29.684Z","path":"wiki/Java/虚拟机/虚拟机是如何装载一个类的/","text":"Java语言的类型可以分为两大类:基本类型(primitive types)和引用类型(reference types)。 基本类型是由Java虚拟机预先定义好的。 另一个大类引用类型，Java将其细分为四种:类、接口、数组类和泛型参数。由于泛型参数会在 编译过程中被擦除，因此Java虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java虚拟机直接生成的，其他两种则有对应的字节流。 说到字节流，最常见的形式要属由Java编译器生成的class文件。除此之外，我们也可以在程序内 部直接生成，或者从网络中获取(例如网页中内嵌的小程序Java applet)字节流。这些不同形式的字节流，都会被加载到Java虚拟机中，成为类或接口。为了叙述方便，下面我就用“类”来统称它们。 无论是直接生成的数组类，还是加载的类，Java虚拟机都需要对其进行链接和初始化。 加载加载，是指查找字节流，并且据此创建类的过程。对于数组类来说，它并没有对应的字节流，而 是由Java虚拟机直接生成的。对于其他的类来说，Java虚拟机则需要借助类加载器来完成查找字 节流的过程。 java中有很多类加载器，共同的祖师爷，叫启动类加载器(bootstrap class loader)。启动类加载 器是由C++实现的，没有对应的Java对象，因此在Java种只能用null来指代。 除了启动类加载器之外，其他的类加载器都是java.lang.ClassLoader的子类，因此有对应的Java对 象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至Java虚拟机中，方能 执行类加载。 每当一个类加载器接收到加载请求时，它会将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。叫双亲委派模型。 在Java9之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在JRE的lib目录下jar包中的类(以及由虚拟机参数-Xbootclasspath 指定的类)。除了启动类加载器之外，另外两个重要 的类加载器是扩展加载器(extension class loader)和应用类加载器(application class loader)， 均由Java核心类库提供。 扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如放在JRE 的lib&#x2F;ext目录下jar包中的类(以及由系统变量java.ext.dirs指定的类)。 应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。(这里的应用 程序路径，便是指虚拟机参数 -cp&#x2F;-classpath、系统变量java.class.path或环境变量CLASSPATH所 指定的路径。)默认情况下，应用程序中包含的类便是由应用类加载器加载的。 Java9引入模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器 (platform class loader)。Java SE中除了少数几个关键模块，比如说java.base是由启动类加载器 加载之外，其他的模块均由平台类加载器所加载。 除了由Java核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载 方式。举例来说，我们可以对class文件进行加密，加载时再利用自定义的类加载器对其解密。 在Java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节 流，经过不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特 性，来运行同一个类的不同版本 链接链接，是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。它可以分为验证、准备以及解析三个阶段。 验证阶段的目的，在于确保被加载的类能够满足Java虚拟机的约束条件。通常而言，Java编译器 生成的类文件必然满足Java虚拟机的约束条件。 准备阶段的目的，则是为被加载类的静态字段分配内存。Java代码中对静态字段的具体初始化， 则会在稍后的初始化阶段中进行。除了分配内存外，部分Java虚拟机还会在此阶段构造 其他跟类 层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。 在class文件被加载至Java虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java编译器会生成一 个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。 举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收餐宿和类型以及返回值类型的符号引用，来指代所要调用的方法。 解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载的字段或方法，那么解析将触发这个类的加载(但未必触发这个类的链接以及初始化。) Java虚拟机规范并没有要求在链接过程中完成解析。它仅规定了:如果某些字节码使用了符号引 用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。 初始化在Java代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块 中对其赋值。 如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段便会 被Java编译器标记成为常量值(ConstantValue)，其初始化直接由Java虚拟机完成。除此之外的 直接赋值操作，以及所有静态代码块中的代码，则会被Java编译器置于同一方法中，并把它命名 为。 类加载的最后一步时初始化，便是为标记为常量值的字段赋值，以及执行方法的过程。Java虚拟 机会通过加锁来确保类的方法仅被执行一次。 只有当初始化完成之后，类才正式成为可执行的状态。那么，类的初始化何时会被触发呢?JVM 规范枚举了下述多种触发情况: 当虚拟机启动时，初始化用户指定的主类; 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类; 当遇到调用静态方法的指令时，初始化该静态方法所在的类; 当遇到访问静态字段的指令时，初始化该静态字段所在的类; 子类的初始化会触发父类的初始化; 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该 接口的初始化; 使用反射API对某个类进行反射调用时，初始化这个类; 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。 使用卸载","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://airshu.github.io/tags/JVM/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"虚拟机","slug":"Java/虚拟机","permalink":"http://airshu.github.io/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"ClassLoader","date":"2022-03-08T02:25:29.684Z","path":"wiki/Java/进阶/ClassLoader/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"内存模型","date":"2022-03-08T02:25:29.684Z","path":"wiki/Java/进阶/内存模型/","text":"概述Java 内存模型 (Java Memory Model) 定义了 JVM 如何正确访问计算机主内存。JMM 指定了不同线程如何以及何时可以看到其他线程写入到共享变量的值，以及如何在必要时同步访问共享变量。 Java 多线程之间通信一般有两种方式: 共享内存和消息传递。Java 的并发采用共享内存的方式，共享内存通信方式对于程序员而言总是透明隐式进行的。 JMM 关键技术点都是围绕着多线程的原子性、可见性、有序来讨论的。JMM 解决了可见性和有序性的问题，而锁解决了原子性的问题。 Java 内存模型的可见性问题的底层实现是通过内存屏障 (memory barriers) 实现。 现代计算机内存模型： Java内存模型： 具体操作 read 读取，作用于主内存把变量从主内存中读取到本本地内存。 load 加载，主要作用本地内存，把从主内存中读取的变量加载到本地内存的变量副本中use 使用，主要作用本地内存，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到 一个需要使用变量的值的字节码指令时将会执行这个操作。 assign 赋值 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变 量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store 存储 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随 后的write的操作。 write 写入 作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的 变量中。 lock 锁定 :作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock 解锁:作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 规则 不允许read和load、store和write的操作单独出现。 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 不允许一个线程无原因地(没有发生过任何assign操作)把数据从工作内存同步回主内存 中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或 assign)的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现 如果对 一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要 重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作;也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中(执行store和write操作) 内存结构JVM运行时内存结构 程序计数器：程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。 Java栈(虚拟机栈)：栈描述的是Java方法执行的内存模型。每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 栈分为3个部分:基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 堆区:堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。 存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 方法区: 又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 在JAVA虚拟机进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。 线程栈JVM 内存结构中有一个非常重要的内存区域叫做线程栈 , 每个线程的栈大小可以通过设置 JVM 参 数-Xss, -Xss128k 表示每个线程堆栈大小为 128K，JDK1.5 默认值为 1M。(Android也是，每当新建一个线程，native就会划分1M左右空间出来) 线程栈内存存储了基本类型变量和对象引用，当访问了对象的某一实例变量时，通过在栈中获得对象引用再获取变量的值，然后将变量的值拷贝至线程的工作内存。 每个线程 (处理器) 都有工作内存，工作内存存了该线程以读写共享变量的副本。工作内存是 JMM 抽象概念 , 并不真实存在。 read and load 从主存复制变量到当前工作内存; use and assign 执行代码，改变共享变量值; store and write 用工作内存数据刷新主存相关内容; 其中 use and assign 可以多次出现。 但是这一些操作并不是原子性，也就是在 read load 之后，如果主内存 count 变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样。 可见性可见性指的是一个线程对变量的写操作对其他线程后续的读操作可见。 由于现代 CPU 都有多级缓存，CPU 的操作都是基于高速缓存的，而线程通信是基于内存的，这中间有一个Gap, 可见性的关键还是在对变量的写操作之后能够在某个时间点显示地写回到主内存， 这样其他线程就能从主内存中看到最新的写的值。 volatile，synchronized(隐式锁), Lock（显式锁），Atomic（原子变量）这些同步手段都可以保证可见性。可见性底层的实现是通过加内存屏障实现的: 写变量后加写屏障，保证 CPU 写缓冲区的值强制刷新回主内存; 读变量之前加读屏障，使缓存失效，从而强制从主内存读取变量最新值。 指令重排序对于处理器而言，一条汇编指令的执行时分为很多步骤的。在多处理器下，一个汇编指令不一定是原子操作的。为提高CPU利用率，加快执行速度，将指令分为若干个阶段，可并行执行不同指令的不同阶段，从而多个指令可以同时执行。 数据依赖性 上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。前面提到过，编译 器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和 处理器不会改变存在数据依赖关系的两个操作的执行顺序。这里所说的数据依赖性仅针对单个处 理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性 不被编译器和处理器考虑。 as-if-serial不管怎么重排序，(单线程)程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。 为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。 happens-before 原则happen 与 before 规则阐述操作之间的内存可见性，目的都是为了在不改变程序的语义情况下提 高程序的并行度。在 JMM 中，如果一个操作执行的结果需要对另一个操作线程，那么这两个操作之间必须存在 happen-before 关系。 程序次序规则:一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作; 锁定规则:一个 unLock 操作先行发生于后面对同一个锁的 lock 操作; volatile 变量规则:对一个变量的写操作先行发生于后面对这个变量的读操作; 传递规则:如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C; 线程启动规则:Thread 对象的 start() 方法先行发生于此线程的每个一个动作; 线程中断规则:对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生; 线程终结规则:线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行; 对象终结规则:一个对象的初始化完成先行发生于他的 finalize() 方法的开始; 程序顺序规则:一个线程中的每个操作，happen-before 于该线程中的任意后续操作; 监视器锁规则:对一个锁的解锁，happens-before 于随后对这个锁的加锁; Volatile 变量规则:对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读; 传递性:如果 A happens-beforeB , 且 B happens-before C, 那么 A happens-before C; Start 规则: 如果线程 A 执行操作 ThreadB.start()(启动线程 B), 那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作。 参考 《Time，Clocks and the Ordering of Events in a Distributed System》","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"JVMTI","date":"2022-03-08T02:25:29.684Z","path":"wiki/Java/进阶/JVMTI/","text":"概要JVM Tool Interface：JVMTI 本质上是在JVM内部的许多事件进行了埋点。通过这些埋点可以给外部提供当前上下文的一些信息。甚至可以接受外部的命令来改变下一步的动作。外部程序一般利用C&#x2F;C++实现一个JVMTIAgent，在Agent里面注册一些JVM事件的回调。当事件发生时JVMTI调用这些回调方法。Agent可以在回调方法里面实现自己的逻辑。JVMTIAgent是以动态链接库的形式被虚拟机加载的。 主要的功能： 重新定义类。 跟踪对象分配和垃圾回收过程。 遵循对象的引用树，遍历堆中的所有对象。 检查 Java 调用堆栈。 暂停（和恢复）所有线程。 运用在Android中，内存溢出分析、大图检测、ANR监控都可以通过此中方式实现。 参考 ART TI Java黑科技之源：JVMTI完全解读 基于JVMTI 实现性能监控","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}]},{"title":"ASM","date":"2022-03-08T02:25:29.680Z","path":"wiki/Java/开源库/ASM/","text":"插桩 参考 https://asm.ow2.io/index.html https://github.com/Leifzhang/AndroidAutoTrack","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"开源库","slug":"Java/开源库","permalink":"http://airshu.github.io/categories/Java/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"RxJava","date":"2022-03-08T02:25:29.680Z","path":"wiki/Java/开源库/RxJava/","text":"概要使用观察者模式、装饰器模式，类似Java的IO流。将不同的操作符一层层的封装，然后再进行一层层的解封。 基本概念 Observable(可观察者，即被观察者) Observer (观察者) subscribe (订阅) 事件 线程设置 Scheduler.immediate() 直接运行在当前线程，这是默认的scheduler Scheduler.newThread() 开一个新的线程，并在新的线程中执行操作 Scheduler.io() io操作(读写文件、网络交互)所使用的scheduler，和newThead类似，区别是io内部维护了一个没有数量上限的线程池，使用io可以避免不必要的线程创建 Scheduler.computation() 计算所用的scheduler，计算指的是cpu密集型计算，如图形的计算，使用固定数量(cpu核心数)的线程池 Scheduler.mainThread() 在android主线程中运行 BackpressureStrategy当异步情况下, 被观察者发送数据过快, 而消费者无法及时处理数据, 导致缓存内存增大, 最终导致OOM, 背压就是为了处理这种情况。 策略 效果 MISSING 无任何背压策略执行, 除非调用onBackpressureXXX ERROR 抛出异常 BUFFER 内部维护可扩容的缓存池, 效果与Observer一样, 可能导致OOM DROP 如果下流无法跟上上流发射速度, 则会丢弃这块数据 LATEST 当下流无法跟上上流的发射速度的时候, 则只保存最近生产的数据 操作符create12345678910111213141516171819202122232425262728293031323334353637383940414243Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; observableEmitter) throws Exception &#123; observableEmitter.onNext(&quot;1&quot;); observableEmitter.onNext(&quot;2&quot;); observableEmitter.onNext(&quot;3&quot;); observableEmitter.onNext(&quot;4&quot;); observableEmitter.onError(new Throwable()); observableEmitter.onComplete();//执行完complete之后就不能执行其他操作了 &#125; &#125;).map(new Function&lt;String, String&gt;() &#123; @Override public String apply(@NonNull String s) throws Exception &#123; return s + &quot;---&quot;;//进行转换 &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; private Disposable mDisposable; @Override public void onSubscribe(Disposable disposable) &#123; Log.d(TAG, &quot;onSubscribe&quot;); mDisposable = disposable; &#125; @Override public void onNext(String s) &#123; Log.d(TAG, &quot;onNext=&quot; + s); &#125; @Override public void onError(Throwable throwable) &#123; Log.d(TAG, &quot;onError&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125; &#125;); map一对一变换 1 flatmap一对多、多对多变换 1 intervalRange间隔触发 1234567891011121314151617/*start：起始数值count：发射数量initialDelay：延迟执行时间period：发射周期时间unit：时间单位scheduler：使用的线程策略*/public static Flowable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)public static Flowable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)// 从0-100，每个100毫秒刷新一次，刷新100次，在Android主线程Flowable.intervalRange(1, 100, 0, 100, TimeUnit.MILLISECONDS, AndroidSchedulers.mainThread()) .subscribe(aLong -&gt; &#123; Log.d(TAG, &quot; =&quot; + (100-aLong) + &quot; &quot; + Thread.currentThread().getName()); &#125;); 参考 RxJava源码解析(三)-背压","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"开源库","slug":"Java/开源库","permalink":"http://airshu.github.io/categories/Java/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"Class文件","date":"2022-03-08T02:25:29.680Z","path":"wiki/Java/虚拟机/Class文件/","text":"概述Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class文件之中，中间没有添加任何分隔符。根据Java虚拟机规范的规定，Class文件结构采用一种 类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型:无符号数和表。 无符号数属于基本的数据类型，以u1、u2、u4、u8来表示1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构 成的字符串值。 表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯性地以 “_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表， 它由下表所示的数据项构成。 魔数与Class文件的版本每个Class文件的头四个字节称为魔数(Magic Number)，值为0xCAFEBABE。紧跟着魔数的四个字节存储的是Class文件的版本号:第5和第6个字节是次版本号(Minor Version),第7和第8个字节是主版本号(Major Version)。 常量池(constant_pool)由于常量池中的常量数量不固定，所以在常量池的入口需要放置一项u2类型的数据，代表容量池容量计数值(constant_pool_count)，这个容量计数从1而不是0开始。 常量池中主要存放两大类常量:字面量(Literal)和符号引用(Symbolic Reference)。字面量 比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量: 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 JDK1.7中，总共有14种类型的常量，每种常量都是表类型的数据项。这14种表都有一个共同的特 点，就是表开始的第一位是一个u1类型的标志位，代表当前常量属于哪种常量类型。这14种常量类型代表的具体含义见下表: 访问标志(access_flags)常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括:这个Class是接口还是类;是否被定义为public类型;是否定义为abstract类型;如 果是类的话，是否被声明为final等。 类索引(this_class)、父类索引(super_class)与接口索引集合(interfaces)类索引、父类索引和接口索引集合都按顺序排列代访问标志之后，类索引用于确定这个类的全限 定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多继承，因此父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了Object外，所有Java类的父类索引都不为0。 类索引和父类索引均是u2类型的数据，它们各自指向一个类型为CONSTANT_Class_info类型的常 量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTATN_Utf8_info类型 的常量中的全限定名字符串。该查找过程可用下图表示 接口索引集合用来描述这个类实现了哪些接口，它是一组u2类型的数据的集合，集合中的第一项 是接口计数器，表示索引表的容量。如果一个类没有实现任何接口，则该计数器值为0。 字段表集合(fields)方法表集合(methods)属性表集合(attributes)","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://airshu.github.io/tags/JVM/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"虚拟机","slug":"Java/虚拟机","permalink":"http://airshu.github.io/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"jenv","date":"2022-03-08T02:25:29.680Z","path":"wiki/Java/未分类/jenv/","text":"概述有时候，我们可能需要在电脑中安装多个Java环境，在不同的场景切换版本，我们需要修改JAVA_HOME、PATH等环境变量。每次改起来就很繁琐。我们也可以自己写一个shell命令，来动态切换不同的版本。jenv就是帮我们解决了这个问题。 jenv支持在当前shell、文件夹、全局切换不同的Java版本 安装和配置安装1brew install jenv 配置我们一般先下载对应的JDK&#x2F;JRE的压缩包，然后即可进行配置。 123456789101112131415161718192021222324252627282930313233343536运行以下命令添加环境变量export PATH=&quot;$HOME/.jenv/bin:$PATH&quot; eval &quot;$(jenv init -)&quot;添加JAVA_HOME，每次切换后只需要source一下，就会更新此变量export JAVA_HOME=&quot;$HOME/.jenv/versions/`jenv version-name`&quot;# 添加java版本jenv add /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Homejenv versions # 查看所有版本 system 1.8* 1.8.0.252 (set by /Users/loneqd/.java-version) 1.8.0.51 16.0 16.0.1 openjdk64-1.8.0.252 openjdk64-16.0.1 oracle64-1.8.0.51# 切换当前目录下的jdk版本，如切换当前目录下的版本为1.6jenv local 1.8# 全局切换版本，如下切换为1.7jenv global 1.7# 当前shell中使用某个版本jenv shell 1.6# 查看当前使用版本jenv version 参考 Java8相关环境下载地址 https://www.jenv.be/ https://github.com/jenv/jenv/issues/44","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"未分类","slug":"Java/未分类","permalink":"http://airshu.github.io/categories/Java/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"volatile详解二","date":"2022-03-08T02:25:29.680Z","path":"wiki/Java/并发编程/volatile详解二/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"线程间通讯方式","date":"2022-03-08T02:25:29.680Z","path":"wiki/Java/并发编程/线程间通讯方式/","text":"什么是线程安全？线程的工作原理，jvm有一个main memory，而每个线程有自己的working memory，一个线程对一个variable进行操作时，都要在自己的working memory里面建立一个copy，操作完之后再写入main memory。多个线程同时操作同一个variable，就可能会出现不可预知的结果。 而用synchronized的关键是建立一个monitor，这个monitor可以是要修改的variable也可以其他你 认为合适的object比如method，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完load到workingmemory -&gt; use&amp;assign -&gt; store到mainmemory 的过程，才会释放它得到的锁。这样就实现了所谓的线程安全。 线程安全就是说多线程访问同一块内存，不会产生不确定的结果。编写线程安全的代码是依靠线程同步。 CPU时间片轮转机制cpu 给每个进程分配一个“时间段”，这个时间段就叫做这个进程的“时间片”，这个时间片就是这个进程允许运行的时间，如果当这个进程的时间片段结束，操作系统就会把分配给这个进程的 cpu 剥夺，分配给另外一个进程。如果进程在时间片还没结束的情况下阻塞了，或者说进程跑完了，cpu 就会进行切换。cpu 在两个进程之间的切换称为“上下文切换”，上下文切换是需要时间的，大约需要花费 5000~20000(5 毫秒到 20 毫秒，这个花费的时间是由操作系统决定)个时钟周期，尽管我们平时感觉不到。所以在开发过程中要注意上下文切换(两个进程之间的切换)对我们程序性能的影响。 死锁造成死锁的四个条件： 互斥条件：资源只能被一个线程占用,如果其它线程请求获取该资源,则请求者只能等待,直到占用资源的线程释放该资源. 请求并持有条件：指一个线程已经持有了至少一个资源,但又提出了新的资源请求,而新的资源已被其他线程占 用,所以当前线程会被阻塞,但阻塞的同时不释放自己获取的资源. 不可剥夺条件：获取到的资源在自己使用完之前不能被其他线程抢占,只能在使用完之后释放. 环路等待条件：发生死锁的时候必然存在一个线程-资源的环形链,即线程集合{T0,T1,T2,…Tn}中的T0正在等待 一个T1占用的资源,T1正在等待T2占用的资源,…Tn正在等待T1占用的资源 通信方式 共享进程的变量 ThreadLocal 同步锁、信号量（Synchronize、Semaphore、Lock）","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"ThreadLocal原理","date":"2022-03-08T02:25:29.679Z","path":"wiki/Java/并发编程/ThreadLocal原理/","text":"ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。 源码分析Thread中有一个成员变量： 1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal的set方法中，如果当前Thread的threadLocals有值，则设置，没有则创建一个新的ThreadLocalMap。 123456789101112131415161718/** * Sets the current thread&#x27;s copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread&#x27;s copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; ThreadLocal的get方法中，从当前线程的threadLocals拿map，如果有则返回，没有则初始化值。 12345678910111213141516171819202122/** * Returns the value in the current thread&#x27;s copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread&#x27;s value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 值的修改都是在自己线程中操作的，所以是线程安全的。 使用场景 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望被多线程共享 Android中Hander 1234567static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 参考 http://www.jasongj.com/java/threadlocal/ https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"ThreadPoolExecutor","date":"2022-03-08T02:25:29.679Z","path":"wiki/Java/并发编程/ThreadPoolExecutor/","text":"参数1234public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); corePoolSize: 线程池核心线程的数量； maximumPoolSize: 线程池可创建的最大线程数量； keepAliveTime: 当线程数量超过了corePoolSize指定的线程数，并且空闲线程空闲的时间达到当前参数指定的时间时该线程就会被销毁，如果调用过allowCoreThreadTimeOut(boolean value)方法允许核心线程过期，那么该策略针对核心线程也是生效的； allowCoreThreadTimeOut为true,则线程池数量最后销毁到0个。 allowCoreThreadTimeOut为false,超过核心线程数时，而且（超过最大值或者timeout），就会销毁。 unit: 指定了keepAliveTime的单位，可以为毫秒，秒，分，小时等； workQueue: 存储未执行的任务的队列； threadFactory: 创建线程的工厂，如果未指定则使用默认的线程工厂； handler: 指定了当任务队列已满，并且没有可用线程执行任务时对新添加的任务的处理策略； 调度策略当初始化一个线程池之后，池中是没有任何用户执行任务的活跃线程的，当新的任务到来时，根据配置的参数其主要的执行任务如下： 若线程池中线程数小于corePoolSize指定的线程数时，每来一个任务，都会创建一个新的线程执行该任务，无论线程池中是否已有空闲的线程； 若当前执行的任务达到了corePoolSize指定的线程数时，也即所有的核心线程都在执行任务时，此时来的新任务会保存在workQueue指定的任务队列中； 当前核心线程都在执行任务，并且任务队列已满时，会创建新的线程执行任务，这里需要注意的是，创建新线程的时候当前总共需要执行的任务数是(corePoolSize + workQueueSize)，并不是只有corePoolSize个任务； 当所有的核心线程都在执行任务，并且任务队列中存满了任务，此时若新来了任务，那么线程池将会创建新线程执行任务； 这里workQueue主要有三种类型：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue，第一个是有界阻塞队列，第二个是无界阻塞队列，当然也可以为其指定界限大小，第三个是同步队列，对于ArrayBlockingQueue，其是需要指定队列大小的，当队列存满了任务线程池就会创建新的线程执行任务，对于LinkedBlockingQueue，如果其指定界限，那么和ArrayBlockingQueue区别不大，如果其不指定界限，那么其理论上是可以存储无限量的任务的，实际上能够存储Integer.MAX_VALUE个任务（还是相当于可以存储无限量的任务），此时由于LinkedBlockingQueue是永远无法存满任务的，因而maxPoolSize的设定将没有意义，一般其会设定为和corePoolSize相同的值，对于SynchronousQueue，其内部是没有任何结构存储任务的，当一个任务添加到该队列时，当前线程和后续添加任务的线程都会被阻塞，直至有一个线程从该队列中取出任务，当前线程才会被释放，因而如果线程池使用了该队列，那么一般corePoolSize都会设计得比较小，maxPoolSize会设计得比较大，因为该队列比较适合大量并且执行时间较短的任务的执行； 若所有的线程（maximumPoolSize指定的线程数）都在执行任务，并且任务队列也存满了任务时，对于新添加的任务，其都会使用handler所指定的方式对其进行处理。 DiscardPolicy和DiscardOldestPolicy一般不会配合SynchronousQueue使用，因为当同步队列阻塞了任务时，该任务都会被抛弃；对于AbortPolicy，因为如果队列已满，那么其会抛出异常，因而使用时需要小心；对于CallerRunsPolicy，由于当有新的任务到达时会使用调用线程执行当前任务，因而使用时需要考虑其对服务器响应的影响，并且还需要注意的是，相对于其他几个策略，该策略不会抛弃任务到达的任务，因为如果到达的任务使队列满了而只能使用调用线程执行任务时，说明线程池设计得不够合理，如果任其发展，那么所有的调用线程都可能会被需要执行的任务所阻塞，导致服务器出现问题。 系统提供的线程池FixedThreadPool123456public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 特征 这是一种线程数量固定的线程池，因为corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉，不过因为最多只有nThreads个线程，且corePoolSize和maximunPoolSize值一致，所以不会发生线程停掉的情况； 阻塞队列采用了LinkedBlockingQueue，它是一个无界队列，由于阻塞队列是一个无界队列，因此永远不可能拒绝任务 弊端 由于使用的是LinkedBlockingQueue无界队列，在资源有限的时候容易引起OOM异常 CachedThreadPool12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 特征 corePoolSize为0，maximumPoolSize为无限大，意味着线程数量可以无限大 keepAliveTime为60S，意味着线程空闲时间超过60S就会被杀死 采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程 弊端 当一个任务提交时，corePoolSize为0不创建核心线程，SynchronousQueue是一个不存储元素的队列，可以理解为队列永远是满的，因此最终会创建非核心线程来执行任务。 对于非核心线程空闲60s时将被回收。因为Integer.MAX_VALUE非常大，可以认为是可以无限创建线程的，在资源有限的情况下容易引起OOM异常 SingleThreadExecutor1234567public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 特征 只有一个线程，使用了无界队列LinkedBlockingQueue，某种意义上等同于newFixedThreadPool(1) ScheduledThreadPool12345public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 特征 ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。能够延时调度任务或者周期性调度任务 参考 https://juejin.cn/post/6844903542965157901 https://blog.csdn.net/kusedexingfu/article/details/107374172","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"ThreadPoolExecutor原理分析","date":"2022-03-08T02:25:29.679Z","path":"wiki/Java/并发编程/ThreadPoolExecutor原理分析/","text":"线程池状态1234567private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 当创建线程池后，初始时，线程池处于 RUNNING 状态;如果调用了 shutdown()方法，则线程池处于 SHUTDOWN 状态，此时线程池不 能够接受新的任务，它会等待所有任务执行完毕;如果调用了 shutdownNow()方法，则线程池处于 STOP 状态，此时线程池不能 接受新的任务，并且会去尝试终止正在执行的任务;当线程池处于 SHUTDOWN 或 STOP 状态，并且所有工作线程已经销毁，任务缓 存队列已经清空或执行结束后，线程池被设置为 TERMINATED 状态。 任务的执行1234567891011121314private final BlockingQueue&lt;Runnable&gt; workQueue;//任务缓存队列，用来存放等待执行的任务private final ReentrantLock mainLock = new ReentrantLock();//线程池的主要状态锁，对线程池状态(比如线程池大小、runState 等的改变都要使用这个锁)private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();//用来存放工作集private volatile long keepAliveTime;//线程存货时间private volatile boolean allowCoreThreadTimeOut;//是否允许为核心线程设置存活时间private volatile int corePoolSize;//核心池的大小(即线程池中的线程数目大于这 个参数时，提交的任务会被放进任务缓存队列)private volatile int maximumPoolSize;//线程池最大能容忍的线程数public int getPoolSize()&#123;&#125;//获取当前线程池的线程数量private volatile RejectedExecutionHandler handler;//任务拒绝策略private volatile ThreadFactory threadFactory;//线程工厂，用来创建线程private int largestPoolSize;//用来记录线程池中曾经出现过的最大线程数private long completedTaskCount;//用来记录已经执行完毕的任务个数 最核心的任务提交方法是 execute()方法，虽然通 过 submit 也可以提交任务，但是实际上 submit 方法里面最终调用的还是 execute()方法 12345678910111213141516171819public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command);&#125; 分三步： If fewer than corePoolSize threads are running, try tostart a new thread with the given command as its firsttask. The call to addWorker atomically checks runState andworkerCount, and so prevents false alarms that would addthreads when it shouldn’t, by returning false. If a task can be successfully queued, then we still needto double-check whether we should have added a thread(because existing ones died since last checking) or thatthe pool shut down since entry into this method. So werecheck state and if necessary roll back the enqueuing ifstopped, or start a new thread if there are none. If we cannot queue task, then we try to add a newthread. If it fails, we know we are shut down or saturatedand so reject the task. 线程池中的线程初始化addWorker中进行初始化，创建一个Worker，Worker内部从threadFactory中获取Thread。 在Thread的run方法中会调用getTask，来获取任务来执行。 12345678910111213141516171819202122232425262728293031323334353637private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 任务缓存队列及排队策略workQueue的类型为BlockingQueue，通常可以取下面三种类型: ArrayBlockingQueue:基于数组的先进先出队列，此队列创建时必须指定大小; LinkedBlockingQueue:基于链表的先进先出队列，如果创建时没有指定此 队列大小，则默认为 Integer.MAX_VALUE; SynchronousQueue:这个队列比较特殊，它不会保存提交的任务，而是将直 接新建一个线程来执行新来的任务。 任务拒绝策略当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略: ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出 RejectedExecutionException 异常。 ThreadPoolExecutor.DiscardPolicy:也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy:丢弃队列最前面的任务，然后重新尝试执行任务(重复此过程) ThreadPoolExecutor.CallerRunsPolicy:由调用线程处理该任务 线程池的关闭ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown()和 shutdownNow()，其中： shutdown():不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 shutdownNow():立即终止线程池，并尝试打断正在执行的任务，并且清 空任务缓存队列，返回尚未执行的任务 线程池容量的动态调整 setCorePoolSize:设置核心池大小 setMaximumPoolSize:设置线程池最大能创建的线程数目大小","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"volatile","date":"2022-03-08T02:25:29.679Z","path":"wiki/Java/并发编程/volatile/","text":"volatile作用在Java并发编程中，volatile 是经常用到的一个关键字，它可以用于保证不同的线程共享一个变量时每次都能获取最新的值。volatile具有锁的部分功能并且性能比锁更好，所以也被称为轻量级锁。 一个变量被volatile修饰，则： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 一些基本概念CPU缓存CPU的计算速度相比内存的读写是非常快的，为了能充分利用CPU的计算能力，这个时候缓存的概念出现了。CPU缓存是位于CPU与内存之间的临时存储器，它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。 按照读取顺序与CPU结合的紧密程度，CPU缓存可分为： 一级缓存：简称L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存 二级缓存：简称L2 Cache，分内部和外部两种芯片，内部芯片二级缓存运行速度与主频相同，外部芯片二级缓存运行速度则只有主频的一半 三级缓存：简称L3 Cache，部分高端CPU才有 当系统运行时，CPU执行计算的过程如下： 程序以及数据被加载到主内存 指令和数据被加载到CPU缓存 CPU执行指令，把结果写到高速缓存 高速缓存中的数据写回主内存 原子性即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 可见性指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 volatile是如何实现可见性的呢？ 在线程和主内存之间添加了一条总线，当线程中的变量发生变化时，会将值复制到主内存，这个时候这个值会通过总线，总线就会通知其他线程做修改。 指令重排处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 比如： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 使用场景修饰boolean变量123456789volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125; 双重锁校验123456789101112131415class Singleton &#123; private static volatile Singleton instance; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 其实问题出在 instance &#x3D; new Singleton(); 这一行，这里是创建 Singleton 对象的地方，其实这里可以看成三个步骤： 123memory = allocate(); //1: 分配对象的内存空间ctorInstance(memory); //2: 初始化对象instance = memory； //3: 设置 instance 指向刚分配的内存地址 上面的伪代码可能会被重排序。什么是重排序？编译器以及处理器有时候会为了执行的效率改变代码的执行顺序，这个被称为重排序。上面的三个步骤可能会被重排序为下面的步骤： 1234memory = allocate(); //1: 分配对象的内存空间instance = memory； //2: 设置 instance 指向刚分配的内存地址// 注意：此时对象还没有被初始化ctorInstance(memory); //3: 初始化对象 在这种情况下，当一个线程执行到 instance &#x3D; memory; 的时候，对象还没有被初始化，另一个线程也调用了 getInstance 方法，发现 instance 引用不为 null，就会认为这个对象已经创建好了，从而使用了未初始化的对象。 为什么 volatile 可以避免上面的问题？其实是因为 volatile 会禁止重排序，方法是插入了内存屏障。 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。 lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将对缓存的修改操作立即写入主存； 如果是写操作，它会导致其他CPU中对应的缓存行无效。 参考 https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg https://www.cnblogs.com/dolphin0520/p/3920373.html https://github.com/AdoptOpenJDK/jitwatch volatile与lock前缀指令","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Thread","date":"2022-03-08T02:25:29.678Z","path":"wiki/Java/并发编程/Thread/","text":"Java中的Thread的用法 同步队列与等待队列 同步队列：所有尝试获取该对象Monitor失败的线程，都加入同步队列排队获取锁。调用了start、notify方法后会进入该队列。 等待队列：已经拿到锁的线程在等待其他资源时，主动释放锁，置入该对象等待队列中，等待被唤醒，当调用notify会在等待队列中任意唤醒一个线程，将其置入同步队列的尾部，排队获取锁。调用wait方法时，会进入该队列。 API join主要作用是线程调度，等待该线程完成后，才能继续用下运行。一般用于等待异步线程执行完结果之后才能继续运行的场景。 123Thread t1 = new Thread(new Worker(&quot;thread-1&quot;)); t1.start();t1.join();//要等待t1执行完后，当前线程才会继续往下执行 yield暂停当前正在执行的线程对象，不会释放资源锁，和sleep不同的是yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 notify该方法用来通知那些可能等待该对象的对象锁的其他线程。 wait和sleep区别 区别 wait() sleep() 归属类 Object类实例方法 Thread类静态方法 是否释放锁 释放锁 不会释放锁 线程状态 等待 睡眠 使用时机 只能在同步块(Synchronized)中使用 在任何时候使用 唤醒条件 其他线程调用notify()或notifyAll()方法 超时或调用Interrupt()方法 cpu占用 不占用cpu，程序等待n秒 占用cpu，程序等待n秒 interruptThread类的sleep(),wait()等方法，在接收到interrupt()方法中断时，会抛出异常，同时会将中断标志置为false,如果确实需要中断该线程，则应该在捕捉到异常后，继续调用interrupt()方法进行中断。 123456789101112131415161718192021222324//为什么不在异常时直接中断线程呢?主要是为了防止线程的资源没有得到释放而中断了线程public class UserThread extends Thread &#123; public void run() &#123; while (!isInterrupt()) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName + &quot; Exception,interrupt flag is&quot; + isInterrupted()); //释放资源 doRelease(); interrupt(); e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName + &quot; runing&quot;); &#125; System.out.println(Thread.currentThread().getName + &quot; interrupt flag is &quot; + isInterrupted()); &#125; public static void main(String args) &#123; UserThread thread = new UserThread(); thread.start(); Thread.sleep(30); thread.interrupt(); &#125;&#125; 参考 深入理解线程通信","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Synchronized","date":"2022-03-08T02:25:29.677Z","path":"wiki/Java/并发编程/Synchronized/","text":"前言在学习synchronized之前，应该先了解多线程的机制和锁的概念，请先阅读以下文章： Java锁 Java多线程 使用方式 同步普通方法，锁的是当前对象this。 1234567891011121314151617181920public class SynchronizedTest &#123; public synchronized void sayHello()&#123; &#125;&#125;//对应字节码 Compiled from &quot;SynchronizedTest.java&quot; public class com.myth.SynchronizedTest &#123; public com.myth.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public synchronized void sayHello(); Code: 0: return &#125; 同步静态方法，锁的是当前 Class 对象。 12345678910111213141516171819public class SynchronizedTest &#123; public synchronized static void sayHello()&#123; &#125;&#125;//对应字节码public class com.myth.SynchronizedTest &#123;public com.myth.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: returnpublic static synchronized void sayHello(); Code: 0: return&#125; 同步块，锁的是 () 中的对象。 12345678910111213141516171819202122232425262728293031323334353637383940public class SynchronizedTest &#123; private String words; public void sayHello()&#123; synchronized(words)&#123; &#125; &#125;&#125;//对应字节码 Compiled from &quot;SynchronizedTest.java&quot; public class com.myth.SynchronizedTest &#123; public com.myth.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public void sayHello(); Code: 0: aload_0 1: getfield #2 // Field words:Ljava/lang/String; 4: dup 5: astore_1 6: monitorenter 7: aload_1 8: monitorexit 9: goto 17 12: astore_2 13: aload_1 14: monitorexit 15: aload_2 16: athrow 17: return Exception table: from to target type 7 9 12 any 12 15 12 any &#125; 通过查阅字节码（javap -c XXX.class）可知，synchronized修饰对象时，使用monitorenter、monitorexit来实现同步操作，修饰方法时网络上很多资源都说使用ACC_SYNCHRONIZED来实现同步，ACC_SYNCHRONIZED内部隐式的调用monitorenter、monitorexit，可自己查看的字节码却没有看到，不知道啥原因，🤷‍ 底层原理对象头我们编写一个Java类，编译后会生成.class文件，当类加载器将class文件加载到jvm时，会生成一个Klass类型的对象(c++)，称为类描述元数据，存储在方法区中，即jdk1.8之后的元数据区。当使用new创建对象时，就是根据类描述元数据Klass创建的对象oop，存储在堆中。每个java对象都有相同的组成部分，称为对象头。 对象头 Mark Word（标记字段）：默认存储对象的HashCode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 MarkWord在64位JVM中的结构： MarkWord在32位JVM中的结构： Klass Point（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据 这部分主要是存放类的数据信息，父类的信息。 对其填充 由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐。 查看对象占用内存通过jol-core可以分析出内存占用情况和锁的情况 12345678910111213141516171819202122232425262728//添加依赖&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt;//使用public class App &#123; public static void main(String[] args) &#123; System.out.println(ClassLayout.parseInstance(new MyObject()).toPrintable()); &#125;&#125;class MyObject &#123; public int age;&#125;//结果 OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 41 c1 00 f8 (01000001 11000001 00000000 11111000) (-134168255) 12 4 (loss due to the next object alignment)Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total 锁升级JDK 1.6之前，synchronized 是一个重量级锁，是一个效率比较低下的锁，但是在JDK 1.6后，Jvm为了提高锁的获取与释放效率对（synchronized ）进行了优化，引入了”偏向锁”和”轻量级锁”，从此以后锁的状态就有了四种（无锁、偏向锁、轻量级锁、重量级锁），并且四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程。 关于锁的概念，参考Java锁 参考 https://juejin.cn/post/6844904069845221384","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java中的异常","date":"2022-03-08T02:25:29.668Z","path":"wiki/Java/基础/Java中的异常/","text":"Java语言是编译型语言，Java代码编译成字节码，然后由JVM解释成目标代码由CPU执行;这里包含我们常说的两个过程，即编译时和运行时;Java语言把编译时可能产生的异常称为受检查异常，把运行时可能产生的异常称为不受检查异常(比如NullPointException和ClassNotFoundException)。","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://airshu.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}]},{"title":"NIO","date":"2022-03-08T02:25:29.668Z","path":"wiki/Java/基础/NIO/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://airshu.github.io/tags/IO/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://airshu.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}]},{"title":"CAS原理","date":"2022-03-08T02:25:29.668Z","path":"wiki/Java/并发编程/CAS原理/","text":"CAS原理在计算机科学中，比较和交换(Conmpare And Swap)是用于实现多线程同步的原子指令。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改 为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果 该值在同一时间被另一个线程更新，则写入将失败。操作结果必须说明是否进行替换; 这 可以通过一个简单的布尔响应(这个变体通常称为比较和设置)，或通过返回从内存位置读取的值来完成。 CAS带来的问题多线程情况下，每个线程使用 CAS 操作欲将数据 A 修改成 B，当然我们只希望 只有一个线程能够正确的修改数据，并且只修改一次。当并发的时候，其中一个线程已经将 A 成功的改成了 B，但是在线程并发调度过程中尚未被调度，在这个期间，另外一个线程(不在并发中的请求线程)将 B 又修改成了 A，那么原来并发中的线程又可以通过 CAS 操作将 A 改成 B。 解决办法 java 中提供了 AtomicStampedReference 来解决这个问题，它是基于版本或者是 一种状态，在修改的过程中不仅对比值，也同时会对比版本号","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java锁","date":"2022-03-08T02:25:29.668Z","path":"wiki/Java/并发编程/Java锁/","text":"锁的基本概念从广义上来定义： 悲观锁： 比如线程A对某个变量进行修改，在这个修改期间，它持悲观心理，认为其他线程在这个期间，也有可能去修改这个变量，所以它就给变量加个锁，保证在它修改期间，别的线程没法去访问这个变量。这个锁就是悲观锁。悲观锁是重量级锁，代表对象synchronized和Lock。悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 乐观锁： 比如线程A对某个变量进行修改，在这个修改期间，它持乐观心理，认为其他线程在这个期间，不会去修改这个变量，所以不会加锁。 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁是轻量级锁，代表对象CAS。Java原子类中的递增操作就通过CAS自旋实现的。乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。 悲观锁和乐观锁的基本用法12345678910111213141516// ------------------------- 悲观锁的调用方式 -------------------------// synchronizedpublic synchronized void testMethod() &#123; // 操作同步资源&#125;// ReentrantLockprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁public void modifyPublicResources() &#123; lock.lock(); // 操作同步资源 lock.unlock();&#125;// ------------------------- 乐观锁的调用方式 -------------------------private AtomicInteger atomicInteger = new AtomicInteger(); // 需要保证多个线程使用的是同一个AtomicIntegeratomicInteger.incrementAndGet(); //执行自增1 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。这四种锁是指锁的状态，专门针对synchronized的。 Java头对象synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？ 我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。 Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 MonitorMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。 Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。 如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。 无锁： 无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。 偏向锁： 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。 偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking&#x3D;false，关闭之后程序默认会进入轻量级锁状态。 轻量级锁： 是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 重量级锁 重量级锁是依赖对象内部的monitor锁来实现。当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，需要从用户态转换到内核态，而转换状态是需要消耗很多时间。 综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 CASCAS锁：（Compare And Swap） 乐观锁的一种实现方式。 CAS算法涉及到三个操作数： 需要读写的内存值 V。 进行比较的值 A。 要写入的新值 B。 当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。 123456789101112131415161718192021222324// ------------------------- JDK 8 -------------------------// AtomicInteger 自增方法public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;// Unsafe.classpublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;// ------------------------- OpenJDK 8 -------------------------// Unsafe.javapublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; 根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。 后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。 CAS虽然很高效，但是它也存在三大问题，这里也简单说一下： ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。 JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。 Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。 公平锁和非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。 如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。 但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示： ReentrantLock中公平锁和非公平锁的实现如下： 12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。 综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。 可重入锁 VS 非可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析： 12345678910public class Widget &#123; public synchronized void doSomething() &#123; System.out.println(&quot;方法1执行...&quot;); doOthers(); &#125; public synchronized void doOthers() &#123; System.out.println(&quot;方法2执行...&quot;); &#125;&#125; 在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。 如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。 而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。 还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。 但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。 之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。 首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。 当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status &#x3D;&#x3D; 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status !&#x3D; 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status !&#x3D; 0的话会导致其获取锁失败，当前线程阻塞。 释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 &#x3D;&#x3D; 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。 独享锁 VS 共享锁独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。 独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。 共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。 在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。 那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。 在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示： 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState(); // 取到当前锁的个数 int w = exclusiveCount(c); // 取写锁的个数w if (c != 0) &#123; // 如果已经有线程持有了锁(c!=0) // (Note: if c != 0 and w == 0 then shared count != 0) if (w == 0 || current != getExclusiveOwnerThread()) // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败 return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 throw new Error(&quot;Maximum lock count exceeded&quot;); // Reentrant acquire setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。 return false; setExclusiveOwnerThread(current); // 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者 return true;&#125; 这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w &#x3D; exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!&#x3D;0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!&#x3D;0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。 如果c&#x3D;0,w&#x3D;0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！ tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。 因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。 接着是读锁的代码： 123456789101112131415161718192021222324252627protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); int c = getState(); if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。 此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码： 我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。 参考 volatile和synchronized的区别 https://stackoverflow.com/questions/9851133/when-to-use-volatile-and-synchronized https://tech.meituan.com/2018/11/15/java-lock.html","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"混合开发","date":"2022-03-08T02:25:29.666Z","path":"wiki/Flutter/混合开发/","text":"官方方案https://flutter.cn/docs/development/add-to-app/android/project-setup flutter_boosthttps://github.com/alibaba/flutter_boost","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"状态管理","date":"2022-03-08T02:25:29.666Z","path":"wiki/Flutter/状态管理/","text":"概述什么是状态管理？ 这里的状态指的是UI的状态，不同的场景下展示不同的UI，所以需要一种方式来管理UI不同的状态。flutter的很多设计都借鉴来React，而React中就有专门用来进行状态管理的方案。比如redux、bloc等，所以到了flutter这里，就有了flutter_redux、flutter_bloc。 状态管理解决的问题： 状态保存哪里 状态如何获取 UI如何更新 如何改变状态 如何选择开源方案 上手程度 性能比较 高扩展性 flutter本身支持状态管理的方式 State 缺点： 无法做到跨组件共享数据 处理数据逻辑和视图混合在一起，违反代码设计原则 InheritedWidget：向下共享数据 缺点： 容易造成不必要的刷新 不支持跨页面(route)的状态 数据是不可变的，必须结合StatefulWidget、ChangeNotifier或者Steam使用 Notification：向上共享数据 缺点： 不支持跨页面(route)的状态，准备的说不支持NotificationListener同级或者父级Widget的状态通知 本身不支持刷新UI，需要结合State使用 如果结合State，会导致整个UI的重绘 Stream：Dart的异步API，flutter中有StreamBuilder的封装 ChangeNotifier：属性绑定刷新 setState优点： 简单场景下特别适用，逻辑简单，易懂易实现 所见即所得，效率比较高 缺点: 逻辑与视图耦合严重，复杂逻辑下可维护性很差 数据传输基于依赖传递，层级较深情况下不易维护，可读性差 使用场景： Widget内部的状态管理 scoped_modelproviderflutter提供的的状态管理方案 获取信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263///使用Provider.ofWidget build(BuildContext context) &#123; return Container(child: MyText());&#125;class MyText extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final text = Provider.of&lt;String&gt;(context); return Text(text); &#125;&#125;///使用ConsumerWidget getWidget2(BuildContext context) &#123;return Consumer&lt;BusinessPattern&gt;(builder: (context, businessModel, child) &#123; switch (businessModel.currentState) &#123; case PatternState.none: return Text(&quot;无模式&quot;); break; case PatternState.normal: return Text(&quot;正常模式&quot;); break; case PatternState.small: return Text(&quot;小屏模式&quot;); break; case PatternState.overview: return Text(&quot;全屏模式&quot;); break; default: return Text(&quot;其他模式&quot;); return SizedBox(); &#125;&#125;);&#125;///使用SelectorWidget getWidget4(BuildContext context) &#123;return Selector&lt;BusinessPattern, PatternState&gt;(selector: (context, businessPattern) =&gt;businessPattern.currentState,builder: (context, state, child) &#123; switch (state) &#123; case PatternState.none: return Text(&quot;无模式&quot;); break; case PatternState.normal: return Text(&quot;正常模式&quot;); break; case PatternState.small: return Text(&quot;小屏模式&quot;); break; case PatternState.overview: return Text(&quot;全屏模式&quot;); break; default: return Text(&quot;其他模式&quot;); return SizedBox(); &#125;&#125;); flutter_blocbloc是基于RxDart开发的纯dart库 参考 官方文档 Flutter中的bloc模式解析 flutter_redux为了解决组件间的通信，Facebook提出了Flux的概念，随后出现Redux，其基于函数式编程实现。 flutter_mobxhttps://mobx.netlify.com/getting-started flutter_hooks参考 https://segmentfault.com/a/1190000040543449 flutter状态管理调研 Flutter State Management状态管理全面分析","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"依赖冲突处理","date":"2022-03-08T02:25:29.666Z","path":"wiki/Flutter/未分类/依赖冲突处理/","text":"Flutter | 如何优雅的解决依赖版本冲突","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"打包","date":"2022-03-08T02:25:29.666Z","path":"wiki/Flutter/未分类/打包/","text":"下载证书，本地安装到钥匙链中 配置Xcode 打包命令修改项目的版本号和构建次数若要使pubspec.yaml文件中的version生效，需要修改Android、iOS项目的配置文件。 Android项目配置文件修改确认android&#x2F;app&#x2F;build.gradle文件中使用了Flutter的versionCode和versionName 123456789101112131415161718192021222324252627282930313233343536373839def localProperties = new Properties()def localPropertiesFile = rootProject.file(&#x27;local.properties&#x27;)if (localPropertiesFile.exists()) &#123; localPropertiesFile.withReader(&#x27;UTF-8&#x27;) &#123; reader -&gt; localProperties.load(reader) &#125;&#125;def flutterRoot = localProperties.getProperty(&#x27;flutter.sdk&#x27;)if (flutterRoot == null) &#123; throw new FileNotFoundException(&quot;Flutter SDK not found. Define location with flutter.sdk in the local.properties file.&quot;)&#125;def flutterVersionCode = localProperties.getProperty(&#x27;flutter.versionCode&#x27;)if (flutterVersionCode == null) &#123; flutterVersionCode = &#x27;1&#x27;&#125;def flutterVersionName = localProperties.getProperty(&#x27;flutter.versionName&#x27;)if (flutterVersionName == null) &#123; flutterVersionName = &#x27;1.0&#x27;&#125;android &#123; compileSdkVersion 31 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; defaultConfig &#123; applicationId &quot;com.xiaopeng.scepter&quot; minSdkVersion 21 targetSdkVersion 31 versionCode flutterVersionCode.toInteger() versionName flutterVersionName &#125;&#125; iOS项目ios&#x2F;Runner&#x2F;Info.plist文件中使用Flutter的变量，使用$(FLUTTER_BUILD_NAME)和$(FLUTTER_BUILD_NUMBER)。 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; ... &lt;key&gt;CFBundleShortVersionString&lt;/key&gt; &lt;string&gt;$(FLUTTER_BUILD_NAME)&lt;/string&gt; &lt;key&gt;CFBundleVersion&lt;/key&gt; &lt;string&gt;$(FLUTTER_BUILD_NUMBER)&lt;/string&gt; ...&lt;/dict&gt;&lt;/plist&gt; 构建脚本设置版本123# 设置版本号、设置构建次数flutter build apk --build-name=1.1.1 --build-number=3 包体积优化12345# --analyze-size参数用于生成*-code-size-analysis_*.json文件，该文件可以导入到devtools中进行分析包组成flutter build xx --analyze-size# 打开devtoolsflutter pub global run devtools 优化方法使用obfuscate参数obfuscate参数会对应用进行混淆，split-debug-info参数配置符号表输出路径，用于后续解析。 12flutter build apk --obfuscate --split-debug-info=/&lt;project-name&gt;/&lt;directory&gt; 参考 https://flutter.cn/docs/perf/app-size https://flutter.cn/docs/deployment/obfuscate Flutter 2.0 iOS包大小优化 手把手教你分离flutter ios编译产物-附工具","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"滚动条","date":"2022-03-08T02:25:29.666Z","path":"wiki/Flutter/未分类/滚动条/","text":"分类 CustomScrollView DraggableScrollableSheet GridView ListView NestedScrollView NotificationListener PageView RefreshIndicator ReorderableListView ScrollCongiuration：一个InheritedWidget，作用是给Scrollable传递ScrollBehavior Scrollable： Scrollbar： SingleChildScrollView 滑动体系 Viewport：视口，一个固定大小的窗口；它根据自元素的大小和给定的[ViewportOffset offset]显示不同的子元素（offset指ScrollPosition） ShrinkWrappingViewport：在performLayout阶段才能确定自己的大小，因为它的大小依赖于自己的子widget，需要先统计子view的大小，才能确定自身的大小 Viewport：在performSize阶段就可以确定自己的大小 ScrollPosition extend ViewportOffset：滑动位置控制器。 确定在[Viewport]哪一部分显示 [pixels]值决定了滚动视图用来选择显示其内容的哪一部分的滚动偏移量。当用户滚动视图时，该值会发生变化，从而改变显示内容 [ScrollPosition]将[physics]应用于滚动，并存储[minScrollExtent]和[maxScrollExtent] 每个Scrollable对应唯一的ScrollPosition管理滑动信息 keepScrollOffset：用[PageStorage]保存当前滚动偏移量 ScrollController：滑动控制器 ScrollPhysics：滑动物理模拟 ScrollView：可滑动视图的父类，ListView、CustomScrollView、GridView都是它的子类，它们通过实现buildSlivers函数为ScroolView提供子视图，同时将ScrollController、ScrollPhysics、ViewportBuilder、children等传递给Scrollable ScrollActivity：表示滑动过程中某一阶段，记录了当前的状态，比如是否滑动中、当前的滑动速度等 delegate，ScrollActivityDelegate，有些更新滑动位置的实现，一般是ScrollPosition寄其子类 shouldIgnorePotinter，是否忽略触摸事件，这里的主体，是 Scrollable 的子 widget，也就是 Viewport，而在 Scrollable 中用于接收手势滑动的 RawGestureDetector 在它之上，也就是说，这个参数并不是控制是否检测滑动手势，而是待滑动的内容是否可以接收事件，所以，在众多 ScrollActivity 中，只有 HoldScrollActivity 和 IdleScrollActivity 中它的值才为 true isScrolling：是否处于滑动状态 velocity：如果是滑动状态，当前的滑动速度 ScrollPhysics：描述滚动的物理属性 spring：SpringDescription，描述了滑动的一些物理特性，会在创建Simulation时传递过去 tolerance，Tolerance，定义了一些可忽略的距离、速度、时间等 flingDistance，定义了最小的可被认定为fling手势的距离 flingVelocity，定义了最小的可被认定为fling手势的速度，和最大的fling速度 dragStartDistanceMotionThreshold，定义了开始滑动时，可被认定是滑动手势的最小距离 allowImplicitScrolling: ScrollActivity分类不滑动 HoldScrollActivity IdleScrollActivity 滑动 DragScrollActivity（事件驱动）：滑动过程是根据外部传进来的滑动事件，来决定是否以及如何更新视图 BallisticScrollActivity（速度驱动）：当 drag 系列事件结束后，会留下一个滑动速度，此时滑动并不会停止，而是在基于这个速度下，做减速滑动，直到速度为 0，或者滑动到边界，这个阶段，对应的就是 BallisticScrollActivity DrivenScrollActivity（动画驱动）：当我们直接通过 ScrollController 控制 Scrollable 进行滑动时，一般就是调用 animateTo，会创建一个 DrivenScrollActivity，根据当前给出的 duration、curve 等，创建一个动画并执行。在 BallisticScrollActivity 执行过程中，用于决定滑动位置的就是 Simulation ScrollPhysics分类 BouncingScrollPhysics：允许滚动超出边界，但之后内容会回弹 ClampingScrollPhysics：防止滚动超出边界 AlwaysScrollableScrollPhysics：始终响应用户的滚动 NeverScrollableScrollPhysics：不响应用户的滚动 1234567891011121314151617181920212223/// [position] 当前的位置, [offset] 用户拖拽距离/// 将用户拖拽距离 offset 转为需要移动的 pixelsdouble applyPhysicsToUserOffset(ScrollMetrics position, double offset)/// 返回 overscroll ，如果返回 0 ，overscroll 就一直是0/// 返回边界条件double applyBoundaryConditions(ScrollMetrics position, double value)///创建一个滚动的模拟器Simulation createBallisticSimulation(ScrollMetrics position, double velocity) ///最小滚动数据 double get minFlingVelocity///传输动量，返回重复滚动时的速度double carriedMomentum(double existingVelocity)///最小的开始拖拽距离double get dragStartDistanceMotionThreshold///滚动模拟的公差///指定距离、持续时间和速度差应视为平等的差异的结构。Tolerance get tolerance SingleChildScrollView类似Android中的ScrollView，处理简单可滑动的页面布局视图，当内容足够多时，一屏显示不下时，就需要滑动处理。 12345678910const SingleChildScrollView(&#123; Key key, this.scrollDirection = Axis.vertical,//设置视图的滚动方向(默认垂直方向), 需要对应的设置其子 Widget 是 Column 或者 Row, 否则会报 Overflow 错误。 this.reverse = false,//是否按照阅读方向相反的方向滑动。若 reverse: false，则滚动内容头部和左侧对其, 那么滑动方向就是从左向右 this.padding, bool primary,//是否使用默认的 controller this.physics,//此属性接受一个 ScrollPhysics 对象，它决定可滚动 Widget 如何响应用户操作，比如用户滑动完抬起手指后，继续执行动画；或者滑动到边界时，如何显示。ClampingScrollPhysics：安卓下微光效果。ClampingScrollPhysics：安卓下微光效果。 this.controller, this.child,&#125;) CustomScrollView： 12345678910111213141516const CustomScrollView(&#123; Key key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, bool shrinkWrap = false, Key center, double anchor = 0.0, double cacheExtent,// this.slivers = const &lt;Widget&gt;[], //Sliver家族列表 int semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start,&#125;) NestedScrollView：滑动可折叠部分内容，配合Sliver相关组件使用。帮我们解决滑动冲突的控件。通过为外部 ScrollView 和内部 ScrollView 提供自定义 ScrollController 来解决此问题，将它们链接在一起，以便它们作为一个连贯的滚动视图显示给用户。 1234567891011const NestedScrollView(&#123; Key key, this.controller, this.scrollDirection = Axis.vertical, this.reverse = false, this.physics, @required this.headerSliverBuilder, @required this.body, this.dragStartBehavior = DragStartBehavior.start,&#125;) 什么是Sliver？通常指具有特定滚动效果的可滚动块，可滚动 widget，如 ListView、GridView 等都有对应的 Sliver 实现如 SliverList、SliverGrid 等。 对于大多数 Sliver 来说，它们和可滚动 Widget 最主要的区别是 Sliver 不会包含 Scrollable，也就是说 Sliver 本身不包含滚动交互模型。 正因如此，CustomScrollView 才可以将多个 Sliver “粘”在一起，这些 Sliver 共用 CustomScrollView 的 Scrollable，最终实现统一的滑动效果。 CustomScrollView：所有Sliver的根源 SliverList：展示线性列表 SliverFixedExtentList：固定高度的线性列表 SliverPrototypeExtentlist： SliverGrid SliverPadding SliverPersistentHeader：吸顶效果控件 SliverAppBar： SliverToBoxAdapter： SliverSafeArea： SliverFillRemaining： SliverOverlapAbsorber： 配合SliverOverlapInjector使用，解决滑动越过pinned的sliver SliverOverlapAbsorberHandle： SliverAppBar12345678910111213141516171819202122232425const SliverAppBar(&#123; Key key, this.leading,//导航栏左侧 widget this.automaticallyImplyLeading = true,//如果 leading 为 null，是否自动实现默认的 leading 按钮 this.title,//导航栏标题 this.actions,//如果 leading 为 null，是否自动实现默认的 leading 按钮 this.flexibleSpace,//可缩放区域 this.bottom,//控件底部固定区域，可以放tabbar等 this.elevation,//控件的 z 坐标顺序? this.forceElevated = false, this.backgroundColor, this.brightness,//状态栏的颜色, 黑白两种, 取值: Brightness.dark this.iconTheme,//设置导航栏上图标的颜色、透明度、和尺寸信息 this.actionsIconTheme,//action 按钮图标的颜色、透明度、和尺寸信息 this.textTheme, this.primary = true,//导航栏的内容是否显示在顶部, 状态栏的下面 this.centerTitle,//标题是否居中显示，默认值根据不同的操作系统，显示方式不一样 this.titleSpacing = NavigationToolbar.kMiddleSpacing, this.expandedHeight,//展开最大高度 this.floating = false, this.pinned = false,//是否固定在顶部 this.snap = false, this.shape,//阴影设置&#125;) SliverPersistentHeader滑动到顶部可以固定，可以根据滚动而变大变小的组件，SliverAppBar就是基于这个实现的。 minHeight:固定高度 maxHeight:最大显示高度 delegate：SliverPersistentHeaderDelegate pinned：收缩到最小高度的时候SliverPersistentHeader是否可见， true：会以折叠高度固定显示在头部， false：缩小到折叠高度后滑出页面 floating：true 的时候下滑先展示SliverPersistentHeader介绍，展示完成后才展示其他滑动组件内容 SliverPersistentHeaderDelegate1234567891011121314151617181920212223abstract class SliverPersistentHeaderDelegate &#123; // header 最大高度；pined为 true 时，当 header 刚刚固定到顶部时高度为最大高度。 double get maxExtent; // header 的最小高度；pined为true时，当header固定到顶部，用户继续往上滑动时，header // 的高度会随着用户继续上滑从 maxExtent 逐渐减小到 minExtent double get minExtent; // 构建 header。 // shrinkOffset取值范围[0,maxExtent],当header刚刚到达顶部时，shrinkOffset 值为0， // 如果用户继续向上滑动列表，shrinkOffset的值会随着用户滑动的偏移减小，直到减到0时。 // // overlapsContent：一般不建议使用，在使用时一定要小心，后面会解释。 Widget build(BuildContext context, double shrinkOffset, bool overlapsContent); // header 是否需要重新构建；通常当父级的 StatefulWidget 更新状态时会触发。 // 一般来说只有当 Delegate 的配置发生变化时，应该返回false，比如新旧的 minExtent、maxExtent // 等其他配置不同时需要返回 true，其余情况返回 false 即可。 bool shouldRebuild(covariant SliverPersistentHeaderDelegate oldDelegate);&#125; SliverList12345678910111213141516const SliverList(&#123; Key key, @required SliverChildDelegate delegate,&#125;) SliverChildListDelegate( this.children, &#123; this.addAutomaticKeepAlives = true, this.addRepaintBoundaries = true, this.addSemanticIndexes = true, this.semanticIndexCallback = _kDefaultSemanticIndexCallback, this.semanticIndexOffset = 0,&#125;) SliverToBoxAdapter用于包装非Sliver类型的Widget SliverFillRemaining填充剩余部分 hasScrollBody表示内容是否可以滚动，如果是为false，则只是填补空白。 fillOverscroll表示子控件是否应该应该伸展以填充超出区域（比如iOS的ListView默认可伸展出一部分区域），当hasScrollBody为false时才起作用。 参考 Flutter（81）：Scroll组件之NestedScrollView Flutter完整开发实战详解(十八、 神奇的ScrollPhysics与Simulation)","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"版本管理工具fvm","date":"2022-03-08T02:25:29.666Z","path":"wiki/Flutter/未分类/版本管理工具/","text":"Java中的版本管理可以使用jenv，Flutter中可以使用fvm。 官网：https://fvm.app 官方使用文档：https://fvm.app/docs/getting_started&#x2F;overview 使用流程： 1234567891011121314151617181920# Mac下安装brew tap leoafarias/fvmbrew install fvm# 激活，不确定要不要使用pub global activate fvm# 安装2.5.0的版本fvm install 2.5.0# 移除版本fvm remove 2.5.0# 显示所有安装的版本fvm list# 全局使用某个版本fvm global 2.5.0 全局使用某个版本# 局部使用某个版本，会在当前目录生成.fvm文件夹fvm use beta --force 会在当前目录创建.fvm文件夹","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"路由管理","date":"2022-03-08T02:25:29.666Z","path":"wiki/Flutter/源码分析/路由管理/","text":"一些问题 路由存在的意义？ 如果是你，会如何设计？ dialog、bottomsheet、snackbar、dropmenubutton的底层实现是怎样的？ pop的时候路由是如何传递数据回到上一个界面的？ hero动画如何实现？ 基本定义 相关类 Navigator:负责整个路由栈，在结构上实际是一个Overlay； NavigatorState：管理整个栈，通过_RouteEntry列表管理栈。有push、pop等操作； Overlay：完成页面的协调、展示；维护一个OveralyEntry列表； _Theatre：_Theatre用来管理所有页面，在_Theatre中，可见&#x2F;不可见的子结点都会转换成Element，但是在绘制的时候，_Theatre对应的_RenderTheatre只会把可见的子结点绘制出来；Overlay中创建，onstage表示舞台，offstage表示观众席； OverlayEntry：用来在Overlay上展示Widget; RouteSettings：用来保存路由的名字和参数； Route：定义路由接口，保存RouteSettings；它的子类： OverlayRoute：页面元素的创建，展示Widget，createOverlayEntries创建两个OverlayEntry，用于构建视图; TransitionRoute：处理转场; ModalRoute：可以阻止与不同路由的交互; PopupRoute： RawDialogRoute： CupertinoDialogRoute：iOS风格的路由； PageRoute:定义了路由构建及切换时转场动画的相关接口和属性； MaterialPageRoute：Material风格的路由，通过builder设置路由具体页面； CupertinoPageRoute： PageRouteBuilder：自定义转场动画； _RouteEntry：包含Route，状态机管理，各个生命周期的回调处理，标记转场是否有动画效果，通过transitionDelegate属性配置； RouteTransitionRecord：_RouteEntry的父类； NavigatorObserver：监控push、pop、replace、remove路由的情况 Page：继承于RouteSettings，自己创建Route，有一个key用来作为唯一性判断，用于设置Navigator的历史堆栈； MaterialPage: CupertinoPage: Router：精细化管理页面，路由信息提供器、解析器； RouteDelegate：定义路由行为，监听RouteInformationParser和应用状态，并构建Pages RouteInformation： RouteInformationParser：解析RouteInformation，它从RouteInformationProvider中获取RouteInformation，并将其解析为用户定义的数据类型； RouteInformationProvider：负责通知RouteInformation变化； RouterDelegate：定义了Router如何学习应用状态变化以及如何响应这些变化的应用特定行为。它的工作是监听RouteInformationParser和应用状态，并利用当前的Pages列表构建Navigator； BackButtonDispatcher：向Router报告返回按钮按下的情况； 路由状态123456789101112131415161718192021222324252627282930enum _RouteLifecycle &#123; staging, // we will wait for transition delegate to decide what to do with this route. // // routes that are present: // add, // we&#x27;ll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages adding, // we&#x27;ll waiting for the future from didPush of top-most route to complete // routes that are ready for transition. push, // we&#x27;ll want to run install, didPush, etc; a route added via push() and friends pushReplace, // we&#x27;ll want to run install, didPush, etc; a route added via pushReplace() and friends pushing, // we&#x27;re waiting for the future from didPush to complete replace, // we&#x27;ll want to run install, didReplace, etc; a route added via replace() and friends idle, // route is being harmless // // routes that are not present: // // routes that should be included in route announcement and should still listen to transition changes. pop, // we&#x27;ll want to call didPop complete, // we&#x27;ll want to call didComplete, remove, // we&#x27;ll want to run didReplace/didRemove etc // routes should not be included in route announcement but should still listen to transition changes. popping, // we&#x27;re waiting for the route to call finalizeRoute to switch to dispose removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose // routes that are completely removed from the navigator and overlay. dispose, // we will dispose the route momentarily disposed, // we have disposed the route&#125; 状态变化add–&gt;adding–&gt;idle NavigatorState初始化的时候，通过混入RestorationMixin，didChangeDependencies的时候调用restoreState校验是否有initialRoute，有则进行初始路由初始化，初始化状态为add；该方法最后调用_flushHistoryUpdates，接着调用entry.handleAdd，状态修改为adding，接着continue下一次循环，执行entry.didAdd。 push–&gt;pushing–&gt;idle Navigator.push，将Route封装成_RouteEntry加入到_history中，并调用_flushHistoryUpdates。该方法返回Future对象，可用于接收返回结果。在_flushHistoryUpdates中调用entry.handlePush，状态切换为pushing；push&#x2F;pushReplace有一个转场动画，动画结束后状态变为idle。 pop–&gt;poping–&gt;dispose–&gt;disposed Navigator.pop，如果entry的settings是Page，先让外部来判断是否需要pop，否则直接entry.pop，设置状态为pop，执行_flushHistoryUpdates，接着执行entry.handlePop，切换状态到popping，执行route.didPop，完成返回值的传递、移除动画启动。didPop中调用navigator.finalizeRoute方法，状态切换到dispose，刷新_flushHistoryUpdates，状态到disposed。 remove–&gt;removing–&gt;dispose–&gt;disposed Navigator.removeRoute，调用entry.remove，将当前状态设置为remove，并调用_flushHistoryUpdates。调用entry.handleRemoval切换状态到revoming，接着切换状态到dispose，并添加到toBeDisposed中，然后切换状态到disposed，整个过程不涉及动画。 命名路由通过名字进行路由跳转，Navigator.pushNamed(context, ‘&#x2F;xxx&#x2F;yyy’);通过_WidgetsAppState中的_onGenerateRoute方法来根据名字返回不同的Route。 嵌套路由showGeneralDialog基本用法12345678910111213141516171819202122Future&lt;T?&gt; showGeneralDialog&lt;T extends Object?&gt;(&#123; required BuildContext context, required RoutePageBuilder pageBuilder,//自定义UI bool barrierDismissible = false,//是否模态 String? barrierLabel, Color barrierColor = const Color(0x80000000), Duration transitionDuration = const Duration(milliseconds: 200), RouteTransitionsBuilder? transitionBuilder, bool useRootNavigator = true,//true表示从根节点弹窗 RouteSettings? routeSettings,&#125;) &#123; return Navigator.of(context, rootNavigator: useRootNavigator).push&lt;T&gt;(RawDialogRoute&lt;T&gt;( pageBuilder: pageBuilder, barrierDismissible: barrierDismissible, barrierLabel: barrierLabel, barrierColor: barrierColor, transitionDuration: transitionDuration, transitionBuilder: transitionBuilder, settings: routeSettings, ));&#125; fluro分析 封装了原生代码，减少重复代码量； 封装了默认的转场动画； 所有路由组装成一个tree，统一管理所有路由，通过命名路由的方式跳转； getx路由模块分析 记录了Navigator的key，方便其他地方获取NavigatorState； 封装Page，支持路由拦截，内置转场动画； 参考 Flutter路由机制 官方导航Demo Learning Flutter’s new navigation and routing system 路由官方设计规范 庖丁解牛 · 如何理解 Flutter 路由源码设计","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"flutterboost","date":"2022-03-08T02:25:29.665Z","path":"wiki/Flutter/开源库/flutterboost/","text":"概述为什么要使用flutterboost？ 在原生页面和Flutter页面共存的情况下，进行管理路由。 以下问题如何处理？ Native如何传递参数给Flutter页面 Flutter页面如何传递参数给Native 基本的使用123//native跳转flutter//flutter跳转native","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"GetX","date":"2022-03-08T02:25:29.664Z","path":"wiki/Flutter/开源库/GetX/","text":"概述高性能的状态管理、智能的依赖注入和便捷的路由管理。 状态管理Get有两个不同的状态管理器：简单的状态管理器（GetBuilder）和响应式状态管理器（GetX）。 12345//使得变量变的可观察var name = &#x27;Jonatas Borges&#x27;.obs;//绑定UIObx(() =&gt; Text(&quot;$&#123;controller.name&#125;&quot;)); GetBuilder1234567891011121314//返回一个widget，通过泛型绑定一个GetxControllerclass Controller extends GetxController &#123; // static Controller get to =&gt; Get.find(); // with no static get[...]&#125;// on stateful/stateless classGetBuilder&lt;Controller&gt;( init: Controller(), // 每个控制器只用一次 builder: (_) =&gt; Text( &#x27;$&#123;Get.find&lt;Controller&gt;().counter&#125;&#x27;, //通过find方法使用 ),), 唯一的ID123456789101112GetBuilder&lt;Controller&gt;( id: &#x27;text&#x27;, //这里 init: Controller(), // 每个控制器只用一次 builder: (_) =&gt; Text( &#x27;$&#123;Get.find&lt;Controller&gt;().counter&#125;&#x27;, //here ),),update([&#x27;text&#x27;]);update([&#x27;text&#x27;], counter &lt; 10); 声明响应式变量的方式123456789101112131415161718192021222324252627282930//第一种是使用 Rx&#123;Type&#125;。// 建议使用初始值，但不是强制性的final name = RxString(&#x27;&#x27;);final isLogged = RxBool(false);final count = RxInt(0);final balance = RxDouble(0.0);final items = RxList&lt;String&gt;([]);final myMap = RxMap&lt;String, int&gt;(&#123;&#125;);//第二种是使用 Rx，规定泛型 Rx&lt;Type&gt;。final name = Rx&lt;String&gt;(&#x27;&#x27;);final isLogged = Rx&lt;Bool&gt;(false);final count = Rx&lt;Int&gt;(0);final balance = Rx&lt;Double&gt;(0.0);final number = Rx&lt;Num&gt;(0)final items = Rx&lt;List&lt;String&gt;&gt;([]);final myMap = Rx&lt;Map&lt;String, int&gt;&gt;(&#123;&#125;);//第三种更实用、更简单、更可取的方法，只需添加 .obs 作为value的属性。final name = &#x27;&#x27;.obs;final isLogged = false.obs;final count = 0.obs;final balance = 0.0.obs;final number = 0.obs;final items = &lt;String&gt;[].obs;final myMap = &lt;String, int&gt;&#123;&#125;.obs;// 自定义类 - 可以是任何类final user = User().obs; 路由管理123456789101112131415161718192021222324252627282930313233343536373839404142//在你的MaterialApp前加上 &quot;Get&quot;，把它变成GetMaterialApp。GetMaterialApp( // Before: MaterialApp( home: MyHome(),)//导航到新页面Get.to(NextScreen());//别名导航Get.toNamed(&#x27;/details&#x27;);//浏览并删除前一个页面。Get.offNamed(&quot;/NextScreen&quot;);//浏览并删除所有以前的页面。Get.offAllNamed(&quot;/NextScreen&quot;);//只要发送你想要的参数即可。Get在这里接受任何东西，无论是一个字符串，一个Map，一个List，甚至一个类的实例。Get.toNamed(&quot;/NextScreen&quot;, arguments: &#x27;Get is the best&#x27;);//Get提供高级动态URL，就像在Web上一样。Web开发者可能已经在Flutter上想要这个功能了，Get也解决了这个问题。Get.offAllNamed(&quot;/NextScreen?device=phone&amp;id=354&amp;name=Enzo&quot;);print(Get.parameters[&#x27;id&#x27;]);// out: 354print(Get.parameters[&#x27;name&#x27;]);// out: Enzo//要关闭snackbars, dialogs, bottomsheets或任何你通常会用Navigator.pop(context)关闭的东西。Get.back();//进入下一个页面，但没有返回上一个页面的选项（用于闪屏页，登录页面等）。Get.off(NextScreen());//进入下一个页面并取消之前的所有路由（在购物车、投票和测试中很有用）。Get.offAll(NextScreen());//要导航到下一条路由，并在返回后立即接收或更新数据。var data = await Get.to(Payment());//在另一个页面上，发送前一个路由的数据。Get.back(result: &#x27;success&#x27;); 定义路由1234567891011121314151617void main() &#123; runApp( GetMaterialApp( unknownRoute: GetPage(name: &#x27;/notfound&#x27;, page: () =&gt; UnknownRoutePage()),//未定义路线的导航（404错误） initialRoute: &#x27;/&#x27;, getPages: [ GetPage(name: &#x27;/&#x27;, page: () =&gt; MyHomePage()), GetPage(name: &#x27;/second&#x27;, page: () =&gt; Second()), GetPage( name: &#x27;/third&#x27;, page: () =&gt; Third(), transition: Transition.zoom ), ], ) );&#125; 中间件嵌套导航12345678910111213141516171819202122class AppPages &#123; static const INITIAL = Routes.HOME; static final routes = [ GetPage( name: Routes.HOME, page: () =&gt; HomeView(), binding: HomeBinding(), children: [ GetPage( name: Routes.COUNTRY, page: () =&gt; CountryView(), children: [ GetPage( name: Routes.DETAILS, page: () =&gt; DetailsView(), ), ], ), ]), ];&#125; 访问导航的时候，可以使用&#x2F;home&#x2F;country&#x2F;details等方式跳转。 依赖管理添加依赖Get.put1234567891011121314151617181920212223242526272829303132Get.put&lt;S&gt;( // 必备：你想得到保存的类，比如控制器或其他东西。 // 注：&quot;S &quot;意味着它可以是任何类型的类。 S dependency // 可选：当你想要多个相同类型的类时，可以用这个方法。 // 因为你通常使用Get.find&lt;Controller&gt;()来获取一个类。 // 你需要使用标签来告诉你需要哪个实例。 // 必须是唯一的字符串 String tag, // 可选：默认情况下，get会在实例不再使用后进行销毁 // （例如：一个已经销毁的视图的Controller) // 但你可能需要这个实例在整个应用生命周期中保留在那里，就像一个sharedPreferences的实例或其他东西。 //所以你设置这个选项 // 默认值为false bool permanent = false, // 可选：允许你在测试中使用一个抽象类后，用另一个抽象类代替它，然后再进行测试。 // 默认为false bool overrideAbstract = false, // 可选：允许你使用函数而不是依赖（dependency）本身来创建依赖。 // 这个不常用 InstanceBuilderCallback&lt;S&gt; builder,)Get.put&lt;SomeClass&gt;(SomeClass());Get.put&lt;LoginController&gt;(LoginController(), permanent: true);Get.put&lt;ListItemController&gt;(ListItemController, tag: &quot;some unique string&quot;); Get.lazyPut懒加载一个依赖，这样它只有在使用时才会被实例化。 123456789101112131415161718192021222324252627282930Get.lazyPut&lt;S&gt;( // 强制性：当你的类第一次被调用时，将被执行的方法。 InstanceBuilderCallback builder, // 可选：和Get.put()一样，当你想让同一个类有多个不同的实例时，就会用到它。 // 必须是唯一的 String tag, // 可选：类似于 &quot;永久&quot;， // 不同的是，当不使用时，实例会被丢弃，但当再次需要使用时，Get会重新创建实例， // 就像 bindings api 中的 &quot;SmartManagement.keepFactory &quot;一样。 // 默认值为false bool fenix = false )///只有当第一次使用Get.find&lt;ApiMock&gt;时，ApiMock才会被调用。Get.lazyPut&lt;ApiMock&gt;(() =&gt; ApiMock());Get.lazyPut&lt;FirebaseAuth&gt;( () &#123; // ... some logic if needed return FirebaseAuth(); &#125;, tag: Math.random().toString(), fenix: true)Get.lazyPut&lt;Controller&gt;( () =&gt; Controller() ) Get.putAsync12345678910111213141516171819202122Get.putAsync&lt;S&gt;( // 必备：一个将被执行的异步方法，用于实例化你的类。 AsyncInstanceBuilderCallback&lt;S&gt; builder, // 可选：和Get.put()一样，当你想让同一个类有多个不同的实例时，就会用到它。 // 必须是唯一的 String tag, // 可选：与Get.put()相同，当你需要在整个应用程序中保持该实例的生命时使用。 // 默认值为false bool permanent = false)Get.putAsync&lt;SharedPreferences&gt;(() async &#123; final prefs = await SharedPreferences.getInstance(); await prefs.setInt(&#x27;counter&#x27;, 12345); return prefs;&#125;);Get.putAsync&lt;YourAsyncClass&gt;( () async =&gt; await YourAsyncClass() ) Get.create1234567891011121314151617181920Get.create&lt;S&gt;( // 需要：一个返回每次调用&quot;Get.find() &quot;都会被新建的类的函数。 // 示例: Get.create&lt;YourClass&gt;(()=&gt;YourClass()) FcBuilderFunc&lt;S&gt; builder, // 可选：就像Get.put()一样，但当你需要多个同类的实例时，会用到它。 // 当你有一个列表，每个项目都需要自己的控制器时，这很有用。 // 需要是一个唯一的字符串。只要把标签改成名字 String name, // 可选：就像 Get.put() 一样， // 它是为了当你需要在整个应用中保活实例的时候 // 区别在于 Get.create 的 permanent默认为true bool permanent = true)Get.Create&lt;SomeClass&gt;(() =&gt; SomeClass());Get.Create&lt;LoginController&gt;(() =&gt; LoginController()); 使用12345678final controller = Get.find&lt;Controller&gt;();// 或者Controller controller = Get.find();Get.delete&lt;Controller&gt;(); //通常你不需要这样做，因为GetX已经删除了未使用的控制器。 BindingsBindings使得Get可以知道当使用某个控制器时，哪个页面正在显示，并知道在哪里以及如何销毁它。 此外，Binding类将允许你拥有SmartManager配置控制。你可以配置依赖关系，当从堆栈中删除一个路由时，或者当使用它的widget被布置时，或者两者都不布置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//使用BindingsBuilder创建getPages: [ GetPage( name: &#x27;/&#x27;, page: () =&gt; HomeView(), binding: BindingsBuilder(() &#123; Get.lazyPut&lt;ControllerX&gt;(() =&gt; ControllerX()); Get.put&lt;Service&gt;(()=&gt; Api()); &#125;), ), GetPage( name: &#x27;/details&#x27;, page: () =&gt; DetailsView(), binding: BindingsBuilder(() &#123; Get.lazyPut&lt;DetailsController&gt;(() =&gt; DetailsController()); &#125;), ),];//自定义Bindings类class HomeBinding implements Bindings &#123; @override void dependencies() &#123; Get.lazyPut&lt;HomeController&gt;(() =&gt; HomeController()); Get.put&lt;Service&gt;(()=&gt; Api()); &#125;&#125;class DetailsBinding implements Bindings &#123; @override void dependencies() &#123; Get.lazyPut&lt;DetailsController&gt;(() =&gt; DetailsController()); &#125;&#125;getPages: [ GetPage( name: &#x27;/&#x27;, page: () =&gt; HomeView(), binding: HomeBinding(), ), GetPage( name: &#x27;/details&#x27;, page: () =&gt; DetailsView(), binding: DetailsBinding(), ),];Get.to(Home(), binding: HomeBinding());Get.to(DetailsView(), binding: DetailsBinding()) 智能管理GetX 默认情况下会将未使用的控制器从内存中移除。 但是如果你想改变GetX控制类的销毁方式，你可以用SmartManagement类设置不同的行为。 12345678void main () &#123; runApp( GetMaterialApp( smartManagement: SmartManagement.onlyBuilders //这里 home: Home(), ) )&#125; SmartManagement.full 这是默认的。销毁那些没有被使用的、没有被设置为永久的类。在大多数情况下，你会希望保持这个配置不受影响。如果你是第一次使用GetX，那么不要改变这个配置。 SmartManagement.onlyBuilders 使用该选项，只有在init:中启动的控制器或用Get.lazyPut()加载到Binding中的控制器才会被销毁。 如果你使用Get.put()或Get.putAsync()或任何其他方法，SmartManagement将没有权限移除这个依赖。 在默认行为下，即使是用 “Get.put “实例化的widget也会被移除，这与SmartManagement.onlyBuilders不同。 SmartManagement.keepFactory 就像SmartManagement.full一样，当它不再被使用时，它将删除它的依赖关系，但它将保留它们的工厂，这意味着如果你再次需要该实例，它将重新创建该依赖关系。 国际化翻译翻译被保存为一个简单的键值字典映射。 要添加自定义翻译，请创建一个类并扩展翻译 12345678910111213141516import &#x27;package:get/get.dart&#x27;;class Messages extends Translations &#123; @override Map&lt;String, Map&lt;String, String&gt;&gt; get keys =&gt; &#123; &#x27;zh_CN&#x27;: &#123; &#x27;hello&#x27;: &#x27;你好 世界&#x27;, &#125;, &#x27;de_DE&#x27;: &#123; &#x27;hello&#x27;: &#x27;Hallo Welt&#x27;, &#125; &#125;;&#125; 使用翻译123456789101112131415161718//传递参数给GetMaterialApp来定义语言和翻译。return GetMaterialApp( translations: Messages(), // 你的翻译 locale: Locale(&#x27;zh&#x27;, &#x27;CN&#x27;), // 将会按照此处指定的语言翻译，ui.window.locale表示系统设置的语言 fallbackLocale: Locale(&#x27;en&#x27;, &#x27;US&#x27;), // 添加一个回调语言选项，以备上面指定的语言翻译不存在);//使用翻译//只要将.tr追加到指定的键上，就会使用Get.locale和Get.fallbackLocale的当前值进行翻译。Text(&#x27;title&#x27;.tr);//调用Get.updateLocale(locale)来更新语言环境。然后翻译会自动使用新的locale。var locale = Locale(&#x27;en&#x27;, &#x27;US&#x27;);Get.updateLocale(locale); 改变主题123Get.changeTheme(ThemeData.light()); 其他API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 给出当前页面的args。Get.arguments//给出以前的路由名称Get.previousRoute// 给出要访问的原始路由，例如，rawRoute.isFirst()Get.rawRoute// 允许从GetObserver访问Rounting API。Get.routing// 检查 snackbar 是否打开Get.isSnackbarOpen// 检查 dialog 是否打开Get.isDialogOpen// 检查 bottomsheet 是否打开Get.isBottomSheetOpen// 删除一个路由。Get.removeRoute()//反复返回，直到表达式返回真。Get.until()// 转到下一条路由，并删除所有之前的路由，直到表达式返回true。Get.offUntil()// 转到下一个命名的路由，并删除所有之前的路由，直到表达式返回true。Get.offNamedUntil()//检查应用程序在哪个平台上运行。GetPlatform.isAndroidGetPlatform.isIOSGetPlatform.isMacOSGetPlatform.isWindowsGetPlatform.isLinuxGetPlatform.isFuchsia//检查设备类型GetPlatform.isMobileGetPlatform.isDesktop//所有平台都是独立支持web的!//你可以知道你是否在浏览器内运行。//在Windows、iOS、OSX、Android等系统上。GetPlatform.isWeb// 相当于.MediaQuery.of(context).size.height,//但不可改变。Get.heightGet.width// 提供当前上下文。Get.context// 在你的代码中的任何地方，在前台提供 snackbar/dialog/bottomsheet 的上下文。Get.contextOverlay// 注意：以下方法是对上下文的扩展。// 因为在你的UI的任何地方都可以访问上下文，你可以在UI代码的任何地方使用它。// 如果你需要一个可改变的高度/宽度（如桌面或浏览器窗口可以缩放），你将需要使用上下文。context.widthcontext.height// 让您可以定义一半的页面、三分之一的页面等。// 对响应式应用很有用。// 参数： dividedBy (double) 可选 - 默认值：1// 参数： reducedBy (double) 可选 - 默认值：0。context.heightTransformer()context.widthTransformer()/// 类似于 MediaQuery.of(context).size。context.mediaQuerySize()/// 类似于 MediaQuery.of(context).padding。context.mediaQueryPadding()/// 类似于 MediaQuery.of(context).viewPadding。context.mediaQueryViewPadding()/// 类似于 MediaQuery.of(context).viewInsets。context.mediaQueryViewInsets()/// 类似于 MediaQuery.of(context).orientation;context.orientation()///检查设备是否处于横向模式context.isLandscape()///检查设备是否处于纵向模式。context.isPortrait()///类似于MediaQuery.of(context).devicePixelRatio。context.devicePixelRatio()///类似于MediaQuery.of(context).textScaleFactor。context.textScaleFactor()///查询设备最短边。context.mediaQueryShortestSide()///如果宽度大于800，则为真。context.showNavbar()///如果最短边小于600p，则为真。context.isPhone()///如果最短边大于600p，则为真。context.isSmallTablet()///如果最短边大于720p，则为真。context.isLargeTablet()///如果当前设备是平板电脑，则为真context.isTablet()///根据页面大小返回一个值&lt;T&gt;。///可以给值为：///watch：如果最短边小于300///mobile：如果最短边小于600///tablet：如果最短边（shortestSide）小于1200///desktop：如果宽度大于1200context.responsiveValue&lt;T&gt;() 局部状态组件GetView它是一个对已注册的Controller有一个名为controller的getter的const Stateless的Widget 1234567891011121314class AwesomeController extends GetxController &#123; final String title = &#x27;My Awesome View&#x27;; &#125; // 一定要记住传递你用来注册控制器的`Type`! class AwesomeView extends GetView&lt;AwesomeController&gt; &#123; @override Widget build(BuildContext context) &#123; return Container( padding: EdgeInsets.all(20), child: Text( controller.title ), // 只需调用 &quot;controller.something&quot;。 ); &#125; &#125; GetWidgetGetxService整个生命周期都存在 12345678910111213141516171819202122232425262728293031323334Future&lt;void&gt; main() async &#123; await initServices(); /// 等待服务初始化. runApp(SomeApp());&#125;/// 在你运行Flutter应用之前，让你的服务初始化是一个明智之举。////因为你可以控制执行流程（也许你需要加载一些主题配置，apiKey，由用户自定义的语言等，所以在运行ApiService之前加载SettingService。///所以GetMaterialApp()不需要重建，可以直接取值。void initServices() async &#123; print(&#x27;starting services ...&#x27;); ///这里是你放get_storage、hive、shared_pref初始化的地方。 ///或者moor连接，或者其他什么异步的东西。 await Get.putAsync(() =&gt; DbService().init()); await Get.putAsync(SettingsService()).init(); print(&#x27;All services started...&#x27;);&#125;class DbService extends GetxService &#123; Future&lt;DbService&gt; init() async &#123; print(&#x27;$runtimeType delays 2 sec&#x27;); await 2.delay(); print(&#x27;$runtimeType ready!&#x27;); return this; &#125;&#125;class SettingsService extends GetxService &#123; void init() async &#123; print(&#x27;$runtimeType delays 1 sec&#x27;); await 1.delay(); print(&#x27;$runtimeType ready!&#x27;); &#125;&#125; 参考 中文官方文档","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"SliverPersistentHeader","date":"2022-03-08T02:25:29.664Z","path":"wiki/Flutter/UI/标准库/widgets/sliver_persistent_header/","text":"1234567SliverPersistentHeader(&#123; &#125;);","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"}]},{"title":"media_query","date":"2022-03-08T02:25:29.664Z","path":"wiki/Flutter/UI/标准库/widgets/media_query/","text":"MediaQueryMediaQuery 用于查询解析给定数据的媒体信息（例如，window宽高&#x2F;横竖屏&#x2F;像素密度比等信息）官方提供这个组件让开发者可以获取想要的数据。它主要用于不同尺寸大小设备的适配。 Object &gt; DiagnosticableTree &gt; Widget &gt; ProxyWidget &gt; InheritedWidget &gt; MediaQuery 常用属性data → MediaQueryData：MediaQueryData是MediaQuery.of获取数据的类型。 使用MediaQuery必须要MaterialApp 或者WidgetsApp去包裹我们的Widget，这样才能够提供正常使用它，否则会出现错误。 1234var deviceData = MediaQuery.of(context); // 返回 MediaQueryDatavar width = deviceData.size.width; //返回context所在的窗口宽度var height = deviceData.size.height;//返回context所在的窗口高度 常用方法MediaQueryData1234// 获取MediaQueryData的方式MediaQueryData.fromWindow(WidgetsBinding.instance!.window);MediaQuery.of(context); 常用属性 属性 说明 size 逻辑像素，并不是物理像素，类似于Android中的dp，逻辑像素会在不同大小的手机上显示的大小基本一样，物理像素 &#x3D; size*devicePixelRatio。 devicePixelRatio 单位逻辑像素的物理像素数量，即设备像素比。 textScaleFactor 单位逻辑像素字体像素数，如果设置为1.5则比指定的字体大50%。 platformBrightness 当前设备的亮度模式，比如在Android Pie手机上进入省电模式，所有的App将会使用深色（dark）模式绘制。 viewInsets 被系统遮挡的部分，通常指键盘，弹出键盘，viewInsets.bottom表示键盘的高度。 padding 被系统遮挡的部分，通常指“刘海屏”或者系统状态栏。 viewPadding 被系统遮挡的部分，通常指“刘海屏”或者系统状态栏，此值独立于padding和viewInsets，它们的值从MediaQuery控件边界的边缘开始测量。在移动设备上，通常是全屏。 systemGestureInsets 显示屏边缘上系统“消耗”的区域输入事件，并阻止将这些事件传递给应用。比如在Android Q手势滑动用于页面导航（ios也一样），比如左滑退出当前页面。 physicalDepth 设备的最大深度，类似于三维空间的Z轴。 alwaysUse24HourFormat 是否是24小时制。 accessibleNavigation 用户是否使用诸如TalkBack或VoiceOver之类的辅助功能与应用程序进行交互，用于帮助视力有障碍的人进行使用。 invertColors 是否支持颜色反转。 highContrast 用户是否要求前景与背景之间的对比度高， iOS上，方法是通过“设置”-&gt;“辅助功能”-&gt;“增加对比度”。 此标志仅在运行iOS 13的iOS设备上更新或以上。 disableAnimations 平台是否要求尽可能禁用或减少动画。 boldText 平台是否要求使用粗体。 orientation 是横屏还是竖屏。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"}]},{"title":"text","date":"2022-03-08T02:25:29.664Z","path":"wiki/Flutter/UI/标准库/widgets/text/","text":"TextPainter12","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"}]},{"title":"scroll_view","date":"2022-03-08T02:25:29.664Z","path":"wiki/Flutter/UI/标准库/widgets/scroll_view/","text":"ListView123ListView&#123;itemExtent //强制限制高度&#125; CustomScrollViewslivers 如果不是Sliver家族的Widget，需要使用SliverToBoxAdapter做层包裹 注意点 当列表项高度固定时，使用 SliverFixedExtendList 比 SliverList 具有更高的性能 GridView1234567891011121314GridView.builder( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(//可以直接指定每行（列）显示多少个Item crossAxisCount: 3,//一行的Widget数量 crossAxisSpacing: 5.0, //水平间距 mainAxisSpacing: 5.0, //垂直间距 childAspectRatio: 1.0,//子Widget宽高比例 ), padding: EdgeInsets.all(10.0),//GridView内边距 itemCount: _dataArr.length, // 元素个数 //单元格样式 itemBuilder: (context, index) &#123; return item(_dataArr,index,context); &#125;)","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"}]},{"title":"State","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/State/","text":"概述State表示对应的StatefulElement需要保存的信息。 生命周期 常用属性widget它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 contextStatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext，表示当前widget在widget树中的上下文，每一个widget都会对应一个context对象（因为每一个widget都是widget树上的一个节点）。 常用方法initState当Widget第一次插入到Widget树时会被调用，对于每一个State对象，Flutter framework只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用BuildContext.dependOnInheritedWidgetOfExactType（该方法用于在Widget树上获取离当前widget最近的一个父级InheritFromWidget，关于InheritedWidget我们将在后面章节介绍），原因是在初始化完成后，Widget树中的InheritFromWidget也可能会发生变化，所以正确的做法应该在build()方法或didChangeDependencies()中调用它。 Element.mount—&gt;Element._firstBuild—&gt;Element.rebuild—&gt;state.initState() didChangeDependencies()当State对象的依赖发生变化时会被调用；例如：在之前build() 中包含了一个InheritedWidget，然后在之后的build() 中InheritedWidget发生了变化，那么此时InheritedWidget的子widget的didChangeDependencies()回调都会被调用。典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。 build()：它主要是用于构建Widget子树的，会在如下场景被调用： 在调用initState()之后。 在调用didUpdateWidget()之后。 在调用setState()之后。 在调用didChangeDependencies()之后。 在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。 reassemble()此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。 didUpdateWidget()在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果Widget.canUpdate返回true则会调用此回调。正如之前所述，Widget.canUpdate会在新旧widget的key和runtimeType同时相等时会返回true，也就是说在在新旧widget的key和runtimeType同时相等时didUpdateWidget()就会被调用。 deactivate()当State对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework会将State对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法。 dispose()当State对象从树中被永久移除时调用；通常在此回调中释放资源。 APP生命周期1234567891011121314151617181920212223242526abstract class WidgetsBindingObserver &#123; // 页面 pop Future&lt;bool&gt; didPopRoute() =&gt; Future&lt;bool&gt;.value(false); // 页面 push Future&lt;bool&gt; didPushRoute(String route) =&gt; Future&lt;bool&gt;.value(false); // 系统窗口相关改变回调，如旋转 void didChangeMetrics() &#123; &#125; // 文本缩放系数变化 void didChangeTextScaleFactor() &#123; &#125; // 系统亮度变化 void didChangePlatformBrightness() &#123; &#125; // 本地化语言变化 void didChangeLocales(List&lt;Locale&gt; locale) &#123; &#125; //App 生命周期变化 AppLifecycleState枚举值： resumed：可见的，并能响应用户的输入。 inactive：处在不活动状态，无法处理用户响应。 paused：不可见并不能响应用户的输入，但是在后台继续活动中。 void didChangeAppLifecycleState(AppLifecycleState state) &#123; &#125; // 内存警告回调 void didHaveMemoryPressure() &#123; &#125; //Accessibility 相关特性回调 void didChangeAccessibilityFeatures() &#123;&#125;&#125; 参考 Flutter Widget生命周期详解","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"}]},{"title":"MaterialApp","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/material/MaterialApp/","text":"常用属性GlobalKey navigatorKey类型，导航键 final RouteFactory? onGenerateRoute生成路由的回调函数，当导航的命名路由的时候，会使用这个来生成界面。 final RouteFactory? onUnknownRoute;未知路由 final String? initialRoute;初始路由，默认值为 Window.defaultRouteName。 app运行后进入的初始路由，如果没有设置，则进入home。 final TransitionBuilder? builder;建造者 final String title;在任务管理窗口中所显示的应用名字 final GenerateAppTitle? onGenerateTitle;生成标题 final Color? color;应用的主要颜色值（primary color），也就是安卓任务管理窗口中所显示的应用颜色 final Locale? locale;本地化 final Iterable&lt;LocalizationsDelegate&gt;? localizationsDelegates;本地化委托 final Iterable supportedLocales;支持本地化列表 final Widget? home;应用默认所显示的界面 Widget。 home是默认根路由，也就是’&#x2F;‘ routes是路由表. 如果没有home，那么routes中要有“&#x2F;”路由（Navigator.defaultRouteName） final Map&lt;String, WidgetBuilder&gt;? routes;应用的顶级导航表格 final bool debugShowMaterialGrid;是否显示 纸墨设计 基础布局网格，用来调试 UI 的工具 theme:ThemeData主题设置","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"material","slug":"Flutter/UI/标准库/material","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/material/"}]},{"title":"Scaffold","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/material/Scaffold/","text":"Scaffold是Material Design布局结构的基本实现。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"material","slug":"Flutter/UI/标准库/material","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/material/"}]},{"title":"app_bar","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/material/app_bar/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243AppBar(&#123;Key? key,this.leading, //widget类型，即可任意设计样式，表示左侧leading区域，通常为icon，如返回iconthis.automaticallyImplyLeading = true, // 如果leading!=null，该属性不生效；如果leading==null且为true，左侧leading区域留白；如果leading==null且为false，左侧leading区域扩展给title区域使用this.title,// 如果leading!=null，该属性不生效；如果leading==null且为true，左侧leading区域留白；如果leading==null且为false，左侧leading区域扩展给title区域使用this.actions,// List&lt;Widget&gt;类型，即可任意设计样式，表示右侧actions区域，可放置多个widget，通常为icon，如搜索icon、菜单iconthis.flexibleSpace, //可缩放区域，吸顶后被title挡住this.bottom,//PreferredSizeWidget类型，appbar底部区域，通常为Tab控件this.elevation,//PreferredSizeWidget类型，appbar底部区域，通常为Tab控件this.shadowColor,this.shape, //描边this.backgroundColor,this.foregroundColor,@Deprecated( &#x27;This property is no longer used, please use systemOverlayStyle instead. &#x27; &#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;,)this.brightness,//Brightness类型，表示当前appbar主题是亮或暗色调，有dark和light两个值，可影响系统状态栏的图标颜色this.iconTheme, //IconThemeData类型，可影响包括leading、title、actions中icon的颜色、透明度，及leading中的icon大小。this.actionsIconTheme,@Deprecated( &#x27;This property is no longer used, please use toolbarTextStyle and titleTextStyle instead. &#x27; &#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;,)this.textTheme,// TextTheme类型，文本主题样式，可设置appbar中文本的许多样式，如字体大小、颜色、前景色、背景色等...this.primary = true,//true时，appBar会以系统状态栏高度为间距显示在下方；false时，会和状态栏重叠，相当于全屏显示。this.centerTitle,// boolean 类型，表示标题是否居中显示this.excludeHeaderSemantics = false,this.titleSpacing,this.toolbarOpacity = 1.0,//toolbar区域透明度this.bottomOpacity = 1.0,//bottom区域透明度this.toolbarHeight,this.leadingWidth,@Deprecated( &#x27;This property is obsolete and is false by default. &#x27; &#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;,)this.backwardsCompatibility,this.toolbarTextStyle,this.titleTextStyle,this.systemOverlayStyle,&#125;) 1234567891011121314151617181920212223242526272829303132333435363738SliverAppBar(&#123; //在标题左侧显示的一个控件，在首页通常显示应用的 logo；在其他界面通常显示为返回按钮 this.leading, this.automaticallyImplyLeading = true, this.title, this.actions,//一个 Widget 列表，代表 Toolbar 中所显示的菜单，对于常用的菜单，通常使用 IconButton 来表示；对于不常用的菜单通常使用 PopupMenuButton 来显示为三个点，点击后弹出二级菜单 this.flexibleSpace, this.bottom,//一个 AppBarBottomWidget 对象，用来在 Toolbar 标题下面显示一个Widget。 this.elevation, this.shadowColor, this.forceElevated = false, this.backgroundColor, //APP bar 的颜色 this.foregroundColor, this.brightness, //App bar 的亮度，有白色和黑色两种主题，默认值为 ThemeData.primaryColorBrightness this.iconTheme, this.actionsIconTheme, this.textTheme, this.primary = true,//此应用栏是否显示在屏幕顶部 this.centerTitle,//标题是否居中显示，默认值根据不同的操作系统，显示方式不一样,true居中 false居左 this.excludeHeaderSemantics = false, this.titleSpacing,//标题是否居中显示，默认值根据不同的操作系统，显示方式不一样,true居中 false居左 this.collapsedHeight,//收缩的最小高度 this.expandedHeight,//展开高度 this.floating = false,//是否随着滑动隐藏标题 this.pinned = false,//SliverAppBar收缩到最小高度的时候SliverAppBar是否可见 this.snap = false,//SliverAppBar收缩到最小高度的时候SliverAppBar是否可见。SliverAppBar收缩到最小高度的时候SliverAppBar是否可见 this.stretch = false,//SliverAppBar完全展开后是否可以继续拉伸，注意这个需要外部滑动组件physics的支持（设置BouncingScrollPhysics()，滑动到标界可以继续滑动拥有回弹效果），否则是不会生效的 this.stretchTriggerOffset = 100.0, this.onStretchTrigger, this.shape, this.toolbarHeight = kToolbarHeight, this.leadingWidth, this.backwardsCompatibility, this.toolbarTextStyle, this.titleTextStyle, this.systemOverlayStyle,&#125;); 参考 https://github.com/yechaoa/flutter_sliverappbar","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"material","slug":"Flutter/UI/标准库/material","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/material/"}]},{"title":"tabs","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/material/tabs/","text":"概述TabBar：Tab页的选项组件，默认为水平排列。 TabBarView：Tab页的内容容器，Tab页内容一般处理为随选项卡的改变而改变。 TabController：TabBar和TabBarView的控制器，它是关联这两个组件的桥梁。 TabBarView1234567891011121314151617181920212223242526 const TabBar(&#123; Key? key, required this.tabs,//一系列标签控件 this.controller,//一系列标签控件 this.isScrollable = false,//是否可滚动，默认false this.padding, this.indicatorColor,//是否可滚动，默认false this.automaticIndicatorColorAdjustment = true, this.indicatorWeight = 2.0,//是否可滚动，默认false this.indicatorPadding = EdgeInsets.zero, this.indicator,//是否可滚动，默认false this.indicatorSize,//指示器长短，tab：和tab一样长，label：和标签label 一样长 this.labelColor,//标签颜色 this.labelStyle,//标签颜色 this.labelPadding,//标签颜色 this.unselectedLabelColor,//标签颜色 this.unselectedLabelStyle,//标签颜色 this.dragStartBehavior = DragStartBehavior.start, this.overlayColor, this.mouseCursor, this.enableFeedback, this.onTap, this.physics,indicator, //自定义指示器，比如使用UnderlineTabIndicator &#125;) 如何隐藏指示器 12//设置指示器为没有视图的Widgetindicator: const BoxDecoration(),","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"material","slug":"Flutter/UI/标准库/material","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/material/"}]},{"title":"toggle_buttons","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/material/toggle_buttons/","text":"12345678910111213141516171819202122232425const ToggleButtons(&#123; Key key, @required this.children, @required this.isSelected, this.onPressed, // 点击状态 this.mouseCursor, this.textStyle, // 文本样式 this.constraints, // 宽高最大最小限制 this.color, // 未选中颜色 this.selectedColor, // 选中颜色 this.disabledColor, // 不可选中颜色 this.fillColor, // 填充颜色 this.focusColor, // 有输入焦点时颜色 this.highlightColor, // 选中时高亮颜色 this.hoverColor, // 初始水波纹颜色 this.splashColor, // 选中时水波纹颜色 this.focusNodes, // 接受对应于每个切换按钮焦点列表 this.renderBorder = true, // 是否绘制边框 this.borderColor, // 未选中边框颜色 this.selectedBorderColor, // 选中边框颜色 this.disabledBorderColor, // 不可选中边框颜色 this.borderRadius, // 边框圆角弧度 this.borderWidth, // 边框宽度&#125;)","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"material","slug":"Flutter/UI/标准库/material","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/material/"}]},{"title":"Column、Row","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/widgets/Column、Row/","text":"常用属性MainAxisSize主轴的可用空间大小 min:主轴上可以分配的最小空间，由子元素的布局约束决定 max:主轴上可以分配的最大空间 mainAxisAlignment主轴，对于行，水平是主轴；对于列，竖直是主轴。 假设TextDirection是ltr（文字从左向右读） start: 居左 end：居右 center：居中 spaceBetween:将主轴方向上的空白区域均分，使得children之间的空白区域相等，首尾child都靠近首尾，没有间隙； spaceAround：将主轴方向上的空白区域均分，使得子元素之间的空白区域相等，但是首尾child的空白区域为1&#x2F;2 spaceEvenly：将主轴方向上的空白区域均分，使得children之间的空白区域相等，包括首尾child； crossAxisAlignment交叉轴，对于行，竖直方向是交叉轴；对于列，水平方向是交叉轴。 假设VerticalDirection是down start: 居上 end：居下 center：居中 stretch：让children填满竖轴方向 baseline：使得children的baseline对齐，在对齐文字时候比较游泳。尤其是一行中有不同大小的文字，那么可以使用baseline对齐.","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"}]},{"title":"Overlay","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/widgets/Overlay/","text":"概述Overlay使用Stack的方式添加悬浮层，可以实现类似toast的效果。 参考 Flutter：使用Overlay展示浮动的widget Flutter Overlay 用法简介","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"}]},{"title":"async","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/widgets/async/","text":"FutureBuilder1234567891011FutureBuilder(&#123; this.future, //通常是一个异步耗时任务 this.initialData,//初始数据 required this.builder,//Widget构造器，该builder会在Future执行的不同阶段被调用多次&#125;)final AsyncWidgetBuilder&lt;T&gt; builder;//snapshot包含当前异步任务的状态信息及结果typedef AsyncWidgetBuilder&lt;T&gt; = Widget Function(BuildContext context, AsyncSnapshot&lt;T&gt; snapshot); 实例12345678910111213141516171819202122232425262728293031323334353637383940Widget build(BuildContext context) &#123; return Center( child: FutureBuilder&lt;String&gt;( future: mockNetworkData(), builder: (BuildContext context, AsyncSnapshot snapshot) &#123; // 请求已结束 if (snapshot.connectionState == ConnectionState.done) &#123; if (snapshot.hasError) &#123; // 请求失败，显示错误 return Text(&quot;Error: $&#123;snapshot.error&#125;&quot;); &#125; else &#123; // 请求成功，显示数据 return Text(&quot;Contents: $&#123;snapshot.data&#125;&quot;); &#125; &#125; else &#123; // 请求未结束，显示loading return CircularProgressIndicator(); &#125; &#125;, ), );&#125;enum ConnectionState &#123; /// 当前没有异步任务，比如[FutureBuilder]的[future]为null时 none, /// 异步任务处于等待状态 waiting, /// Stream处于激活状态（流上已经有数据传递了），对于FutureBuilder没有该状态。 active, /// 异步任务已经终止. done,&#125; StreamBuilderDart中，Stream也是用于异步事件数据，和Future不同的是，它可以接收多个异步操作的结果。 StreamBuilder正式用于配合Stream来展示流上事件（数据）变化的UI组件。 12345StreamBuilder(&#123; this.initialData, Stream&lt;T&gt; stream, required this.builder,&#125;) 参考 如何使用 FutureBuilder and StreamBuilder 优雅的构建高质量项目 https://book.flutterchina.club/chapter7/futurebuilder_and_streambuilder.html","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"}]},{"title":"Key、ValueKey、ObjectKey、UniqueKey、PageStorageKey、GlobalKey","date":"2022-03-08T02:25:29.663Z","path":"wiki/Flutter/UI/标准库/widgets/framework/Key/","text":"概述Key的分类 ValueKey:以一个值为key。 ObjectKey:以一个对象为key。 UniqueKey:生成唯一的随机数作为key。 PageStorageKey:专用于存储页面滚动位置的key。 GlobalKey:整个应用内唯一的key。 参考","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"},{"name":"framework","slug":"Flutter/UI/标准库/widgets/framework","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/framework/"}]},{"title":"Flutter插件","date":"2022-03-08T02:25:29.662Z","path":"wiki/Flutter/Flutter插件/","text":"Flutter只是一个UI框架，运行在宿主平台上，Flutter本身无法提供一些系统能力，比如蓝牙、相机、GPS等。插件是一种特殊的包，和纯dart包的主要区别是插件中除了dart代码，还包括特定平台的代码。 插件实现原理Flutter提供了平台通道（platform channel）用于Flutter和原生平台的通信，通信本质上是一个远程调用（RPC），通过消息传递实现： 应用的Flutter部分通过平台通道将调用消息发送到宿主 宿主监听平台通道，并接收改消息。然后调用平台API，并将响应发送回Flutter","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"Flutter项目结构","date":"2022-03-08T02:25:29.662Z","path":"wiki/Flutter/Flutter项目结构/","text":"文件夹目录最基础的helloworld项目结构如下： .dart_tool：记录了一些dart工具库所在的位置和信息 .idea：android studio 是基于idea开发的，.idea 记录了项目的一些文件的变更记录 android：Android项目文件夹 ios：iOS项目文件夹 lib：lib文件夹内存放我们的dart代码 test：用于存放我们的测试代码 web：网页项目文件夹 fuchsia：fuchsia项目文件夹 .gitignore：git忽略配置文件 .metadata：IDE 用来记录某个 Flutter 项目属性的的隐藏文件 .packages：pub 工具需要使用的，包含 package 依赖的 yaml 格式的文件 flutter_app.iml： 工程文件的本地路径配置 pubspec.lock：当前项目依赖所生成的文件 pubspec.yaml： 当前项目的一些配置文件，包括依赖的第三方库、图片资源文件等 README.md： READEME文件 pubspec.yaml详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566name: flutter_app #包名，如果发布一个插件到pub.dev，则该属性会作为标题出现description: A new Flutter application. # 项目的介绍publish_to: &#x27;none&#x27; # 是否发布到dev.pub，发布命令flutter pub publish version: 1.0.0+1 # 版本号，version number + build number，在 Android 中 version number 对应 versionName，build number 对应 versionCode# Flutter 和 Dart 版本控制environment: sdk: &quot;&gt;=2.7.0 &lt;3.0.0&quot;# 依赖的库配置，所有的库会编译到项目中# 依赖库的写法有以下几种：# # 1. 依赖 pub.dev 上的第三方库: path_provider: ^1.6.22# 2. 依赖本地库:# flutter_package:# path: ../flutter_package# 3. 依赖 git repository:# bloc:# git:# url: https://github.com/felangel/bloc.git# ref: bloc_fixes_issue_110# path: packages/bloc //pub 会默认假定 package 位于 Git 仓库的根目录。如果不是这种情况，你可以使用 path 参数指定位置# 4. 依赖我们自己的 pub仓库:# bloc: # hosted:# name: bloc# url: http://your-package-server.com# version: ^6.0.0#dependencies: flutter: sdk: flutter# 版本的写法# x.y.z 指定具体版本号# &lt;=x.y.z 或者&lt;x.y.z 小于或者小于等于此版本的包# &gt;=a.b.c &lt;x.y.z 指定版本区间，# ^x.y.z 表示大版本不变，小版本使用最新的版本 cupertino_icons: ^1.0.0# 仅仅是运行期间的依赖库dev_dependencies: flutter_test: sdk: flutter# flutter相关的配置选项。flutter: uses-material-design: true # 资源文件设置 assets: - images/# 字体配置 fonts: - family: Schyler fonts: - asset: fonts/Schyler-Regular.ttf - asset: fonts/Schyler-Italic.ttf style: italic - family: Trajan Pro fonts: - asset: fonts/TrajanPro.ttf - asset: fonts/TrajanPro_Bold.ttf weight: 700 包依赖方式1234567891011// 本地依赖dependencies: pkg1: path: ../../code/pkg1 // 依赖github地址dependencies: pkg1: git: url: git://github.com/xxx/pkg1.git path: packages/package1 //path参数指定相对位置 资源管理1234flutter: assets: - assets/my_icon.png - assets/background.png assets指定应包含在应用程序中的文件， 每个asset都通过相对于pubspec.yaml文件所在的文件系统路径来标识自身的路径。asset的声明顺序是无关紧要的，asset的实际目录可以是任意文件夹（在本示例中是assets文件夹）。 Dart项目结构写Dart也可按照Android的MVVM思想来划分文件夹结构 lib api：网络库 base：基础组件 data：数据model model：网络请求数据的封装，方便跟后端映射 utils：工具类 view：视图文件夹 viewmodel：vm层 参考 https://www.dartlang.org/tools/pub/dependencies The pubspec file","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"AppBar","date":"2022-03-08T02:25:29.662Z","path":"wiki/Flutter/UI/标准库/material/AppBar/","text":"概述AppBar（应用栏）由一个工具栏和其他小部件组成，应用栏通常使用IconButton公开一个或多个操作，使用PopMenuButton作为点击后展开的菜单。 AppBar通常用于Scaffold.appBar属性，它将应用栏固定高度的小部件放置在屏幕顶部。对于可滚动的应用栏，则使用SliverAppBar，它将AppBar嵌入到sliver中。 常用属性 leading → Widget - 在标题前面显示的一个控件，在首页通常显示应用的 logo；在其他界面通常显示为返回按钮。 automaticallyImplyLeading： 隐藏leading title → Widget - Toolbar 中主要内容，通常显示为当前界面的标题文字。 actions → List - 一个 Widget 列表，代表 Toolbar 中所显示的菜单，对于常用的菜单，通常使用 IconButton 来表示；对于不常用的菜单通常使用 PopupMenuButton 来显示为三个点，点击后弹出二级菜单。 bottom → PreferredSizeWidget - 一个 AppBarBottomWidget 对象，通常是 TabBar。用来在 Toolbar 标题下面显示一个 Tab 导航栏。 elevation → double - 控件的 z 坐标顺序，默认值为 4，对于可滚动的 SliverAppBar，当 SliverAppBar 和内容同级的时候，该值为 0， 当内容滚动 SliverAppBar 变为 Toolbar 的时候，修改 elevation 的值。 flexibleSpace → Widget - 一个显示在 AppBar 下方的控件，高度和 AppBar 高度一样，可以实现一些特殊的效果，该属性通常在 SliverAppBar 中使用。 backgroundColor → Color - Appbar 的颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用。 brightness → Brightness - Appbar 的亮度，有白色和黑色两种主题，默认值为 ThemeData.primaryColorBrightness。 iconTheme → IconThemeData - Appbar 上图标的颜色、透明度、和尺寸信息。默认值为 ThemeData.primaryIconTheme。 textTheme → TextTheme - Appbar 上的文字样式。 centerTitle → bool - 标题是否居中显示，默认值根据不同的操作系统，显示方式不一样。 toolbarOpacity → double 范例12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 返回每个隐藏的菜单项SelectView(IconData icon, String text, String id) &#123; return new PopupMenuItem&lt;String&gt;( value: id, child: new Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: &lt;Widget&gt;[ new Icon(icon, color: Colors.blue), new Text(text), ], ) );&#125;appBar: new AppBar( title: new Text(&#x27;首页&#x27;), leading: new Icon(Icons.home), backgroundColor: Colors.blue, centerTitle: true, actions: &lt;Widget&gt;[ // 非隐藏的菜单 new IconButton( icon: new Icon(Icons.add_alarm), tooltip: &#x27;Add Alarm&#x27;, onPressed: () &#123;&#125; ), // 隐藏的菜单 new PopupMenuButton&lt;String&gt;( itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuItem&lt;String&gt;&gt;[ this.SelectView(Icons.message, &#x27;发起群聊&#x27;, &#x27;A&#x27;), this.SelectView(Icons.group_add, &#x27;添加服务&#x27;, &#x27;B&#x27;), this.SelectView(Icons.cast_connected, &#x27;扫一扫码&#x27;, &#x27;C&#x27;), ], onSelected: (String action) &#123; // 点击选项的时候 switch (action) &#123; case &#x27;A&#x27;: break; case &#x27;B&#x27;: break; case &#x27;C&#x27;: break; &#125; &#125;, ), ],), 参考 Flutter AppBar（顶端栏） https://api.flutter.dev/flutter/material/AppBar-class.html","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"material","slug":"Flutter/UI/标准库/material","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/material/"}]},{"title":"Flutter体系","date":"2022-03-08T02:25:29.658Z","path":"wiki/Flutter/Flutter体系/","text":"概述 Flutter架构最核心的便是Framework（框架）和Engine（引擎）： Flutter Framework层：用Dart编写，封装整个Flutter架构的核心功能，包括Widget、动画、绘制、手势等功能，有Material（Android风格UI）和Cupertino（iOS风格）的UI界面， 可构建Widget控件以及实现UI布局。 Flutter Engine层：用C++编写，用于高质量移动应用的轻量级运行时环境，实现了Flutter的核心库，包括Dart虚拟机、动画和图形、文字渲染、通信通道、事件通知、插件架构等。引擎渲染采用的是2D图形渲染库Skia，虚拟机采用的是面向对象语言Dart VM，并将它们托管到Flutter的嵌入层。shell实现了平台相关的代码，比如跟屏幕键盘IME和系统应用生命周期事件的交互。不同平台有不同的shell，比如Android和iOS的shell。 编译产物 Flutter产物分为Dart业务代码和Engine代码各自生成的产物，图中的Dart Code包含开发者编写的业务代码，Engine Code是引擎代码，如果并没有定制化引擎，则无需重新编译引擎代码。 一份Dart代码，可编译生成双端产物，实现跨平台的能力。经过编译工具处理后可生成双端产物，图中便是release模式的编译产物，Android产物是由vm、isolate各自的指令段和数据段以及flutter.jar组成的app.apk，iOS产物是由App.framework和Flutter.framework组成的Runner.app。 这个过程涉及frontend_server、gen_snapshot、xcrun、ninja编译工具。frontend_server前端编译器会进行词法分析、语法分析以及相关全局转换等工作，将dart代码转换为AST(抽象语法树)，并生成app.dill格式的dart kernel。gen_snapshot经过CHA、内联等一系列执行流的优化，根据中间代码生成优化后的FlowGraph对象，再转换为具体相应系统架构（arm&#x2F;arm64等）的二进制指令。 启动引擎 FlutterApplication.java的onCreate过程主要完成初始化配置、加载引擎libflutter.so、注册JNI方法； FlutterActivity.java的onCreate过程，通过FlutterJNI的AttachJNI()方法来初始化引擎Engine、Dart虚拟机、Isolate、taskRunner等对象。再经过层层处理最终调用main.dart中main()方法，执行runApp(Widget app)来处理整个Dart业务代码。 Flutter引擎启动中会创建有4个TaskRunner以及创建虚拟机，分别来看看它们的工作原理。 TaskRunner工作原理 Flutter引擎启动过程，会创建UI&#x2F;GPU&#x2F;IO这3个线程，会为这些线程依次创建MessageLoop对象，启动后处于epoll_wait等待状态。对于Flutter的消息机制跟Android原生的消息机制有很多相似之处，都有消息(或者任务)、消息队列(或任务队列)以及Looper；有一点不同的是Android有一个Handler类，用于发送消息以及执行回调方法，相对应Flutter中有着相近功能的便是TaskRunner。 上图是从源码中提炼而来的任务处理流程，比官方流程图更容易理解一些复杂流程的时序问题，后续会专门讲解个中原由。Flutter的任务队列处理机制跟Android的消息队列处理相通，只不过Flutter分为Task和MicroTask两种类型，引擎和Dart虚拟机的事件以及Future都属于Task，Dart层执行scheduleMicrotask()所产生的属于Microtask。 每次Flutter引擎在消费任务时调用FlushTasks()方法，遍历整个延迟任务队列delayed_tasks_，将已到期的任务加入task队列，然后开始处理任务。 检查task，当task队列不为空，先执行一个task； 检查microTask，当microTask不为空，则执行microTask；不断循环Step 2 直到microTask队列为空，再回到执行Step 1； 可简单理解为先处理完所有的Microtask，然后再处理Task。因为scheduleMicrotask()方法的调用自身就处于一个Task，执行完当前的task，也就意味着马上执行该Microtask。 了解了其工作机制，再来看看这4个Task Runner的具体工作内容。 Platform Task Runner：运行在Android或者iOS的主线程，尽管阻塞该线程并不会影响Flutter渲染管道，平台线程建议不要执行耗时操作；否则可能触发watchdog来结束该应用。比如Android、iOS都是使用平台线程来传递用户输入事件，一旦平台线程被阻塞则会引起手势事件丢失。 UI Task Runner: 运行在ui线程，比如1.ui，用于引擎执行root isolate中的所有Dart代码，执行渲染与处理Vsync信号，将widget转换生成Layer Tree。除了渲染之外，还有处理Native Plugins消息、Timers、Microtasks等工作； GPU Task Runner：运行在gpu线程，比如1.gpu，用于将Layer Tree转换为具体GPU指令，执行设备GPU相关的skia调用，转换相应平台的绘制方式，比如OpenGL, vulkan, metal等。每一帧的绘制需要UI Runner和GPU Runner配合完成，任何一个环节延迟都可能导致掉帧； IO Task Runner：运行在io线程，比如1.io，前3个Task Runner都不允许执行耗时操作，该Runner用于将图片从磁盘读取出来，解压转换为GPU可识别的格式后，再上传给GPU线程。为了能访问GPU，IO Runner跟GPU Runner的Context在同一个ShareGroup。比如ui.image通过异步调用让IO Runner来异步加载图片，该线程不能执行其他耗时操作，否则可能会影响图片加载的性能。 虚拟机工作Flutter引擎启动会创建Dart虚拟机以及Root Isolate。DartVM自身也拥有自己的Isolate，完全由虚拟机自己管理的，Flutter引擎也无法直接访问。Dart的UI相关操作，是由Root Isolate通过Dart的C++调用，或者是发送消息通知的方式，将UI渲染相关的任务提交到UIRunner执行，这样就可以跟Flutter引擎相关模块进行交互。 何为Isolate，从字面上理解是“隔离”，isolate之间是逻辑隔离的。Isolate中的代码也是按顺序执行，因为Dart没有共享内存的并发，没有竞争的可能性，故不需要加锁，也没有死锁风险。对于Dart程序的并发则需要依赖多个isolate来实现。 isolate是Dart对actor并发模式的实现。运行中的Dart程序由一个或多个actor组成，这些actor也就是Dart概念里面的isolate。isolate是有自己的内存和单线程控制的运行实体。isolate本身的意思是“隔离”，因为isolate之间的内存在逻辑上是隔离的。isolate中的代码是按顺序执行的，任何Dart程序的并发都是运行多个isolate的结果。 由于isolate之间没有共享内存，所以他们之间的通信唯一方式只能是通过Port进行，而且Dart中的消息传递总是异步的。 isolate堆是运该isolate中代码分配的所有对象的GC管理的内存存储； vm isolate是一个伪isolate，里面包含不可变对象，比如null，true，false； isolate堆能引用vm isolate堆中的对象，但vm isolate不能引用isolate堆； isolate彼此之间不能相互引用； 每个isolate都有一个执行dart代码的Mutator thread，一个处理虚拟机内部任务(比如GC, JIT等)的helper thread； 可见，isolate是拥有内存堆和控制线程，虚拟机中可以有很多isolate，但彼此之间内存不共享，无法直接访问，只能通过dart特有的Port端口通信；isolate除了拥有一个mutator控制线程，还有一些其他辅助线程，比如后台JIT编译线程、GC清理&#x2F;并发标记线程； 架构概览 Widget是所有Flutter应用程序的基石，Widget可以是一个按钮，一种字体或者颜色，一个布局属性等，在Flutter的UI世界可谓是“万物皆Widget”。常见的Widget子类为StatelessWidget(无状态)和StatefulWidget(有状态)； StatelessWidget：内部没有保存状态，UI界面创建后不会发生改变； StatefulWidget：内部有保存状态，当状态发生改变，调用setState()方法会触发StatefulWidget的UI发生更新，对于自定义继承自StatefulWidget的子类，必须要重写createState()方法。 三棵树 Widget是为Element描述需要的配置， 负责创建Element，决定Element是否需要更新。Flutter Framework通过差分算法比对Widget树前后的变化，决定Element的State是否改变。当重建Widget树后并未发生改变， 则Element不会触发重绘，否则就是Widget树的重建并不一定会触发Element树的重建。 Element表示Widget配置树的特定位置的一个实例，同时持有Widget和RenderObject，负责管理Widget配置和RenderObject渲染。Element状态由Flutter Framework管理， 开发人员只需更改Widget即可。 RenderObject表示渲染树的一个对象，负责真正的渲染工作，比如测量大小、位置、绘制等都由RenderObject完成。 渲染原理 渲染过程，UI线程完成布局、绘制操作，生成Layer Tree；GPU线程执行合成并光栅化后交给GPU来处理，其中几个关键步骤： Animate: 遍历_transientCallbacks，执行动画回调方法； Build: 对于dirty的元素会执行build构造，没有dirty元素则不会执行，对应于buildScope() Layout: 计算渲染对象的大小和位置，对应于flushLayout()，这个过程可能会嵌套再调用build操作； Compositing bits: 更新具有脏合成位的任何渲染对象， 对应于flushCompositingBits()； Paint: 将绘制命令记录到Layer， 对应于flushPaint()； Compositing: 将Compositing bits发送给GPU， 对应于compositeFrame()； GPU线程通过skia向GPU硬件绘制一帧的数据，GPU将帧信息保存到FrameBuffer里面，然后视频控制器会根据VSync信号从FrameBuffer取帧数据传递给显示器，从而显示出最终的画面。 Platform Channels Flutter框架提供了UI的控件支持，对于APP除了UI还有其他依赖于Native平台的支持，比如调用Camera的功能，该怎么办呢？为此，Flutter通过提供Platform Channel的功能，使得Dart代码具备与Native交互的能力。 Platform Channel用于Flutter与Native之间的消息传递，整个过程的消息与响应是异步执行，不会阻塞用户界面。Flutter引擎框架已完成桥接的通道，这样开发者只需在Native层编写定制的Android&#x2F;iOS代码，即可在Dart代码中直接调用，这也就是Flutter Plugin插件的一种形式。 Engine环境搭建 官方文档 https://github.com/flutter/flutter/wiki/Compiling-the-engine https://github.com/flutter/flutter/wiki/The-flutter-tool 源码目录结构 flutter 根目录 packages： flutter： lib： src：标准库的源码文件夹 animation：动画库 cupertino：iOS风格UI库 foundation：基础 gestures：手势识别 material：Android风格UI库 painting：自绘 physics：移动的物理效果，Android、iOS不一样 rendering：渲染相关 scheduler：调度相关，底层传入数据给到Flutter进行操作 semantics：语义化的东西？ services widgets：UI库 flutter_driver: flutter_goldens: flutter_goldens_client: flutter_localizations:国际化相关 flutter_test: flutter_tools: flutter_web_plugins: fuchsia_remote_debug_protocol: integration_test: bin: internal cache: artifacts: engine: android-arm: android-arm64: android-arm64-profile: android-arm64-release: android-arm-profile: android-arm-release: android-x64: android-x64-profile: android-x86: android-x86-jit-release: common: windows-x64: gradle_wrapper: ios-deploy: libimobiledevice: libplist: material_fonts: openssl: usbmuxd: dart-sdk: downloads: flutter_web_sdk: pkg: sky_engine: mingit: cmd etc mingw64 usr dart：dart命令 dart.bat flutter:linux相关平台的命令 flutter.bat：windows上的命令 dev:Flutter团队开发框架时用到的工具 automated_tests: benchmarks: bots: ci: conductor: customer_testing: devicelab: docs: forbidden_from_release_tests: integration_tests: manual_tests: missing_dependency_tests: snippets: tools: tracing_tests: examples 参考 Introduction to Dart VM Flutter 跨平台演进及架构开篇 Flutter System Architecture","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"}]},{"title":"Android逆向记录","date":"2022-03-08T02:25:29.655Z","path":"wiki/Android/逆向/Android逆向记录/","text":"12345678910111213#反编译apk文件apktool d app-release.apk如果出现编译assets文件夹中的dex文件失败，则使用--only-main-classes参数。#编译修改后的应用apktool b app-release -o output.apk#对编译好的apk进行签名apksigner sign --ks keystore文件路径 output.apk~/Android/sdk/build-tools/29.0.3/apksigner sign --ks ~/Android/tools/keys/test_keystore lizhi_output.apk 签名参考：https://developer.android.com/studio/command-line/apksigner?hl=zh-cn META-INF文件夹的内容 MINFEST.MF：声明了资源，与CERT.SF文件相似。CERT.RSA：公钥证书。keytool -printcert -file CERT.RSA 输出证书内容 1234567891011所有者: CN=Bbcallen, OU=danmaku.tv, O=danmaku.tv, L=Zhuhai, ST=Guangdong, C=CN发布者: CN=Bbcallen, OU=danmaku.tv, O=danmaku.tv, L=Zhuhai, ST=Guangdong, C=CN序列号: 4f3bb0ec有效期为 Wed Feb 15 21:19:40 CST 2012 至 Thu Nov 18 21:19:40 CST 2066证书指纹: MD5: 71:94:D5:31:CB:E7:96:0A:22:00:7B:9F:6B:DA:A3:8B SHA1: 96:DC:60:5B:95:19:BA:B9:4E:DD:BE:AA:A0:59:A6:69:FB:A2:C2:11 SHA256: 93:BA:27:0F:55:21:13:9E:CA:FE:4B:B6:38:AC:5B:11:98:BC:54:8F:62:D9:FD:8F:85:80:A0:79:FA:F5:91:0E签名算法名称: SHA1withRSA主体公共密钥算法: 1024 位 RSA 密钥版本: 3 CERT.SF：包含了app的所有资源文件，负责对app进行签名， Android Studio动态调试12345678910111213141516171819202122232425262728反编译apk文件，添加debug属性，打包、签名新的可debug的apk。安装。安装Android Studio插件smalideahttps://bitbucket.org/JesusFreke/smali/downloads/使用baksmali反编译apk文件java -jar baksmali -o myapp/src先启动应用，查看主activityadb shell &quot;dumpsys activity top | grep ACTIVITY&quot;然后以debug模式启动appadb shell am start -D -n androiddemo.han.com.myapplication/.MainActivity查看进程adb shell &quot;ps | grep 包名&quot;端口转发adb forward tcp:8787 jdwp:app_pidadb shell am set-debug-app -w --persistent 包名 一直使用debug模式启动应用adb shell am clear-debug-app 取消使用debug启动应用","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://airshu.github.io/categories/Android/%E9%80%86%E5%90%91/"}]},{"title":"JEB使用笔记","date":"2022-03-08T02:25:29.655Z","path":"wiki/Android/逆向/JEB使用笔记/","text":"https://www.pnfsoftware.com/jeb/manual/ 在使用Jeb的时候，关闭Android Studio。 如何debug 对于一个release包，是无法进行debug的，需要apktool进行反编译，自行打包并签名。 command+b：打开关闭断点","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://airshu.github.io/categories/Android/%E9%80%86%E5%90%91/"}]},{"title":"如何提升Android应用的安全","date":"2022-03-08T02:25:29.655Z","path":"wiki/Android/逆向/如何提升Android应用的安全/","text":"权限设置 尽量使用更少的权限，动态获取权限。 release版本中设置日志输出等级 危险代码检测确认代码中是否使用插件化技术，hook技术 源文件安全 Java代码混淆 底层代码加固 密钥等信息是否存在暴露风险 启动时进行签名检查（防止二次打包） 数据存储安全 是否明文存储配置信息 数据库存储的安全 是否暴露不必要的组件，检查exported属性 数据传输安全 是否存在网络数据被拦截的风险 是否使用Https 参考 https://blog.csdn.net/u013107656/category_6257625.html","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://airshu.github.io/categories/Android/%E9%80%86%E5%90%91/"}]},{"title":"Android逆向之Xposed","date":"2022-03-08T02:25:29.654Z","path":"wiki/Android/逆向/Android逆向之Xposed/","text":"Xposed的作用非常强大，以前虽然也大致了解，但没有自己实践过。最近在做其他App分析的时候，发现其限制了模拟器的使用，于是想着逆向破解一下，于是开启了Xposed之旅。 首先阅读下官网，嗯，版本很久没有更新了，后面又出现了”太极”之类的新的工具。就不折腾那么多了，先以快速解决问题为目标。下载雷电模拟器，其版本为Android7.1.2。进入”雷电游戏中心”搜索xposed，下载对应的App，打开后点击安装，重启。 Hello World下一步完成一个最简单的Hello World，网上搜有一大把。总结下： 添加依赖，目前最新的版本为82： 12compileOnly &#x27;de.robv.android.xposed:api:82&#x27;compileOnly &#x27;de.robv.android.xposed:api:82:sources&#x27; 修改AndroidManifest.xml文件，添加相应标识，用于Xposed识别。 1234567891011&lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot; /&gt;&lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;这是一个Xposed例程&quot; /&gt;&lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;53&quot; /&gt; 新建assets文件夹，添加xposed_init文件，添加hook启动入口，文件内容为你的hook类。 添加hook类，实现IXposedHookLoadPackage，实现handleLoadPackage方法。 熟悉API https://api.xposed.info/reference/packages.html 12345/**当App装载的时候会被调用，被调用的非常早，比Application.onCreate还早。*/public abstract void handleLoadPackage (XC_LoadPackage.LoadPackageParam lpparam) xposed工具开发者助手:下载地址：https://github.com/WrBug/DeveloperHelper 可以直接在界面上看到UI的名字，可以查看log Inspeckage：下载地址：https://repo.xposed.info/module/mobi.acpm.inspeckage 在网页上看相关信息：包信息，Shared Preferences，使用了Crypto、Hash的记录，抓包信息等 JustTrustMe：https://github.com/Fuzion24/JustTrustMe UCrack：https://gitee.com/virjar/ucrack 一个基于Xposed写的辅助工具，集成了自动网络抓包、网络堆栈爆破、文件日志、WebView调试环境、自动脱壳、Native函数注册监控、记录程序自杀堆栈等功能。 ReflectMaster（反射大师）：https://github.com/FormatFa/ReflectMaster 可以从当前页面提取dex，对于加壳的App很有用。","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://airshu.github.io/categories/Android/%E9%80%86%E5%90%91/"}]},{"title":"Android逆向之脱壳","date":"2022-03-08T02:25:29.654Z","path":"wiki/Android/逆向/Android逆向之脱壳/","text":"有些App为了安全，会使用相关加壳工具来提高破解难度。但其实意义不大，通过hook，应该是很容易获取内存dump出dex文件的。还记得以前进行flash游戏破解的时候，当时使用一个技巧，通过flash的运行机制，在swf启动的时候将自己写的swfload进来并运行，运行的代码就是将内存中的swf导出来。破解成功的概率非常高。而个人认为，通过代码混淆来增加阅读难度比加壳的作用更有用。 最近看到某款竟品，于是想学习学习，直接放到Jadx中，嗯哼，竟然使用了腾讯乐固。了解了大致破壳的原理，其实就算自己实现也是可行的。不过自己能想到的事情，可能有人早就想到了。搜一搜吧，果然有很多破解工具。有些文章可以参考参考、学习学习： https://crifan.github.io/android_app_security_crack&#x2F;website&#x2F; 我们的目的是为了快速获取dex，阅读源码，所以就不折腾每个工具是怎么实现的了。找到文章说的工具，一个一个试吧。最终发现ReflectMaster可以dump出来dex。使用如下： 安装ReflectMaster，下载地址：https://www.lanzous.com/i6x1kaf 在xposed环境中，安装并激活。 启动对应带壳的App，点击”中间的图标”，点击”当前Activity”，点击”导出dex”。 确认使用腾讯乐固： 导出的dex如下： 参考 https://github.com/FormatFa/ReflectMaster https://www.kanxue.com/chm.htm?id=9948&pid=node1000000 https://blog.csdn.net/qq_41855420&#x2F;article&#x2F;details&#x2F;106276824 https://www.kanxue.com/chm.htm?id=9948&pid=node1000000","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://airshu.github.io/categories/Android/%E9%80%86%E5%90%91/"}]},{"title":"代码混淆","date":"2022-03-08T02:25:29.653Z","path":"wiki/Android/进阶知识/代码混淆/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"保活策略","date":"2022-03-08T02:25:29.653Z","path":"wiki/Android/进阶知识/保活策略/","text":"一个像素的Activity 前台service 进程间唤醒 JobSheduler 1559","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"动态换肤","date":"2022-03-08T02:25:29.653Z","path":"wiki/Android/进阶知识/动态换肤/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"多渠道打包","date":"2022-03-08T02:25:29.653Z","path":"wiki/Android/进阶知识/多渠道打包/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"如何提升编译速度","date":"2022-03-08T02:25:29.653Z","path":"wiki/Android/进阶知识/如何提升编译速度/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"硬件加速","date":"2022-03-08T02:25:29.653Z","path":"wiki/Android/进阶知识/硬件加速/","text":"参考 https://www.mtyun.com/library/hardware-accelerate https://rengwuxian.com/ui-1-8/ 理解Android硬件加速原理的小白文","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"屏幕适配","date":"2022-03-08T02:25:29.653Z","path":"wiki/Android/进阶知识/屏幕适配/","text":"基本概念屏幕尺寸屏幕尺寸指屏幕的对角线的长度，单位是英寸，1英寸&#x3D;2.54厘米 屏幕分辨率屏幕分辨率是指在横纵向上的像素点数，单位是px，1px&#x3D;1个像素点 屏幕像素密度屏幕像素密度是指每英寸上的像素点数 dp、dip、dpi、sp、px dpi：屏幕像素密度 dp&#x2F;dip：Density Independent Pixels的缩写，即密度无关像素 px：物理像素 sp：scale-independent pixels，文字大小使用像素 公式转换 px &#x3D; density * dp; density &#x3D; dpi &#x2F; 160; px &#x3D; dp * (dpi &#x2F; 160); 屏幕尺寸、分辨率、像素密度三者关系 DisplayMetrics中和适配相关的几个变量: DisplayMetrics#density：就是上述的density DisplayMetrics#densityDpi： 就是上述的dpi DisplayMetrics#scaledDensity： 字体的缩放因子，正常情况下和density相等，但是调节系统字体大小后会改变这个值 mdpi、hdpi、xdpi、xxdpi根据不同像素范围来存储的资源文件夹 名称 像素密度范围 代表的分辨率 屏幕密度 换算 比例 mdpi 120dpi~160dpi 320x480 160 hdpi 160dpi~240dpi 480x800 240 1dp&#x3D;1px 4 xhdpi 240dpi~320dpi 720x1280 320 1dp&#x3D;2px 8 xxhdpi 320dpi~480dpi 1080x1920 480 1dp&#x3D;3px 12 xxxhdpi 480dpi~640dpi 适配原理今日头条适配方案12345678910111213141516171819202122232425262728293031DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics();if (sNoncompatDensity == 0) &#123; sNoncompatDensity = appDisplayMetrics.density; sNoncompatDensity = appDisplayMetrics.scaledDensity; application.registerComponentCallbacks(new ComponentCallbacks() &#123; public void onConfigurationChanged(Configuration newConfig) &#123; if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) &#123; //系统字体大小发生变化监听 sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity; &#125; &#125; public void onLowMemory() &#123; &#125; &#125;);&#125;float targetDensity = appDisplayMetrics.widthPixels / 360;//360指设计图原始dp值float targetScaleDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity);int targetDensityDpi = (int) (160 * targetDensity);appDisplayMetrics.density = targetDensity;appDisplayMetrics.scaledDensity = targetScaleDensity;appDisplayMetrics.densityDpi = targetDensityDpi;final DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();activityDisplayMetrics.density = targetDensity;activityDisplayMetrics.scaledDensity = targetScaleDensity;activityDisplayMetrics.densityDpi = targetDensityDpi; 根据设备的实际宽度与设计图的dp值，算出设备的密度和屏幕像素密度。 smallestWidth根据屏幕的最小宽度去寻找对应的配置文件，设置高宽值。可参考：SmallestWidth 限定符适配方案 总结综合各方面考虑，目前觉得AndroidAutoSize这个库比较适合接入到项目中。 参考 https://developer.android.com/guide/practices/screens_support?hl&#x3D;zh-cn https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA http://jessyan.me/autosize-introduce/ https://www.jianshu.com/p/5d4504fc599a?utm_campaign&#x3D;maleskine&amp;utm_content&#x3D;note&amp;utm_medium&#x3D;seo_notes&amp;utm_source&#x3D;recommendation","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"组件化之路","date":"2022-03-08T02:25:29.653Z","path":"wiki/Android/进阶知识/组件化之路/","text":"Android项目架构发展史在说组件化之前，有必要讲讲Android项目的设计发展过程，也有必要讲讲在移动端兴起之前，其他语言是如何做项目架构设计的。 写代码最基础的一个准则就是分层，分层有利于扩展。比如我们的计算机就分为硬件、驱动、系统层、应用层，网络被分为物理层、数据链路层、网络层、传输层、应用层。而写代码中最著名的分层思想就是MVC。MVC模式最早由Trygve Reenskaug在1978年提出，MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式透过对复杂度的简化，使程序结构更加直观。软件系统透过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。 运用MVC，我们会把代码分为视图（View）、模型（Model）、控制器（Controller），不同层也可以向上抽象，比如抽离出通用的视图，达到复用的效果。 Android中，我们是如何进行重构优化的呢？ 封装代码 封装Http请求，使用自己内部的一套接口，具体实现可以是OKHttp，其他库也都做类似封装； 封装BaseActivity、BaseFragment、BaseView，将一些比如uiHandler、模版方法放到基类里；封装通用的UI控件； 封装常用工具方法，比如字符串处理、文件处理、时间处理、线程池等； 模块化 将以上封装的代码放到单独的module，并存储到单独仓库，单独部署到代码中心； 根据业务的不同，划分不同的module，比如分享module、媒体处理module、图片处理module、事件总线module、支付module、IM module等等； 代码分层 MVP：添加一层Presenter，将业务逻辑的操作放到这一层，释放Activity、Fragment中的压力； MVVM：划分层次更细，并基于最新的LiveData等技术，降低了OOM的可能性； 使用Dagger、WMRouter、Hilt等技术实现模块间通讯，主要还是降低模块之间的耦合性； 插件化 进一步解耦不同业务； 降低包体积； 动态更新； 跨端技术 Hybrid：由Native通过JSBridge等方法提供统一的API,然后用Html5+JS来写实际的逻辑； React Native：Facebook发起的开源的一套新的APP开发方案,使用JS+部分原生语法来实现功能； Flutter：Google出品，高性能的跨端方案； 组件化的好处 业务解耦 提高开发效率 提升编译速度 提高代码复用性 如何实现组件化获取不同组件实例对象我们可以把需要暴露出的对象通过接口的方式暴露给其他组件使用，内部通过某种方式建立与接口的联系，当使用时，可以动态创建该对象。行话叫依赖注入。 Dagger、ARouter、WMRouter、Hilt等为我们提供了相关功能，其内部原理类似，基于标注，建立关联关系。当然，里面还有很多需要注意的点，比如有时候需要的单例对象，有时候需要考虑到生命周期。大家可以根据自己的需要选择不同的实现方式。 组件间页面跳转我们要跳转到一个新的页面，一般都是通过startActivity(context, XXXActivity.class)进行跳转的。不同的组件具体实现是不会彼此依赖的，也就是说在A组件中是拿不到B组件的对应Activity的。我们可以采用的方案有： 隐式跳转使用这个方式，需要很多配置，比较麻烦。 接口封装比如，在B组件中，我们提供的接口层，添加一个startHomePage(Params params)方法，A组件中通过接口获取对应实例调用这个方法，这个方法的具体实现在B组件内部。 路由方法ARouter、WMRouter都提供了基于标注的方式，实现的页面跳转。我们只需要在对应Activity的头部进行标注设置，在使用框架提供的工具方法进行跳转即可。这里实现的原理是基于Java的标注解析器，保存相应关系。 参考 Android组件化方案及组件消息总线modular-event实战 使用 Hilt 实现依赖项注入 “终于懂了” 系列：Android组件化，全面掌握！","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"Dalvik、ART虚拟机","date":"2022-03-08T02:25:29.652Z","path":"wiki/Android/进阶知识/Dalvik、ART虚拟机/","text":"概要Dalvik 是 Google 公司自己设计用于 Android 平台的虚拟机。它可以支持已转换为** .dex 格式**的 Java 应用程序的运行，.dex 格式是专为Dalvik 设计的一种压缩格式，适合内存和处理器速度有限的系统。 Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的 Linux 进程执行。独立的进程可以防止在虚拟机 崩溃的时候所有程序都被关闭。 2014 年 6 月 25 日，Android L 正式亮相于召开的谷歌 I&#x2F;O 大会，Android L 改 动幅度较大，谷歌将直接删除 Dalvik，代替它的是传闻已久的 ART。 Dalvik与JVM的区别 Dalvik 是基于寄存器的，而 JVM 是基于栈的。 Dalvik 运行 dex 文件，而 JVM 运行 java 字节码 自 Android 2.2 开始，Dalvik 支持 JIT(just-in-time，即时编译技术)。 ART（Android Runtime）ART 的机制与 Dalvik 不同。在 Dalvik 下，应用每次运行的时候，字节码都需要通过即时编译器(just in time ，JIT)转换为机器码，这会拖慢应用的运行效率，而在 ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码， 使其成为真正的本地应用。这个过程叫做预编译(AOT,Ahead-Of-Time)。这样 的话，应用的启动(首次)和执行都会变得更加快速。 优点 系统性能的显著提升。 应用启动更快、运行更快、体验更流畅、触感反馈更及时。 更长的电池续航能力。 支持更低的硬件。 缺点 机器码占用的存储空间更大，字节码变为机器码之后，可能会增加 10%-20% 应用的安装时间会变长。","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"Framework概要","date":"2022-03-08T02:25:29.652Z","path":"wiki/Android/进阶知识/Framework概要/","text":"概述启动时init进程加载init.rc文件，启动zegote进程，zegote就是app_process进程，app_process进程装在Android的系统Class、装载需要的底层so库，装载相应资源；app_process启动system_server进程，system_server进程中创建了AMS、PMS、WMS。app_process与system_server进程通过socket通讯。 启动一个App时，执行ActivityThread的main方法，初始化Context、Resource、AssetManager等基础设施。运行主线程Looper。 在system_server中会启动以下服务 SystemServiceManagerPowerManagerServiceWebViewUpdateServiceDisplayManagerServiceActivityManagerService管理Activity，在App进程启动时，通过Binder，在ActivityThread中进行Activity的管理。 统一调度所有应用程序的Activity的生命周期 启动或杀死应用程序的进程 启动并调度Service的生命周期 注册BroadcastReceiver，并接收和分发Broadcast 启动并发布ContentProvider 调度task 处理应用程序的Crash 查询系统当前运行状态 PackageManagerService包管理，为了能在运行时快速的打开对应App，启动时会遍历整个app文件夹，解析Android Manifest.xml文件，将相应信息存储起来。 WindowManagerService控制所有Window的显示与隐藏以及要显示的位置，设置成AMS的成员变量 为所有窗口分配Surface。客户端向WMS添加一个窗口的过程，其实就是WMS为其分配一块Suiface的过程，一块块Surface在WMS的管理下有序的排布在屏幕上。Window的本质就是Surface。 管理Surface的显示顺序、尺寸、位置 管理窗口动画 输入系统相关：WMS是派发系统按键和触摸消息的最佳人选，当接收到一个触摸事件，它需要寻找一个最合适的窗口来处理消息，而WMS是窗口的管理者，系统中所有的窗口状态和信息都在其掌握之中，完成这一工作不在话下。 Activity负责生命周期和事件处理 Window控制视图 流程图","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"PackageManagerService工作原理","date":"2022-03-08T02:25:29.652Z","path":"wiki/Android/进阶知识/PackageManagerService工作原理/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"Binder","date":"2022-03-08T02:25:29.649Z","path":"wiki/Android/进阶知识/Binder/","text":"一个进程空间分为: 用户空间：数据不可共享，所以用户空间 &#x3D; 不可共享空间 内核空间：数据可共享，所以内核空间 &#x3D; 可共享空间 Binder 的作用则是:连接两个进程，实现了mmap()系统调用，主要负责创建数据接收的缓存空间 &amp; 管理数据接收缓存。传统的跨进程通信需拷贝数据2次，但 Binder 机制只需1次，主要是使用到了内存映射 Android中IPC的不同方式比较 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件间的进程间通信 文件共享 简单易用 不适合高并发场景，并且无法做到进程间的即时通信 无并发访问场景 AIDL 功能强大，支持一对多并发通信，支持实时通信 无 一对多通信且有RPC需求 Messager 功能一般，支持一对多并发通信，支持实时通信 不能很好处理高并发场景，不支持RPC 低并发的一对多通信，无RPC需求 ContentProvider 在数据源访问方面功能强大 Socket 功能强大 参考 https://www.jianshu.com/p/719fc4758813","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"Android中的ClassLoader","date":"2022-03-08T02:25:29.648Z","path":"wiki/Android/进阶知识/Android中的ClassLoader/","text":"概述 BootClassLoader:主要用于加载系统的类，包括 java 和 android 系统的 类库，和 JVM 中不同，BootClassLoader 是 ClassLoader 内部类，是由 Java 实现的，它也是所有系统 ClassLoader 的父 ClassLoader PathClassLoader:用于加载 Android 系统类和开发编写应用的类，只能加载已经安装应用的 dex 或 apk 文件，也是 getSystemClassLoader 的返回对象 DexClassLoader:可以用于加载任意路径的 zip,jar 或者 apk 文件，也是进行安卓动态加载的基础 继承关系","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"Android测试实践","date":"2022-03-08T02:25:29.647Z","path":"wiki/Android/未分类/Android测试实践/","text":"为什么要做测试？很多公司为了节省成本，基本上是不会要求开发写单元测试的。自己做完的功能，动手点点看看基本流程是否通畅就丢给测试了。项目小的时候这样也不会有啥问题。随着项目的复杂度越来越高，人员越来越多，不同的人员改动到同一块代码，但彼此对原来的逻辑不是很清楚（因为代码量实在太多，想要一个人弄清楚所有细节已经不太可能）。这也是为什么大家宁肯写新的代码也不愿意改旧的代码的原因。而如果每个功能在开发的同时配置了单元测试，那么理论上新的功能 开发完之后，所有的单元测试应该都是可以跑通的。这样就能自动帮我们检查出来一些难以发现的bug。 Android如何进行单元测试 androidTest目录：应包含在实际或虚拟设备上运行的测试。此类测试包括集成测试，端到端测试以及仅JVM无法验证应用程序功能的其他测试。 test目录：应包含在本地计算机上运行的测试，例如单元测试 测试常用库 JUnit Mockito PowerMock Espresso JUnitTestCase TestResult TestSuite 测试套件 在实际项目中，随着项目进度的开展，单元测试类会越来越多，可是直到现在我们还只会一个一个的单独运行测试类，这在实际项目实践中肯定是不可行的。 为了解决这个问题，JUnit 提供了一种批量运行测试类的方法，叫做测试套件。 断言： Assert 标注： 标注 描述 @Test 该方法是一个测试用例 @Before 每个测试方法执行之前执行 @After 每个测试方法执行后执行 @BeforeClass 一个测试文件只执行一次 @AfterClass 一个测试文件最后执行一次 @Ignore 这个注解是用来忽略有关不需要执行的测试的。 Mockito模拟被测对象依赖的对象 参考 https://dunwu.github.io/javatech/test/mockito.html PowerMock模拟被测对象依赖的静态方法 RobolectricAndroid SDK测试框架 Config配置参考 https://maxwell-nc.github.io/android/robolectricTest.html https://www.jianshu.com/p/6c23f2681105 Espresso","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://airshu.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"Android常见问题整理","date":"2022-03-08T02:25:29.647Z","path":"wiki/Android/未分类/Android常见问题整理/","text":"问题描述12345678!SESSION 2017-08-29 15:27:40.107 ----------------------------------------------- eclipse.buildId=unknown java.version=1.8.0_112-release java.vendor=JetBrains s.r.o BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN Command-line arguments: -os win32 -ws win32 -arch x86_64 -data @noDefault... !ENTRY org.eclipse.osgi 4 0 2017-08-29 15:27:41.441 !MESSAGE Application error !STACK 1 java.lang.NullPointerException at org.eclipse.core.runtime.URIUtil.toURI(URIUtil.java:280) at org.eclipse.e4.ui.internal.workbench.ResourceHandler.loadMostRecentModel(ResourceHandler.java:127)... 解决办法 进程管理器中杀死monitor.exe进程； 删除$HOME&#x2F;.android&#x2F;monitor-workspace目录 参考 https://tutel.me/c/programming/questions/26052849/unexpected+error+while+parsing+input+invalid+uiautomator+hierarchy+file 问题描述12345* What went wrong:Execution failed for task &#x27;:app:transformDexArchiveWithExternalLibsDexMergerForDebug&#x27;.&gt; com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives: Program type already present: org.intellij.lang.annotations.Identifier Learn how to resolve the issue at https://developer.android.com/studio/build/dependencies#duplicate_classes. 解决办法android &#123; configurations &#123; cleanedAnnotations compile.exclude group: &#39;org.jetbrains&#39; , module:&#39;annotations&#39; &#125; &#125; 参考 https://stackoverflow.com/questions/49811851/program-type-already-present-org-intellij-lang-annotations-flow 问题描述1Error:Execution failed for task &#x27;:app:javaPreCompilePreProductDebug&#x27;. &gt; Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. 解决办法android &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; includeCompileClasspath true &#125; &#125; &#125; 参考 问题描述1234567FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring project &#x27;:myProject&#x27;.&gt; Could not resolve all files for configuration &#x27;:myProject:classpath&#x27;.&gt; Could not find org.jetbrains.trove4j:trove4j:20160824. Searched in the following locations: 解决办法找不到依赖，添加仓库地址。 buildscript &#123; repositories &#123; google() jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; mavenCentral() &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:3.3.2&#39; &#125; &#125; allprojects &#123; repositories &#123; google() jcenter() mavenCentral() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125; &#125; 参考 https://blog.csdn.net/rooney8/article/details/86065188 问题描述1Android-SDK/ndk-bundle/build/core/add-application.mk:178: ### * Android NDK: APP_STL gnustl_shared is no longer supported. Please switch to either c++_static or c++_shared. See https://developer.android.com/ndk/guides/cpp-support.html for more information. . Stop. 解决办法修改项目中Application.mk文件，将其中的APP_STL :&#x3D; gnustl_static改成APP_STL :&#x3D; c++_static 参考 https://stackoverflow.com/questions/52475177/android-ndk-app-stl-gnustl-shared-is-no-longer-supported 问题描述1This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_SUPPORT_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead. 解决办法修改主题属性 参考 https://my.oschina.net/ocean870227/blog/738442","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://airshu.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"AIDL","date":"2022-03-08T02:25:29.647Z","path":"wiki/Android/进阶知识/AIDL/","text":"Binder是一个工作在Linux层面的驱动，这 一段驱动运行在内核态。Binder本身又是一种架构，这种架构提供了服务端、Binder驱动和客户端三个模块。 服务端Binder服务端实际上就是一个Binder类的对象，当我们创建一个Binder对象的时候，Binder内部就 会启动一个隐藏线程，该线程的主要作用就是接收Binder驱动发送来的消息，那么Binder驱动为 什么会给Binder服务端的线程发送消息呢?原因很简单，我们在客户端调用服务端的时候并不能直接调用服务端相应的类和方法，只能通过Binder驱动来调用。当服务端的隐藏线程收到Binder 驱动发来的消息之后，就会回调服务端的onTransact方法，我们来看看这个方法的方法头: 1234567891011121314151617181920212223242526272829303132333435363738/**@param code 指定客户端要调 用服务端的哪一个方法@param data 客户端传来的参数@param reply 表示服务端返回的参数@param flags 表示客户端的调用是否有返回值，0表示服务端执行完成之后有返回值，1表示服务 端执行完后没有返回值。*/protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteExceptionpublic class MyAddBinder extends Binder &#123; private final static int ADD = 1; @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case ADD: data.enforceInterface(&quot;MyAddBinder&quot;); int a = data.readInt(); int b = data.readInt(); int add = add(a, b); reply.writeInt(add); return true; &#125; return super.onTransact(code, data, reply, flags); &#125; public int add(int a, int b) &#123; return a + b; &#125;&#125;public class MyService extends Service &#123; @Nullable @Override public IBinder onBind(Intent intent) &#123; return new MyAddBinder(); &#125;&#125; Binder驱动Binder驱动是Binder服务端和Binder客户端之间连接的一个桥梁，当一个服务端Binder被创建出来的时候，系统同时会在Binder驱动中创建另外一个Binder对象，当客户端想要访问远程的Binder服务端的时候，都是通过这个Binder对象来完成的。那么Binder驱动中的这个对象要怎么样获取呢?其实很简单，这个BInder对象就是我们用绑定的方式启动一个Service服务时，在绑定成功时所获取的那个IBinder对象。 1234567891011boolean b = bindService(intent, new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //这个service就是Binder驱动中创建的Binder对象 mRemote = service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;, Service.BIND_AUTO_CREATE); 客户端在客户端获取Binder驱动中的Binder对象，然后调用该对象中的 transact方法进行数据传递。客户端在向服务端发送消息的时候是以线程间通信的模式来进行的，而且调用服务端代码是同步进行的，也就是说线程会阻塞。 1234567891011121314151617int code = 1;//向服务端发送的数据Parcel data = Parcel.obtain();//接收服务端返回的数据Parcel reply = Parcel.obtain();data.writeInterfaceToken(&quot;MyAddBinder&quot;);data.writeInt(10);data.writeInt(9);try &#123; mRemote.transact(code, data, reply, 0); int i = reply.readInt(); Log.d(&quot;google.sang&quot;, &quot;add: &quot; + i); reply.recycle(); data.recycle();&#125; catch (RemoteException e) &#123; e.printStackTrace();&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"APK打包流程","date":"2022-03-08T02:25:29.647Z","path":"wiki/Android/进阶知识/APK文件打包流程/","text":"APK文件的结构 xxx.apk res：未编译的资源文件 anim color drawable layout menu lib assets META-INF CERT.RSA：保存了签名和公钥证书 CERT.SF：对每个文件的头3行进行SHA1 hash MANIFEST.MF：版本号以及每一个文件的哈希值（Base64），包括资源文件。 com classes.dex resources.arsc AndroidManifest.xml 一、资源打包使用aapt来打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res&#x2F;raw和pic保持原样） res目录有9种目录 animator。这类资源以XML文件保存在res&#x2F;animator目录下，用来描述属性动画。 anim。这类资源以XML文件保存在res&#x2F;anim目录下，用来描述补间动画。 color。这类资源以XML文件保存在res&#x2F;color目录下，用描述对象颜色状态选择子。 drawable。这类资源以XML或者Bitmap文件保存在res&#x2F;drawable目录下，用来描述可绘制对象。例如，我们可以在里面放置一些图片（.png, .9.png, .jpg, .gif），来作为程序界面视图的背景图。注意，保存在这个目录中的Bitmap文件在打包的过程中，可能会被优化的。例如，一个不需要多于256色的真彩色PNG文件可能会被转换成一个只有8位调色板的PNG面板，这样就可以无损地压缩图片，以减少图片所占用的内存资源。 layout。这类资源以XML文件保存在res&#x2F;layout目录下，用来描述应用程序界面布局。 menu。这类资源以XML文件保存在res&#x2F;menu目录下，用来描述应用程序菜单。 raw。这类资源以任意格式的文件保存在res&#x2F;raw目录下，它们和assets类资源一样，都是原装不动地打包在apk文件中的，不过它们会被赋予资源ID，这样我们就可以在程序中通过ID来访问它们。例如，假设在res&#x2F;raw目录下有一个名称为filename的文件，并且它在编译的过程，被赋予的资源ID为R.raw.filename，那么就可以使用以下代码来访问它： 12Resources res = getResources(); InputStream is = res.openRawResource(R.raw.filename); values。这类资源以XML文件保存在res&#x2F;values目录下，用来描述一些简单值，例如，数组、颜色、尺寸、字符串和样式值等，一般来说，这六种不同的值分别保存在名称为arrays.xml、colors.xml、dimens.xml、strings.xml和styles.xml文件中。 xml。这类资源以XML文件保存在res&#x2F;xml目录下，一般就是用来描述应用程序的配置信息。toc R.java public final class R { public static final class layout { public static int xxx &#x3D; 0xxxxxx; } … } resources.arsc记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息。 使用资源 程序中通过R.resource_type.resource_name来引用相关资源 xml文件中的使用格式：@[package:]type&#x2F;name aapt命令 /e/Android/sdk/build-tools/28.0.2/aapt.exe package -f -M src/main/AndroidManifest.xml -I &quot;/e/Android/sdk/platforms/android-28/android.jar&quot; -S src/main/res -J gen -m -f 如果编译出来的文件已经存在，强制覆盖。 -m 使生成的包的目录放在-J参数指定的目录。 -J 指定生成的R.java的输出目录 -S res文件夹路径 -A assert文件夹的路径 -M AndroidManifest.xml的路径 -I 某个版本平台的android.jar的路径 -F 具体指定apk文件的输出 二、aidl阶段处理.aidl文件，生成对应的Java接口文件 aidl命令 三、Java编译阶段编译R.java、Java接口文件、Java源文件，生成.class文件 javac javac -encoding UTF-8 -bootclasspath -d gen/out src/main/java/com/test/MainActivity.java -classpath 四、dex阶段通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex dx命令 dx --dex --output=gen/classes.dex gen/out/java/com/test/ 五、apkbuilder阶段将classes.dex、resources.arsc、res文件夹(res&#x2F;raw资源被原装不动地打包进APK之外，其它的资源都会被编译或者处理)、Other Resources(assets文件夹)、AndroidManifest.xml打包成apk文件。 注意： res&#x2F;raw和assets的相同点： 两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 res&#x2F;raw和assets的不同点： res&#x2F;raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 res&#x2F;raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 aapt aapt add package/res.apk classes.dex 六、签名阶段对apk进行签名 apksigner 12345678910111213141516171819202122在Android Studio中点击菜单 Build-&gt;Generate signed apk... 打包签名过程中,可以看到两种签名选项 V1(Jar Signature) V2(Full APK Signature),刚开始升级AS看到这个懵了,既然是APK Signature,就放心偷懒选了V2,结果安装失败？？？无奈,只能查资料...从Android 7.0开始, 谷歌增加新签名方案 V2 Scheme (APK Signature);但Android 7.0以下版本, 只能用旧签名方案 V1 scheme (JAR signing)V1签名: 来自JDK(jarsigner), 对zip压缩包的每个文件进行验证, 签名后还能对压缩包修改(移动/重新压缩文件) 对V1签名的apk/jar解压,在META-INF存放签名文件(MANIFEST.MF, CERT.SF, CERT.RSA), 其中MANIFEST.MF文件保存所有文件的SHA1指纹(除了META-INF文件), 由此可知: V1签名是对压缩包中单个文件签名验证 V2签名: 来自Google(apksigner), 对zip压缩包的整个文件验证, 签名后不能修改压缩包(包括zipalign), 对V2签名的apk解压,没有发现签名文件,重新压缩后V2签名就失效, 由此可知: V2签名是对整个APK签名验证 V2签名优点很明显: 签名更安全(不能修改压缩包) 签名验证时间更短(不需要解压验证),因而安装速度加快注意: apksigner工具默认同时使用V1和V2签名,以兼容Android 7.0以下版本 apksigner sign --ks key.jks --out package/app-release.apk package/app-unsigned-aligned.apk //检查签名 apksigner verify app.apk 七、zipalign阶段对apk中未压缩的数据进行4字节对齐，对齐后就可以使用mmap函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存。 zipalign zipalign 4 package/res.apk package/app-unsigned-aligned.apk","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"包体积优化","date":"2022-03-08T02:25:29.646Z","path":"wiki/Android/性能优化/包体积优化/","text":"删除无用资源底层库优化有时候，可能只使用了开源库中对某部分功能，可以对其源码进行删减重新打包。 图片压缩放入项目之前，对图片进行压缩，比如使用tinypng 图片资源格式的选择优先选择使用webp格式 Gradle配置minifyEnabled true //删除无用代码 shrinkResources true //删除无用资源 动态加载资源对于一些不是启动就要使用的资源，可以将其放到服务器，做成动态下载。","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Android中的集合","date":"2022-03-08T02:25:29.646Z","path":"wiki/Android/未分类/Android中的集合/","text":"SparseArraySparseArray由两个数组mKeys和mValues存放数据;其中key的类型为int型，这就显得SparseArray比HashMap更省内存一些。SparseArray存储的元素都是按元素的key值从小到大排列好的。使用二分查找来判断元素的位置，数据量较小时比HashMap更快。 SparseIntArray：当map的结构为Map&lt;Integer,Integer&gt;的时候使用，效率较高。 SparseBooleanArray: 当map的结构为Map&lt;Integer,Boolean&gt;的时候使用，效率较高。 SparseLongArray: 当map的结构为Map&lt;Integer,Long&gt;的时候使用，效率较高。 LongSparseArray: 当map的结构为Map&lt;Long,Value&gt;的时候使用，效率较高。 1234SparseArray&lt;String&gt; sparseArray = new SparseArray&lt;&gt;();sparseArray.put(1,&quot;A&quot;);sparseArray.put(2,&quot;B&quot;);Log.i(TAG, &quot;init: &quot;+sparseArray.toString()); ArrayMapArrayMap是一个键值对映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，区别是ArrayMap的key是hash值。 1234ArrayMap&lt;String ,String&gt; arrayMap = new ArrayMap&lt;&gt;();arrayMap.put(&quot;a&quot;,&quot;A&quot;);arrayMap.put(&quot;b&quot;,&quot;B&quot;);Log.i(TAG, &quot;init: &quot;+arrayMap.toString()); 参考 http://gityuan.com/2019/01/13/arraymap/","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://airshu.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"Android客户端经验谈","date":"2022-03-08T02:25:29.646Z","path":"wiki/Android/未分类/Android客户端经验谈/","text":"一些技巧 异步线程应该在Activity、Fragment的生命周期结束时停止掉 减少不必要的线程切换 主线程中throw的异常要catch 不要在主线程做耗时的操作 使用线程池，不要每次操作都new Thread。频繁创建线程有性能消耗 尽量减少布局层级，测量可能会进行多次 关于隐私策略由于政策要求，隐私策略需要放到运行时就弹出并由用户确认。这里有个点需要注意，只有当用户确认后才可进行后续的数据请求。 参考 https://developer.android.com/training/articles/perf-tips?hl=zh-cn","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://airshu.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"WebView独立进程","date":"2022-03-08T02:25:29.645Z","path":"wiki/Android/性能优化/WebView独立进程/","text":"参考 https://github.com/tianshaojie/android-library-web https://github.com/xudjx/webprogress 有效解决WebView多进程崩溃","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"内存管理","date":"2022-03-08T02:25:29.645Z","path":"wiki/Android/性能优化/内存管理/","text":"概述有时候，线上会出现一些”莫名其妙”的bug，比如用户用的好好的，突然就爆出一个空指针异常，这个异常的提示信息如下： 12java.lang.RuntimeException: Unable to start activityComponentInfo&#123;xxx.xxx.xxx/xxx.xxx.xxxActivity&#125;: java.lang.NullPointerException: Attempt to invoke interface method &#x27;xxx&#x27; on a null object reference 看上去好像就是一般的空指针，但这个异常发生在启动Activity的时候。ActivityThread的performLaunchActivity方法确实有catch 123456789...&#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( &quot;Unable to start activity &quot; + component + &quot;: &quot; + e.toString(), e); &#125;&#125;... 那怎么会装样子呢？ 做了以下分析： 猜测这个时候App都被回收了，在Application的onCreate方法中添加日志；在Activity的生命周期回调方法中添加日志。 等用户再次触发时，获取行为日志，查看。 果然，这个时候Application被重新create了，且没有走splash，直接打开了原来的某个页面，而这个页面时需要获取xxx数据的，但这个数据都还没初始化呢！ 问题定位了，所以只需要在此种情况恢复都时候，重新初始化相关数据即可。 问题解决后，得想想为什么会出现这种情况呢？这个时候就该了解下Android是如何来管理内存的。 先看看官方文档：https://developer.android.com/topic/performance/memory-overview 内存不足管理Android 有两种处理内存不足情况的主要机制：内核交换守护进程和低内存终止守护进程。 内核交换守护进程kswapd是用来做虚拟缓存的进程，当设备上的可用内存不足时，该守护进程将变为活动状态。Linux 内核设有可用内存上下限阈值。当可用内存降至下限阈值以下时，kswapd 开始回收内存。当可用内存达到上限阈值时，kswapd 停止回收内存。 低内存终止守护进程很多时候，kswapd 不能为系统释放足够的内存。在这种情况下，系统会使用 onTrimMemory() 通知应用内存不足，应该减少其分配量。如果这还不够，内核会开始终止进程以释放内存。它会使用低内存终止守护进程 (LMK) 来执行此操作。 LMK 使用一个名为 oom_adj_score 的“内存不足”分值来确定正在运行的进程的优先级，以此决定要终止的进程。最高得分的进程最先被终止。后台应用最先被终止，系统进程最后被终止。下表列出了从高到低的 LMK 评分类别。评分最高的类别，即第一行中的项目将最先被终止： 后台应用：之前运行过且当前不处于活动状态的应用。LMK 将首先从具有最高 oom_adj_score 的应用开始终止后台应用。 上一个应用：最近用过的后台应用。上一个应用比后台应用具有更高的优先级（得分更低），因为相比某个后台应用，用户更有可能切换到上一个应用。 主屏幕应用：这是启动器应用。终止该应用会使壁纸消失。 服务：服务由应用启动，可能包括同步或上传到云端。 可觉察的应用：用户可通过某种方式察觉到的非前台应用，例如运行一个显示小界面的搜索进程或听音乐。 前台应用：当前正在使用的应用。终止前台应用看起来就像是应用崩溃了，可能会向用户提示设备出了问题。 持久性（服务）：这些是设备的核心服务，例如电话和 WLAN。 系统：系统进程。这些进程被终止后，手机可能看起来即将重新启动。 原生：系统使用的极低级别的进程（例如，kswapd）。 经验总结为了能让App尽量少出错，采取了以下的一些办法： 添加Activity回调，判断当前是否是”异常”启动，如果是，进行相应处理； 监听lowmemory，释放调可以释放的内存，比如Glide的资源占用； 平常写代码时注意一些写法，比如： 不要在for循环、onDraw中频繁创建对象 尽量使用Android优化过的数据结构，比如SparseArray 参考 https://developer.android.com/topic/performance/memory-overview Android 开发，跳不过的内存管理","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"内存溢出分析","date":"2022-03-08T02:25:29.645Z","path":"wiki/Android/性能优化/OOM专题/内存溢出分析/","text":"概述OOM(Out of Memory)即内存溢出，是因为应用所需要分配的内存超过系统对应用内存的阈值，而抛出java.lang.OutOfMemoryError错误。 其根本原因是对象的生命周期不一致，导致内存泄漏。 内存抖动内存抖动是指在短时间内有大量的对象被创建或者被回收的现象，主要是循环中大量创建、回收对象。 内存泄漏和内存溢出的区别 内存溢出 是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。 内存泄漏 是指程序在申请内存后，无法释放已申请的内存空间。内存泄漏最终会导致内存溢出。 栈内存溢出和堆内存溢出堆內存溢出 new出来的对象所需内存不够了 栈內存溢出 抛出”StackOverflowError”的原因：线程请求的栈深度大于JVM所允许的最大深度。所以根本原因是，某个线程所需的栈内存超过了JVM的限制，而此时物理内存仍有足够的可用空间。出现的情况：方法中无限递归调用。 抛出”OutOfMemoryError”的原因：无法（向操作系统）申请到足够的内存空间用来拓展栈。根本原因是，（操作系统管理的）物理内存已没有足够的可用内存分配给JVM的栈使用。出现的情况：方法中不停的创建线程。 可能出现OOM的场景静态变量导致的内存泄漏描述比如某个静态变量持有Activity，则当Activity生命周期结束时不会被释放。 1234567Static Vector v = new Vector(10);//静态变量的生命周期跟应用一致for (int i = 1; i&lt;100; i++)&#123; Object o = new Object(); v.add(o); o = null;&#125; 解决办法：及时释放静态变量 单例模式导致的内存泄漏描述单例持有Activity 解决办法如果需要持有Context，则使用ApplicationContext 属性动画导致的内存泄漏解决办法视图销毁时停止动画 for循环中不停的创建局部变量非静态内部类（包括匿名内部类）默认会持有外部类的引用当非静态内部类会持有外部类引用，如果在内部类中，将外部类的引用传入到另外的线程中，则可能造成内存泄漏。 未取消注册或回调导致的内存泄漏比如在Activity中注册广播，如果Activity销毁后不取消注册，那么这个广播就会一直存在系统中 一些经验 在onDestroy中手动释放View上的资源 尽量避免使用静态变量 异常状态，静态变量会被回收，系统启动恢复到当前页面时相应值可能没空 可能会造成某些对象没有释放 兜底策略 在Activity、Fragment的onDestroy时，手动释放一下资源，降低内存泄漏时内存的占用。 123456789101112131415private void traverse(ViewGroup root) &#123; final int childCount = root.getChildCount(); for (int i = 0; i &lt; childCount; ++i) &#123; final View child = root.getChildAt(i); if (child instanceof ViewGroup) &#123; child.setBackground(null); traverse((ViewGroup) child); &#125; else &#123; if (child != null) &#123; child.setBackground(null); &#125; if (child instanceof ImageView) &#123; ((ImageView) child).setImageDrawable(null); &#125; else if (child instanceof EditText) &#123; ((EditText) child).cleanWatchers(); &#125; &#125; &#125;&#125; 监控内存使用情况，到达到某个阈值时，手动释放资源。 1234567891011121314151617181920212223242526272829303132private static Handler lowMemoryMonitorHandler;private static final int MEMORY_MONITOR_INTERVAL = 1000 * 60;/** * 开启低内存监测，如果低内存了，作出相应的反应 */public static void startMonitorLowMemory() &#123; HandlerThread thread = new HandlerThread(&quot;thread_monitor_low_memory&quot;); thread.start(); lowMemoryMonitorHandler = new Handler(thread.getLooper()); lowMemoryMonitorHandler.postDelayed(releaseMemoryCacheRunner, MEMORY_MONITOR_INTERVAL);&#125;/** * 低内存时释放内存资源 * 如果已用内存达到了总的 80%时，就清空缓存 */private static Runnable releaseMemoryCacheRunner = new Runnable() &#123; @Override public void run() &#123; long alreadyUsedSize = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); long maxSize = Runtime.getRuntime().maxMemory(); if (Double.compare(alreadyUsedSize, maxSize * 0.8) == 1) &#123; BitmapUtil.clearMemoryCaches(); &#125; lowMemoryMonitorHandler.postDelayed(releaseMemoryCacheRunner, MEMORY_MONITOR_INTERVAL); &#125;&#125;; 参考","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}]},{"title":"动画造成的OOM的处理方式","date":"2022-03-08T02:25:29.645Z","path":"wiki/Android/性能优化/OOM专题/动画造成的OOM的处理方式/","text":"解决办法在视图销毁的时候，要cancel掉动画 参考","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}]},{"title":"Bitmap造成的OOM的处理方式","date":"2022-03-08T02:25:29.644Z","path":"wiki/Android/性能优化/OOM专题/Bitmap造成的OOM的处理方式/","text":"Bitmap总结Android中的图片是以Bitmap方式存在的，绘制的时候也是Bitmap，对内存的影响还是很大的。 Bitmap所占用内存的计算公式：图片长度 x 图片宽度 x 像素点的字节数 图片常用的压缩格式 ALPHA_8：每个像素都存储为一个半透明通道 ARGB_4444：API 13中已弃用 ARGB_8888：每个像素存储在4个字节 RGB_565：每个像素存储在2个字节中，只有RGB通道被编码；红色以5位精度存储，绿色以6位精度存储，蓝色以5位精度存储。 单个像素点的字节数 ALPHA_8：表示8位Alpha位图，即透明度占8个位，一个像素点占用1个字节，他没有颜色，只有透明度。 ARGB_4444：表示16位的ARGB位图，即A&#x3D;4，R&#x3D;4，G&#x3D;4，B&#x3D;4，一个像素点占4+4+4+4&#x3D;16位，2个字节。 ARGB_8888：表示32位ARGB位图，即A&#x3D;8，R&#x3D;8，G&#x3D;8，B&#x3D;8，一个像素点占8+8+8+8&#x3D;32位，4个字节。 RGB_565：表示16位RGB位图，即R&#x3D;5，G&#x3D;6，B&#x3D;5，没有透明度，一个像素点占用5+6+5&#x3D;16位，2个字节。 常用压缩方法 质量压缩 12345private void compressQuality() &#123; Bitmap bm = BitmapFactory.decodeResource(getResources(),R.drawable.test); mSrcSize = bm.getByteCount() + &quot;byte&quot;; ByteArrayOutputStream bos = new ByteArrayOutputStream(); bm.compress(Bitmap.CompressFormat.JPEG, 100, bos); byte[] bytes = bos.toByteArray(); mSrcBitmap = BitmapFactory.decodeByteArray(bytes, 0,bytes.length);&#125; 质量压缩不会减少图片的像素，它是在保持像素的前提下改变图片的位深和透明度来达到压缩的目的；图片的长、宽，像素不改变，占用的内存是不会变的。 质量压缩对png无效，png是无损压缩。 采样率压缩 1234private void compressSampling() &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 2; mSrcBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test, options);&#125; 采样率压缩其原理是缩放 bitamp 的尺寸，通过调节其 inSampleSize 参数，比如调节为 2，宽高会为原来的 1&#x2F;2，内存变回原来的 1&#x2F;4. 缩放压缩 1234567private void compressMatrix() &#123; Matrix matrix = new Matrix(); matrix.setScale(0.5f, 0.5f); Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.test); mSrcBitmap = Bitmap.createBitmap(bm, 0, 0, bm.getWidth(), bm.getHeight(), matrix, true); bm = null; &#125; 放缩法压缩使用的是通过矩阵对图片进行裁剪，也是通过缩放图片尺寸，来达到 压缩图片的效果，和采样率的原理一样。 RGB_565压缩 12345private void compressRGB565() &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inPreferredConfig = Bitmap.Config.RGB_565; mSrcBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test, options);&#125; 这是通过压缩像素占用的内存来达到压缩的效果，相比 ARGB_8888 将节省一半的内存开销。 createScaledBitmap 12345private void compressScaleBitmap() &#123; Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.test); mSrcBitmap = Bitmap.createScaledBitmap(bm, 600, 900, true); bm = null; &#125; 将图片的大小压缩成用户的期望大小，来减少占用内存。 参考","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}]},{"title":"RePlugin","date":"2022-03-08T02:25:29.643Z","path":"wiki/Android/开源库/RePlugin/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"RxAndroid","date":"2022-03-08T02:25:29.643Z","path":"wiki/Android/开源库/RxAndroid/","text":"Schedulers参考","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"Small","date":"2022-03-08T02:25:29.643Z","path":"wiki/Android/开源库/Small/","text":"插件化框架 https://github.com/wequick/Small","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"WMRouter","date":"2022-03-08T02:25:29.643Z","path":"wiki/Android/开源库/WMRouter/","text":"概述WMRouter主要提供URI分发、ServiceLoader两大功能。基于注解的方式来实现解耦。 提供了以下标注： RouterPage：指定一个内部页面跳转，此注解可以用在Activity和UriHandler上 RouterProvider：指定一个静态方法，用于构造Service。提供构造对象的替代方法，比如getInstance。 RouterRegex：指定一个正则匹配的跳转，此注解可以用在Activity和UriHandler上 RouterService：声明一个Service，通过interface和key加载实现类 RouterUri：指定一个Uri跳转，此注解可以用在Activity和UriHandler上 注：WMRouter中运用了反射、注解、责任链模式等技术，请先了解相关技术。 URI分发使用RouterUri使用路由功能，我们可以使用以下标注 1234567891011121314151617// 指定路径、scheme、host@RouterUri(path = &quot;/test/schemehost&quot;, scheme = &quot;test&quot;, host = &quot;test.demo.com&quot;)public static class TestSchemeHostHandler extends EmptyHandler &#123;&#125;// 指定path、拦截器@RouterUri(path = &quot;/test/interceptor&quot;, interceptors = UriParamInterceptor.class)public static class TestInterceptorHandler extends EmptyHandler &#123;&#125;// 指定路径@RouterUri(path = DemoConstant.ADVANCED_DEMO)public class AdvancedDemoActivity extends BaseActivity &#123; &#125; 跳转到具体Uri1234567Router.startUri(context, &quot;/home&quot;);Router.startUri(context, &quot;demo_scheme://demo_host/path1&quot;);Router.startUri(new UriRequest(context, &quot;/account&quot;)) 解析RouterUriUriAnnotationProcessor对RouterUri标注进行解析处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123; if (annotations == null || annotations.isEmpty()) &#123; return false; &#125; CodeBlock.Builder builder = CodeBlock.builder(); String hash = null; for (Element element : env.getElementsAnnotatedWith(RouterUri.class)) &#123; if (!(element instanceof Symbol.ClassSymbol)) &#123; continue; &#125; // 判断是否是Activity boolean isActivity = isActivity(element); // 判断是否UriHandler的子类 boolean isHandler = isHandler(element); if (!isActivity &amp;&amp; !isHandler) &#123; continue; &#125; Symbol.ClassSymbol cls = (Symbol.ClassSymbol) element; RouterUri uri = cls.getAnnotation(RouterUri.class); if (uri == null) &#123; continue; &#125; if (hash == null) &#123; hash = hash(cls.className()); &#125; CodeBlock handler = buildHandler(isActivity, cls); CodeBlock interceptors = buildInterceptors(getInterceptors(uri)); // scheme, host, path, handler, exported, interceptors String[] pathList = uri.path(); for (String path : pathList) &#123; builder.addStatement(&quot;handler.register($S, $S, $S, $L, $L$L)&quot;, uri.scheme(), uri.host(), path, handler, uri.exported(), interceptors); &#125; &#125; if (hash == null) &#123; hash = randomHash(); &#125; // 生成对应的初始化文件，将对应的Class添加到ServiceLoader中的Map中 buildHandlerInitClass(builder.build(), &quot;UriAnnotationInit&quot; + Const.SPLITTER + hash, Const.URI_ANNOTATION_HANDLER_CLASS, Const.URI_ANNOTATION_INIT_CLASS); return true;&#125; UriHandler运用责任链模式，用于拦截相关URI。 RouterRegex用于设置路由匹配的正则，可以设置的属性有： regex：完整uri的正则表达式匹配 priority：优先级，数字越大越先执行，默认为0 exported：是否允许外部跳转 interceptors：要添加的interceptors，需要实现UriInterceptor，拦截器处理后决定是继续还是结束。 12345678910111213141516171819202122232425262728293031@RouterRegex(regex = &quot;http(s)?://.*&quot;)public class SystemBrowserHandler extends UriHandler &#123; // 是否要处理 @Override protected boolean shouldHandle(@NonNull UriRequest request) &#123; return true; &#125; // 根据实际业务需要进行处理 @Override protected void handleInternal(@NonNull UriRequest request, @NonNull UriCallback callback) &#123; try &#123; Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setData(request.getUri()); request.getContext().startActivity(intent); callback.onComplete(UriResult.CODE_SUCCESS); &#125; catch (Exception e) &#123; callback.onComplete(UriResult.CODE_ERROR); &#125; &#125;&#125;@RouterRegex(regex = &quot;http(s)://test.demo.com/test/interceptor.*&quot;, interceptors = UriParamInterceptor.class)public static class TestInterceptorHandler extends EmptyHandler &#123;&#125; RouterPageRouterPage用于内部页面跳转，此注解可以用在Activity、Fragment和UriHandler上。可以设置拦截器UriInterceptor。 123456789@RouterPage(path = &quot;/test/interceptor&quot;, interceptors = UriParamInterceptor.class)public static class TestInterceptorHandler extends EmptyHandler &#123;&#125;@RouterPage(path = DemoConstant.TEST_DEMO_FRAGMENT_2, interceptors = DemoFragmentInterceptor.class)public class Demo2Fragment extends Fragment &#123; &#125; ServiceLoaderServiceLoader帮助我们到项目实现解耦的效果，跟Dagger等框架等功能类似。不过WMRouter内部是沟通反射来构造对象的，感觉性能上没有google官方提供的框架好。 使用RouterServiceRouterService可以设置以下属性： interfaces：实现的接口（或继承的父类） key：同一个接口的多个实现类之间，可以通过唯一的key区分。 singleton：是否为单例。如果是单例，则使用ServiceLoader.getService不会重复创建实例。 defaultImpl：是否设置为默认实现类。如果是默认实现类，则在获取该实现类实例时可以不指定key 12345678910111213141516171819//注册@RouterService(interfaces = Func2.class, key = &quot;/method/add&quot;, singleton = true)public class AddMethod implements Func2&lt;Integer, Integer, Integer&gt; &#123;//获取，第一个参数为接口的class，第二个为注册时填的keyRouter.getService(IAccountService.class, &quot;key_name&quot;);// 可以通过接口拿到所有注册的对象Router.getAllServiceClasses(IService.class);// 可以传入一个工厂，如果没有拿到对象，则可以通过工厂构造一个IFactoryService service4 = Router.getService(IFactoryService.class, &quot;/factory&quot;, new IFactory() &#123; @NonNull @Override public &lt;T&gt; T create(@NonNull Class&lt;T&gt; clazz) throws Exception &#123; return clazz.getConstructor(String.class).newInstance(&quot;CreateByCustomFactory&quot;); &#125;&#125;); getService流程流程： ServiceLoader的SERVICES如果有对应的对象，则直接返回； 没有则创建一个ServiceLoader，将class传进入； 调用ServiceLoader的get方法： 如果用单例修饰，则从SingletonPool中拿 不是则判断是否有用RouterProvider修饰来返回对象 不是则通过反射创建对象 ServiceAnnotationProcessorServiceAnnotationProcessor用来解析RouterService注解 1234567891011121314@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123; //最后一轮的时候，生成ServiceInit文件 if (env.processingOver()) &#123; generateInitClass(); &#125; else &#123; // 处理相应注解 processAnnotations(env); &#125; return true;&#125; 参考 WMrouter源码拆解 WMRouter：美团外卖Android开源路由框架","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"multitype","date":"2022-03-08T02:25:29.643Z","path":"wiki/Android/开源库/multitype/","text":"概述有些业务场景，比如IM聊天、直播房间的消息面板。可能会出现有好几十个ViewHolder的场景。这个时候，如果按照Adapter的标准写法，所有的类型都堆叠在一个文件中，文件会变得臃肿，到后期维护成本变化。也违反了开闭原则，新增一个类型的时候又要改这个Adapter。MultiTypeAdapter就是帮我们处理了复杂场景下Adapter的工作。 MultiTypeAdapter在渲染多类型布局的时候，根据Adapter的数据集合拿到第i个数据的JavaBean Class,然后根据这个Classs, 拿到ViewType。之后onCreateViewHolder方法和 onBindViewHolder方法根据这个View Type 拿到对应的Binder，然后让相应的Binder来进行绑定布局和绑定数据。 用法支持一对多、支持修改item中多子view。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 自己实现ItemViewBinderclass PostViewBinder : ItemViewBinder&lt;Post, PostViewBinder.ViewHolder&gt;() &#123; override fun onCreateViewHolder(inflater: LayoutInflater, parent: ViewGroup): ViewHolder &#123; return ViewHolder(inflater.inflate(R.layout.item_post, parent, false)) &#125; override fun onBindViewHolder(holder: ViewHolder, item: Post) &#123; holder.setData(item) &#125; class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; private val cover: ImageView = itemView.findViewById(R.id.cover) private val title: TextView = itemView.findViewById(R.id.title) fun setData(post: Post) &#123; cover.setImageResource(post.coverResId) title.text = post.title &#125; &#125;&#125;// 也可以实现ViewDelegate// 其内部自己实现ViewHolder，通过工厂方法模式暴露onCreateView、onBindView让子类实现class RichViewDelegate : ViewDelegate&lt;RichItem, RichView&gt;() &#123; override fun onCreateView(context: Context): RichView &#123; return RichView(context).apply &#123; layoutParams = LayoutParams(MATCH_PARENT, WRAP_CONTENT) &#125; &#125; @SuppressLint(&quot;SetTextI18n&quot;) override fun onBindView(view: RichView, item: RichItem) &#123; view.imageView.setImageResource(item.imageResId) view.textView.text = &quot;&quot;&quot; |$&#123;item.text&#125; |layoutPosition: $&#123;view.layoutPosition&#125; |absoluteAdapterPosition: $&#123;view.absoluteAdapterPosition&#125; |bindingAdapterPosition: $&#123;view.bindingAdapterPosition&#125; &quot;&quot;&quot;.trimMargin() &#125;&#125;MultiTypeAdapter adapter = new MultiTypeAdapter()//注册后，会自动匹配Post类型的数据设置成对应的视图adapter.register(PostViewBinder())adapter.register(RichViewDelegate())//一对多关系adapter.register(Weibo::class).to( SimpleTextViewBinder(), SimpleImageViewBinder() ).withLinker &#123; _, weibo -&gt; // 判断使用那种类型 when (weibo.content) &#123; is SimpleText -&gt; 0 is SimpleImage -&gt; 1 else -&gt; 0 &#125; &#125;//有content对应的类型SimpleTextViewBinder、SimpleImageViewBinderval simpleText = SimpleText(&quot;A simple text Weibo: Hello World.&quot;)val simpleImage = SimpleImage(R.drawable.img_10)for (i in 0..19) &#123; items.add(Weibo(user, simpleText)) items.add(Weibo(user, simpleImage))&#125; 源码分析参考 https://github.com/drakeet/MultiType","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"tinker","date":"2022-03-08T02:25:29.643Z","path":"wiki/Android/开源库/tinker/","text":"概述测试是无法测出所有bug的，线上出问题在所难免，如果没有热更新方案。那么每次都需要重新更新！tinker是经过腾讯实践后公布的开源解决方案。由于patch包需要分发，如果自己做后台也是开源，但bugly提供了相关解决方案。那么我们直接使用就行了。这里记录自己的整个接入流程，后续再分析其原理。 接入流程 大致流程： 编译基准包； 基于基准包，修复bug，编译patch文件； 上传patch文件。 由于自己是直接接入bugly的集成方案，建议大家在接入前好好看看他们的文档。 Bugly Android热更新使用指南 Bugly Android热更新详解 Bugly Android 热更新常见问题 热更新API接口 tinker官方wiki 注意事项 原有的Application逻辑，应该全部移到ApplicationLike中； 上传的包改一下名字，apk为扩展名可能会被运营商拦截； 注意打包命令，buildTinkerPatchArmeabiRelease，根据gradle的配置不同，有时候需要指定cpu架构，有时候不需要指定。主要看bakApk目录的层次； 基准包需要先启动，才可以上传patch文件； 可以不用指定基本版本，tinker自动获取versionCode、versionName 原理参考 https://github.com/Tencent/tinker Tinker - 微信开源的 Android 热修复框架","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"Glide原理分析","date":"2022-03-08T02:25:29.640Z","path":"wiki/Android/开源库/Glide原理分析/","text":"流程图参考","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"GreenDao","date":"2022-03-08T02:25:29.640Z","path":"wiki/Android/开源库/GreenDao/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"KOOM","date":"2022-03-08T02:25:29.640Z","path":"wiki/Android/开源库/KOOM/","text":"KOOM ：OOM分析工具 流程初始化后，10秒后启动一个线程，每5秒轮询检测。当满足条件（比如内存不够用），启动一个新的进程，进行内存泄漏分析、裁剪、保存分析信息。内存泄漏的判断是通过读取shark获取的heapGraph，判断Activity、Fragment、Bitmap等是否存在泄漏。 KOOMEnableChecker有一些限制条件，不满足条件的则不能进行监控。 sharkshark-graph：square的开源库。文档地址：https://square.github.io/leakcanary/api/shark/shark/ xhookxhook：爱奇艺的开源库，用于hook动态库。文档地址：https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md Get到的知识点Handler的用法Handler执行一个Runnable方法，可以直接使用以下的方式来执行类方法 1koomHandler.post(this::manualTriggerInternal); ResultReceiver使用ResultReceiver进行进程间通信，这个类也挺简单的，实现序列化接口。构造函数接受一个Handler。没有序列化的情况下使用Handler通信，序列化后使用Binder通信。send发送消息，onReceiveResult接收消息。 参考 https://github.com/KwaiAppTeam/KOOM https://www.gushiciku.cn/pl/p3Rl https://square.github.io/leakcanary/api/shark/shark/ https://github.com/iqiyi/xHook","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"LeakCanary","date":"2022-03-08T02:25:29.640Z","path":"wiki/Android/开源库/LeakCanary/","text":"参考 https://square.github.io/leakcanary","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"MMKV","date":"2022-03-08T02:25:29.640Z","path":"wiki/Android/开源库/MMKV/","text":"概述MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化&#x2F;反序列化使用 protobuf 实现，性能高，稳定性强。 MMKV 本质上是将文件 mmap 到内存块中，将新增的 key-value 统统 append 到内存中；到达边界后，进行重整回写以腾出空间，空间还是不够的话，就 double 内存空间；对于内存文件中可能存在的重复键值，MMKV 只选用最后写入的作为有效键值。 MMKV支持多进程。如果要自己实现的话，一般能想到的是基于ContentProvider。但这种方式启动慢、访问也慢。 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 初始化String rootDir = MMKV.initialize(this);System.out.println(&quot;mmkv root: &quot; + rootDir);// 提供默认的全局实例MMKV kv = MMKV.defaultMMKV();kv.encode(&quot;bool&quot;, true);System.out.println(&quot;bool: &quot; + kv.decodeBool(&quot;bool&quot;));kv.encode(&quot;int&quot;, Integer.MIN_VALUE);System.out.println(&quot;int: &quot; + kv.decodeInt(&quot;int&quot;));kv.encode(&quot;long&quot;, Long.MAX_VALUE);System.out.println(&quot;long: &quot; + kv.decodeLong(&quot;long&quot;));kv.encode(&quot;float&quot;, -3.14f);System.out.println(&quot;float: &quot; + kv.decodeFloat(&quot;float&quot;));kv.encode(&quot;double&quot;, Double.MIN_VALUE);System.out.println(&quot;double: &quot; + kv.decodeDouble(&quot;double&quot;));kv.encode(&quot;string&quot;, &quot;Hello from mmkv&quot;);System.out.println(&quot;string: &quot; + kv.decodeString(&quot;string&quot;));byte[] bytes = &#123;&#x27;m&#x27;, &#x27;m&#x27;, &#x27;k&#x27;, &#x27;v&#x27;&#125;;kv.encode(&quot;bytes&quot;, bytes);System.out.println(&quot;bytes: &quot; + new String(kv.decodeBytes(&quot;bytes&quot;)));// 删除和查询kv.removeValueForKey(&quot;bool&quot;);System.out.println(&quot;bool: &quot; + kv.decodeBool(&quot;bool&quot;)); kv.removeValuesForKeys(new String[]&#123;&quot;int&quot;, &quot;long&quot;&#125;);System.out.println(&quot;allKeys: &quot; + Arrays.toString(kv.allKeys()));boolean hasBool = kv.containsKey(&quot;bool&quot;);// 如果不同业务需要区别存储，也可以单独创建自己的实例MMKV kv = MMKV.mmkvWithID(&quot;MyID&quot;);kv.encode(&quot;bool&quot;, true);// 如果业务需要多进程访问，那么在初始化的时候加上标志位 MMKV.MULTI_PROCESS_MODEMMKV kv = MMKV.mmkvWithID(&quot;InterProcessKV&quot;, MMKV.MULTI_PROCESS_MODE);kv.encode(&quot;bool&quot;, true); 参考 https://github.com/Tencent/MMKV","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"OkHttp","date":"2022-03-08T02:25:29.640Z","path":"wiki/Android/开源库/OkHttp/","text":"流程图 同步请求 异步请求 判断当前 call 是否只执行了一次，否则抛出异常 创建一个 AsyncCall 对象，它其实是一个 Runable 对象 通过 client.dispatcher().enqueue() 传入 AsyncCall 对象执行异步请求，如果当前运行的异步任务队列(runningAsyncCalls)元素个数小于maxRequests 并且当前请求的 Host 个数小于 maxRequestsPerHost 则直接放进运行对象并执行当前的任务，否则放进准备队列中 (readyAsyncCalls) 如果第 3 步可以执行，则会调用 AsyncCall 的 execute 方法，之后调用 getResponseWithInterceptorChain() 获取 Response，执行onResponse 或 onFailure。这也 印证了上面提到的异步任务回调是在子线程中 execute 方法末尾会必调 client.dispatcher().finished(this) 方法 finished 方法中会做三件事: 从 runningAsyncCalls 中清除当前任务 通过 promoteCalls方法调整整个异步任务队列，主要工作是判断准备队列 readyAsyncCalls 中的任务是否可以执行 重新计算正在执行的任务数量，为 0 则执行 idleCallback 拦截器 拦截器可以添加、移除或者替换请求的头信息，也可以改变传输的主体部分。 应用拦截器发送前进行拦截 网络拦截器对响应的数据进行拦截 内部拦截器RetryAndFollowUpInterceptor重定向拦截器：客户端向服务器发送一个请求，获取对应的资源，服务器收到请求后，发现请求的这个资源实际放在另一个位置，于是服务器在返回的响应头的Location字段中写入那个请求资源的正确的URL，并设置reponse的状态码为30x 。 工作流程 创建一个 StreamAllocation。 调用下一个chain 。 判断是否重定向。重定向会对 request做一些修改，返回新的request，否则会返回null。 followUp &#x3D;&#x3D; null 无重定向，释放资源，直接返回response。 比较重定向前后的 host、port、scheme是否一致，一致的话复用， 否则重新创建 StreamAllocation。 通过 while (true) ，重复步骤 BridgeInterceptor桥接拦截器：负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应。 工作流程 发起请求前： 如果这个请求有请求体，就添加 Content-Type, Content-Length等。 如果这个请求没有 Host，就通过 url 来获取 Host 值添加到 Header中。 如果这个请求没有接收的数据类型 Accept-Encoding，且没指定接收的数据范围，就添加默认接受格式为 gzip。 去 CookieJar 中 根据 url 查询 Cookie 添加到 Header。 如果当前没有，就添加 User-Agent 信息。 发起请求后: 解析响应 Header 中的 Cookie 如果想要数据的格式是 gzip，就创建 GzipSource 进行解压， 同时移除 Content-Encoding 和 Content-Length CacheInterceptor缓存拦截器：最快的请求就是不请求，直接用缓存。 根据Request和之前缓存的Response得到CacheStrategy 根据 CacheStrategy决定是请求网络还是直接返回缓存 如果 step 2中决定请求网络，则在这一步将返回的网络响应和本地缓存对比，对本地缓存进行改增删操作 ConnectInterceptor连接拦截器：部维护了可以重复使用的 Socket 连接池，减少握手次数，加快请求响应 连接 RealConnection 是对 Socket 的封装。 OkHttp 的连接复用主要是通过 StreamAllocation 来实现的，每个连接上持有一个。 StreamAllocation 引用的列表，以此来标识当前连接是否空闲。它里面维护了List的引用。List中StreamAllocation的数量也就是socket被引用的计数，如果计数为0的话，说明此连接没有被使用就是空闲的，需要通过下文的 算法实现回收;如果计数不为0，则表示上层代码仍然引用，就不需要关闭连接。 判断连接是否可以重用，除了比较连接当前的 host，也可以比较路由信息。 连接池在添加新连接时会运行清理任务，默认最多空闲连接为5，最长空闲时间为5分钟。 CallServerInterceptor读写拦截器：它负责实现网络 IO，所有拦截器都要依赖它才能拿到响应数据。 CallServerInterceptor 首先会将请求中的 header 写给服务器。 如果有请求体的话，会再将 body 发送给服务器。 最后通过httpCodec.finishRequest() 结束 http 请求的发送。 然后从连接中读取服务器的响应，并构造 Response。 如果请求的 header或服务器 响应的 header 中，Connection 的值为 close，就关闭连接。 最后返回 Response。 Get到的知识点 责任链模式、建造者模式的运用 线程池的运用 参考 https://juejin.cn/post/6898145227765186567","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"样式和主题","date":"2022-03-08T02:25:29.639Z","path":"wiki/Android/基础/样式和主题/","text":"概述样式是一个属性集合，用于指定单个 View 的外观。样式可以指定字体颜色、字号、背景颜色等属性。 主题背景是应用于整个应用、Activity 或视图层次结构，而非仅仅应用于单个视图的属性集合。当您应用主题背景时，应用或 Activity 中的每个视图都会应用其支持的每个主题背景属性。主题还可以将样式应用于非视图元素，例如状态栏和窗口背景。主题可以理解成样式的集合。 样式定义样式1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encodeing=&quot;utf-8&quot;?&gt;&lt;resource&gt; &lt;style name=&quot;BaseToolBarLine&quot;&gt; &lt;item name=&quot;android:layout_width&quot;&gt;match_parent&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;1px&lt;/item&gt; &lt;item name=&quot;android:background&quot;&gt;@color/base_toolbar_line_color&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;CodeFontRed&quot; parent=&quot;CodeFont&quot;&gt; &lt;item name=&quot;android:textColor&quot;&gt;#FF0000&lt;/item&gt; &lt;/style&gt; &lt;!-- 样式是可以继承的 --&gt; &lt;style name=&quot;CodeFont.Red&quot;&gt; &lt;item name=&quot;android:textColor&quot;&gt;#FF0000&lt;/item&gt; &lt;/style&gt;&lt;/resource&gt; 在布局文件中使用样式 1&lt;View style=&quot;@style/BaseToolBarLine&quot; /&gt; 如果有多个module，需要注意样式的继承，以免出现，子module修改了某个同名的style，造成父module中的样式被修改。 主题Android的主题发展历史 在Android3.0之前，Android的界面不论是从系统还是空间的主题都是按钮为白色，点击事件为黄色。现在看来很简陋 Holo主题：Android3.0 （API11）开始，Google推出了Holo主题（就是我们印象中的黑底白字蓝主色的主题）。在4.0google又发布了应用设计规范Android Design。有了设计规范的指导，就有了更多的应用采用Holo主题。所以我们可以简单认为Android Design就是Holo主题。但是这种主题是适合移动设备，其他平台略显突兀。 在4.0之前Android可以说是没有设计可言的，在4.0之后推出了Android Design，从此Android在设计上有了很大的改善，而在程序实现上相应的就是Holo风格，所以你看到有类似 Theme.Holo.Light、 Theme.Holo.Light.DarkActionBar 就是4.0的设计风格，但是为了让4.0之前的版本也能有这种风格怎么办呢？这个时候就不得不引用v7包了，所以对应的就有 Theme.AppCompat.Light、Theme.AppCompat.Light.DarkActionBar，如果你的程序最小支持的版本是API14（即Android 4.0），那么可以不用考虑v7的兼容 Material 主题：从Android5.0（API21）开始，Google又推出了材料设计语言Material Design，又叫Google Design。MD崇尚的就是图层扁平化，所有图层像纸或者卡片一样重叠在一起，所以Android5.0就有了RecyclerView和CardView。图层之间有间隔，所以Android5.0中有了translation和elevation两个属性。同时也规范了Android的运动元素，界面上的每个元素不是无故产生的，同时每个图层的产生和消失都有方向的约定，从哪里来就往哪里去，这也是为什么Android 5.0中会有Ripple，Circular Receal，Activity Transition Android在5.0版本推出了Material Design的概念，这是Android设计上又一大突破。对应的程序实现上就有Theme.Material.Light、Theme.Material.Light.DarkActionBar等，但是这种风格只能应用在在5.0版本的手机，如果在5.0之前应用Material Design该怎么办呢？同样的引用appcompat-v7包，这个时候的Theme.AppCompat.Light、Theme.AppCompat.Light.DarkActionBar就是相对应兼容的Material Design的Theme。 主题也跟样式一样是可以继承的，主题的根在themes.xml文件中。定义了&lt;style name=&quot;Theme&quot;&gt;&lt;/style&gt;。 1234567891011121314151617181920&lt;style name=&quot;Theme&quot;&gt;&lt;/style&gt;&lt;!-- 黑色背景--&gt;&lt;style name=&quot;Theme.Black&quot;&gt; &lt;item name=&quot;windowBackground&quot;&gt;@color/black&lt;/item&gt; &lt;item name=&quot;colorBackground&quot;&gt;@color/black&lt;/item&gt;&lt;/style&gt;&lt;!-- 没有标题 --&gt;&lt;style name=&quot;Theme.Black.NoTitleBar&quot;&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;/style&gt;&lt;!--兼容主题的根主题 --&gt;&lt;style name=&quot;Theme.AppCompat&quot; parent=&quot;Base.Theme.AppCompat&quot;/&gt;&lt;style name=&quot;Theme.AppCompat.Dialog&quot; parent=&quot;Base.Theme.AppCompat.Dialog&quot;/&gt;&lt;!-- 没有actionbar --&gt;&lt;style name=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- 这里是AppCompat定义的属性，另外还有android:windowNoTitle属性 --&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 常用属性12345678910111213&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt; Dialog的windowFrame框为无&lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt; 是否浮现在activity之上&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;false&lt;/item&gt; 是否半透明&lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; 是否显示title&lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/dia_bg&lt;/item&gt; 设置背景&lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt; 背景是否变暗&lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/AnimBottom&lt;/item&gt; 窗口的动画设置&lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; 这个drawable会覆盖在content区域的上面&lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt; Dialog弹窗漂浮 参考 样式和主题背景 Android中主题知识","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"ARouter","date":"2022-03-08T02:25:29.639Z","path":"wiki/Android/开源库/ARouter/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"EventBus","date":"2022-03-08T02:25:29.639Z","path":"wiki/Android/开源库/EventBus/","text":"事件总线匡救啊，降低了代码的耦合性。","tags":[],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"Dagger2学习笔记","date":"2022-03-08T02:25:29.639Z","path":"wiki/Android/开源库/Dagger2/","text":"","tags":[],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"Glide","date":"2022-03-08T02:25:29.639Z","path":"wiki/Android/开源库/Glide/","text":"此篇文章只是用于记录使用Glide时要注意的点和一些使用技巧，如需查看基本使用，请查阅官方文档。也可以看看Glide原理分析。 注意点占位符1234567Glide.with(this) .load(url) .asBitmap() //指定加载的图片是位图，这样底层不会进行图片格式判断，Gif就无法播放，也可以设置asGif()指明是Gif图片 .placeholder(R.drawable.loading)//下载过程中的占位符 .error(R.drawable.error)//下载失败后的显示 .diskCacheStrategy(DiskCacheStrategy.NONE)//磁盘策略，这里不使用缓存 .into(imageView); 缓存等级活动缓存：内存缓存：默认开启，可以通过skipMemoryCache(true)关闭内存缓存。 磁盘缓存：InternalCacheDiskCacheFactory（默认） DiskCacheStrategy.NONE 不缓存文件 DiskCacheStrategy.DATA 对应 Glide 3 中的 DiskCacheStrategy.SOURCE， 只缓存原图 DiskCacheStrategy.RESOURCE 对应 Glide 3 中的 DiskCacheStrategy.RESULT， 只缓存最终加载的图 DiskCacheStrategy.ALL 同时缓存原图和结果图 DiskCacheStrategy.AUTOMATIC:表示让 Glide 根据图片资源智能地选择使用哪一 种缓存策略(默认选项)。 缓存键123//缓存的键包括图片的宽、高、signature等参数EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,resourceClass, transcodeClass, options) submitsubmit()方法其实就是对应的 Glide 3 中的 downloadOnly()方法，和 preload()方法 类似，submit()方法也是可以替换 into()方法的，不过 submit()方法的用法明显要 比 preload()方法复杂不少。这个方法只会下载图片，而不会对图片进行加载。当 图片下载完成之后，我们可以得到图片的存储路径，以便后续进行操作。 重要知识点 通过attach一个Fragment来监听Context的生命周期，合理的管理图片的加载和释放。 Glide默认采用的是RGB-565，相比ARGB-8888内存占用会减小一半。 会根据ImageView的尺寸来缓存图片。 常用配置整合OkHttp3为了提升请求效率，使用更高效的OkHttp3来进行资源的下载。接入方式很简单，直接在gradle中引入 compile “com.github.bumptech.glide:okhttp3-integration:4.11.0” 它会自动添加以下配置 12345678@GlideModulepublic final class OkHttpLibraryGlideModule extends LibraryGlideModule &#123; @Override public void registerComponents(@NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) &#123; registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory()); &#125;&#125; 注意点 使用时尽量传生命周期所对应的Context（比如Activity、Fragment） 如果使用ApplicationContext，则使用弱引用 参考 https://github.com/bumptech/glide 官方文档","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"WindowManager","date":"2022-03-08T02:25:29.638Z","path":"wiki/Android/基础/WindowManager/","text":"概述Window是一个抽象的概念，每一个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，因此Window并不是实际存在的，它是以View的形式存在。 Android系统中Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限在能创建的Window，比如Toast和系统状态栏这些都是系统Window。 Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面。在三类Window中，应用Window的层级范围是199，子Window的层级范围是10001999，系统Window的层级范围是2000~2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR，如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可:mLayoutParams.type &#x3D; LayoutParams.TYPE_SYSTEM_ERROR;同时声明权限:。因为系统类型的Window是需要检查权限的，如果不在AndroidManifest中使用相应的权限，那么创建Window的时候就会报错， 流程分析WindowManager实现了ViewManager接口，ViewManager接口提供以下三个方法： 123public void addView(View view, ViewGroup.LayoutParams params);public void updateViewLayout(View view, ViewGroup.LayoutParams params);public void removeView(View view); addView过程WindowManager在Android中的实现类为WindowManagerImpl，WindowManagerImpl内部使用桥接模式封装了WindowManagerGlobal。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//WindowManagerGlobal.javapublic void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(&quot;view must not be null&quot;); &#125; if (display == null) &#123; throw new IllegalArgumentException(&quot;display must not be null&quot;); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there&#x27;s no parent, then hardware acceleration for this view is // set from the application&#x27;s hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; // Start watching for system property changes. if (mSystemPropertyUpdater == null) &#123; mSystemPropertyUpdater = new Runnable() &#123; @Override public void run() &#123; synchronized (mLock) &#123; for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123; mRoots.get(i).loadSystemProperties(); &#125; &#125; &#125; &#125;; SystemProperties.addChangeCallback(mSystemPropertyUpdater); &#125; int index = findViewLocked(view, false);//判断是否已经添加 if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don&#x27;t wait for MSG_DIE to make it&#x27;s way through root&#x27;s queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView);//PhoneWindow要开始创建 &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125;&#125; mViews存储的是所有Window所对应的View，mRoots存储的是所有Window所对应的ViewRootImpl，mParams存储的是所有Window所对应的布局参数，mDyingViews则存储了那些正在被删除的View对象，或者说是那些已经调用removeView方法但是删除操作还未完成的Window对象。 总结如下： 检查参数是否合法，如果是子Window那么还需要调整一些布局参数 创建ViewRootImpl并将View添加到列表中 通过ViewRootImpl来更新界面并完成Window的添加过程 在setView内部会通过requestLayout来完成异步刷新请求 WindowSession最终来完成Window的添加过程 在Session内部会通过WindowManagerService来实现Window的添加 removeView过程updateView过程Window的创建过程Activity的Window创建过程由Activity工作过程可知，Activity启动时会调用ActivityThread的performLaunchActivity方法来完成整个启动流程。 performLaunchActivity会调用Activity的attach方法。在这个方法里，会创建PhoneWindow对象。 接下来看看setContentView做了哪些事情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//PhoneWindow.javapublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125;private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); ...&#125;protected DecorView generateDecor(int featureId) &#123; // System process doesn&#x27;t have application context and in that case we need to directly use // the context we have. Otherwise we want the application context, so we don&#x27;t cling to the // activity. Context context; if (mUseDecorContext) &#123; Context applicationContext = getContext().getApplicationContext(); if (applicationContext == null) &#123; context = getContext(); &#125; else &#123; context = new DecorContext(applicationContext, getContext()); if (mTheme != -1) &#123; context.setTheme(mTheme); &#125; &#125; &#125; else &#123; context = getContext(); &#125; return new DecorView(context, featureId, this, getAttributes());&#125; 大致步骤如下： 如果没有DecorView，那么就创建它 将View添加到DecorView的mContentParent中 回调Activity的onContentChanged方法通知Activity视图已经发生改变 ActivityThread中的handleResumeActivity只通过WindowManager添加视图到DecorView中 参考 《Android开发艺术探索》 https://juejin.cn/post/6844904073586556935 https://blog.csdn.net/hzw19920329/article/details/52423771","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"View的基本概念","date":"2022-03-08T02:25:29.637Z","path":"wiki/Android/基础/View的基本概念/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"View的事件分发机制","date":"2022-03-08T02:25:29.637Z","path":"wiki/Android/基础/View的事件分发机制/","text":"分发过程事件分发过程由三个方法共同完成： dispatchTouchEvent方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件，返回为false表示交给父类的onTouchEvent处理。 onInterceptTouchEvent方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 如果该View存在子View且点击到了该子View, 则不拦截, 继续分发给子View处理, 此时相当于return false。 如果该View没有子View或者有子View但是没有点击中子View(此时ViewGroup 相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。 注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。 onTouchEvent方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况： 如果该View是clickable或者longclickable的,则会返回true, 表示消费了该事件, 与返回true一样; 如果该View不是clickable或者longclickable的,则会返回false, 表示不消费该事件,将会向上传递,与返回false一样。 注意：在Android系统中，拥有事件传递处理能力的类有以下三种： Activity：拥有分发和消费两个方法。 ViewGroup：拥有分发、拦截和消费三个方法。 View：拥有分发、消费两个方法。 三个方法的关系用伪代码表示如下： 12345678910public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; coonsume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 通过上面的伪代码，我们可以大致了解点击事件的传递规则：对应一个根ViewGroup来说，点击事件产生后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会返回true消耗这个事件。如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。 一些重要的结论： 事件传递优先级：onTouchListener.onTouch &gt; onTouchEvent &gt; onClickListener.onClick。 正常情况下，一个时间序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。特例：通过将重写View的onTouchEvent返回false可强行将事件转交给其他View处理。 如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件（返回false）。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。 View的enable属性不影响onTouchEvent的默认返回值。 通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 ACTION_CANCEL什么时候触发，触摸button然后滑动到外部抬起会触发点击事件吗，再滑动回去抬起会么？ 一般ACTION_CANCEL和ACTION_UP都作为View一段事件处理的结束。如果在父View中拦截ACTION_UP或ACTION_MOVE，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到ACTION_CANCEL事件。如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现action_cancel。 点击事件被拦截，但是想传到下面的View，如何操作？ 重写子类的requestDisallowInterceptTouchEvent()方法返回true就不会执行父类的onInterceptTouchEvent()，即可将点击事件传到下面的View。 如何解决View的事件冲突？举个开发中遇到的例子？ 常见开发中事件冲突的有ScrollView与RecyclerView的滑动冲突、RecyclerView内嵌同时滑动同一方向。 滑动冲突的处理规则： 对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。 对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件，何时由内部View拦截事件。 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。 滑动冲突的实现方法： 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent方法。 参考","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"View的工作流程","date":"2022-03-08T02:25:29.637Z","path":"wiki/Android/基础/View的工作流程/","text":"DecorView是视图的顶级View，我们添加的布局文件是它的一个子布局，而ViewRootImpl则负责渲染视图，它调用了一个performTraveals方法使得ViewTree开始三大工作流程，然后使得View展现在我们面前。 绘制的流程概要 注意：这里的三个步骤是每次从根视图到最上层视图依次执行完，再进行下一步骤。 三个步骤： 测量（measure）：测量视图大小。从顶层父View到子View递归调用measure方法，measure方法又回调OnMeasure。 布局（layout）：确定View位置，进行页面布局。从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。 绘制（draw）：绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤： 绘制视图的背景； 保存画布的图层（Layer）； 绘制View的内容； 绘制View子视图，如果没有就不用； 还原图层（Layer）； 绘制滚动条 绘制从ViewRootImpl的performTraversals()方法开始，从上到下遍历整个视图树，每个View控件负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。 12345678910111213141516private void performTraversals() &#123; ... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ... //执行测量流程 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... //执行布局流程 performLayout(lp, desiredWindowWidth, desiredWindowHeight); ... //执行绘制流程 performDraw();&#125; measureMeasureSpecMeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。 mode的模式分为： EXACTLY：对应LayoutParams中的match_parent和具体数值这两种模式。检测到View所需要的精确大小，这时候View的最终大小就是SpecSize所指定的值， AT_MOST ：对应LayoutParams中的wrap_content。View的大小不能大于父容器的大小。 UNSPECIFIED ：不对View进行任何限制，要多大给多大，一般用于系统内部，如ListView，ScrollView 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** * UNSPECIFIED 模式： * 父View不对子View有任何限制，子View需要多大就多大 */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * EXACTYLY 模式： * 父View已经测量出子Viwe所需要的精确大小，这时候View的最终大小 * 就是SpecSize所指定的值。对应于match_parent和精确数值这两种模式 */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * AT_MOST 模式： * 子View的最终大小是父View指定的SpecSize值，并且子View的大小不能大于这个值， * 即对应wrap_content这种模式 */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; //将size和mode打包成一个32位的int型数值 //高2位表示SpecMode，测量模式，低30位表示SpecSize，某种测量模式下的规格大小 public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; //将32位的MeasureSpec解包，返回SpecMode,测量模式 public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; //将32位的MeasureSpec解包，返回SpecSize，某种测量模式下的规格大小 public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; //... &#125; ViewGroup的measure由于DecorView继承自FrameLayout，是PhoneWindow的一个内部类，而FrameLayout没有measure方法，因此调用的是父类View的measure方法。 View的measurelayoutView的layout流程123456789101112131415161718192021222324// ViewRootImpl.javaprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...&#125;// View.javapublic void layout(int l, int t, int r, int b) &#123; ... // 通过setFrame方法来设定View的四个顶点的位置，即View在父容器中的位置 boolean changed = isLayoutModeOptical(mParent) ? set OpticalFrame(l, t, r, b) : setFrame(l, t, r, b); ... onLayout(changed, l, t, r, b); ...&#125;// 空方法，子类如果是ViewGroup类型，则重写这个方法，实现ViewGroup// 中所有View控件布局流程protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; Layout的onLayout12345678910111213141516171819202122232425262728293031323334353637383940414243protected void onlayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l,) &#125;&#125;// layoutVertical核心源码void layoutVertical(int left, int top, int right, int bottom) &#123; ... final int count = getVirtualChildCount(); for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasureWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); ... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; // 为子元素确定对应的位置 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); // childTop会逐渐增大，意味着后面的子元素会被 // 放置在靠下的位置 childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child,i) &#125; &#125;&#125;private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height);&#125; draw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void performDraw() &#123; ... draw(fullRefrawNeeded); ...&#125;private void draw(boolean fullRedrawNeeded) &#123; ... if (!drawSoftware(surface, mAttachInfo, xOffest, yOffset, scalingRequired, dirty)) &#123; return; &#125; ...&#125;private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scallingRequired, Rect dirty) &#123; ... mView.draw(canvas); ...&#125;// 绘制基本上可以分为六个步骤public void draw(Canvas canvas) &#123; ... // 步骤一：绘制View的背景 drawBackground(canvas); ... // 步骤二：如果需要的话，保持canvas的图层，为fading做准备 saveCount = canvas.getSaveCount(); ... canvas.saveLayer(left, top, right, top + length, null, flags); ... // 步骤三：绘制View的内容 onDraw(canvas); ... // 步骤四：绘制View的子View dispatchDraw(canvas); ... // 步骤五：如果需要的话，绘制View的fading边缘并恢复图层 canvas.drawRect(left, top, right, top + length, p); ... canvas.restoreToCount(saveCount); ... // 步骤六：绘制View的装饰(例如滚动条等等) onDrawForeground(canvas)&#125; 常见问题如何在onCreate中获取View的高宽12345678910111213141516171819202122//方法1：view.post(new Runnable() &#123; @Override public void run() &#123; int width = view.getWidth(); int measuredWidth = view.getMeasuredWidth(); Log.i(TAG, &quot;width: &quot; + width); Log.i(TAG, &quot;measuredWidth: &quot; + measuredWidth); &#125; &#125;);//方法2：ViewTreeObserver vto = view.getViewTreeObserver(); vto.addOnGlobalLayoutListener(new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeGlobalOnLayoutListener(this); Log.i(TAG, &quot;width: &quot; + view.getWidth()); Log.i(TAG, &quot;height: &quot; + view.getHeight()); &#125; &#125;); 参考 https://jsonchao.github.io/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Handler基本用法","date":"2022-03-08T02:25:29.636Z","path":"wiki/Android/基础/Handler基本用法/","text":"Hanlder系列目录： Handler基本用法 Handler原理 概要A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instanceis associated with a single thread and that thread’s message queue. When you create a new Handler it is bound to a Looper.It will deliver messages and runnables to that Looper’s message queue and execute them on that Looper’s thread. There are two main uses for a Handler: (1) to schedule messages and runnables to be executed at some point in the future;and (2) to enqueue an action to be performed on a different thread than your own. Scheduling messages is accomplished with the post(Runnable), postAtTime(java.lang.Runnable, long),postDelayed(Runnable, Object, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long), andsendMessageDelayed(Message, long) methods. The post versions allow you to enqueue Runnable objects to be called by themessage queue when they are received; the sendMessage versions allow you to enqueue a Message object containing a bundleof data that will be processed by the Handler’s handleMessage(Message) method (requiring that you implement a subclass of Handler). When posting or sending to a Handler, you can either allow the item to be processed as soon as the message queue is readyto do so, or specify a delay before it gets processed or absolute time for it to be processed. The latter two allow youto implement timeouts, ticks, and other timing-based behavior. When a process is created for your application, its main thread is dedicated to running a message queue that takes careof managing the top-level application objects (activities, broadcast receivers, etc) and any windows they create. Youcan create your own threads, and communicate back with the main application thread through a Handler. This is done bycalling the same post or sendMessage methods as before, but from your new thread. The given Runnable or Message will thenbe scheduled in the Handler’s message queue and processed when appropriate. Handler用于Android中的线程通信。主要的用于在异步线程中发送Message或者直接运行一个Runnable，即可回到主线程执行UI操作。Handler在哪个线程初始化，则它依附在哪个线程。Activity中有一个runOnUiThread方法，封装了Handler可以直接在异步线程中使用。Handler也可以延迟执行。 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.lqd.androidpractice.handler;import android.app.Activity;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.util.Log;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import com.lqd.androidpractice.R;import org.jetbrains.annotations.NotNull;import java.lang.ref.WeakReference;/** * handler 使用实例 * * 在异步线程发送消息到主线程刷新UI * * @author: a564 * @Date 2021/6/7 */public class HandlerActivity extends Activity &#123; private static String TAG = &quot;HandlerActivity&quot;; private TextView textView; private MyHandler myHandler; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler); textView = findViewById(R.id.ah_textview); findViewById(R.id.ah_btn1).setOnClickListener(v -&gt; &#123; new Thread() &#123; @Override public void run() &#123; super.run(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.d(TAG, Thread.currentThread().getStackTrace()[2].getMethodName()); Message msg = Message.obtain(); msg.what = 1; // 消息标识 msg.obj = &quot;A&quot;; // 消息内存存放 myHandler.sendMessage(msg); // 异步线程发送消息 //使用post myHandler.post(new Runnable() &#123; @Override public void run() &#123; //回到UI线程 &#125; &#125;); &#125; &#125;.start(); &#125;); myHandler = new MyHandler(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); myHandler.removeCallbacksAndMessages(null);//跟随Activity销毁 myHandler = null; &#125; //静态内部类 private static class MyHandler extends Handler &#123; //弱引用 WeakReference&lt;HandlerActivity&gt; activityWeakReference; public MyHandler(HandlerActivity activity) &#123; activityWeakReference = new WeakReference&lt;HandlerActivity&gt;(activity); &#125; @Override public void handleMessage(@NonNull @NotNull Message msg) &#123; super.handleMessage(msg); Log.d(TAG, Thread.currentThread().getStackTrace()[2].getMethodName()); Log.d(TAG, msg.toString()); HandlerActivity activity = activityWeakReference.get(); if (activity == null) return; switch (msg.what) &#123; case 1: activity.textView.setText(&quot;执行了线程1的UI操作&quot;); break; case 2: activity.textView.setText(&quot;执行了线程2的UI操作&quot;); break; &#125; &#125; &#125;;&#125; HandlerThread顾名思义，HandlerThread使得Thread拥有的Handler的特性，可以在此线程中进行消息的分发和处理。使用场景也是创建异步线程并有数据交互。我们也可以将其封装成一个工具类，这样不需要每次都new一个线程出来，方便使用且节省性能。 123456789101112131415161718192021222324252627282930313233343536373839class BackgroundHandlerThread &#123; private static class Holder&#123; private static BackgroundHandlerThread _instance = new BackgroundHandlerThread(); static&#123; _instance.init(); &#125; &#125; public static BackgroundHandlerThread getInstance()&#123; return Holder._instance; &#125; private HandlerThread mHandlerThread; private Handler mHandler; private void init()&#123; //HandlerThread的第二个参数为线程优先级 mHandlerThread = new HandlerThread(BackgroundHandlerThread.class.getSimpleName()); mHandlerThread.start(); mHandler = new Handler(mHandlerThread.getLooper())&#123; @Override public void handleMessage(Message msg) &#123; &#125; &#125;; &#125; public Looper getLooper()&#123; return mHandlerThread.getLooper(); &#125; public Handler getHandler()&#123; return this.mHandler; &#125;&#125;// 当需要异步执行的地方可以直接使用下面的代码BackgroundHandlerThread.getInstance().getHandler().post(Runnable) API介绍sendMessage(Message message) 发送消息到消息队列 post(Runnable runable) 把一个Runnable对象添加到消息队列中，这个方法会在对应Looper的线程中运行。 dispatchMessage(Message msg) 将消息分发给对应的Handler handleMessage 根据某个消息类型进行处理 参考 https://developer.android.com/reference/android/os/Handler 详解 Android 中的 HandlerThread","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Intent","date":"2022-03-08T02:25:29.636Z","path":"wiki/Android/基础/Intent/","text":"介绍Intent是一个消息传递对象，他的作用： 启动Activity。不同的业务场景启动Activity又分为显示调用和隐式调用。 启动Service 传递广播 Intent的属性有:component(组件)、action、category、data、type、extras、flags;所有的属性也是各显神通，满足开发者的各种需要满足不同场景; component: 显然就是设置四大组件的， 将直接使用它指定的组件，借助这一属性可以实现不同应用组件之间通讯; action: 是一个可以 指定目标组件行为的字符串，开发人员可以自定义action通过匹配action实现组件之间的隐式跳转，当然Android系统也已经预定部分String作为系统应用Action，例如打开系统设置页面等等; data: 通常是URI类型或者MIME类型格式定义的操作数据;表示与动作要操纵的数据 Category: 属性用于指定当前动作(Action)被执行的环境; type: 对于data范例的描写; Intent.setFlags(int flags)设置启动模式 FLAG_ACTIVITY_CLEAR_TOP : 等同于mainfest中配置的singleTask FLAG_ACTIVITY_SINGLE_TOP: 同样等同于mainfest中配置的singleTop; FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS: 其对应在AndroidManifest中的属性为android:excludeFromRecents&#x3D;“true”,当用户按了“最近任务列表”时候,该Task不会出现在最近任务列表中，可达到隐藏应用的目的。 FLAG_ACTIVITY_NO_HISTORY: 对应在AndroidManifest中的属性为:android:noHistory&#x3D;“true”，这个FLAG启动的Activity，一旦退出，它不会存在于栈中。 FLAG_ACTIVITY_NEW_TASK : 这个属性需要在被start的目标Activity在AndroidManifest.xml文件 配置taskAffinity的值【必须和startActivity发其者Activity的包名不一样，如果是跳转另一个 App的话可以taskAffinity可以省略】，则会在新标记的Affinity所存在的taskAffinity中压入这个Activity。 参考 Intent和Intent过滤器","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Service工作过程","date":"2022-03-08T02:25:29.636Z","path":"wiki/Android/基础/Service工作过程/","text":"概述Service是一种计算型组件，其生命是嵌套在主线程中的。Service有两种状态：启动状态和绑定状态，并且只能显示启动，因此在AndroidManifest.xml中注册Service时，只需要注册服务的类名即可。启动状态和绑定状态的区别在于：启动之后，Service的动作不受Activity的控制；而绑定之后，Service的动作是由Activity控制的。在实现Service时，需要继承Service抽象类，并且重写onCreat()方法，因此，Service也具有启动和停止的概念。 Service是Android四大组件之一，用于执行长时间运行且不需要用户交互的任务。即使应用被销毁也依然可以工作。组件可通过绑定到服务与之进行交互，甚至是执行进程间通信 (IPC)。例如，服务可在后台处理网络事务、播放音乐，执行文件 I&#x2F;O 或与内容提供程序进行交互。 Service分为以下几种不同的类型： 前台：前台服务必须显示通知（Notification），可以跟用户交互，比如播放音乐。 后台：用户无感知，可以做一些数据存储之类的事情。 绑定：使用bindService进行绑定。此种类型方便与其他组件进行交互。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 服务既可以是启动服务（以无限期运行），也支持绑定。唯一的问题在于是否实现一组回调方法：onStartCommand()（让组件启动服务）和 onBind()（实现服务绑定）。 基本使用Service的使用跟Activity类似，需要先在清单文件中声明，然后使用Context启动（startService(Intent)）或绑定服务。服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非在清单文件中配置）。如果有耗时操作，则可以在服务内创建线程来处理。 API 方法 描述 onStartCommand() 其他组件(如活动)通过调用startService()来请求启动服务时，系统调用该方法。如果你实现该方法，你有责任在工作完成时通过stopSelf()或者stopService()方法来停止服务。 onBind 当其他组件想要通过bindService()来绑定服务时，系统调用该方法。如果你实现该方法，你需要返回IBinder对象来提供一个接口，以便客户来与服务通信。你必须实现该方法，如果你不允许绑定，则直接返回null。 onUnbind() 当客户中断所有服务发布的特殊接口时，系统调用该方法。 onRebind() 当新的客户端与服务连接，且此前它已经通过onUnbind(Intent)通知断开连接时，系统调用该方法。 onCreate() 当服务通过onStartCommand()和onBind()被第一次创建的时候，系统调用该方法。该调用要求执行一次性安装。 onDestroy() 当服务不再有用或者被销毁时，系统调用该方法。你的服务需要实现该方法来清理任何资源，如线程，已注册的监听器，接收器等。 如果组件通过调用 startService() 启动服务（这会引起对 onStartCommand() 的调用），则服务会一直运行，直到其使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 将其停止为止。 如果组件通过调用 bindService() 来创建服务，且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。当该服务与其所有组件取消绑定后，系统便会将其销毁。 onStartCommand的注意事项1public @StartResult int onStartCommand(Intent intent, @StartArgFlags int flags, int startId)&#123;&#125; 参数 intent 启动时传入的参数，当Service重启时可能为空 flags 0：正常创建 START_FLAG_REDELIVERY：onStartCommand返回的是START_REDELIVER_INTENT，并且Service被系统清理掉了，那么重新创建Service，调用onStartCommand的时候，传入的intent不为null，而传入的flags就是START_FLAG_REDELIVERY START_FLAG_RETRY：如果Service创建过程中，onStartCommand方法未被调用或者没有正常返回的异常情况下， 再次尝试创建，传入的flags就为START_FLAG_RETRY 。 startId 用来代表这个唯一的启动请求。我们可以在stopSelfResult(int startId)中传入这个startId，用来终止Service。 返回值 START_STICKY：如果Service所在的进程，在执行了onStartCommand方法后，被清理了，那么这个Service会被保留在已开始的状态，但是不保留传入的Intent，随后系统会尝试重新创建此Service，由于服务状态保留在已开始状态，所以创建服务后一定会调用onStartCommand方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null，需要我们小心处理。 START_NOT_STICKY：如果Service所在的进程，在执行了onStartCommand方法后，被清理了，则系统不会重新启动此Service。 START_REDELIVER_INTENT：如果Service所在的进程，在执行了onStartCommand方法后，被清理了，则结果和START_STICKY一样，也会重新创建此Service并调用onStartCommand方法。不同之处在于，如果是返回的是START_REDELIVER_INTENT ，则重新创建Service时onStartCommand方法会传入之前的intent。 START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但是不能保证被清理后onStartCommand方法一定会被重新调用。 生命周期 源码分析Service的启动方式是Context.startService(Intent service)。而Context的实现类为ContextImpl 12345678910111213141516171819202122232425262728293031323334@Overridepublic ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, false, mUser);&#125;private ComponentName startServiceCommon(Intent service, boolean requireForeground, UserHandle user) &#123; try &#123; validateServiceIntent(service); service.prepareToLeaveProcess(this); ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), requireForeground, getOpPackageName(), user.getIdentifier()); if (cn != null) &#123; if (cn.getPackageName().equals(&quot;!&quot;)) &#123; throw new SecurityException( &quot;Not allowed to start service &quot; + service + &quot; without permission &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123; throw new SecurityException( &quot;Unable to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;?&quot;)) &#123; throw new IllegalStateException( &quot;Not allowed to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; &#125; return cn; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 由以上代码可知，调用了AMS中的startService方法 1234567891011121314151617181920212223242526272829303132@Overridepublic ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, boolean requireForeground, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(&quot;startService&quot;); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;); &#125; if (callingPackage == null) &#123; throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;); &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;*** startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; fg=&quot; + requireForeground); synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res; try &#123; res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, requireForeground, callingPackage, userId); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return res; &#125;&#125; 这里的mServices为ActiveServices，它是用来对Service进行管理的。我们进去看看startServiceLocked 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId) throws TransactionTooLargeException &#123; return startServiceLocked(caller, service, resolvedType, callingPid, callingUid, fgRequired, callingPackage, userId, false);&#125;ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId, boolean allowBackgroundActivityStarts) throws TransactionTooLargeException &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; args=&quot; + service.getExtras()); ... if (allowBackgroundActivityStarts) &#123; r.whitelistBgActivityStartsOnServiceStart(); &#125; ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting); return cmp;&#125;ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123; ServiceState stracker = r.getTracker(); ... String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false); if (error != null) &#123; return new ComponentName(&quot;!!&quot;, error); &#125; ... return r.name;&#125;private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123; ... if (!isolated) &#123; app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid + &quot; app=&quot; + app); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats); realStartServiceLocked(r, app, execInFg); return null; &#125; catch (TransactionTooLargeException e) &#123; throw e; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortInstanceName, e); &#125; &#125; &#125; else &#123; app = r.isolatedProc; if (WebViewZygote.isMultiprocessEnabled() &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123; hostingRecord = HostingRecord.byWebviewZygote(r.instanceName); &#125; if ((r.serviceInfo.flags &amp; ServiceInfo.FLAG_USE_APP_ZYGOTE) != 0) &#123; hostingRecord = HostingRecord.byAppZygote(r.instanceName, r.definingPackageName, r.definingUid); &#125; &#125; ... return null;&#125; private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; r.setProcess(app);//绑定进程...try &#123; if (LOG_SERVICE_START_STOP) &#123; String nameTerm; int lastPeriod = r.shortInstanceName.lastIndexOf(&#x27;.&#x27;); nameTerm = lastPeriod &gt;= 0 ? r.shortInstanceName.substring(lastPeriod) : r.shortInstanceName; EventLogTags.writeAmCreateService( r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid); &#125; StatsLog.write(StatsLog.SERVICE_LAUNCH_REPORTED, r.appInfo.uid, r.name.getPackageName(), r.name.getClassName()); synchronized (r.stats.getBatteryStats()) &#123; r.stats.startLaunchedLocked(); &#125; mAm.notifyPackageUse(r.serviceInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_SERVICE); app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo), app.getReportedProcState()); r.postNotification(); created = true;&#125; catch (DeadObjectException e) &#123; Slog.w(TAG, &quot;Application dead when creating service &quot; + r); mAm.appDiedLocked(app); throw e;&#125; finally &#123; &#125;... sendServiceArgsLocked(r, execInFg, true);//执行onStartCommand过程&#125;private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg, boolean oomAdjusted) throws TransactionTooLargeException &#123; ... Exception caughtException = null; try &#123; r.app.thread.scheduleServiceArgs(r, slice); //调用ActivityThread &#125; catch (TransactionTooLargeException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Transaction too large for &quot; + args.size() + &quot; args, first: &quot; + args.get(0).args); Slog.w(TAG, &quot;Failed delivering service starts&quot;, e); caughtException = e; &#125; catch (RemoteException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while sending args: &quot; + r); Slog.w(TAG, &quot;Failed delivering service starts&quot;, e); caughtException = e; &#125; catch (Exception e) &#123; Slog.w(TAG, &quot;Unexpected exception&quot;, e); caughtException = e; &#125; ...&#125; 由以上代码可知，startServiceLocked调用了startServiceInnerLocked，startServiceInnerLocked调用了bringUpServiceLocked，bringUpServiceLocked调用了realStartServiceLocked，realStartServiceLocked调用了ActivityThread的scheduleCreateService。且realStartServiceLocked还会调用sendServiceArgsLocked，sendServiceArgsLocked调用ActivityThread的scheduleServiceArgs，这里会启动onStartCommand 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s);&#125;public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; ... case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SERVICE_ARGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceStart: &quot; + String.valueOf(msg.obj))); handleServiceArgs((ServiceArgsData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ...&#125;private void handleCreateService(CreateServiceData data) &#123; //创建对象 LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; ClassLoader cl = packageInfo.getClassLoader(); //创建service对象 service = packageInfo.getAppFactory() .instantiateService(cl, data.info.name, data.intent); &#125; catch (Exception e) &#123;&#125; try &#123; //创建上下文 ContextImpl context = ContextImpl.createAppContext(this, packageInfo); //关联service对象 context.setOuterContext(service); //获取Application对象 Application app = packageInfo.makeApplication(false, mInstrumentation); //关联上下文和Application对象 service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); service.onCreate(); //data.token都是ServiceRecord，它是binder对象，token与service建立映射关系存储在mServices的map中 mServices.put(data.token, service); &#125; catch (Exception e) &#123;&#125;&#125; //onStartCommand流程 public final void scheduleServiceArgs(IBinder token, ParceledListSlice args) &#123; List&lt;ServiceStartArgs&gt; list = args.getList(); for (int i = 0; i &lt; list.size(); i++) &#123; ServiceStartArgs ssa = list.get(i); ServiceArgsData s = new ServiceArgsData(); s.token = token; s.taskRemoved = ssa.taskRemoved; s.startId = ssa.startId; s.flags = ssa.flags; s.args = ssa.args; sendMessage(H.SERVICE_ARGS, s); &#125;&#125; private void handleServiceArgs(ServiceArgsData data) &#123; Service s = mServices.get(data.token); if (s != null) &#123; try &#123; if (data.args != null) &#123; data.args.setExtrasClassLoader(s.getClassLoader()); data.args.prepareToEnterProcess(); &#125; int res; if (!data.taskRemoved) &#123; res = s.onStartCommand(data.args, data.flags, data.startId);//运行了onStartCommand方法 &#125; else &#123; s.onTaskRemoved(data.args); res = Service.START_TASK_REMOVED_COMPLETE; &#125; QueuedWork.waitToFinish(); try &#123; ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_START, data.startId, res); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( &quot;Unable to start service &quot; + s + &quot; with &quot; + data.args + &quot;: &quot; + e.toString(), e); &#125; &#125; &#125;&#125; 由以上代码可知 scheduleCreateService发送了CREATE_SERVICE消息。ActivityThread的内部类H处理此消息，在handleCreateService方法中，运行了Service的onCreate方法。 scheduleServiceArgs发送了SERVICE_ARGS的消息。在handleServiceArgs中处理，调用了onStartCommand方法 流程图 关于Service保活应该是利用service的机制，当service下一次重新创建时判断应用中的某些场景是否也可以跟着一起恢复。比如直播房间。 参考 Android 10 Service 工作过程 《Android开发艺术探索》 https://developer.android.com/guide/components/services?hl=zh-cn","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Fragment工作过程","date":"2022-03-08T02:25:29.634Z","path":"wiki/Android/基础/Fragment工作过程/","text":"常见类的介绍 ActivityThread : 入口类 Instrumentation : ActivityThread 的得力助手，帮助 ActivityThread 触发 Activity 的生命周期 MainActivity : 就是上文提到例子中的 MainActivity 类，继承自 Activity HostCallbacks : Activity 的内部类，继承自 FragmentHostCallback FragmentHostCallback : 持有 Handler、FragmentManagerImpl 等对象的引用，别的对象可以通过持有它的引用间接控制 FragmentManagerImpl 等对象 FragmentController : Activity 通过控制它间接向 FragmentManagerImpl 发出命令 FragmentManagerImpl : 继承自 FragmentManager，用来对 Fragment 进行管理，在 FragmentHostCallback 中被初始化 BackStackRecord : 继承自 FragmentTransation 并实现了 Runnable，每次调用 FragmentManager 对象的 beginTransaction() 方法都会产生一个 BackStackRecord 对象，可以将其理解为对 Fragment 的一系列操作（即事务） Op : 每次对 Fragment 的操作都会产生一个 Op 对象，其表示双向链表的一个结点 启动流程根据Activity工作过程可知，启动一个Activity会来到ActivityThreadp的erformLaunchActivity方法。在这个方法中 12345678910111213141516171819202122232425262728293031323334353637//ActivityThreadprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); .... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; &#125;//ActivitymFragments.attachHost(null /*parent*/);//FragmentControllerpublic void attachHost(Fragment parent) &#123; mHost.mFragmentManager.attachController( mHost, mHost /*container*/, parent);&#125;/FragmentManagerImplpublic void attachController(FragmentHostCallback&lt;?&gt; host, FragmentContainer container, Fragment parent) &#123; if (mHost != null) throw new IllegalStateException(&quot;Already attached&quot;); mHost = host;//FragmentManagerImpl 对象持有了 HostCallbacks 对象的引用 mContainer = container; mParent = parent;&#125; attach的流程： attach---&gt;attachHost---&gt;attachController 然后是callActivityOnCreate： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//ActivityThreadprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125;&#125;//Instrumentationpublic void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) &#123; prePerformCreate(activity); activity.performCreate(icicle, persistentState); postPerformCreate(activity);&#125;//Activityfinal void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; dispatchActivityPreCreated(icicle); mCanEnterPictureInPicture = true; restoreHasCurrentPermissionRequest(icicle); if (persistentState != null) &#123; onCreate(icicle, persistentState); &#125; else &#123; onCreate(icicle); &#125; writeEventLog(LOG_AM_ON_CREATE_CALLED, &quot;performCreate&quot;); mActivityTransitionState.readState(icicle); mVisibleFromClient = !mWindow.getWindowStyle().getBoolean( com.android.internal.R.styleable.Window_windowNoDisplay, false); mFragments.dispatchActivityCreated(); mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); dispatchActivityPostCreated(icicle);&#125;//FragmentControllerpublic void dispatchActivityCreated() &#123; mHost.mFragmentManager.dispatchActivityCreated();&#125;/FragmentManagerImplpublic void dispatchActivityCreated() &#123; this.mStateSaved = false; this.mStopped = false; this.dispatchStateChange(2);&#125;/FragmentManagerImplvoid moveToState(int newState, boolean always) &#123;...&#125; callActivityOnCreate的流程： callActivityOnCreate---&gt;callActivityOnCreate---&gt;performCreate---&gt;dispatchActivityCreated---&gt;moveToState Fragment的操作原理Fragment的一般操作如下： 12345fragmentManager = getSupportFragmentManager();transaction = fragmentManager.beginTransaction();transaction.replace(R.id.testFragment, fragment);transaction.addToBackStack(null);transaction.commit(); getSupportFragmentManager方法直接返回FragmentManagerImpl。 beginTransaction方法返回一个BackStackRecord对象，BackStackRecord对象代表一系列对Fragment的操作，即事务。 replacereplace方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//BackStackRecordpublic FragmentTransaction replace(int containerViewId, Fragment fragment, @Nullable String tag) &#123; //判断容器id是否有效 if (containerViewId == 0) &#123; throw new IllegalArgumentException(&quot;Must use non-zero containerViewId&quot;); &#125; doAddOp(containerViewId, fragment, tag, OP_REPLACE); return this;&#125;private void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) &#123; final Class fragmentClass = fragment.getClass(); final int modifiers = fragmentClass.getModifiers(); if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() &amp;&amp; !Modifier.isStatic(modifiers))) &#123; throw new IllegalStateException(&quot;Fragment &quot; + fragmentClass.getCanonicalName() + &quot; must be a public static class to be properly recreated from&quot; + &quot; instance state.&quot;); &#125; fragment.mFragmentManager = mManager; if (tag != null) &#123; if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) &#123; throw new IllegalStateException(&quot;Can&#x27;t change tag of fragment &quot; + fragment + &quot;: was &quot; + fragment.mTag + &quot; now &quot; + tag); &#125; fragment.mTag = tag; &#125; if (containerViewId != 0) &#123; if (containerViewId == View.NO_ID) &#123; throw new IllegalArgumentException(&quot;Can&#x27;t add fragment &quot; + fragment + &quot; with tag &quot; + tag + &quot; to container view with no id&quot;); &#125; if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) &#123; throw new IllegalStateException(&quot;Can&#x27;t change container ID of fragment &quot; + fragment + &quot;: was &quot; + fragment.mFragmentId + &quot; now &quot; + containerViewId); &#125; fragment.mContainerId = fragment.mFragmentId = containerViewId; &#125; //生成一个节点 addOp(new Op(opcmd, fragment));&#125;void addOp(Op op) &#123; mOps.add(op); op.enterAnim = mEnterAnim; op.exitAnim = mExitAnim; op.popEnterAnim = mPopEnterAnim; op.popExitAnim = mPopExitAnim;&#125; replace主要是生成一个双向链表的节点。 commit最后就是commit 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280//BackStackStateint commitInternal(boolean allowStateLoss) &#123; if (mCommitted) throw new IllegalStateException(&quot;commit already called&quot;); if (FragmentManagerImpl.DEBUG) &#123; Log.v(TAG, &quot;Commit: &quot; + this); LogWriter logw = new LogWriter(TAG); PrintWriter pw = new PrintWriter(logw); dump(&quot; &quot;, null, pw, null); pw.close(); &#125; mCommitted = true; if (mAddToBackStack) &#123; mIndex = mManager.allocBackStackIndex(this); &#125; else &#123; mIndex = -1; &#125; mManager.enqueueAction(this, allowStateLoss); return mIndex;&#125;//FragmentManagerpublic void enqueueAction(OpGenerator action, boolean allowStateLoss) &#123; if (!allowStateLoss) &#123; checkStateLoss(); &#125; synchronized (this) &#123; if (mDestroyed || mHost == null) &#123; if (allowStateLoss) &#123; // This FragmentManager isn&#x27;t attached, so drop the entire transaction. return; &#125; throw new IllegalStateException(&quot;Activity has been destroyed&quot;); &#125; if (mPendingActions == null) &#123; mPendingActions = new ArrayList&lt;&gt;(); &#125; mPendingActions.add(action);//保存BackStackState scheduleCommit(); &#125;&#125;void scheduleCommit() &#123; synchronized (this) &#123; boolean postponeReady = mPostponedTransactions != null &amp;&amp; !mPostponedTransactions.isEmpty(); boolean pendingReady = mPendingActions != null &amp;&amp; mPendingActions.size() == 1; if (postponeReady || pendingReady) &#123; mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); &#125; &#125;&#125;Runnable mExecCommit = new Runnable() &#123; @Override public void run() &#123; execPendingActions(); &#125;&#125;;public boolean execPendingActions() &#123; ensureExecReady(true); boolean didSomething = false; while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123; mExecutingActions = true; try &#123; removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop); &#125; finally &#123; cleanupExec(); &#125; didSomething = true; &#125; doPendingDeferredStart(); burpActive(); return didSomething;&#125;private boolean generateOpsForPendingActions(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isPop) &#123; boolean didSomething = false; synchronized (this) &#123; if (mPendingActions == null || mPendingActions.size() == 0) &#123; return false; &#125; final int numActions = mPendingActions.size(); for (int i = 0; i &lt; numActions; i++) &#123; didSomething |= mPendingActions.get(i).generateOps(records, isPop);//添加到回退栈中 &#125; mPendingActions.clear(); mHost.getHandler().removeCallbacks(mExecCommit); &#125; return didSomething;&#125;private void removeRedundantOperationsAndExecute(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop) &#123; ... executePostponedTransaction(records, isRecordPop); ... executeOpsTogether(records, isRecordPop, recordNum, reorderingEnd); ... &#125;private void executeOpsTogether(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop, int startIndex, int endIndex) &#123; ... oldPrimaryNav = record.expandOps(mTmpAddedFragments, oldPrimaryNav);//OP_REPLACE会从这里触发 ... executeOps(records, isRecordPop, startIndex, endIndex);//Run the operations in the BackStackRecords, either to push or pop. ... record.runOnCommitRunnables();//执行回BackStackRecord，调用runOnCommit注册的方法 ...&#125;//BackStackRecordFragment expandOps(ArrayList&lt;Fragment&gt; added, Fragment oldPrimaryNav) &#123; for (int opNum = 0; opNum &lt; mOps.size(); opNum++) &#123; final Op op = mOps.get(opNum); switch (op.cmd) &#123; case OP_ADD: case OP_ATTACH: added.add(op.fragment); break; case OP_REMOVE: case OP_DETACH: &#123; added.remove(op.fragment); if (op.fragment == oldPrimaryNav) &#123; mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, op.fragment)); opNum++; oldPrimaryNav = null; &#125; &#125; break; case OP_REPLACE: &#123;//来到这里 final Fragment f = op.fragment; final int containerId = f.mContainerId; boolean alreadyAdded = false; for (int i = added.size() - 1; i &gt;= 0; i--) &#123; final Fragment old = added.get(i); if (old.mContainerId == containerId) &#123; if (old == f) &#123; alreadyAdded = true; &#125; else &#123; // This is duplicated from above since we only make // a single pass for expanding ops. Unset any outgoing primary nav. if (old == oldPrimaryNav) &#123; mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, old)); opNum++; oldPrimaryNav = null; &#125; final Op removeOp = new Op(OP_REMOVE, old); removeOp.enterAnim = op.enterAnim; removeOp.popEnterAnim = op.popEnterAnim; removeOp.exitAnim = op.exitAnim; removeOp.popExitAnim = op.popExitAnim; mOps.add(opNum, removeOp); added.remove(old); opNum++; &#125; &#125; &#125; if (alreadyAdded) &#123; mOps.remove(opNum); opNum--; &#125; else &#123; op.cmd = OP_ADD; added.add(f); &#125; &#125; break; case OP_SET_PRIMARY_NAV: &#123; // It&#x27;s ok if this is null, that means we will restore to no active // primary navigation fragment on a pop. mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, oldPrimaryNav)); opNum++; // Will be set by the OP_SET_PRIMARY_NAV we inserted before when run oldPrimaryNav = op.fragment; &#125; break; &#125; &#125; return oldPrimaryNav;&#125;void executeOps() &#123; final int numOps = mOps.size(); for (int opNum = 0; opNum &lt; numOps; opNum++) &#123; final Op op = mOps.get(opNum); final Fragment f = op.fragment; if (f != null) &#123; f.setNextTransition(mTransition, mTransitionStyle); &#125; switch (op.cmd) &#123; case OP_ADD: f.setNextAnim(op.enterAnim); mManager.addFragment(f, false); break; case OP_REMOVE: f.setNextAnim(op.exitAnim); mManager.removeFragment(f); break; case OP_HIDE: f.setNextAnim(op.exitAnim); mManager.hideFragment(f); break; case OP_SHOW: f.setNextAnim(op.enterAnim); mManager.showFragment(f); break; case OP_DETACH: f.setNextAnim(op.exitAnim); mManager.detachFragment(f); break; case OP_ATTACH: f.setNextAnim(op.enterAnim); mManager.attachFragment(f); break; case OP_SET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(f); break; case OP_UNSET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(null); break; default: throw new IllegalArgumentException(&quot;Unknown cmd: &quot; + op.cmd); &#125; if (!mReorderingAllowed &amp;&amp; op.cmd != OP_ADD &amp;&amp; f != null) &#123; mManager.moveFragmentToExpectedState(f); &#125; &#125; if (!mReorderingAllowed) &#123; // Added fragments are added at the end to comply with prior behavior. mManager.moveToState(mManager.mCurState, true); &#125;&#125;////FragmentManagerpublic void addFragment(Fragment fragment, boolean moveToStateNow) &#123; if (moveToStateNow) &#123; moveToState(fragment); &#125;&#125; void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) &#123; if (f.mState &lt;= newState) &#123; switch (f.mState) &#123; case Fragment.INITIALIZING: ... case Fragment.CREATED: ... case Fragment.ACTIVITY_CREATED: ... case Fragment.STARTED: ... &#125; &#125; else if (f.mState &gt; newState) &#123; switch (f.mState) &#123; case Fragment.RESUMED: ... case Fragment.STARTED: ... case Fragment.ACTIVITY_CREATED: ... case Fragment.CREATED: ... &#125; &#125; &#125; 这里的流程有点复杂，大致流程如下： commit---&gt;commitInternal---&gt;FragmentManager中到enqueueAction---&gt;scheduleCommit---&gt;execPendingActions---&gt;removeRedundantOperationsAndExecute---&gt;executeOpsTogether---&gt;expandOps 最终会执行mManager.addFragment，然后调用moveToState来执行真正的操作。在这里面会调用Fragment的生命周期方法。 参考 https://www.jianshu.com/p/f2fcc670afd6","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Handler原理","date":"2022-03-08T02:25:29.634Z","path":"wiki/Android/基础/Handler原理/","text":"Hanlder系列目录： Handler基本用法 Handler原理 概要Handler是Android子线程和主线程之间通信的一种机制。像Qt等技术使用的也是类似的消息机制。 我们站在设计者的角度思考，如果要自己搭建一套线程间通信会怎么做？ 首先应该有个消息队列queue，然后在线程中无线轮询，发现队列里面有数据了，就拿出来，调用其target的回调。Android就是这样来设计的，而Handler类只是一个辅助，它有消息和对象的引用，方便调用。HandlerThread呢，又帮我们封装了一个用于两个子线程的通信。它帮我们考虑到了异步调用的时间先后问题。 在native层，还是基于pthread相关API的封装。 使用Handler的原因是多个线程并发更新UI的同时保证线程安全。 概念 定义 作用 主线程 当应用程序第一次启动时，会同时自动开启一条主线程 处理UI相关 子线程 人为手动创建的线程 执行耗时操作 消息（Message） 线程间通讯的数据单元 存储需要操作的信息 消息队列（MessageQueue） 一种数据结构 存储Handler发送过来的信息（Message） 处理者（Handler） 主线程与子线程的通信媒介，线程消息的主要处理者 添加消息到消息队列，处理Looper分派过来的消息 循环器（Looper） 消息队列与处理器的通信媒介 消息获取：循环取出消息队列的消息，消息分发：将取出的消息发送给对应的处理者 ThreadLocal 用于不同线程保存自己的信息 工作流程 异步通信准备 在主线程中创建 处理器对象Looper 消息队列对象MessageQueue，Looper自动进入消息循环 Handler对象，自动绑定主线程的Looper、MessageQueue 消息发送 消息循环 消息处理 注意 每个线程只有一个Looper 一个Looper可以绑定多个线程的Handler（实现线程间通信） 在Looper中有一个setMessageLogging方法，可以添加日志的监听，用于分析所有的消息 源码分析按照我们的使用顺序，先看看Handler的构造函数 123456789101112131415161718192021222324252627//接受Looper参数，绑定线程public Handler(@NonNull Looper looper) &#123; this(looper, null, false);&#125; public Handler(@Nullable Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125;//绑定线程，在使用的时候，如果不设置Looper，则使用当前线程的Looper。//Looper.myLooper()作用：获取当前线程的Looper对象；若线程无Looper对象则抛出异常 mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 那么Looper是在什么时候构造的呢？我们可以先看看主线程的初始化是如何做的，以下是ActivityThread的入口函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper();//构造了Looper // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format &quot;seq=114&quot; long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop();//looper进入循环，正常情况下下面的代码是不会执行的 throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 那么Looper内部又做了什么呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125; &#125;private static void prepare(boolean quitAllowed) &#123;//判断looper是否是null如果是，就创建，并将其存到ThreadLocal中，上面说的handler中的looper就是从ThreadLocal中取出来的；//这里可知，每个线程只有一个Looper if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); //分发消息，这里的target就是handler &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); //消息的回收 &#125;&#125; 至此，我们知道一个线程中只有一个Looper，Looper进行循环后，会不停的从消息队列中拿到消息进行处理。 然后就是消息的发送和接收，我们先看看消息是如何发送的 123456789101112131415161718192021222324252627282930313233343536Handler.java//发送消息public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //消息被添加到消息队列中，loop中处理 return queue.enqueueMessage(msg, uptimeMillis);&#125; 从loop方法中可知，dispatchMessage会最终处理消息 123456789101112131415Handler.javapublic void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 判断msg.callback是不是null，如果不是，那么就给这个callback处理，这个callback是message中的一个Runnable；Message.obtain()其实是有其他参数的方法的，其中有一个是obtain(Handler h, Runnable callback)；如果你用了这个，那么消息就会在你实现的Runnable中接收到处理的回调； 第二个是判断handler内部的callback是不是null，如果不是null，就让他去处理，这里的Callback可不是Runnable了，他是一个interface，里面定义了一个handleMessage(Message msg);方法，这个怎么实现呢？handler类里同样有Handler(Callback callback)构造方法 最后才轮到handler类里的方法handleMessage来处理消息。 底层原理 Handler引起的内存泄露原因以及最佳解决方案Handler允许我们发送延时消息，如果在延时期间用户关闭了Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。 将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并在Acitivity的onDestroy()中调用handler.removeCallbacksAndMessages(null)及时移除所有消息。具体用法可以参考Handler基本用法 参考 https://www.jianshu.com/p/03d29cfe85cc https://www.jianshu.com/p/b4d745c7ff7a","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"ContentProvider","date":"2022-03-08T02:25:29.626Z","path":"wiki/Android/基础/ContentProvider/","text":"概述ContentProvider是一种数据共享型组件，可以在应用之间共享数据。所以与BroadcastReceiver一样，其可以脱离Activity实现。在实现ContentProvider时，需要继承ContentProvider抽象类，然后在AndroidManifest.xml中注册类名和ContentProvider的域名。同样的，不需要重写onCreat()方法，而是实现CRUD操作，所以ContentProvider没有启动和停止的概念，更像是一个系统级的监听器。与前三个组件不同的是，ContentProvider并没有使用intent，而是使用URI来判定能否为ContentResolver提供数据共享。 关于ContentProvider，用来提供其他地方（包括其他App）调用的一种全局（系统级）方式。有了ContentProvider，我们就能方便的调用相册的东西、进行文件选择，在我们自己的App中，也可以提供一个数据中心。 当数据量比较大的时候，继续用Parcel做容器效率会比较低，因此它还使用了匿名共享内存的方式。 但是有一个问题是，ContentProvider的提供者进程不再存活时，其他进程通过Provider读一个非 常简单的数据时，都需要先把提供者进程启动起来(除非指定multiprocess&#x3D;true)，这对用户是 相当不友好的。又因为其是间接通过db进行数据操作，所以效率也远不如直接操作db。因此在用户app中，不是很建议经常使用ContentProvider。不过对于系统级的app，它统一了数据操作的规范，利是远大于弊的。 在很多开源库中，也运用了ContentProvider的特性来进行初始化。 一些注意点 对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:&#x2F;&#x2F; URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。 因为Android7的变化，所以在使用FileProvider时需要做一些处理，关于如何处理，网上一大把资料，总结出来需要以下步骤： 配置Manifest文件，添加provider 对于Android7以上，在FileProvider.getUriForFile时使用配置的authority 参考 官方使用手册 https://blog.csdn.net/lmj623565791/article/details/72859156 https://developer.android.com/topic/libraries/app-startup","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"ContentProvider工作过程","date":"2022-03-08T02:25:29.626Z","path":"wiki/Android/基础/ContentProvider工作过程/","text":"概要ContentProvider主要用来给不同应用提供数据，当其所在进程启动时，ContentProvider会同时启动并发布到AMS中。 当android:multiprocess为true时，ContentProvider为多实例。 其提供了query、update、delete、insert等接口，方便我们进行数据操作。 启动流程我们要使用ContentProvider，需要通过getContentResolver()，实际是ApplicationContentResolver对象。 我们从query方法入手 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//开始查询Cursor cursor = getContentResolver().query(Uri.parse(&quot;content://com.lqd.androidpractice.provider.UsersProvider/users&quot;), null, null, null, null);//ContentResolver.javapublic final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable Bundle queryArgs, @Nullable CancellationSignal cancellationSignal) &#123; Preconditions.checkNotNull(uri, &quot;uri&quot;); try &#123; if (mWrapped != null) &#123; return mWrapped.query(uri, projection, queryArgs, cancellationSignal); &#125; &#125; catch (RemoteException e) &#123; return null; &#125; IContentProvider unstableProvider = acquireUnstableProvider(uri);//调用子类ApplicationContentResolver if (unstableProvider == null) &#123; return null; &#125;.... &#125;//ContextImpl的静态内部类ApplicationContentResolver@Overrideprotected IContentProvider acquireUnstableProvider(Context c, String auth) &#123; //ActivityThread return mMainThread.acquireProvider(c, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), false);&#125;//ActivityThread.java//存储Provider对象final ArrayMap&lt;IBinder, ProviderRefCount&gt; mProviderRefCountMap = new ArrayMap&lt;IBinder, ProviderRefCount&gt;(); public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; // There is a possible race here. Another thread may try to acquire // the same provider at the same time. When this happens, we want to ensure // that the first one wins. // Note that we cannot hold the lock while acquiring and installing the // provider since it might take a long time to run and it could also potentially // be re-entrant in the case where the provider is in the same process. ContentProviderHolder holder = null; try &#123; synchronized (getGetProviderLock(auth, userId)) &#123; holder = ActivityManager.getService().getContentProvider( getApplicationThread(), c.getOpPackageName(), auth, userId, stable); &#125; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; if (holder == null) &#123; Slog.e(TAG, &quot;Failed to find provider info for &quot; + auth); return null; &#125; // Install provider will increment the reference count for us, and break // any ties in the race. holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider;&#125;private ContentProviderHolder installProvider(Context context, ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; .. mProviderRefCountMap.put(jBinder, prc);//添加到Map中 ...&#125; 由以上代码可知，没有就创建Provider，创建完后会添加到mProviderRefCountMap中。如果Provider对应到进程有启动，则在Application启动时同时初始化了Provider。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980ActivityThread.javapublic static void main(String[] args) &#123;...ActivityThread thread = new ActivityThread();thread.attach(false, startSeq);...&#125;private void attach(boolean system, long startSeq) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try &#123; mgr.attachApplication(mAppThread, startSeq);//ActivityManagerService &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; .... &#125;&#125;//ActivityManagerService.java@Overridepublic final void attachApplication(IApplicationThread thread, long startSeq) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid, callingUid, startSeq); Binder.restoreCallingIdentity(origId); &#125;&#125;private final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; .... if (app.isolatedEntryPoint != null) &#123; // This is an isolated process which should just call an entry point instead of // being bound to an application. thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs); &#125; else if (instr2 != null) &#123; //ApplicationThread thread.bindApplication(processName, appInfo, providers, instr2.mClass, profilerInfo, instr2.mArguments, instr2.mWatcher, instr2.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions); &#125; else &#123; thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions); &#125; ... &#125; &#125; AMS的attachApplication方法调用了attachApplicationLocked方法，attachApplicationLocked中又调用了ApplicationThread的bindApplication，注意这个过程也是进程间调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184ActivityThread的内部类ApplicationThreadpublic final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial, AutofillOptions autofillOptions, ContentCaptureOptions contentCaptureOptions) &#123; if (services != null) &#123; if (false) &#123; // Test code to make sure the app could see the passed-in services. for (Object oname : services.keySet()) &#123; if (services.get(oname) == null) &#123; continue; // AM just passed in a null service. &#125; String name = (String) oname; // See b/79378449 about the following exemption. switch (name) &#123; case &quot;package&quot;: case Context.WINDOW_SERVICE: continue; &#125; if (ServiceManager.getService(name) == null) &#123; Log.wtf(TAG, &quot;Service &quot; + name + &quot; should be accessible by this app&quot;); &#125; &#125; &#125; // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableBinderTracking = enableBinderTracking; data.trackAllocation = trackAllocation; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; data.buildSerial = buildSerial; data.autofillOptions = autofillOptions; data.contentCaptureOptions = contentCaptureOptions; sendMessage(H.BIND_APPLICATION, data);&#125;private void handleBindApplication(AppBindData data) &#123;...//Context初始化final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales()); ...//Instrumentation初始化 try &#123; final ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException( &quot;Unable to instantiate instrumentation &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); &#125; final ComponentName component = new ComponentName(ii.packageName, ii.name); mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection);....//Application初始化 try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. app = data.info.makeApplication(data.restrictedBackupMode, null); // Propagate autofill compat state app.setAutofillOptions(data.autofillOptions); // Propagate Content Capture options app.setContentCaptureOptions(data.contentCaptureOptions); mInitialApplication = app; if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers);//初始化Provider，添加到Map中 &#125; &#125; ... try &#123; mInstrumentation.callApplicationOnCreate(app);//调用Application的onCreate，由此可知，ContentProvider的onCreate要先调用 &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); &#125; &#125; ...&#125;private ContentProviderHolder installProvider(Context context, ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; ... try &#123; final java.lang.ClassLoader cl = c.getClassLoader(); LoadedApk packageInfo = peekPackageInfo(ai.packageName, true); if (packageInfo == null) &#123; // System startup case. packageInfo = getSystemContext().mPackageInfo; &#125; localProvider = packageInfo.getAppFactory() .instantiateProvider(cl, info.name); provider = localProvider.getIContentProvider(); if (provider == null) &#123; Slog.e(TAG, &quot;Failed to instantiate class &quot; + info.name + &quot; from sourceDir &quot; + info.applicationInfo.sourceDir); return null; &#125; if (DEBUG_PROVIDER) Slog.v( TAG, &quot;Instantiating local provider &quot; + info.name); // XXX Need to create the correct context for this provider. localProvider.attachInfo(c, info);//进入ContentProvider&#125; catch (java.lang.Exception e) &#123; if (!mInstrumentation.onException(null, e)) &#123; throw new RuntimeException( &quot;Unable to get provider &quot; + info.name + &quot;: &quot; + e.toString(), e); &#125; return null; ...&#125; //ContentProvider.javaprivate void attachInfo(Context context, ProviderInfo info, boolean testing) &#123; mNoPerms = testing; mCallingPackage = new ThreadLocal&lt;&gt;(); /* * Only allow it to be set once, so after the content service gives * this to us clients can&#x27;t change it. */ if (mContext == null) &#123; mContext = context; if (context != null &amp;&amp; mTransport != null) &#123; mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService( Context.APP_OPS_SERVICE); &#125; mMyUid = Process.myUid(); if (info != null) &#123; setReadPermission(info.readPermission); setWritePermission(info.writePermission); setPathPermissions(info.pathPermissions); mExported = info.exported; mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0; setAuthorities(info.authority); &#125; ContentProvider.this.onCreate();//调用生命周期函数 &#125;&#125; 由以上代码可知，Provider的创建步骤如下： 创建ContextImpl和Instrumentation 创建Application对象 启动当前进程的ContentProvider并调用其onCreate 调用Application的onCreate方法 流程图 参考 《Android开发艺术探索》","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"AndroidManifest描述文件","date":"2022-03-08T02:25:29.625Z","path":"wiki/Android/基础/AndroidManifest/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;?xml version=&quot;1.0&quot; encoding=&quot;uft-8&quot; ?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/red/android&quot; package=&quot;com.example.android&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot;&gt; &lt;uses-permission /&gt; &lt;permission /&gt; &lt;permission-tree /&gt; 权限配置 &lt;permission-group /&gt; &lt;instrumentation android:functionalTest=[&quot;true&quot; | &quot;false&quot;] android:handleProfiling=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:name=&quot;string&quot; android:targetPackage=&quot;string&quot; /&gt; &lt;uses-sdk /&gt; &lt;uses-configuration /&gt; &lt;uses-feature /&gt; 环境配置 &lt;supports-screens /&gt; &lt;compatible-screens /&gt; &lt;supports-gl-texture /&gt; 应用基本配置 &lt;application android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:allowBackup=[&quot;true&quot; | &quot;false&quot;] android:backupAgent=&quot;string&quot; android:debuggable=[&quot;true&quot; | &quot;false&quot;] android:description=&quot;string resource&quot; android:enabled=[&quot;true&quot; | &quot;false&quot;] android:hasCode=[&quot;true&quot; | &quot;false&quot;] android:hardwareAccelerated=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:killAfterRestore=[&quot;true&quot; | &quot;false&quot;] android:largeHeap=[&quot;true&quot; | &quot;false&quot;] android:label=&quot;string resource&quot; android:logo=&quot;drawable resource&quot; android:manageSpaceActivity=&quot;string&quot; android:name=&quot;string&quot; android:permission=&quot;string&quot; android:persistent=[&quot;true&quot; | &quot;false&quot;] android:process=&quot;string&quot; android:restoreAnyVersion=[&quot;true&quot; | &quot;false&quot;] android:requiredAccountType=&quot;string&quot; android:restrictedAccountType=&quot;string&quot; android:supportsRtl=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:testOnly=[&quot;true&quot; | &quot;false&quot;] android:theme=&quot;resource or theme&quot; android:uiOptions=[&quot;none&quot; | &quot;splitActionBarWhenNarrow&quot;] android:vmSafeMode=[&quot;true&quot; | &quot;false&quot;] &gt; //界面组件配置 &lt;activity android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;] android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;] android:configChanges=[&quot;mcc&quot;, &quot;mnc&quot;, &quot;locale&quot;, &quot;touchscreen&quot;, &quot;keyboard&quot;, &quot;keyboardHidden&quot;, &quot;navigation&quot;, &quot;screenLayout&quot;, &quot;fontScale&quot;, &quot;uiMode&quot;, &quot;orientation&quot;, &quot;screenSize&quot;, &quot;smallestScreenSize&quot;] android:enabled=[&quot;true&quot; | &quot;false&quot;] android:excludeFromRecents=[&quot;true&quot; | &quot;false&quot;] android:exported=[&quot;true&quot; | &quot;false&quot;] android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;] android:hardwareAccelerated=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:launchMode=[&quot;multiple&quot; | &quot;singleTop&quot; | &quot;singleTask&quot; | &quot;singleInstance&quot;] android:multiprocess=[&quot;true&quot; | &quot;false&quot;] android:name=&quot;string&quot; android:noHistory=[&quot;true&quot; | &quot;false&quot;] android:parentActivityName=&quot;string&quot; android:permission=&quot;string&quot; android:process=&quot;string&quot; android:screenOrientation=[&quot;unspecified&quot; | &quot;behind&quot; | &quot;landscape&quot; | &quot;portrait&quot; | &quot;reverseLandscape&quot; | &quot;reversePortrait&quot; | &quot;sensorLandscape&quot; | &quot;sensorPortrait&quot; | &quot;userLandscape&quot; | &quot;userPortrait&quot; | &quot;sensor&quot; | &quot;fullSensor&quot; | &quot;nosensor&quot; | &quot;user&quot; | &quot;fullUser&quot; | &quot;locked&quot;] android:stateNotNeeded=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:theme=&quot;resource or theme&quot; android:uiOptions=[&quot;none&quot; | &quot;splitActionBarWhenNarrow&quot;] android:windowSoftInputMode=[&quot;stateUnspecified&quot;, &quot;stateUnchanged&quot;, &quot;stateHidden&quot;, &quot;stateAlwaysHidden&quot;, &quot;stateVisible&quot;, &quot;stateAlwaysVisible&quot;, &quot;adjustUnspecified&quot;, &quot;adjustResize&quot;, &quot;adjustPan&quot;] &gt; . . . &lt;/activity&gt; &lt;activity&gt; &lt;intent-filter&gt; &lt;action /&gt; &lt;category /&gt; &lt;data /&gt; &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity&gt; &lt;activity-alias&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity-alias&gt; &lt;service&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data/&gt; 服务组件配置 &lt;/service&gt; &lt;receiver&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; 触发器组件配置 &lt;meta-data /&gt; &lt;/receiver&gt; 数据源组件配置 &lt;provider android:authorities=&quot;list&quot; android:enabled=[&quot;true&quot; | &quot;false&quot;] android:exported=[&quot;true&quot; | &quot;false&quot;] android:grantUriPermissions=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:initOrder=&quot;integer&quot; android:label=&quot;string resource&quot; android:multiprocess=[&quot;true&quot; | &quot;false&quot;] android:name=&quot;string&quot; android:permission=&quot;string&quot; android:process=&quot;string&quot; android:readPermission=&quot;string&quot; android:syncable=[&quot;true&quot; | &quot;false&quot;] android:writePermission=&quot;string&quot; &gt; . . . &lt;/provider&gt;------------------------------------------------------------------------------------------------------------------------------------------- &lt;uses-library /&gt; 依赖库配置------------------------------------------------------------------------------------------------------------------------------------------- &lt;/application&gt;&lt;/manifest&gt; manifest标签 属性 描述 android:installLocation 设置应用的安装环境，如preferExternal表示安装到外部存储设备中；但运行时产生的数据还是会在&#x2F;data&#x2F;data目录下 uses-permission标签请求应用使用到的权限 属性 描述 android:name 使用的权限名字 permission标签限定权限来限制第三方应用的访问 属性 描述 android:name android:permissionGroup 权限的分组，如android.permission-group.COST_MONEY提示用户该应用可能会消耗通信费用，如果没有预定义该权限的分组，也可以通过配置项定义 android:label 标签 android:description 描述 instrumentation标签这个元素声明了一个Instrumentation类，这个类能够监视应用程序跟系统的交互。Instrumentation对象会在应用的其他所有组件被实例化之前实例化。 属性 描述 android:functionalTest 这个属性用于指定Instrumentation类是否应该作为一个功能性的测试来运行，如果设置为true，这要运行，否则不应该运行。默认值是false。 android:handleProfiling 这个属性用于指定Instrumentation对象是否会开启和关闭分析功能。如果设置为true，那么由Instrumentation对象来决定分析功能的启动和终止时机，如果设置为false，则分析功能会持续到Instrumentation对象整个运行周期。如果设置为true，会使Instrumentation对象针对一组特定的操作来进行分析。默认值是false。 android:targetPackage 制定Intrumentation对象所监视的应用程序。 uses-feature标签声明应用所依赖的外设或Android的特色功能。比如，一款主打拍照功能的应用需要声明所安装的设备需要有相机 supports-screens标签 属性 描述 android:resizeable 指明应用程序是否根据不同的屏幕尺寸进行缩放。如果设为否，则在较大屏幕上系统将以屏幕兼容模式运行应用程序。本属性已过时。为了帮助程序从Android 1.5升级为1.6才引入本属性，当时第一次引入了对多种屏幕的支持。不应再使用本属性。 android:smallScreens 指明应用程序是否支持较小屏幕。较小的屏幕是指小于“normal”（传统的HVGA）大小的屏幕。不支持小屏幕的应用程序将在外部服务（比如Android Market）中禁止用于小屏幕设备，因为只有很少一部分平台能让程序运行在小屏幕上。缺省值是“true”。 android:normalScreens 指明应用程序是否支持“normal”屏幕尺寸。传统意义上指的是中等密度的HVGA 屏幕，但低密度的WQVGA和高密度的WVGA一般也被视为是正常尺寸。缺省属性是“true”。 android:largeScreens 指明应用程序是否支持大屏幕尺寸。大屏幕是指明显比“normal”手持设备屏幕更大的尺寸。虽然依赖于系统的缩放也能全屏显示，但为了更好的用户体验可能需要对程序组件进行特定的处理。本属性的缺省值依版本而各不相同，因此最好是一直都明确声明这个属性。注意设为“false”将总是启用屏幕兼容模式。 android:xlargeScreens 指明应用程序是否支持超大屏幕尺寸。超大屏幕是指明显比“large”屏幕更大的尺寸，比如平板设备（或更大），虽然依赖于系统的缩放也能全屏显示，但为了更好的用户体验可能需要对程序组件进行特定的处理。本属性的缺省值依版本而各不相同，因此最好是一直都明确声明这个属性。注意设为“false”将总是启用屏幕兼容模式。本属性自API level 9引入。 android:anyDensity 指明应用程序是否包含适用于任何屏幕密度的资源。对于支持Android 1.6 (API level 4)以上版本的应用程序而言，本属性缺省值是“true”。除非绝对确认程序必须要能运行，不应设为“false”。只有应用程序要直接操作位图时（详情参阅支持多种屏幕文档），才可能需要禁用此选项。 android:requiresSmallestWidthDp 指定程序所需的smallestWidth最小值。smallestWidth是指可被程序用户界面使用的屏幕可用空间的最小值（单位为dp）——指可用屏幕两边中最短的那条边长。为了保证与应用程序兼容，设备的smallestWidth必须大于等于本属性值。（通常此值对应于布局layout所支持的“最小宽度”，而与屏幕当前的方向无关。）例如，典型的手持设备的最小宽度是320dp，7英寸的平板设备的最小宽度是600dp，10英寸的平板设备的最小宽度是720dp。因为这些值即为屏幕可用空间的最小值，所以一般也即是smallestWidth的值。在计算屏幕上的组件排列和系统用户界面大小时会与本属性值进行比较。例如，如果设备屏幕上需要显示一些永久性的用户界面元素，这些元素占用的屏幕位置对于其它用户界面元素是不可用的，通过对这些元素尺寸进行计算，系统声明的设备smallestWidth会比实际屏幕尺寸要小些。因此，应该用layout所需的最小宽度来设置此值，而与屏幕的方向无关。如果应用程序能在小屏幕上正确缩放（最低是small尺寸或最小宽度320dp），那就不需要用到本属性。否则，就应该为最小屏幕宽度标识符设置本属性来匹配应用程序所需的最小尺寸。警告：Android系统并不关心本属性，因此它不会影响程序运行时的表现。它是用于为诸如Android Market之类的服务启用过滤功能。不过，Android Market 当前还不支持对这个属性的过滤（Android 3.2），因此如程序不支持小屏幕的话还应继续使用其它屏幕尺寸的属性来进行限制。本属性自API level 13引入。 android:compatibleWidthLimitDp 通过指定程序支持的“最小屏幕宽度”的最大值，本属性可启用屏幕兼容模式作为用户可选项。如果设备可用屏幕的最小边长大于在此设置的值，用户将仍可以安装程序，但会运行在屏幕兼容模式。缺省情况下，屏幕兼容模式将被关闭，layout将如常缩放至全屏显示，但系统状态栏中会出现一个按钮，用户可以用此按钮来开关屏幕兼容模式。如果应用程序能兼容所有的屏幕尺寸，layout也能正确缩放，那就不需要用到本属性。注意：目前屏幕兼容模式只能在手持设备上仿真320dp宽度的屏幕，因此ndroid:compatibleWidthLimitDp大于320时屏幕兼容模式将不会生效。本属性自API level 13引入。 android:largestWidthLimitDp 通过指定程序支持的“最小屏幕宽度”的最大值，本属性可强制开启屏幕兼容模式。如果设备屏幕的最小边长大于本属性值，应用程序将运行在屏幕兼容模式，且用户无法将其关闭。如果应用程序能兼容所有的屏幕尺寸，layout也能正确缩放，那就不需要用到本属性。不然也应优先考虑使用android:compatibleWidthLimitDp属性。仅当应用程序缩放到大屏幕时会崩溃，屏幕兼容模式是用户使用的唯一方式，才会用到android:largestWidthLimitDp属性。注意：目前屏幕兼容模式只能在手持设备上仿真320dp宽度的屏幕，因此android:largestWidthLimitDp大于320时屏幕兼容模式将不会生效。本属性自API level 13引入。 uses-sdk标签 属性 描述 targetSdkVersion minSdkVersion application 属性 描述 android:uiOptions “none” 默认值”splitActionBarWhenNarrow”，分裂ActionBar用来分开action item，在屏幕底部出现一个actionbar来显示顶部显示不完的items android:backupAgent 云端存储组件声明，该组件一个应用只有一个。其值为BackupAgent的子类 android:allowbackup 是否允许备份 android:allowClearUserData 用户是否能选择自行清除数据，默认为true，程序管理器包含一个选择允许用户清除数据。当为true时，用户可自己清理用户数据，反之亦然 android:testOnly 用于判断该应用是否用于测试 android:largeHeap 可以给程序分配大内存。 getMemoryClass() 或getLargeMemoryClass()查询可用内存 activity 属性 描述 android:launchMode 运行模式 android:configChanges 当配置变化时，activity将会重启，但声明了这个属性会阻止activity重新启动，而调用onConfigurationChanged() android:screenOrientation activity在设别中的显示方向 android:parentActivityName 指定父级的activity。系统根据这个属性来决定当使用actionbar的向上按钮时那个activity响应 android:taskAffinity 表示当前activity进入的task adnroid:finishOnTaskLanuch 离开这个Task栈, 则系统会马上清除这个Activity,不管这个Activity在堆栈的任何位置. android:allowTaskReparenting 允许当前Activity可以在任务栈中移动 android:alwaysRetaainTaskState android:excludeFromRecents android:stateNotNeeded android:exported 是否可以导出，是否可以被外部访问 android:clearTaskOnLaunch 当值为true, 只要你一离开这个Task栈, 则系统会马上清理除了Root Activity的全部Activity. android:windowSoftInputMode android:permission android:alwaysRetainTaskState intent-filtermeta-dataactivity-aliastargetActivity属性所指activity的别名。别名会作为一个独立的实体来代表目标Activity。它能够有自己的Intent过滤器。该标签的其他属性是属性的一个子集，对于子集中的属性，不会把目标Activity中所设置的任何值转交给别名Activity，但对于子集中所没有的属性，则目标Activity所设置的值有会应用到别名Activity。 属性 描述 android:enabled android:exported servicereceiverprovider声明内容存储组件 属性 描述 android:authorities android:enabled 是否可以被实例化。只有当application和provider中的enabled都为true时，provider才可以 android:name uses-library引用类库 属性 描述 android:name 指定类库的名称 android:required 是否一定要找个库，true的时候，如果机器上没有这个库则不能安装","tags":[],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Android的消息机制","date":"2022-03-08T02:25:29.625Z","path":"wiki/Android/基础/Android的消息机制/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"BroadcastReceiver工作过程","date":"2022-03-08T02:25:29.625Z","path":"wiki/Android/基础/BroadcastReceiver工作过程/","text":"概述BroadcastReceiver是一种消息型组件。由于BroadcastReceiver可以在不同的组件甚至不同的应用之间传递消息，所以其可以脱离Activity实现，除了要在AndroidManifest.xml中注册广播类名外，还需要添加intentfilter，这样就可以让receiver选择性的接收广播。当注册完成之后，即使没有Activity启动，也可以接收广播。在实现 BroadcastReceiver时，需要继承 BroadcastReceiver抽象类，但是不需要重写onCreat()方法，只需重写onReceive()方法，因此，Service没有启动和停止的概念，更像是一个系统级的监听器。 流程分析广播的注册分为静态注册和动态注册，其中静态注册的广播在应用安装时由系统自动完成注册，具体来说是由PMS(PackageManagerService)来完成整个注册过程的。 注册过程动态注册的过程是从ContextWrapper的registerReceiver方法开始的。 我们从该方法开始 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//ContextWrapper.javapublic Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter) &#123; return mBase.registerReceiver(receiver, filter);&#125;//ContextImpl.javaprivate Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context, int flags) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; //返回ReceiverDispatcher rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; //ActivityManagerService注册 final Intent intent = ActivityManager.getService().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId, flags); if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 在上面的代码中，系统首先从mPackageInfo获取IIntentReceiver对象，然后再采用跨进程的方式向AMS发送广播注册的请求。之所以采用IIntentReceiver而不是直接采用BroadcastReceiver，这是因为上述注册过程是一个进程间通信的过程，而BroadcastReceiver作为Android的一个组件是不能直接跨进程传递的，所以需要通过IIntentReceiver来中转一下。毫无疑问，IIntentReceiver必须是一个Binder接口，它的具体实现是LoadedApk.ReceiverDispatcher.InnerReceiver，ReceiverDispatcher的内部同时保存了BroadcastReceiver和InnerReceiver，这样当接收到广播时，ReceiverDispatcher可以很方便地调用BroadcastReceiver的onReceive方法。 12345678ActivityManagerService.javapublic Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId, int flags) &#123; &#125; 发送和接收过程广播类型： 普通广播(Normal Broadcast) 系统广播(System Broadcast) 有序广播(Ordered Broadcast) 粘性广播(Sticky Broadcast) App应用内广播(Local Broadcast) 发送广播从sendBroadcast开始 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253//ContextImpl.javapublic void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(this); ActivityManager.getService().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125;//ActivityManagerServicepublic final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean serialized, boolean sticky, int userId) &#123; enforceNotIsolatedCaller(&quot;broadcastIntent&quot;); synchronized(this) &#123; intent = verifyBroadcastLocked(intent); final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); try &#123; return broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, bOptions, serialized, sticky, callingPid, callingUid, callingUid, callingPid, userId); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125;&#125;final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int realCallingUid, int realCallingPid, int userId, boolean allowBackgroundActivityStarts) &#123; intent = new Intent(intent); final boolean callerInstantApp = isInstantApp(callerApp, callerPackage, callingUid); // Instant Apps cannot use FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS if (callerInstantApp) &#123; intent.setFlags(intent.getFlags() &amp; ~Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS); &#125; // By default broadcasts do not go to stopped apps. intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); // If we have not finished booting, don&#x27;t allow this to launch new processes. if (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123; intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY); &#125;... final BroadcastRecord oldRecord = replacePending ? queue.replaceOrderedBroadcastLocked(r) : null; if (oldRecord != null) &#123; // Replaced, fire the result-to receiver. if (oldRecord.resultTo != null) &#123; final BroadcastQueue oldQueue = broadcastQueueForIntent(oldRecord.intent); try &#123; oldQueue.performReceiveLocked(oldRecord.callerApp, oldRecord.resultTo, oldRecord.intent, Activity.RESULT_CANCELED, null, null, false, false, oldRecord.userId); &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Failure [&quot; + queue.mQueueName + &quot;] sending broadcast result of &quot; + intent, e); &#125; &#125; &#125; else &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; ... &#125;//BroadcastQueue.javapublic void scheduleBroadcastsLocked() &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot; + mQueueName + &quot;]: current=&quot; + mBroadcastsScheduled); if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125;//处理BROADCAST_INTENT_MSGfinal void processNextBroadcast(boolean fromMsg) &#123; synchronized (mService) &#123; processNextBroadcastLocked(fromMsg, false); &#125;&#125;final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) &#123;...performReceiveLocked(r.callerApp, r.resultTo, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, false, false, r.userId);...&#125;void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously using one-way binder calls. if (app != null) &#123; if (app.thread != null) &#123; // If we have an app thread, do the call through that so it is // correctly ordered with other one-way calls. try &#123; //ActivityThread.ApplicationThread app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.getReportedProcState()); // TODO: Uncomment this when (b/28322359) is fixed and we aren&#x27;t getting // DeadObjectException when the process isn&#x27;t actually dead. //&#125; catch (DeadObjectException ex) &#123; // Failed to call into the process. It&#x27;s dying so just let it die and move on. // throw ex; &#125; catch (RemoteException ex) &#123; // Failed to call into the process. It&#x27;s either dying or wedged. Kill it gently. synchronized (mService) &#123; Slog.w(TAG, &quot;Can&#x27;t deliver broadcast to &quot; + app.processName + &quot; (pid &quot; + app.pid + &quot;). Crashing it.&quot;); app.scheduleCrash(&quot;can&#x27;t deliver broadcast&quot;); &#125; throw ex; &#125; &#125; else &#123; // Application has died. Receiver doesn&#x27;t exist. throw new RemoteException(&quot;app.thread must not be null&quot;); &#125; &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125;&#125;//ActivityThread.ApplicationThreadpublic void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; updateProcessState(processState, false); //实际调用LoadedApk.ReceiverDispatcher.InnerReceiver receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser);&#125;//LoadedApk.ReceiverDispatcher.InnerReceiverpublic void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final LoadedApk.ReceiverDispatcher rd; if (intent == null) &#123; Log.wtf(TAG, &quot;Null intent received&quot;); rd = null; &#125; else &#123; rd = mDispatcher.get(); &#125; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra(&quot;seq&quot;, -1); Slog.i(ActivityThread.TAG, &quot;Receiving broadcast &quot; + intent.getAction() + &quot; seq=&quot; + seq + &quot; to &quot; + (rd != null ? rd.mReceiver : null)); &#125; if (rd != null) &#123; rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; else &#123; // The activity manager dispatched a broadcast to a registered // receiver in this process, but before it could be delivered the // receiver was unregistered. Acknowledge the broadcast on its // behalf so that the system&#x27;s broadcast sequence can continue. if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, &quot;Finishing broadcast to unregistered receiver&quot;); IActivityManager mgr = ActivityManager.getService(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125;&#125;public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); if (intent == null) &#123; Log.wtf(TAG, &quot;Null intent received&quot;); &#125; else &#123; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra(&quot;seq&quot;, -1); Slog.i(ActivityThread.TAG, &quot;Enqueueing broadcast &quot; + intent.getAction() + &quot; seq=&quot; + seq + &quot; to &quot; + mReceiver); &#125; &#125; //会创建一个Args对象并通过mActivityThread的post方法来执行Args中的逻辑，而Args实现了Runnable接口。mActivityThread是一个Handler， //它其实就是ActivityThread中的mH，mH的类型是 ActivityThread的内部类H if (intent == null || !mActivityThread.post(args.getRunnable())) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManager.getService(); if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, &quot;Finishing sync broadcast to &quot; + mReceiver); args.sendFinished(mgr); &#125; &#125;&#125;//LoaderApk.ReceiverDispatcher.Argsfinal class Args extends BroadcastReceiver.PendingResult &#123; public final Runnable getRunnable() &#123; return () -&gt; &#123; ... ClassLoader cl = mReceiver.getClass().getClassLoader(); intent.setExtrasClassLoader(cl); intent.prepareToEnterProcess(); setExtrasClassLoader(cl); receiver.setPendingResult(this); receiver.onReceive(mContext, intent);//接收到消息了 ... &#125; &#125;&#125; 在broadcastIntentLocked的内部，会根据intent-filter查找出匹配的广播接收者并经过一系列的条件过滤，最终会将满足条件的广播接收者添加到BroadcastQueue中，接着BroadcastQueue就会将广播发送给相应的广播接收者。 流程图 参考 《Android开发艺术探索》","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Android sdk目录结构","date":"2022-03-08T02:25:29.624Z","path":"wiki/Android/基础/Android sdk目录结构/","text":"sdk add-ons：第三方公司为Android平台开发的附加功能系统 build-tools：构建工具 28.0.3： aapt.exe：打包res资源文件，生成R.java、resources.arsc和res aapt2.exe aidl.exe apksigner.bat bcc_compat.exe d8.bat dexdump.exe dx.bat llvm-rs-cc.exe mainDexClasses.bat split-select.exe zipalign.exe cmake docs：API文档 emulator extras：存放Android support v4、v7、v13、v17包 fonts licenses lldb：C&#x2F;C++调试器，它与LLVM编译器一起使用，提供了丰富的流程控制和数据检测 ndk-bundle ndk-build.cmd ndk-depends.cmd ndk-gdb.cmd ndk-stack.cmd ndk-which.cmd patcher platforms：根据API level存放不同版本的Android系统 android-28：28表示版本 data：系统资源 optional skin：Android模拟器的皮肤 android.jar uiautomator.jar platform-tools：Android平台通用工具 adb.exe dmtracedump.exe etc1tool.exe：PNG图像压缩为etc1标准 fastboot.exe：刷机工具 hprof-conv.exe：hprof文件转换命令，将Android Studio工具生成的hprof文件转换成一个标准格式 make_f2fs.exe mke2fs.exe：建立ext2文件系统 sqlite3.exe：数据库工具 sources system-images：模拟器映像文件 tools：Android开发和调试工具 bin archquery.bat avdmanager.bat jobb.bat：处理APK扩展文件的工具 lint.bat：代码检测 monkeyrunner.bat：测试工具 sdkmanager.bat:SDK管理器 uiautomatorviewer.bat：测试工具 android.bat emulator.exe emulator-check.exe mksdcard.exe：使用模拟器时，用来创建sd卡 monitor.bat compileSdkVersion：告诉Gradle用哪个Android SDK版本编译你的应用，使用任何新添加的API都需要对应等级的Android SDK。修改compileSdkVersion不会改变运行时的行为。如果使用Support Library，那么使用最新发布的 Support Library 就需要使用最新的 SDK 编译。例如，要使用 23.1.1 版本的 Support Library ，compileSdkVersion 就必需至少是 23 （大版本号要一致！）。 minSdkVersion：设置应用可以运行的最低版本要求 targetSdkVersion：系统会根据这个值来应用最新的行为变化。比如API 23会把你的应用转换到运行时权限模型。当设置targetSdkVersion小于23时，在6.0的机器上不会动态申请权限。 buildToolsVersion：构建工具的版本，其中包括aapt、dx等，这个工具的目录在Android sdk&#x2F;build-tools&#x2F; 参考 https://medium.com/androiddevelopers/picking-your-compilesdkversion-minsdkversion-targetsdkversion-a098a0341ebd#.tz5zzucma","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Android中support的使用","date":"2022-03-08T02:25:29.624Z","path":"wiki/Android/基础/Android support包/","text":"使用support-vX包的原因 向后兼容 提供不适合打包进framework的功能 支持不同形态的设备 support-v4implemention: &quot;com.android.support:support-v4:27.1.1&quot; v4名称是最开始支持api level4的库，官方在Support Library 24.2.0版本的时候移除了对Android 2.2(API Level 8)及以下版本的支持，所以从Android Support Library 24.2.0开始，V4包支持的最低版本是Android 2.3即API Level 9)，并且把v4库拆分成5个部分，可以在项目中按需要引用，但是必要性不是很大，一是因为这5个部分有依赖关系，二是compat库占了v4库的一半大小，v4库的依赖关系图： Fragment:一个专为解决Android碎片化的类，通过它可以让同一个程序适配不同的屏幕。NotificationCompat:支持更丰富的通知形式；LocalBroadcastManager:适合于应用内的消息传递。ViewPager:一个可以管理子view的viewgroup，用户可以在各个view之间自由切换，这个在很多应用中都有使用到； support-v7V7和V4一样，同样包含多个依赖包，但和V4不同的是，V7下的多个子包并不是后面拆分开来的，而是最初发布时就以各个独立库的形式发布的。它是针对Android 2.3(API Level 9)及以上的版本谷歌提供了一系列的support包（和V4包的命名一样，V7最初支持的最低版本是Android 2.1即API Level 7，所以称其为V7，同样在Android Support Library 24.2.0将V7支持的最低版本改为Android 2.3即API Level 9了），这些support包各自对应着特定的功能，每一个都可以单独地被引用。 implemention: &quot;com.android.support:appcompat-v7:27.1.1&quot;, implemention: &quot;com.android.support:design:27.1.1&quot;, implemention: &quot;com.android.support:recyclerview-v7:27.1.1&quot;, implemention: &quot;com.android.support:cardview-v7:27.1.1&quot;, implemention: &quot;com.android.support:support-annotations:27.1.1&quot;, implemention: &quot;com.android.support:support-vector-drawable:27.1.1&quot;, implemention: &quot;com.android.support:mediarouter-v7:27.1.1&quot;, implemention: &quot;com.android.support:gridlayout-v7:27.1.1&quot;, implemention: &quot;com.android.support:preference-v7:27.1.1&quot;, implemention: &quot;com.android.support:palette-v7:27.1.1&quot;, appcompat-v7：这个包支持对Action Bar接口的设计模式、Material Design接口的实现等，核心类有ActionBar、AppCompatActivity、AppCompatDialog、ShareActionProvider等。当使用依赖这个包后，会自动引入v4包 design： recyclerview-v7：核心类是RecyclerView，用于替换ListView、GridView cardview-v7：支持cardview控件，使用Material Design语言设计，卡片式的信息展示，在电视App中有广泛的使用 support-annotations：支持标注 support-vector-drawable： mediarouter-v7：用于设备间音频、视频交换显示的support包 gridlayout-v7：支持Grid Layout布局的包 preference-v7：支持存储配置数据的包，比如CheckBoxPreference和ListPreference palette-v7：页面的颜色动态变换 support-v13这个包的作用主要是为Android3.2（API Level 13）及以上的系统提供更多地Framgnet特性支持，使用它的原因在于，android-support-v4.jar中虽然也对Fragment做了支持，由于要兼容低版本，导致他是自行实现的 Fragment 效果，在高版本的Fragment的一些特性丢失了，而对于v13以上的sdk版本，我们可以使用更加有效，特性更多的代码。 implemention: &quot;com.android.support:support-v13:27.1.1&quot;, support-v14support-v17支持电视设备 implemention &quot;com.android.support:leanback-v17:27.1.1&quot; AndroidX配置 properties.gradle中配置 //启用AndroidX android.useAndroidX=true //将依赖包也迁移到AndroidX android.enableJetifier=true Android Studio中设置 Refactor -&gt; Migrate to AndroidX 解决依赖冲突的一些方法保持版本统一 强制设置使用某一个版本 android &#123; configurations.all &#123; resolutionStrategy.force &quot;com.squareup.okhttp3:okhttp:3.12.1&quot; &#125; &#125; 依赖的时候使用exclude implementation(&#39;me.drakeet.multitype:multitype:3.4.4&#39;, &#123; exclude group: &#39;com.android.support&#39; &#125;) 参考 https://developer.android.com/jetpack/androidx https://developer.android.com/jetpack/androidx/migrate","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Activity","date":"2022-03-08T02:25:29.621Z","path":"wiki/Android/基础/Activity基础/","text":"由来我们在做带UI的软件时，一般的做法是先创建一个窗口，然后在窗口上添加各种Button、Text、List等其他UI控件。Android、iOS也是类似，但代码的设计上跟PC端有些差别，Android使用Activity来管理UI、iOS使用ViewController。一般软件的入口都是main函数开始，Android中则通过描述文件AndroidManifest.xml配置一个Activity的属性作为入口。用户操作手机的时候使得一个界面可能处于可视状态，也可能处理隐藏状态，对应着Activity会有自己的生命周期。不同UI的嵌套也是需要维护的，所以就有了Activity任务栈，对应着不同Activity有不同的启动模式。不同的Activity之间又可能需要数据传递，因而有了Intent。 生命周期 回调函数onCreate生命周期中的第一个函数，整个生命周期中只会调用一次。savedInstanceState参数如果不为空，表示Activity暂时销毁时有存储一些数据，此时可以恢复。 onRestart当前Activity从不可见重新变为可见状态时，会调用。 onStart此时准备进入前台了 onResume可见了 onPause表示Activity正在停止 onStop表示Activity即将停止 onDestroy表示Activity即将被销毁，一般在这个方法中进行资源释放。 savedInstanceState界面销毁时可保存数据 onRestoreInstanceState恢复数据 不同场景的生命周期流程正常的开启和结束从Activity1中打开Activity2 12345672021-06-02 21:03:06.820 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onCreate2021-06-02 21:03:06.831 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onStart2021-06-02 21:03:06.835 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onResume2021-06-02 21:03:26.542 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onPause2021-06-02 21:03:26.649 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onCreate2021-06-02 21:03:26.659 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onStart2021-06-02 21:03:26.663 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onResume 在Activity2中点击返回键，当一个后台Activity会到前台时，会执行onRestart-&gt;onResume-&gt;onDestroy。当回到桌面，再次进入的应用的时候也是此流程 1234562021-06-02 21:06:54.500 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onPause2021-06-02 21:06:54.521 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onRestart2021-06-02 21:06:54.523 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onStart2021-06-02 21:06:54.526 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onResume2021-06-02 21:06:54.762 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onDestroy 屏幕旋转时12345672021-06-02 21:14:02.755 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onPause2021-06-02 21:14:02.763 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onSaveInstanceState2021-06-02 21:14:02.768 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onDestroy2021-06-02 21:14:02.997 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onCreate2021-06-02 21:14:03.011 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onStart2021-06-02 21:14:03.014 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onRestoreInstanceState2021-06-02 21:14:03.018 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onResume 异常情况下的数据保存和恢复某些情况下，Activity会被销毁，此时系统会调用savedInstanceState(Bundle bundle)方法，我们可以在这个方法中存储一些数据，等到Activity恢复时，bundle对象会被传递给onCreate和onRestoreInstanceState方法，我们就可以恢复到原来的状态了。 启动模式和任务栈任务栈Task，是一种用来放置Activity实例的容器，他是以栈的形式进行盛放，也就是所谓的先进后出，主要有2个基本操作：压栈和出栈，其所存放的Activity是不支持重新排序的，只能根据压栈和出栈操作更改Activity的顺序。 启动一个Application的时候，系统会为它默认创建一个对应的Task，用来放置根Activity。默认启动Activity会放在同一个Task中，新启动的Activity会被压入启动它的那个Activity的栈中，并且显示它。当用户按下回退键时，这个Activity就会被弹出栈，按下Home键回到桌面，再启动另一个应用，这时候之前那个Task就被移到后台，成为后台任务栈，而刚启动的那个Task就被调到前台，成为前台任务栈，手机页面显示的就是前台任务栈中的栈顶元素。 启动模式则是用来管理Activity如何添加到任务栈里的。可以在描述文件中配置，也可以代码中设置。 启动模式launchModestandard默认模式，每次启动都会创建一个新的Activity实例。在这个模式中，谁启动了这个Activity，那么新的Activity会添加到启动的Activity所在的任务栈中。当使用非Activity的Context打开一个Activity时，则会创建一个新的任务栈，这个时候需要指定FLAG_ACTIVITY_NEW_TASK标识。 singleTop栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但不是位于栈顶，那么新Activity仍然会重新重建。举个例子，假设目前栈内的情况为ABCD，其中ABCD为四个Activity，A位于栈底，D位于栈顶，这个时候假设要再次启动D，如果D的启动模式为singleTop，那么栈内的情况仍然为ABCD;如果D的启动模式为standard，那么由于D 被重新创建，导致栈内的情况就变为ABCDD。 singleTask栈内复用模式。 这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent。如果当前栈中启动，当前栈如果已经存在，则会将其上面的Activity全部出栈，自己排到栈顶。如果不存在，则创建新任务栈。 比如： 比如目前任务栈S1中的情况为ABC，这个时候Activity D以singleTask模式请求启动，其所需要的任务栈为S2，由于S2和D的实例均不存在，所以系统会先创建任务栈S2，然后再创建D的实例并将其入 栈到S2。 另外一种情况，假设D所需的任务栈为S1，其他情况如上面例子1所示，那么由于S1已经存在，所以系统会直接创建D的实例并将其入栈到S1。 如果D所需的任务栈为S1，并且当前任务栈S1的情况为ADBC，根据栈内复用的原则，此时D不会重新创建，系统会把D切换到栈顶并调用其onNewIntent方法，同时由于singleTask默认具有clearTop的效果，会导致栈内所有在D上面的Activity全部出栈，于是最终S1中的情况为AD。 singleInstance单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中，换句话说，比 如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁了。”来电显示”界面就可以使用该模式。 Activity中的Flags标记位的作用很多，有的标记位可以设定Activity的启动模式，比如FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_SINGLE_TOP等;还有的标记位可以影响Activity的运行状态，比如FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS等。下面主要介绍几个比较常用的标记位，剩下的标记位读者可以查看官方文档去了解，大部分情况下，我们不需要为Activity指定标记位，因此，对于标记位理解即可。在使用标记位的时候，要注意有些标记位是系统内部使用的，应用程序不需要去手动设置这些标记位以防出现问题。 FLAG_ACTIVITY_NEW_TASK 这个标记位的作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。 FLAG_ACTIVITY_SINGLE_TOP 这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定该启动模式相同。 FLAG_ACTIVITY_CLEAR_TOP 具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，被启动Activity的实例如果已经存在，那么系统就会调用它的onNewIntent。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性 android:excludeFromRecents&#x3D;”true”。 Activity之间如何通信参考 https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn 《Android开发艺术探索》","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"Activity工作过程","date":"2022-03-08T02:25:29.621Z","path":"wiki/Android/基础/Activity工作过程/","text":"概述Activity是一种展示型组件，具有两种启动方式，一种是显示的，通过intent实现；另一种是隐式的，也需要intent，但还需要在AndroidManifest.xml中添加intentfilter。在实现Activity时，需要继承Activity抽象类，并且重写onCreat()方法，因此，Activity具有启动和停止的概念。 流程分析流程图 Activity的启动从startActivity开始，代码会运行到Activity的startActivityForResult方法。 123456789101112131415161718192021222324252627282930313233343536373839Activity.javapublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125;&#125; mParent代表的是ActivityGroup，ActivityGroup最开始被用来在一个界面中嵌入多个子Activity，但是其在API 13中已经被废弃了，系统推荐采用Fragment来代替ActivityGroup。 mMainThread.getApplicationThread()这个参数，它的类型是ApplicationThread，ApplicationThread是ActivityThread的内部类，继承IApplicationThread.Stub，也是个Binder对象。 接下来看看execStartActivity方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899Instrumentation.java@UnsupportedAppUsagepublic ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityTaskManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //检查Activity启动的结果 //比如如果没有注册，则会抛出ActivityNotFoundException checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null;&#125;public static void checkStartActivityResult(int res, Object intent) &#123; if (!ActivityManager.isStartResultFatalError(res)) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( &quot;Unable to find explicit activity class &quot; + ((Intent)intent).getComponent().toShortString() + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;); throw new ActivityNotFoundException( &quot;No Activity found to handle &quot; + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException(&quot;Not allowed to start activity &quot; + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( &quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( &quot;PendingIntent is not an activity&quot;); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( &quot;Starting under voice control not allowed for: &quot; + intent); case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION: throw new IllegalStateException( &quot;Session calling startVoiceActivity does not match active session&quot;); case ActivityManager.START_VOICE_HIDDEN_SESSION: throw new IllegalStateException( &quot;Cannot start voice activity on a hidden session&quot;); case ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION: throw new IllegalStateException( &quot;Session calling startAssistantActivity does not match active session&quot;); case ActivityManager.START_ASSISTANT_HIDDEN_SESSION: throw new IllegalStateException( &quot;Cannot start assistant activity on a hidden session&quot;); case ActivityManager.START_CANCELED: throw new AndroidRuntimeException(&quot;Activity could not be started for &quot; + intent); default: throw new AndroidRuntimeException(&quot;Unknown error code &quot; + res + &quot; when starting &quot; + intent); &#125;&#125; 这里使用了ActivityTaskManager来启动Activity。ActivityTaskManager是一个Binder。ActivityTaskManager.getService()会返回Activity服务管理器ActivityManagerService(Android10返回ActivityTaskManagerService)。 ATMS是在Android10中新增的，分担了之前ActivityManagerService（AMS）的一部分功能（activity task相关）。在Android10 之前 ，这个地方获取的是服务是AMS。查看Android10的AMS，你会发现startActivity方法内也是调用了ATMS的startActivity方法。所以在理解上，ATMS就隶属于AMS。 接下来要去ActivityTaskManagerService看看了 Activity的管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ActivityTaskManagerService.java@Overridepublic final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) &#123; final String reason = &quot;startActivities&quot;; enforceNotIsolatedCaller(reason); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, reason); // TODO: Switch to user app stacks here. return getActivityStartController().startActivities(caller, -1, 0, -1, callingPackage, intents, resolvedTypes, resultTo, SafeActivityOptions.fromBundle(bOptions), userId, reason, null /* originatingPendingIntent */, false /* allowBackgroundActivityStart */);&#125;@Overridepublic int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/);&#125;int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; enforceNotIsolatedCaller(&quot;startActivityAsUser&quot;); userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;); // TODO: Switch to user app stacks here. return getActivityStartController().obtainStarter(intent, &quot;startActivityAsUser&quot;) .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute();&#125; getActivityStartController().obtainStarter方法获取ActivityStarter实例，进去看看execute。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596ActivityStarter.java/** * Starts an activity based on the request parameters provided earlier. * @return The starter result. */int execute() &#123; try &#123; // TODO(b/64750076): Look into passing request directly to these methods to allow // for transactional diffs and preprocessing. if (mRequest.mayWait) &#123; //也会执行到startActivity方法 return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart); &#125; else &#123; return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent, mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.callingPid, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.componentSpecified, mRequest.outActivity, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart); &#125; &#125; finally &#123; onExecutionComplete(); &#125;&#125;private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123; int result = START_CANCELED; final ActivityStack startedActivityStack; try &#123; mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity, restrictedBgActivity); ... &#125; private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123;...if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTaskRecord().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; // If the activity is not focusable, we can&#x27;t resume it, but still would like to // make sure it becomes visible as it starts (this will also trigger entry // animation). An example of this are PIP activities. // Also, we don&#x27;t want to resume activities in a task that currently has an overlay // as the starting activity just needs to be in the visible paused state until the // over is removed. mTargetStack.ensureActivitiesVisibleLocked(mStartActivity, 0, !PRESERVE_WINDOWS); // Go ahead and tell window manager to execute app transition for this activity // since the app transition will not be triggered through the resume channel. mTargetStack.getDisplay().mDisplayContent.executeAppTransition(); &#125; else &#123; // If the target stack was not previously focusable (previous top running activity // on that stack was not visible) then any prior calls to move the stack to the // will not update the focused stack. If starting the new activity now allows the // task stack to be focusable, then ensure that we now update the focused stack // accordingly. if (mTargetStack.isFocusable() &amp;&amp; !mRootActivityContainer.isTopDisplayFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;); &#125; mRootActivityContainer.resumeFocusedStacksTopActivities( mTargetStack, mStartActivity, mOptions); &#125;&#125; else if (mStartActivity != null) &#123; mSupervisor.mRecentTasks.add(mStartActivity.getTaskRecord());&#125;mRootActivityContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);...&#125; startActivityMayWait最终也是会进入startActivity，startActivity调用了startActivityUnchecked，startActivityUnchecked调用了mRootActivityContainer.resumeFocusedStacksTopActivities(mTargetStack, mStartActivity, mOptions);。mRootActivityContainer是RootActivityContainer，Android10新增到API，分担了ActivityStackSupervisor部分功能。接着看看RootActivityContainer 12345678910111213141516RootActivityContainer.javaboolean resumeFocusedStacksTopActivities( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (!mStackSupervisor.readyToResume()) &#123; return false; &#125; boolean result = false; if (targetStack != null &amp;&amp; (targetStack.isTopStackOnDisplay() || getTopDisplayFocusedStack() == targetStack)) &#123; result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; ... &#125; 接着跳转到了ActivityStack的resumeTopActivityUncheckedLocked方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778ActivityStack.java@GuardedBy(&quot;mService&quot;)boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mInResumeTopActivity) &#123; // Don&#x27;t even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mInResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); // When resuming the top activity, it may be necessary to pause the top activity (for // example, returning to the lock screen. We suppress the normal pause logic in // &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the // end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here // to ensure any necessary pause logic occurs. In the case where the Activity will be // shown regardless of the lock screen, the call to // &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped. final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); if (next == null || !next.canTurnScreenOn()) &#123; checkReadyForSleep(); &#125; &#125; finally &#123; mInResumeTopActivity = false; &#125; return result;&#125;@GuardedBy(&quot;mService&quot;)private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;... boolean pausing = getDisplay().pauseBackStacks(userLeaving, next, false); if (mResumedActivity != null) &#123; if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity); // 暂停上一个Activity pausing |= startPausingLocked(userLeaving, false, next, false); &#125; ... //这里next.attachedToProcess()，只有启动了的Activity才会返回true if (next.attachedToProcess()) &#123; ... try &#123; final ClientTransaction transaction = ClientTransaction.obtain(next.app.getThread(), next.appToken); ... //启动了的Activity就发送ResumeActivityItem事务给客户端了，后面会讲到 transaction.setLifecycleStateRequest( ResumeActivityItem.obtain(next.app.getReportedProcState(), getDisplay().mDisplayContent.isNextTransitionForward())); mService.getLifecycleManager().scheduleTransaction(transaction); .... &#125; catch (Exception e) &#123; .... mStackSupervisor.startSpecificActivityLocked(next, true, false); return true; &#125; .... &#125; else &#123; .... if (SHOW_APP_STARTING_PREVIEW) &#123; //这里就是 冷启动时 出现白屏 的原因了：取根Activity的主题背景 展示StartingWindow next.showStartingWindow(null , false ,false); &#125; // 继续当前Activity，普通Activity的正常启动 关注这里即可 //ActivityStackSupervisor.java mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; return true;&#125; 接下来到了ActivityStackSupervisor的startSpecificActivityLocked方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677ActivityStackSupervisor.javavoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity&#x27;s application already running? final WindowProcessController wpc = mService.getProcessController(r.processName, r.info.applicationInfo.uid); boolean knownToBeDead = false; if (wpc != null &amp;&amp; wpc.hasThread()) &#123; try &#123; realStartActivityLocked(r, wpc, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); &#125; knownToBeDead = true; &#125; ... try &#123; if (Trace.isTagEnabled(TRACE_TAG_ACTIVITY_MANAGER)) &#123; Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;dispatchingStartProcess:&quot; + r.processName); &#125; // 上面的wpc != null &amp;&amp; wpc.hasThread()不满足的话，说明没有进程，就会去创建进程 final Message msg = PooledLambda.obtainMessage( ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName, r.info.applicationInfo, knownToBeDead, &quot;activity&quot;, r.intent.getComponent()); mService.mH.sendMessage(msg); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125;boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... // Create activity launch transaction. final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.appToken); final DisplayContent dc = r.getDisplay().mDisplayContent; //添加了启动Activity的Item clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global // and override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(), r.icicle, r.persistentState, results, newIntents, dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(), r.assistToken)); // Set desired final state. final ActivityLifecycleItem lifecycleItem; if (andResume) &#123; lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward()); &#125; else &#123; lifecycleItem = PauseActivityItem.obtain(); &#125; clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. //ActivityTaskManagerService获取ClientLifecycleManager mService.getLifecycleManager().scheduleTransaction(clientTransaction); ... return true;&#125; 由以上代码可知，ClientTransaction包含一系列的待客户端处理的事务的容器，客户端接收后取出事务并执行。其添加了LaunchActivityItem、ResumeActivityItem等。然后运行ClientLifecycleManager的scheduleTransaction 123456789101112131415161718192021ClientLifecycleManager.java/** * Schedule a transaction, which may consist of multiple callbacks and a lifecycle request. * @param transaction A sequence of client transaction items. * @throws RemoteException * * @see ClientTransaction */void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; final IApplicationThread client = transaction.getClient(); //ClientTransaction transaction.schedule(); if (!(client instanceof Binder)) &#123; // If client is not an instance of Binder - it&#x27;s a remote call and at this point it is // safe to recycle the object. All objects used for local calls will be recycled after // the transaction is executed on client in ActivityThread. transaction.recycle(); &#125;&#125; 123456ClientTransaction.javapublic void schedule() throws RemoteException &#123;//ApplicationThread mClient.scheduleTransaction(this);&#125; IApplicationThread是ApplicationThread在系统进程的代理，所以真正执行的地方是客户端的ApplicationThread。 现有流程如下：启动Activity的操作从客户端跨进程转移到ATMS，ATMS通过ActivityStarter、ActivityStack、ActivityStackSupervisor对Activity任务、Activity栈、Activity记录管理后，又用过跨进程把正在启动过程又转移到了客户端。 流程图如下： 线程切换及消息处理接下来看看ApplicationThread的scheduleTransaction scheduleTransaction会发送Message，ActivityThread内部类H处理此消息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//ApplicationThread.java@Overridepublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; ActivityThread.this.scheduleTransaction(transaction);&#125;//ActivityThread.java@Overridepublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;//会调用sendMessage ActivityThread.this.scheduleTransaction(transaction);&#125;private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);//对应mH会处理消息，H是ActivityThread的内部类&#125;//ClientTransactionHandler.java 是ActivityThread的父类void scheduleTransaction(ClientTransaction transaction) &#123; transaction.preExecute(this); sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);&#125;//class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; ... case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; //这里处理消息 //TransactionExecutor mTransactionExecutor.execute(transaction); if (isSystem()) &#123; // Client transactions inside system process are recycled on the client side // instead of ClientLifecycleManager to avoid being cleared before this // message is handled. transaction.recycle(); &#125; // TODO(lifecycler): Recycle locally scheduled transactions. break; case RELAUNCH_ACTIVITY: handleRelaunchActivityLocally((IBinder) msg.obj); break; &#125; &#125;&#125; 最终到了TransactionExecutor的execute方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//TransactionExecutor.javapublic void execute(ClientTransaction transaction) &#123; if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + &quot;Start resolving transaction&quot;); final IBinder token = transaction.getActivityToken(); if (token != null) &#123; final Map&lt;IBinder, ClientTransactionItem&gt; activitiesToBeDestroyed = mTransactionHandler.getActivitiesToBeDestroyed(); final ClientTransactionItem destroyItem = activitiesToBeDestroyed.get(token); if (destroyItem != null) &#123; if (transaction.getLifecycleStateRequest() == destroyItem) &#123; // It is going to execute the transaction that will destroy activity with the // token, so the corresponding to-be-destroyed record can be removed. activitiesToBeDestroyed.remove(token); &#125; if (mTransactionHandler.getActivityClient(token) == null) &#123; // The activity has not been created but has been requested to destroy, so all // transactions for the token are just like being cancelled. Slog.w(TAG, tId(transaction) + &quot;Skip pre-destroyed transaction:\\n&quot; + transactionToString(transaction, mTransactionHandler)); return; &#125; &#125; &#125; if (DEBUG_RESOLVER) Slog.d(TAG, transactionToString(transaction, mTransactionHandler)); executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear(); if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + &quot;End resolving transaction&quot;);&#125;public void executeCallbacks(ClientTransaction transaction) &#123; final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null || callbacks.isEmpty()) &#123; // No callbacks to execute, return early. return; &#125; if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + &quot;Resolving callbacks in transaction&quot;); final IBinder token = transaction.getActivityToken(); ActivityClientRecord r = mTransactionHandler.getActivityClient(token); // In case when post-execution state of the last callback matches the final state requested // for the activity in this transaction, we won&#x27;t do the last transition here and do it when // moving to final state instead (because it may contain additional parameters from server). final ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest(); final int finalState = finalStateRequest != null ? finalStateRequest.getTargetState() : UNDEFINED; // Index of the last callback that requests some post-execution state. final int lastCallbackRequestingState = lastCallbackRequestingState(transaction);//遍历callbacks，调用ClientTransactionItem的execute方法//LaunchActivityItem会在这里调用execute final int size = callbacks.size(); for (int i = 0; i &lt; size; ++i) &#123; final ClientTransactionItem item = callbacks.get(i); ... item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); ... &#125;&#125; 继续查看LaunchActivityItem的execute 1234567891011121314LaunchActivityItem.java@Overridepublic void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mIsForward, mProfilerInfo, client, mAssistToken); client.handleLaunchActivity(r, pendingActions, null /* customIntent */); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);&#125; 里面调用了client.handleLaunchActivity方法，client是ClientTransactionHandler的实例，是在TransactionExecutor构造方法传入的，TransactionExecutor创建是在ActivityThread中,所以，client.handleLaunchActivity方法就是ActivityThread的handleLaunchActivity方法。 流程图如下： Activity初始化及生命周期函数回调123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111ActivityThread.javapublic Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; ... final Activity a = performLaunchActivity(r, customIntent); ... return a;&#125;/** activity 启动的核心实现. */private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //1、从ActivityClientRecord获取待启动的Activity的组件信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //创建ContextImpl对象 ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; //2、创建activity实例 java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; .. &#125; try &#123; //3、创建Application对象（如果没有的话） Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); //4、attach方法为activity关联上下文环境 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //5、调用生命周期onCreate if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); &#125; r.activity = activity; &#125; r.setState(ON_CREATE); synchronized (mResourcesManager) &#123; mActivities.put(r.token, r); &#125; &#125; ... return activity;&#125; 由以上代码可知，performLaunchActivity主要完成以下事情： 从ActivityClientRecord获取待启动的Activity的组件信息 通过mInstrumentation.newActivity方法使用类加载器创建activity实例 通过LoadedApk的makeApplication方法创建Application对象，内部也是通过mInstrumentation使用类加载器，创建后就调用了instrumentation.callApplicationOnCreate方法，也就是Application的onCreate方法。 创建ContextImpl对象并通过activity.attach方法对重要数据初始化，关联了Context的具体实现ContextImpl，attach方法内部还完成了window创建，这样Window接收到外部事件后就能传递给Activity了。 调用Activity的onCreate方法，是通过 mInstrumentation.callActivityOnCreate方法完成。 其他生命周期处理也是类似的，先在ActivityStackSupervisor中添加对应的XXXActivityItem，然后在ActivityThread中的handleXXXActivity处理。 总结归纳整体流程图如下： 一些类的介绍： 类名 作用 ActivityThread 应用的入口类，系统通过调用main函数，开启消息循环队列。ActivityThread所在线程被称为应用的主线程（UI线程） ApplicationThread 是ActivityThread的内部类，继承IApplicationThread.Stub，是一个IBinder，是ActiivtyThread和AMS通信的桥梁，AMS则通过代理调用此App进程的本地方法，运行在Binder线程池 H 继承Handler，在ActivityThread中初始化，即主线程Handler，用于主线程所有消息的处理。本片中主要用于把消息从Binder线程池切换到主线程 Intrumentation 具有跟踪application及activity生命周期的功能，用于监控app和系统的交互 ActivityManagerService Android中最核心的服务之一，负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。 ActivityTaskManagerService 管理activity及其容器（task, stacks, displays）的系统服务（Android10中新增，分担了AMS的部分职责） ActivityStarter 用于解释如何启动活动。该类收集所有逻辑，用于确定Intent和flag应如何转换为活动以及相关的任务和堆栈 ActivityStack 用来管理系统所有的Activity，内部维护了Activity的所有状态和Activity相关的列表等数据 ActivityStackSupervisor 负责所有Activity栈的管理。AMS的stack管理主要有三个类，ActivityStackSupervisor，ActivityStack和TaskRecord ClientLifecycleManager 客户端生命周期执行请求管理 ClientTransaction 是包含一系列的 待客户端处理的事务 的容器，客户端接收后取出事务并执行 LaunchActivityItem、ResumeActivityItem 继承ClientTransactionItem，客户端要执行的事务信息，启动activity 参考 https://juejin.cn/post/6847902222294990862 《Android开发艺术探索》","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"自定义View","date":"2022-03-08T02:25:29.620Z","path":"wiki/Android/UI/自定义View/","text":"目录自定义View自定义View之Canvas自定义View之Paint 概述自定义属性声明属性使用declare-styleable声明属性 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;attr name=&quot;enableOnPad&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;supportDeviceType&quot; format=&quot;reference&quot;/&gt; &lt;!-- 如果有通用的属性，可以抽离出来 --&gt; &lt;declare-styleable name=&quot;ExTextView&quot;&gt; &lt;attr name=&quot;enableOnPad&quot;/&gt; &lt;attr name=&quot;supportDeviceType&quot;/&gt; &lt;/declare-styleable&gt; &lt;declare-styleable name=&quot;ExEditText&quot;&gt; &lt;attr name=&quot;enableOnPad&quot;/&gt; &lt;attr name=&quot;supportDeviceType&quot;/&gt; &lt;attr name=&quot;line_color&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;line_stroke_height&quot; format=&quot;dimension&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 使用属性12345678910111213141516171819202122232425262728xml中使用属性&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; //自动查找 xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:orientation=&quot;vertical&quot;&gt; &lt;CustomView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; app:line_color=&quot;&quot; /&gt;&lt;/RelativeLayout&gt;public class CustomView extends View &#123; public DottedLineView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); // 根据Style拿到TypedArray TypedArray array = getContext().obtainStyledAttributes(attrs, R.styleable.ExEditText); mLineColor = array.getColor(R.styleable.ExEditText_line_color, getResources().getColor(R.color.Red)); mLineStrokeHeight = array.getDimension(R.styleable.ExEditText_line_stroke_height, dp2px(getContext(), 1)); array.recycle(); &#125;&#125; 需要注意的点让View支持wrap_content这是因为直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果 如果有必要，让你的View支持padding这是因为直接继承View的控件，如果不在draw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。 尽量不要在View中使用Handler，没必要这是因为View内部本身就提供了post系列的方法，完全可以替代Handler的作用，当然除非你很明确地要使用Handler来发送消息。 View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow如果有线程或者动画需要停止时，那么onDetachedFromWindow是一个很好的时机。当包含此View的Activity退出或者当前View被remove时，View的 onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄漏。 View带有滑动嵌套情形时，需要处理好滑动冲突参考 《Android开发艺术探索》 自定义控件进阶:declare-styleable重用attr","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"自定义View之Canvas","date":"2022-03-08T02:25:29.620Z","path":"wiki/Android/UI/自定义View之Canvas/","text":"目录自定义View自定义View之Canvas自定义View之Paint API颜色填充1234canvas.drawColor(Color.BLACK);canvas.drawColor(Color.parse(&quot;#88880000&quot;); // 半透明红色canvas.drawRGB(100, 200, 100);canvas.drawARGB(100, 100, 200, 100); 画圆12345678/**前两个参数 centerX centerY 是圆心的坐标，第三个参数 radius 是圆的半径，单位都是像素*/drawCircle(float centerX, float centerY, float radius, Paint paint) canvas.drawCircle(300, 300, 200, paint); 画矩形12345paint.setStyle(Style.FILL);canvas.drawRect(100, 100, 500, 500, paint);paint.setStyle(Style.STROKE);canvas.drawRect(700, 100, 1100, 500, paint); 画点12345678910111213141516171819202122/**x 和 y 是点的坐标*/drawPoint(float x, float y, Paint paint)paint.setStrokeWidth(20);paint.setStrokeCap(Paint.Cap.ROUND);canvas.drawPoint(50, 50, paint);/**pts 这个数组是点的坐标，每两个成一对offset 表示跳过数组的前几个数再开始记坐标；count 表示一共要绘制几个点*/drawPoints(float[] pts, int offset, int count, Paint paint)drawPoints(float[] pts, Paint paint) float points = &#123;0, 0, 50, 50, 50, 100, 100, 50, 100, 100, 150, 50, 150, 100&#125;;// 绘制四个点：(50, 50) (50, 100) (100, 50) (100, 100)canvas.drawPoints(points, 2 /* 跳过两个数，即前两个 0 */, 8 /* 一共绘制 8 个数（4 个点）*/, paint); 画椭圆12345/**left, top, right, bottom 是这个椭圆的左、上、右、下四个边界点的坐标。*/drawOval(float left, float top, float right, float bottom, Paint paint) 画线1234567891011121314151617/**startX, startY, stopX, stopY 分别是线的起点和终点坐标。*/drawLine(float startX, float startY, float stopX, float stopY, Paint paint) canvas.drawLine(200, 200, 800, 500, paint);/**批量画线*/drawLines(float[] pts, int offset, int count, Paint paint) drawLines(float[] pts, Paint paint)float points = &#123;20, 20, 120, 20, 70, 20, 70, 120, 20, 120, 120, 120, 150, 20, 250, 20, 150, 20, 150, 120, 250, 20, 250, 120, 150, 120, 250, 120&#125;;canvas.drawLines(points, paint); 画圆角矩形12345678/**left, top, right, bottom 是四条边的坐标，rx 和 ry 是圆角的横向半径和纵向半径。*/drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)canvas.drawRoundRect(100, 100, 500, 300, 50, 50, paint); 弧形或扇形12345678910111213141516/**drawArc() 是使用一个椭圆来描述弧形的。left, top, right, bottom 描述的是这个弧形所在的椭圆；startAngle 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），sweepAngle 是弧形划过的角度；useCenter 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。*/drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) paint.setStyle(Paint.Style.FILL); // 填充模式canvas.drawArc(200, 100, 800, 500, -110, 100, true, paint); // 绘制扇形canvas.drawArc(200, 100, 800, 500, 20, 140, false, paint); // 绘制弧形paint.setStyle(Paint.Style.STROKE); // 画线模式canvas.drawArc(200, 100, 800, 500, 180, 60, false, paint); // 绘制不封口的弧形 画自定义图形123456drawPath(Path path, Paint paint) 画 Bitmap123drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 绘制文字 drawText() drawTextRun() drawTextOnPath() 1234drawText(String text, float x, float y, Paint paint)canvas.drawText(text, 200, 100, paint); 范围裁切clipRect1234canvas.save();canvas.clipRect(left, top, right, bottom);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore(); clipPath12345canvas.save();canvas.clipPath(path1);canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 几何变换 使用 Canvas 来做常见的二维变换； 使用 Matrix 来做常见和不常见的二维变换； 使用 Camera 来做三维变换。 Canvas二维变换12345678910111213141516171819202122232425//translate平移canvas.save();canvas.translate(200, 0);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore();//旋转canvas.save();canvas.rotate(45, centerX, centerY);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore();//缩放canvas.save();canvas.scale(1.3f, 1.3f, x + bitmapWidth / 2, y + bitmapHeight / 2);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore();//错切canvas.save();canvas.skew(0, 0.5f);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore(); Matrix二维变换Matrix 做常见变换的方式： 创建 Matrix 对象； 调用 Matrix 的 pre&#x2F;postTranslate&#x2F;Rotate&#x2F;Scale&#x2F;Skew() 方法来设置几何变换； 使用 Canvas.setMatrix(matrix) 或 Canvas.concat(matrix) 来把几何变换应用到 Canvas。 1234567891011121314Matrix matrix = new Matrix();...matrix.reset();matrix.postTranslate();matrix.postRotate();canvas.save();canvas.concat(matrix);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore(); Camera三维变换123456789canvas.save();camera.save(); // 保存 Camera 的状态camera.rotateX(30); // 旋转 Camera 的三维空间camera.applyToCanvas(canvas); // 把旋转投影到 Canvascamera.restore(); // 恢复 Camera 的状态canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 参考 https://rengwuxian.com/ui-1-1/ https://rengwuxian.com/ui-1-4/","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"自定义View之Paint","date":"2022-03-08T02:25:29.620Z","path":"wiki/Android/UI/自定义View之Paint/","text":"目录自定义View自定义View之Canvas自定义View之Paint API颜色设置123456789101112setColor(int color)paint.setColor(Color.parseColor(&quot;#009688&quot;));canvas.drawRect(30, 30, 230, 180, paint);setARGB(int a, int r, int g, int b)paint.setARGB(100, 255, 0, 0);canvas.drawRect(0, 0, 200, 200, paint); Shader设置在 Android 的绘制里使用 Shader ，并不直接用 Shader 这个类，而是用它的几个子类。具体来讲有： LinearGradient：线性渐变 RadialGradient：辐射渐变 SweepGradient：扫描渐变 BitmapShader ComposeShader：混合着色器 在设置了 Shader 的情况下， Paint.setColor&#x2F;ARGB() 所设置的颜色就不再起作用。 1234567891011121314151617181920212223242526272829Shader shader = new LinearGradient(100, 100, 500, 500, Color.parseColor(&quot;#E91E63&quot;), Color.parseColor(&quot;#2196F3&quot;), Shader.TileMode.CLAMP);paint.setShader(shader);...canvas.drawCircle(300, 300, 200, paint);Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.batman);Shader shader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);paint.setShader(shader);...canvas.drawCircle(300, 300, 200, paint);// 第一个 Shader：头像的 BitmapBitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.batman);Shader shader1 = new BitmapShader(bitmap1, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);// 第二个 Shader：从上到下的线性渐变（由透明到黑色）Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.batman_logo);Shader shader2 = new BitmapShader(bitmap2, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);// ComposeShader：结合两个 ShaderShader shader = new ComposeShader(shader1, shader2, PorterDuff.Mode.SRC_OVER);paint.setShader(shader);...canvas.drawCircle(300, 300, 300, paint); PorterDuff.Mode 是用来指定两个图像共同绘制时的颜色策略的。它是一个 enum，不同的 Mode 可以指定不同的策略。参考： https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html 颜色滤镜 ColorFilter LightingColorFilter PorterDuffColorFilter ColorMatrixColorFilter 12345678setColorFilter(ColorFilter colorFilter)ColorFilter lightingColorFilter = new LightingColorFilter(0x00ffff, 0x000000);paint.setColorFilter(lightingColorFilter); setXfermode1 设置抗锯齿抗锯齿默认是关闭的，如果需要抗锯齿，需要显式地打开。另外，除了 setAntiAlias(aa) 方法，打开抗锯齿还有一个更方便的方式：构造方法。创建 Paint 对象的时候，构造方法的参数里加一个 ANTI_ALIAS_FLAG 的 flag，就可以在初始化的时候就开启抗锯齿。 12345setAntiAlias (boolean aa)Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); setStyle1234567paint.setStyle(Paint.Style.FILL); // FILL 模式，填充canvas.drawCircle(300, 300, 200, paint);paint.setStyle(Paint.Style.STROKE); // STROKE 模式，画线canvas.drawCircle(300, 300, 200, paint); 线条形状 setStrokeWidth(float width) setStrokeCap(Paint.Cap cap) setStrokeJoin(Paint.Join join) setStrokeMiter(float miter) 1234567paint.setStyle(Paint.Style.STROKE);paint.setStrokeWidth(1);canvas.drawCircle(150, 125, 100, paint);paint.setStrokeWidth(5);canvas.drawCircle(400, 125, 100, paint);paint.setStrokeWidth(40);canvas.drawCircle(650, 125, 100, paint); setStrokeCap线头形状有三种： BUTT 平头（默认） ROUND 圆头 SQUARE 方头。 1 setStrokeJoin MITER 尖角 BEVEL 平角 ROUND 圆角。 setStrokeMiter这个方法是对于 setStrokeJoin() 的一个补充，它用于设置 MITER 型拐角的延长线的最大值。 色彩优化123456789//设置图像的抖动setDither(boolean dither)//设置是否使用双线性过滤来绘制 Bitmap setFilterBitmap(boolean filter) setPathEffect使用 PathEffect 来给图形的轮廓设置效果。对 Canvas 所有的图形绘制有效，也就是 drawLine() drawCircle() drawPath() 这些方法。 CornerPathEffect把所有拐角变成圆角 1234PathEffect pathEffect = new CornerPathEffect(20);paint.setPathEffect(pathEffect);...canvas.drawPath(path, paint); DiscretePathEffect把线条进行随机的偏离，让轮廓变得乱七八糟。乱七八糟的方式和程度由参数决定。 12345PathEffect pathEffect = new DiscretePathEffect(20, 5);paint.setPathEffect(pathEffect);...canvas.drawPath(path, paint); 绘制虚线123456789101112131415//使用虚线来绘制线条。PathEffect pathEffect = new DashPathEffect(new float[]&#123;20, 10, 5, 10&#125;, 0);paint.setPathEffect(pathEffect);...canvas.drawPath(path, paint);Path dashPath = ...; // 使用一个三角形来做 dashPathEffect pathEffect = new PathDashPathEffect(dashPath, 40, 0, PathDashPathEffectStyle.TRANSLATE);paint.setPathEffect(pathEffect);...canvas.drawPath(path, paint); SumPathEffect123456PathEffect dashEffect = new DashPathEffect(new float[]&#123;20, 10&#125;, 0);PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new SumPathEffect(dashEffect, discreteEffect);...canvas.drawPath(path, paint); ComposePathEffectsetShadowLayer在之后的绘制内容下面加一层阴影 123paint.setShadowLayer(10, 0, 0, Color.RED);...canvas.drawText(text, 80, 300, paint); setMaskFilter为之后的绘制设置 MaskFilter。上一个方法 setShadowLayer() 是设置的在绘制层下方的附加效果；而这个 MaskFilter 和它相反，设置的是在绘制层上方的附加效果。 MaskFilter 有两种： BlurMaskFilter 和 EmbossMaskFilter 123paint.setMaskFilter(new BlurMaskFilter(50, BlurMaskFilter.Blur.NORMAL));...canvas.drawBitmap(bitmap, 100, 100, paint); 文字相关setTextSize设置字体大小 setTypeface设置字体 setFakeBoldText是否使用伪粗体 setStrikeThruText是否加删除线 setUnderlineText是否加下划线 setTextSkewX设置文字横向错切角度 setTextScaleX设置文字横向放缩 setLetterSpacing设置字符间距 setFontFeatureSettings用 CSS 的 font-feature-settings 的方式来设置文字 1234paint.setFontFeatureSettings(&quot;smcp&quot;); // 设置 &quot;small caps&quot;canvas.drawText(&quot;Hello HenCoder&quot;, 100, 150, paint); setTextAlign设置文字的对齐方式。一共有三个值：LEFT CETNER 和 RIGHT。默认值为 LEFT。 setTextLocale设置绘制所使用的 Locale setHinting设置是否启用字体的 hinting （字体微调） getFontSpacing获取推荐的行距 getTextBounds获取文字的显示范围 measureText测量文字的宽度并返回 getTextWidthsgetTextWidths(String text, float[] widths) 获取字符串中每个字符的宽度，并把结果填入参数 widths breakText也是用来测量文字宽度的。但和 measureText() 的区别是， breakText() 是在给出宽度上限的前提下测量文字的宽度。如果文字的宽度超出了上限，那么在临近超限的位置截断文字。 光标相关getRunAdvance1234/**start end 是文字的起始和结束坐标；contextStart contextEnd 是上下文的起始和结束坐标；isRtl 是文字的方向；offset 是字数的偏移，即计算第几个字符处的光标。*/getRunAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset) getOffsetForAdvance给出一个位置的像素值，计算出文字中最接近这个位置的字符偏移量（即第几个字符最接近这个坐标）。 123456789/**text 是要测量的文字；start end 是文字的起始和结束坐标；contextStart contextEnd 是上下文的起始和结束坐标；isRtl 是文字方向；advance 是给出的位置的像素值。填入参数，对应的字符偏移量将作为返回值返回。*/getOffsetForAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance) 参考 https://rengwuxian.com/ui-1-2/ https://rengwuxian.com/ui-1-3/","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"RecyclerView之缓存策略","date":"2022-03-08T02:25:29.619Z","path":"wiki/Android/UI/RecyclerView之缓存策略/","text":"目录 RecyclerView之概述 RecyclerView之绘制流程 RecyclerView之Adapter RecyclerView之ItemDecoration RecyclerView之ItemAnimator RecyclerView之DiffUtil RecyclerView之缓存策略 概述Recycler12345678910111213141516171819202122232425262728293031323334353637383940public final class Recycler &#123; // 未与RecyclerView分离的ViewHolder列表 // 如果仍依赖于 RecyclerView （比如已经滑动出可视范围，但还没有被移除掉），但已经被标记移除的 ItemView 集合会被添加到 mAttachedScrap 中 final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; int mViewCacheMax = DEFAULT_CACHE_SIZE; // 缓存池，业务场景中可复用的ViewHolder可以存储进来 RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; static final int DEFAULT_CACHE_SIZE = 2; // 将view对应的ViewHolder移动到mCachedViews中；如果View是scrapped状态，会先unscrap public void recycleView(@NonNull View view) &#123;&#125; // 从mChangedScrap、mAttachedScrap、mCachedViews、ViewCacheExtension、RecycledViewPool中进行匹配；若匹配不了， // 最后会直接调用Adapter.createViewHolder方法进行创建 ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; &#125; //从 attach scrap、hidden children 、 cache中，根据 position 返回 ViewHolder ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) &#123; &#125;&#125; 缓存类型 mAttachedScrap、mChangedScrap mAttachedScrap保存依附于 RecyclerView 的 ViewHolder。包含移出屏幕但未从 RecyclerView 移除的 ViewHolder。 mChangedScrap 保存数据发生改变的 ViewHolder，即调用 notifyDataSetChanged() 等系列方法后需要更新的 ViewHolder。 mCachedViews mCachedViews 用于解决滑动抖动的问题，默认容量为2。 ViewCacheExtension 开发者自定义的缓存 RecyclerViewPool 缓存池，可以在多个RecyclerView中共享ViewHolder。通过setMaxRecycledViews设置对应type的ViewHolder的缓存池大小 获取VH流程 RecyclerViewPool缓存池的用法： 1234567var linearLayoutManager = LinearLayoutManager(activity)linearLayoutManager.recycleChildrenOnDetach = truerecyclerView.layoutManager = linearLayoutManager//设置缓存大小recycledViewPool.setMaxRecycledViews(0, 10)//共用缓存池recyclerView.setRecycledViewPool(recycledViewPool) 参考 https://phantomvk.github.io/2019/02/13/RecyclerView_cache&#x2F;","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://airshu.github.io/tags/RecyclerView/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"RecyclerView之绘制流程","date":"2022-03-08T02:25:29.618Z","path":"wiki/Android/UI/RecyclerView之绘制流程/","text":"目录 RecyclerView之概述 RecyclerView之绘制流程 RecyclerView之Adapter RecyclerView之ItemDecoration RecyclerView之ItemAnimator RecyclerView之DiffUtil RecyclerView之缓存策略 绘制流程onMeasure先概括下onMeasure的大致流程： LayoutManager对象为空,RecyclerView不能显示任何的数据。 LayoutManager开启了自动测量时，在这种情况下，有可能会测量两次。 LayoutManager没有开启自动测量的情况，这种情况比较少，因为为了RecyclerView支持warp_content属性，系统提供的LayoutManager都开启自动测量的 测量的状态保存在State中，有以下几种状态： 值 描述 State.STEP_START mState.mLayoutStep 的默认值，这种情况下，表示 RecyclerView 还未经历 dispatchLayoutStep1，因为 dispatchLayoutStep1 调用之后mState.mLayoutStep 会变为 State.STEP_LAYOUT。 State.STEP_LAYOUT 当 mState.mLayoutStep 为 State.STEP_LAYOUT 时，表示此时处于 layout 阶段，这个阶段会调用 dispatchLayoutStep2 方法 layout RecyclerView 的children。调用 dispatchLayoutStep2 方法之后，此时 mState.mLayoutStep 变为了 State.STEP_ANIMATIONS。 State.STEP_ANIMATIONS 当 mState.mLayoutStep为 State.STEP_ANIMATIONS 时，表示 RecyclerView 处于第三个阶段，也就是执行动画的阶段，也就是调用 dispatchLayoutStep3方法。当 dispatchLayoutStep3 方法执行完毕之后，mState.mLayoutStep 又变为了 State.STEP_START。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179@Overrideprotected void onMeasure(int widthSpec, int heightSpec) &#123; //当布局管理器为空时，进行默认的测量。RecyclerView不能显示任何的数据 if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec); return; &#125; //自动测量 if (mLayout.isAutoMeasureEnabled()) &#123; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); // 开始测量 if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); &#125; mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; //测量的第二步，更新子布局 dispatchLayoutStep2(); //如果rclerview没有精确的宽度和高度，并且至少有一个子View //子View也没有精确的宽度和高度，我们必须重新测量。 if (mLayout.shouldMeasureTwice()) &#123; mLayout.setMeasureSpecs( MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); mState.mIsMeasuring = true; dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); &#125; &#125; else &#123; //是否使用固定尺寸 if (mHasFixedSize) &#123; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); return; &#125; // if (mAdapterUpdateDuringMeasure) &#123; processAdapterUpdatesAndSetAnimationFlags(); &#125; else if (mState.mRunPredictiveAnimations) &#123; setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight()); return; &#125; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); &#125; &#125;/** * - 处理 Adapter 更新 * - 决定执行哪一种动画 * - 保存每个 ItemView 的信息 * - 有必要的话，会进行预布局，并把相关信息保存下来 */private void dispatchLayoutStep1() &#123; mState.assertLayoutStep(State.STEP_START); fillRemainingScrollValues(mState); mState.mIsMeasuring = false; startInterceptRequestLayout(); mViewInfoStore.clear(); onEnterLayoutOrScroll(); processAdapterUpdatesAndSetAnimationFlags(); saveFocusInfo(); mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged; mItemsAddedOrRemoved = mItemsChanged = false; // 是否预布局 mState.mInPreLayout = mState.mRunPredictiveAnimations; mState.mItemCount = mAdapter.getItemCount(); findMinMaxChildLayoutPositions(mMinMaxLayoutPositions); if (mState.mRunSimpleAnimations) &#123; // Step 0: Find out where all non-removed items are, pre-layout int count = mChildHelper.getChildCount(); for (int i = 0; i &lt; count; ++i) &#123; //根据当前的显示在界面上的ViewHolder的布局信息创建一个ItemHolderInfo final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123; continue; &#125; // 记录当前的位置信息 Left、Right、Top、Bottom等 final ItemHolderInfo animationInfo = mItemAnimator .recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads()); //把 holder对应的animationInfo保存到 mViewInfoStore中 mViewInfoStore.addToPreLayout(holder, animationInfo); if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved() &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123; long key = getChangedHolderKey(holder); mViewInfoStore.addToOldChangeHolders(key, holder); &#125; &#125; &#125; if (mState.mRunPredictiveAnimations) &#123; saveOldPositions(); final boolean didStructureChange = mState.mStructureChanged; mState.mStructureChanged = false; // temporarily disable flag because we are asking for previous layout //在layoutmanager中进行测量 mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = didStructureChange; for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123; final View child = mChildHelper.getChildAt(i); final ViewHolder viewHolder = getChildViewHolderInt(child); if (viewHolder.shouldIgnore()) &#123; continue; &#125; if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123; int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder); boolean wasHidden = viewHolder .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); if (!wasHidden) &#123; flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; &#125; final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation( mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads()); if (wasHidden) &#123; recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo); &#125; else &#123; mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo); &#125; &#125; &#125; // we don&#x27;t process disappearing list because they may re-appear in post layout pass. clearOldPositions(); &#125; else &#123; clearOldPositions(); &#125; onExitLayoutOrScroll(); stopInterceptRequestLayout(false); //设置状态 mState.mLayoutStep = State.STEP_LAYOUT;&#125; /** * 第二步，我们会真正的测量视图。 * 这一步可能执行多次 */private void dispatchLayoutStep2() &#123; startInterceptRequestLayout(); onEnterLayoutOrScroll(); mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount();//返回元素个数 mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; if (mPendingSavedState != null &amp;&amp; mAdapter.canRestoreState()) &#123; if (mPendingSavedState.mLayoutState != null) &#123; mLayout.onRestoreInstanceState(mPendingSavedState.mLayoutState); &#125; mPendingSavedState = null; &#125; // Step 2: Run layout // 更改此状态，确保不是会执行上一布局操作 mState.mInPreLayout = false; //LayoutManager中进行子视图测量 //子视图的测量通用具体的布局管理器实现 mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = false; // onLayoutChildren may have caused client code to disable item animations; re-check mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null; //设置状态 mState.mLayoutStep = State.STEP_ANIMATIONS; onExitLayoutOrScroll(); stopInterceptRequestLayout(false);&#125; 我们看看LinearLayoutManager是如何测量的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; //布局算法 // 1)通过检查子变量和其他变量，找到一个锚坐标和一个锚物品的位置。 // 2)开始填充，从底部开始堆叠 // 3)向底填充，从上往下堆叠 // 4)从底部滚动以满足堆栈等需求。创建布局状态 // 解决布局方向 resolveShouldLayoutReverse(); final View focused = getFocusedChild(); if (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION || mPendingSavedState != null) &#123; mAnchorInfo.reset(); mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; // calculate anchor position and coordinate // 计算锚点位置和坐标 updateAnchorInfoForLayout(recycler, state, mAnchorInfo); mAnchorInfo.mValid = true; &#125; else if (focused != null &amp;&amp; (mOrientationHelper.getDecoratedStart(focused) &gt;= mOrientationHelper.getEndAfterPadding() || mOrientationHelper.getDecoratedEnd(focused) &lt;= mOrientationHelper.getStartAfterPadding())) &#123; // This case relates to when the anchor child is the focused view and due to layout // shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows // up after tapping an EditText which shrinks RV causing the focused view (The tapped // EditText which is the anchor child) to get kicked out of the screen. Will update the // anchor coordinate in order to make sure that the focused view is laid out. Otherwise, // the available space in layoutState will be calculated as negative preventing the // focused view from being laid out in fill. // Note that we won&#x27;t update the anchor position between layout passes (refer to // TestResizingRelayoutWithAutoMeasure), which happens if we were to call // updateAnchorInfoForLayout for an anchor that&#x27;s not the focused view (e.g. a reference // child which can change between layout passes). mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused)); &#125; if (mAnchorInfo.mLayoutFromEnd) &#123; updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtraFillSpace = extraForStart; fill(recycler, mLayoutState, state, false); &#125; else &#123; fill(recycler, mLayoutState, state, false); &#125; &#125;int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) &#123; while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunkResult.resetInternal(); if (RecyclerView.VERBOSE_TRACING) &#123; TraceCompat.beginSection(&quot;LLM LayoutChunk&quot;); &#125; //填充item layoutChunk(recycler, state, layoutState, layoutChunkResult); &#125; &#125;/**1. 调用layoutState.next(recycler)获取View2. addView3. measureChildWithMargins进行子View测量*/void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; View view = layoutState.next(recycler); LayoutParams params = (LayoutParams) view.getLayoutParams(); if (layoutState.mScrapList == null) &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; //添加item的视图 addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addDisappearingView(view); &#125; else &#123; addDisappearingView(view, 0); &#125; &#125; // 测量view measureChildWithMargins(view, 0, 0); ...&#125; 流程图如下： onLayout123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;void dispatchLayout() &#123; //这个时候测量已经结束 mState.mIsMeasuring = false; if (mState.mLayoutStep == State.STEP_START) &#123; //当还是测量初始状态时，走上面的测量流程 dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else if (mAdapterHelper.hasUpdates() || needsRemeasureDueToExactSkip || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; // First 2 steps are done in onMeasure but looks like we have to run again due to // changed size. // 数据更新、改变尺寸后需要重新测量 mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) // 确保跟布局管理器同步 mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3(); &#125;/**布局的最后一步，我们保存关于视图的动画信息，触发动画并进行必要的清理*/private void dispatchLayoutStep3() &#123; //恢复默认值 mState.mLayoutStep = State.STEP_START; //如果有动画 if (mState.mRunSimpleAnimations) &#123; // Step 3: Find out where things are now, and process change animations. // traverse list in reverse because we may call animateChange in the loop which may // remove the target view holder. // 遍历子元素 for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123; // 拿到VH ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); if (holder.shouldIgnore()) &#123; continue; &#125; long key = getChangedHolderKey(holder); final ItemHolderInfo animationInfo = mItemAnimator .recordPostLayoutInformation(mState, holder); ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key); if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123; // run a change animation // If an Item is CHANGED but the updated version is disappearing, it creates // a conflicting case. // Since a view that is marked as disappearing is likely to be going out of // bounds, we run a change animation. Both views will be cleaned automatically // once their animations finish. // On the other hand, if it is the same view holder instance, we run a // disappearing animation instead because we are not going to rebind the updated // VH unless it is enforced by the layout manager. final boolean oldDisappearing = mViewInfoStore.isDisappearing( oldChangeViewHolder); final boolean newDisappearing = mViewInfoStore.isDisappearing(holder); if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123; // run disappear animation instead of change mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; else &#123; final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout( oldChangeViewHolder); // we add and remove so that any post info is merged. mViewInfoStore.addToPostLayout(holder, animationInfo); ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder); if (preInfo == null) &#123; handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder); &#125; else &#123; // 添加新的视图 // 添加到ChildHelper上 animateChange(oldChangeViewHolder, holder, preInfo, postInfo, oldDisappearing, newDisappearing); &#125; &#125; &#125; else &#123; mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; &#125; // Step 4: Process view info lists and trigger animations // 处理列表的视图信息和触发动画 mViewInfoStore.process(mViewInfoProcessCallback); &#125; mLayout.removeAndRecycleScrapInt(mRecycler); mState.mPreviousLayoutItemCount = mState.mItemCount; mDataSetHasChangedAfterLayout = false; mDispatchItemsChangedEvent = false; mState.mRunSimpleAnimations = false; mState.mRunPredictiveAnimations = false; mLayout.mRequestedSimpleAnimations = false; if (mRecycler.mChangedScrap != null) &#123; mRecycler.mChangedScrap.clear(); &#125; if (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123; // Initial prefetch has expanded cache, so reset until next prefetch. // This prevents initial prefetches from expanding the cache permanently. mLayout.mPrefetchMaxCountObserved = 0; mLayout.mPrefetchMaxObservedInInitialPrefetch = false; mRecycler.updateViewCacheSize(); &#125; //回到布局管理器，同步状态 mLayout.onLayoutCompleted(mState); onExitLayoutOrScroll(); stopInterceptRequestLayout(false); mViewInfoStore.clear(); if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123; dispatchOnScrolled(0, 0); &#125; recoverFocusFromState(); resetFocusInfo();&#125;private void animateChange(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo, boolean oldHolderDisappearing, boolean newHolderDisappearing) &#123; if (oldHolder != newHolder) &#123; if (newHolderDisappearing) &#123; addAnimatingView(newHolder); &#125; oldHolder.mShadowedHolder = newHolder; // old holder should disappear after animation ends //添加视图到管理器 addAnimatingView(oldHolder); mRecycler.unscrapView(oldHolder); newHolder.setIsRecyclable(false); newHolder.mShadowingHolder = oldHolder; &#125; //启动动画 if (mItemAnimator.animateChange(oldHolder, newHolder, preInfo, postInfo)) &#123; postAnimationRunner(); &#125; &#125; 主要的工作内容如下： 检查状态，如果是STEP_START，则先测量； 数据、尺寸发生变化，则走dispatchLayoutStep2； 处理需要播放动画的数据 状态同步给布局管理器 onDraw1234567891011public void onDraw(Canvas c) &#123; super.onDraw(c); final int count = mItemDecorations.size(); // 遍历隔间装饰列表，进行绘制。 // 子视图在自己的onDraw中绘制 for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDraw(c, this, mState); &#125;&#125; 参考","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://airshu.github.io/tags/RecyclerView/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"RecyclerView之ItemDecoration","date":"2022-03-08T02:25:29.617Z","path":"wiki/Android/UI/RecyclerView之ItemDecoration/","text":"目录 RecyclerView之概述 RecyclerView之绘制流程 RecyclerView之Adapter RecyclerView之ItemDecoration RecyclerView之ItemAnimator RecyclerView之DiffUtil RecyclerView之缓存策略 概述ItemDecoration用于在每个元素之间设置视图，比如分割线。它是一个抽象类，我们在使用过程中，只需要实现相应的方法，就能进行视图的大小设置，内容绘制。 方法介绍12345678910111213141516171819//重写绘制方法，画自己想要的内容public void onDraw(@NonNull Canvas c, @NonNull RecyclerView parent) &#123;&#125;//这个方法会在onDraw后面执行public void onDrawOver(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull State state) &#123; onDrawOver(c, parent);&#125;//指定尺寸public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull State state) &#123; getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(), parent);&#125; 参考 https://www.jianshu.com/p/6a093bcc6b83","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://airshu.github.io/tags/RecyclerView/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"RecyclerView之SnapHelper","date":"2022-03-08T02:25:29.617Z","path":"wiki/Android/UI/RecyclerView之SnapHelper/","text":"目录 RecyclerView之概述 RecyclerView之绘制流程 RecyclerView之Adapter RecyclerView之ItemDecoration RecyclerView之ItemAnimator RecyclerView之DiffUtil RecyclerView之缓存策略 概要SnapHelper用于辅助RecyclerView在滚动结束时将Item对齐到某个位置。能让RecyclerView实现类似ViewPager等功能。 RecyclerView描述滚动状态的几个属性： SCROLL_STATE_IDLE：滚动闲置状态，此时并没有手指滑动或者动画执行 SCROLL_STATE_DRAGGING：滚动拖拽状态，由于用户触摸屏幕产生 SCROLL_STATE_SETTLING：自动滚动状态，此时没有手指触摸，一般是由动画执行滚动到最终位置，包括smoothScrollTo等方法的调用 当手指在屏幕上滑动RecyclerView然后松手，RecyclerView中的内容会顺着惯性继续往手指滑动的方向继续滚动直到停止，这个过程叫做Fling。 Fling当触发MotionEvent.ACTION_UP时，RecyclerView会进行fling判断。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public boolean fling(int velocityX, int velocityY) &#123; if (mLayout == null) &#123; Log.e(TAG, &quot;Cannot fling without a LayoutManager set. &quot; + &quot;Call setLayoutManager with a non-null argument.&quot;); return false; &#125; if (mLayoutFrozen) &#123; return false; &#125; final boolean canScrollHorizontal = mLayout.canScrollHorizontally(); final boolean canScrollVertical = mLayout.canScrollVertically(); if (!canScrollHorizontal || Math.abs(velocityX) &lt; mMinFlingVelocity) &#123; velocityX = 0; &#125; if (!canScrollVertical || Math.abs(velocityY) &lt; mMinFlingVelocity) &#123; velocityY = 0; &#125; if (velocityX == 0 &amp;&amp; velocityY == 0) &#123; // If we don&#x27;t have any velocity, return false return false; &#125; //处理嵌套滚动PreFling if (!dispatchNestedPreFling(velocityX, velocityY)) &#123; final View firstChild = mLayout.getChildAt(0); final View lastChild = mLayout.getChildAt(mLayout.getChildCount() - 1); boolean consumed = false; if (velocityY &lt; 0) &#123; consumed = getChildAdapterPosition(firstChild) &gt; 0 || firstChild.getTop() &lt; getPaddingTop(); &#125; if (velocityY &gt; 0) &#123; consumed = getChildAdapterPosition(lastChild) &lt; mAdapter.getItemCount() - 1 || lastChild.getBottom() &gt; getHeight() - getPaddingBottom(); &#125; dispatchNestedFling(velocityX, velocityY, consumed); //通过setOnFlingListener设置mOnFlingListener，由用户来判断是否属性自己定义fling行为 //默认的实现有LinearSnapHelper、PagerSnapHelper if (mOnFlingListener != null &amp;&amp; mOnFlingListener.onFling(velocityX, velocityY)) &#123; return true; &#125; final boolean canScroll = canScrollHorizontal || canScrollVertical; if (canScroll) &#123; velocityX = Math.max(-mMaxFlingVelocity, Math.min(velocityX, mMaxFlingVelocity)); velocityY = Math.max(-mMaxFlingVelocity, Math.min(velocityY, mMaxFlingVelocity)); /默认的Fling操作，最终到OverScroller计算滚动相关的值 mViewFlinger.fling(velocityX, velocityY); return true; &#125; &#125; return false;&#125; 由源码可知，会来到SnapHelper进行判断。 SnapHelperSnapHelper是一个抽象类，具体实现有LinearSnapHelper、PagerSnapHelper。 123456789101112131415161718192021222324/**会计算第二个参数对应的ItemView当前的坐标与需要对齐的坐标之间的距离。该方法返回一个大小为2的int数组，分别对应x轴和y轴方向上的距离。*/public abstract int[] calculateDistanceToFinalSnap(@NonNull RecyclerView.LayoutManager layoutManager, @NonNull View targetView);/**会找到当前layoutManager上最接近对齐位置的那个view，该view称为SanpView，对应的position称为SnapPosition。如果返回null，就表示没有需要对齐的View，也就不会做滚动对齐调整。*/public abstract View findSnapView(RecyclerView.LayoutManager layoutManager);/**会根据触发Fling操作的速率（参数velocityX和参数velocityY）来找到RecyclerView需要滚动到哪个位置，该位置对应的ItemView就是那个需要进行对齐的列表项。我们把这个位置称为targetSnapPosition，对应的View称为targetSnapView。如果找不到targetSnapPosition，就返回RecyclerView.NO_POSITION*/public abstract int findTargetSnapPosition(RecyclerView.LayoutManager layoutManager, int velocityX, int velocityY); 通过下面的代码，注册到RecyclerView中，可以实现相应的效果。 12345//滚动停止时相应的Item停留中间位置new LinearSnapHelper().attachToRecyclerView(mRecyclerView);//类似ViewPage效果new PagerSnapHelper().attachToRecyclerView(mRecyclerView); 来看看LinearSnapHelper的源码 依附RecyclerView流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public void attachToRecyclerView(@Nullable RecyclerView recyclerView) throws IllegalStateException &#123; //如果SnapHelper之前已经附着到此RecyclerView上，不用进行任何操作 if (mRecyclerView == recyclerView) &#123; return; // nothing to do &#125; //如果SnapHelper之前附着的RecyclerView和现在的不一致，清理掉之前RecyclerView的回调 if (mRecyclerView != null) &#123; destroyCallbacks(); &#125; mRecyclerView = recyclerView; if (mRecyclerView != null) &#123; //设置当前RecyclerView对象的回调 setupCallbacks(); //创建一个Scroller对象，用于辅助计算fling的总距离 mGravityScroller = new Scroller(mRecyclerView.getContext(), new DecelerateInterpolator()); //调用snapToTargetExistingView()方法以实现对SnapView的对齐滚动处理 snapToTargetExistingView(); &#125;&#125;private void setupCallbacks() throws IllegalStateException &#123; if (mRecyclerView.getOnFlingListener() != null) &#123; throw new IllegalStateException(&quot;An instance of OnFlingListener already set.&quot;); &#125; //注册滚动监听器 mRecyclerView.addOnScrollListener(mScrollListener); //注册自己 mRecyclerView.setOnFlingListener(this);&#125;// Handles the snap on scroll case.private final RecyclerView.OnScrollListener mScrollListener = new RecyclerView.OnScrollListener() &#123; boolean mScrolled = false; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mScrolled) &#123; mScrolled = false; //对targetView进行滚动调整，以确保停止的位置是在对应的坐标上，这就是RecyclerView添加该OnScrollListener的目的 snapToTargetExistingView(); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; if (dx != 0 || dy != 0) &#123; mScrolled = true; &#125; &#125; &#125;;void snapToTargetExistingView() &#123; if (mRecyclerView == null) &#123; return; &#125; RecyclerView.LayoutManager layoutManager = mRecyclerView.getLayoutManager(); if (layoutManager == null) &#123; return; &#125; //找出SnapView View snapView = findSnapView(layoutManager); if (snapView == null) &#123; return; &#125; //计算出SnapView需要滚动的距离 int[] snapDistance = calculateDistanceToFinalSnap(layoutManager, snapView); //如果需要滚动的距离不是为0，就调用smoothScrollBy（）使RecyclerView滚动相应的距离 if (snapDistance[0] != 0 || snapDistance[1] != 0) &#123; mRecyclerView.smoothScrollBy(snapDistance[0], snapDistance[1]); &#125;&#125; onFling在RecyclerView中的fling方法中，如果依附来LinearSnapHelper，会调用LinearSnapHelper的onFling方法进行判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean onFling(int velocityX, int velocityY) &#123; RecyclerView.LayoutManager layoutManager = mRecyclerView.getLayoutManager(); if (layoutManager == null) &#123; return false; &#125; RecyclerView.Adapter adapter = mRecyclerView.getAdapter(); if (adapter == null) &#123; return false; &#125; //获取RecyclerView要进行fling操作需要的最小速率， //只有超过该速率，ItemView才会有足够的动力在手指离开屏幕时继续滚动下去 int minFlingVelocity = mRecyclerView.getMinFlingVelocity(); //snapFromFling()这个方法，就是通过该方法实现平滑滚动并使得在滚动停止时itemView对齐到目的坐标位置 return (Math.abs(velocityY) &gt; minFlingVelocity || Math.abs(velocityX) &gt; minFlingVelocity) &amp;&amp; snapFromFling(layoutManager, velocityX, velocityY); &#125;private boolean snapFromFling(@NonNull RecyclerView.LayoutManager layoutManager, int velocityX, int velocityY) &#123; //layoutManager必须实现ScrollVectorProvider接口才能继续往下操作 if (!(layoutManager instanceof RecyclerView.SmoothScroller.ScrollVectorProvider)) &#123; return false; &#125; //创建SmoothScroller对象，是一个平滑滚动器，用于对ItemView进行平滑滚动操作 //根据速率计算滑动距离 RecyclerView.SmoothScroller smoothScroller = createScroller(layoutManager); if (smoothScroller == null) &#123; return false; &#125; //通过findTargetSnapPosition()方法，以layoutManager和速率作为参数，找到targetSnapPosition int targetPosition = findTargetSnapPosition(layoutManager, velocityX, velocityY); if (targetPosition == RecyclerView.NO_POSITION) &#123; return false; &#125; //通过setTargetPosition()方法设置滚动器的滚动目标位置 smoothScroller.setTargetPosition(targetPosition); //利用layoutManager启动平滑滚动器，开始滚动到目标位置 layoutManager.startSmoothScroll(smoothScroller); return true;&#125; 总结 使用时使用attachToRecyclerView添加依附 onFling操作触发的时候首先通过findTargetSnapPosition找到最终需要滚动到的位置，然后启动平滑滚动器滚动到指定位置， 在指定位置找出来后，系统会回调onTargetFound,然后调用calculateDistanceToFinalSnap方法计算targetView需要减速滚动的距离，然后通过Action更新给滚动器。 在滚动停止的时候，也就是state变成SCROLL_STATE_IDLE时会调用snapToTargetExistingView，通过findSnapView找到SnapView，然后通过calculateDistanceToFinalSnap计算得到滚动的距离，做最后的对齐调整。 参考 https://www.jianshu.com/p/e54db232df62 https://github.com/rubensousa/GravitySnapHelper","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://airshu.github.io/tags/RecyclerView/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"RecyclerView之概述","date":"2022-03-08T02:25:29.617Z","path":"wiki/Android/UI/RecyclerView之概述/","text":"目录 RecyclerView之概述 RecyclerView之绘制流程 RecyclerView之Adapter RecyclerView之ItemDecoration RecyclerView之ItemAnimator RecyclerView之DiffUtil RecyclerView之缓存策略 相关类 RecyclerView SmoothScroller(RecyclerView内部类)：平滑的速度处理 LinearSmoothScroller：水平方向的处理，用于LinearSnapHelper中 ItemAnimator(RecyclerView内部类)：元素动画类 DefaultItemAnimator：默认动画类 SimpleItemAnimator：抽象类 Recycler(RecyclerView内部类)：保存缓存的类 RecyclerView.State：测量状态 RecyclerListener：当ViewHolder回收时的监听器 LayoutManager：布局管理器基类 LinearLayoutManager：水平布局管理器 GridLayoutManager：方格布局管理器 StaggeredGridLayoutManager：不规则高度的方格管理器 Adapter：视图和数据绑定的适配器，视图复用 ConcatAdapter ViewHolder：视图容器 AdapterHelper： 管理和执行更新操作的帮助类，RecyclerView将每一次更新操作封装成了一个UpdateOp操作，然后通过AdapterHelper进行管理和执行。 OpReorderer：记录操作指令 ChildHelper：布局管理器和RecyclerView的child的处理器，有Callback接口可以对相应事件进行回调 RecyclerViewPool：缓存池 ItemDecoration：元素隔间，比如绘制分隔符 DividerItemDecoration FastScroller ItemTouchHelper DiffUtil：用于比较前后数据的工具类，提升多个item更新的效率 AsyncListDiffer AsyncListUtil ScrollbarHelper SnapHelper：用于辅助RecyclerView在滚动结束时将Item对齐到某个位置 LinearSnapHelper：水平速率计算的帮助类 PagerSnapHelper：类似ViewPage滑动速率帮助类 StableIdStorage ItemTouchHelper AdapterListUpdateCallback OrientationHelper：LayoutManager用于测量child的一个辅助类，可以根据Layoutmanager的布局方式和布局方向来计算得到ItemView的大小位置等信息。 ViewBoundsCheck ViewInfoStore：存放当前VH和相关的InfoRecord InfoRecord（ViewInfoStore内部类）：VH的状态：出现、消失、预布局、实际布局 概述RecyclerView 会回收这些单个的元素。当列表项滚动出屏幕时，RecyclerView 不会销毁其视图。相反，RecyclerView 会对屏幕上滚动的新列表项重用该视图。这种重用可以显著提高性能，改善应用响应能力并降低功耗。 布局管理 LinearLayoutManager：将各个项排列在一维列表中 GridLayoutManager：将各个项排列在二维网格中，就像棋盘上的方格一样。 StaggeredGridLayoutManager：将各个项排列在二维网格中，每一列都在前一列基础上稍微偏移，就像美国国旗中的星星一样。 Adapter通过Adapter来完成数据和视图的绑定，这里使用了模版方法模式，我们只需要完成具体的实现即可。 onCreateViewHolder()：每当 RecyclerView 需要创建新的 ViewHolder 时，它都会调用此方法。此方法会创建并初始化 ViewHolder 及其关联的 View，但不会填充视图的内容，因为 ViewHolder 此时尚未绑定到具体数据。 onBindViewHolder()：RecyclerView 调用此方法将 ViewHolder 与数据相关联。此方法会提取适当的数据，并使用该数据填充 ViewHolder 的布局。例如，如果 RecyclerView 显示的是一个名称列表，该方法可能会在列表中查找适当的名称，并填充 ViewHolder 的 TextView 微件。 getItemCount()：RecyclerView 调用此方法来获取数据集的大小。例如，在通讯簿应用中，这可能是地址总数。RecyclerView 使用此方法来确定什么时候没有更多的列表项可以显示。 常用APIItemDecoration设置单元格间的布局 ItemAnimatorRecycledViewPool用于多个RecyclerView之间共享View ViewCacheExtensionsetNestedScrollingEnabled禁止滑动 setHasFixedSize数据变化不会导致Item高度变化时，可设置此值。 Header&#x2F;Footer数据操作API notifyItemChanged(int position) 更新列表position位置上的数据可以调用 notifyItemInserted(int position) 列表position位置添加一条数据时可以调用，伴有动画效果 notifyItemRemoved(int position) 列表position位置移除一条数据时调用，伴有动画效果 notifyItemMoved(int fromPosition, int toPosition) 列表fromPosition位置的数据移到toPosition位置时调用，伴有动画效果 notifyItemRangeChanged(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项进行数据刷新 notifyItemRangeInserted(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量添加数据时调用，伴有动画效果 notifyItemRangeRemoved(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量删除数据时调用，伴有动画效果 notifyDataSetChanged DiffUtils比较两个数据集，找出差异，再调用notifyItemXXX方法进行更新。 缓存机制 Scrap：屏幕内部的ItemView，通过数据集的position来找到对应的Item，可以直接取过来用； Cache：刚移出屏幕的ItemView，放到Cache里，当Cache里的ItemView重新进入屏幕时，也是通过position来找到对应的Item，直接可以使用，不需要走bindViewHolder()。Cache和 Scrap 一样，都是可以直接通过position来找到对应的Item，不需要重新绑定； ViewCacheExtension：自定义缓存，如果有自定义，需要在这里面找，没有的话直接跳过； RecycledViewPool：所有被废弃的ItemView的Pool，该pool里面的Item都是dirty的，需要通过ViewType来找到数据，找到数据的话，需要重新绑定，不走createViewHodler()，走bindViewHolder()。 RecycledViewPool的用法 不同的RecyclerView共用一个RecycledViewPool RecyclerView的布局管理器需要设置recycleChildrenOnDetach setMaxRecycledViews的设置，设置不同类型的ViewHolder的缓存个数 Adapter中getItemViewType的方法设置ViewHolder的类型 优化设置 onBindViewHolder内不要设置监听器 如果在这里设置，会频繁的重复创建监听器。 高度固定时设置onBindViewHolder 共用RecycleViewPool 参考 https://developer.android.com/guide/topics/ui/layout/recyclerview?hl=zh-cn RecycledViewPool使用 一点点有助于巧用RecyclerView的小技巧 RecyclerView的好伴侣：详解DiffUtil Speed up Your Android RecyclerView Using DiffUtil","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://airshu.github.io/tags/RecyclerView/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"WorkManager","date":"2022-03-08T02:25:29.616Z","path":"wiki/Android/Jetpack/WorkManager/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"http://airshu.github.io/categories/Android/Jetpack/"}]},{"title":"JNI笔记","date":"2022-03-08T02:25:29.616Z","path":"wiki/Android/NDK/JNI笔记/","text":"JNI开发流程 编写声明了native方法的Java类 将Java源代码编译成class字节码文件 用javah -jni 命令生成.h头文件（javah 是 jdk 自带的一个命令，-jni 参数表示将 class 中用native 声明的函数生成 JNI 规则的函数） 用本地代码实现.h头文件中的函数 将本地代码编译成动态库（Windows：*.dll，linux&#x2F;unix：*.so，mac os x：*.jnilib） 拷贝动态库至 java.library.path 本地库搜索目录下，并运行 Java 程序 JVM查找native方法的规则JNI数据类型与Java数据类型的映射关系字符串处理访问数组C&#x2F;C++访问Java实例方法和静态方法C&#x2F;C++访问Java实例变量和静态变量JNI调用构造方法和父类实例方法参考 https://developer.android.com/training/articles/perf-jni wiki.jikexueyuan.com&#x2F;project&#x2F;jni-ndk-developer-guide&#x2F;","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://airshu.github.io/categories/Android/NDK/"}]},{"title":"ConstraintLayout","date":"2022-03-08T02:25:29.616Z","path":"wiki/Android/UI/ConstraintLayout/","text":"概述约束布局，可以降低布局的层次，对性能提升有帮助。 可以把约束理解成一根绳子，比如，如果设置了左侧与父级依赖，则相当于左边有一根绳子拉着自己，就会贴着左边。当右边也有一根绳子拉着自己，则会居中。这跟绳子还可以指向同一个点，比如设置在某个控件的中间位置。也可以设置偏移量bias。 使用约束布局，主要要理解不同控件的约束。比如A控件在B控件上方，则可以使用layout_constraintBottom_toTopOf&#x3D;”B”，同理可设置不同方位。如果是挨着边，则可以设置控件与父级约束。layout_constraintLeft_toLeftOf&#x3D;”parent”表示挨着父级的左边。 layout_constraintLeft_toRightOfconstraintXXX表示约束View自己，XXX分别表示上下左右等位置，toXXXOf表示约束依赖等对象，可以是同级的View，也可以是parent。 layout_constraintBaseline_toBaselineOf对于TextView，可以使用基线对齐，这样文字就能对齐了。 margin两个item之间的间距 不同方位的边距 android:layout_marginStart android:layout_marginEnd android:layout_marginLeft android:layout_marginTop android:layout_marginRight android:layout_marginBottom goneMargin goneMargin 要和 margin 一起使用才有效 在约束的布局 Gone 时，View 自身的 margin 属性会被 goneMargin 替换 Gone 隐藏的控件，会被解析为一个点，其 Margin 会被忽略，它对其他控件的约束仍会保留 常用属性 layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom bias layout_constraintHorizontal_bias 水平偏移 layout_constraintVertical_bias 垂直偏移 两个属性的取值范围在0-1。在水平偏移中，0表示最左，1表示最右；在垂直偏移，0表示最上，1表示最下；0.5表示中间。 Group参考 https://add7.cc/android-base/android-constraintlayout","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"CoordinatorLayout","date":"2022-03-08T02:25:29.616Z","path":"wiki/Android/UI/CoordinatorLayout/","text":"概述","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"RecyclerView之Adapter","date":"2022-03-08T02:25:29.616Z","path":"wiki/Android/UI/RecyclerView之Adapter/","text":"目录 RecyclerView之概述 RecyclerView之绘制流程 RecyclerView之Adapter RecyclerView之ItemDecoration RecyclerView之ItemAnimator RecyclerView之DiffUtil RecyclerView之缓存策略 概述Adapter是RecyclerView的第一个内部类，将RecyclerView和视图关联起来。使用的是很方便的，只要继承它，重写几个方法即可。 123456789101112131415//创建视图public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)//将视图跟当前位置的数据绑定public void onBindViewHolder(RecyclerView.ViewHolder holder, int position)//返回元素的个数public int getItemCount()//设置类型，用于缓存策略中public int getItemViewType(int position) &#123; return 0;&#125; Adapter视图模型中，我们只需要改变数据，并发送通知，系统会自动更新UI。 Adapter内部有一个AdapterDataObservable，继承自Java的Observable，使用观察者模式。RecyclerView中RecyclerViewDataObserver进行监听，最终使用AdapterHelper进行操作。 notifyItemChanged(int position) 更新列表position位置上的数据可以调用 notifyItemInserted(int position) 列表position位置添加一条数据时可以调用，伴有动画效果 notifyItemRemoved(int position) 列表position位置移除一条数据时调用，伴有动画效果 notifyItemMoved(int fromPosition, int toPosition) 列表fromPosition位置的数据移到toPosition位置时调用，伴有动画效果 notifyItemRangeChanged(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项进行数据刷新 notifyItemRangeInserted(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量添加数据时调用，伴有动画效果 notifyItemRangeRemoved(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量删除数据时调用，伴有动画效果 notifyDataSetChanged ApaterHelper管理和执行更新操作的帮助类，RecyclerView将每一次更新操作封装成了一个UpdateOp操作，然后通过AdapterHelper进行管理和执行。 当RecyclerView初始化时，会创建AdapterHelper，然后通过实现的dispatchUpdate方法，最终调用布局管理器进行元素的操作。 它内部有一个静态内部类UpdateOp，定义了相应的操作指令： 12345678910111213141516171819202122232425262728293031final class AdapterHelper implements OpReorderer.Callback &#123;//UpdateOp对象的回收和复用private Pools.Pool&lt;UpdateOp&gt; mUpdateOpPool = new Pools.SimplePool&lt;UpdateOp&gt;(UpdateOp.POOL_SIZE);//将要执行的操作列表final ArrayList&lt;UpdateOp&gt; mPendingUpdates = new ArrayList&lt;UpdateOp&gt;();//需要延迟执行的操作列表final ArrayList&lt;UpdateOp&gt; mPostponedList = new ArrayList&lt;UpdateOp&gt;();//指令操作的记录器// since move operations breaks continuity, their effects on ADD/RM are hard to handle.// we push them to the end of the list so that they can be handled easily.final OpReorderer mOpReorderer; static final class UpdateOp &#123; static final int ADD = 1; static final int REMOVE = 1 &lt;&lt; 1; static final int UPDATE = 1 &lt;&lt; 2; static final int MOVE = 1 &lt;&lt; 3; static final int POOL_SIZE = 30; ... &#125;&#125; preProcess当滑动RecyclerView等原因造成数据改变时，会触发到preProcess方法 12345678910111213141516171819202122232425262728293031void preProcess() &#123; //添加到记录器中 mOpReorderer.reorderOps(mPendingUpdates); final int count = mPendingUpdates.size(); //将待处理队列中的指令进行处理 for (int i = 0; i &lt; count; i++) &#123; UpdateOp op = mPendingUpdates.get(i); switch (op.cmd) &#123; case UpdateOp.ADD: //通过回调到RecyclerView中，找到对应ViewHolder，修改相应数值，比如mPosition applyAdd(op); break; case UpdateOp.REMOVE: applyRemove(op); break; case UpdateOp.UPDATE: applyUpdate(op); break; case UpdateOp.MOVE: applyMove(op); break; &#125; if (mOnItemProcessedCallback != null) &#123; mOnItemProcessedCallback.run(); &#125; &#125; //清空列表 mPendingUpdates.clear();&#125; 参考 https://fsilence.github.io/2020/05/15/RecyclerView-AdapterHelper","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://airshu.github.io/tags/RecyclerView/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"RecyclerView之DiffUtil","date":"2022-03-08T02:25:29.616Z","path":"wiki/Android/UI/RecyclerView之DiffUtil/","text":"目录 RecyclerView之概述 RecyclerView之绘制流程 RecyclerView之Adapter RecyclerView之ItemDecoration RecyclerView之ItemAnimator RecyclerView之DiffUtil RecyclerView之缓存策略 概述使用DiffUtil的原因是替代notifyDataSetChanged，提升性能。 DiffUtil使用的是Eugene Myers的差别算法，这个算法本身不能检查到元素的移动，也就是移动只能被算作先删除、再增加，而DiffUtil是在算法的结果后再进行一次移动检查。假设在不检测元素移动的情况下，算法的时间复杂度为O(N + D2)，而检测元素移动则复杂度为O(N2)。所以，如果集合本身就已经排好序，可以不进行移动的检测提升效率。 ListAdapter和AsyncListDiffer中有使用。 使用123456789101112public void swap(List newList) &#123; MyDiffCallback callback = new MyDiffCallback(oldList, newList); DiffUtil.DiffResult result = DiffUtil.calculateDiff(callback); oldList.clear(); oldList.addAll(newList); result.dispatchUpdatesTo(this);&#125; 使用的步骤： 实现DiffUtil.Callback 调用calculateDiff计算不同点 dispatchUpdatesTo刷新数据 源码分析1234567891011121314151617181920212223242526272829303132333435363738public class DiffUtil &#123; // public static DiffResult calculateDiff(@NonNull Callback cb) &#123; return calculateDiff(cb, true); &#125; public abstract static class Callback &#123; // 旧数据集的长度 public abstract int getOldListSize(); // 新数据集的长度 public abstract int getNewListSize(); // 判断是否是同一个item public abstract boolean areItemsTheSame(int oldItemPosition, int newItemPosition); // 如果item相同，此方法用于判断是否同一个Item的内容也相同 public abstract boolean areContentsTheSame(int oldItemPosition, int newItemPosition); // 如果item相同，内容不同，用 payLoad 记录这个ViewHolder中具体需要更新那个View public Object getChangePayload(int oldItemPosition, int newItemPosition) &#123; return null; &#125; &#125; public static class DiffResult &#123; // 根据diff 数据结果，选择刷新方式 public void dispatchUpdatesTo(@NonNull ListUpdateCallback updateCallback) &#123;&#125; &#125;&#125; 过程如下： 实现DiffUtil.Callback接口 新老数据集通过DiffUtil.calculateDiff计算得到DiffUtil.DiffResult DiffUtil.DiffResult::dispatchUpdatesTo刷新数据 参考 RecyclerView中DiffUtil的一些注意事项 https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil https://github.com/mrmike/DiffUtil-sample","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://airshu.github.io/tags/RecyclerView/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"RecyclerView之ItemAnimator","date":"2022-03-08T02:25:29.616Z","path":"wiki/Android/UI/RecyclerView之ItemAnimator/","text":"目录 RecyclerView之概述 RecyclerView之绘制流程 RecyclerView之Adapter RecyclerView之ItemDecoration RecyclerView之ItemAnimator RecyclerView之DiffUtil RecyclerView之缓存策略 基本用法ItemAnimator用于对每一个元素进行动画控制，Android中默认的实现为DefaultItemAnimator。在DefaultItemAnimator的删除动画中，会对被删除的子视图执行透明度1-0的动画，动画结束后，会删除子视图和回收ViewHolder。 123recyclerView.setItemAnimator(new DefaultItemAnimator());//默认实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public abstract static class ItemAnimator &#123; //表示ViewHolder已经更新 public static final int FLAG_CHANGED = ViewHolder.FLAG_UPDATE; //表示ViewHolder已经被移除 public static final int FLAG_REMOVED = ViewHolder.FLAG_REMOVED; //notifyDataSetChanged已经被调用，ViewHolder已经失效 public static final int FLAG_INVALIDATED = ViewHolder.FLAG_INVALID; //ViewHolder已经移动 public static final int FLAG_MOVED = ViewHolder.FLAG_MOVED; private ItemAnimatorListener mListener = null;//回调监听器 //监听器列表 private ArrayList&lt;ItemAnimatorFinishedListener&gt; mFinishedListeners = new ArrayList&lt;ItemAnimatorFinishedListener&gt;(); //Item移除回调 public boolean animateRemove(RecyclerView.ViewHolder holder) &#123; return false; &#125; //Item添加回调 public boolean animateAdd(RecyclerView.ViewHolder holder) &#123; return false; &#125; //用于控制添加，移动更新时，其它Item的动画执行 public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) &#123; return false; &#125; //Item更新回调，在显式调用notifyItemChanged()或notifyDataSetChanged()时被调用 public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) &#123; return false; &#125; // 真正控制执行动画的地方 // RecyclerView动画的执行方式并不是立即执行，而是每帧执行一次，比如两帧之间添加了多个Item，则会将这些将要执行的动画Pending住， // 保存在成员变量中，等到下一帧一起执行。该方法执行的前提是前面animateXxx()返回true。 public void runPendingAnimations() &#123; &#125; //停止某个Item的动画 public void endAnimation(RecyclerView.ViewHolder item) &#123; &#125; //停止所有动画 public void endAnimations() &#123; &#125; //是否有Item在运行 public boolean isRunning() &#123; return false; &#125; //当ViewHolder出现在屏幕上时被调用 public abstract boolean animateAppearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo); //当ViewHolder消失在屏幕上时被调用 public abstract boolean animateDisappearance(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @Nullable ItemHolderInfo postLayoutInfo); //在没调用notifyItemChanged()和notifyDataSetChanged()的情况下布局发生改变时被调用 public abstract boolean animatePersistence(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo); &#125; DefaultItemAnimator这是RecyclerView的默认实现，删除动画中，会对被删除的子视图执行透明度1-0的动画，动画结束后，会删除子视图和回收ViewHolder。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164public class DefaultItemAnimator extends SimpleItemAnimator &#123; private ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingRemovals = new ArrayList&lt;&gt;();//存放下一帧要执行的一系列add动画 private ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingAdditions = new ArrayList&lt;&gt;();//存放正在执行的一批add动画 private ArrayList&lt;MoveInfo&gt; mPendingMoves = new ArrayList&lt;&gt;(); private ArrayList&lt;ChangeInfo&gt; mPendingChanges = new ArrayList&lt;&gt;(); ArrayList&lt;ArrayList&lt;RecyclerView.ViewHolder&gt;&gt; mAdditionsList = new ArrayList&lt;&gt;();//存放当前正在执行的add动画 ArrayList&lt;ArrayList&lt;MoveInfo&gt;&gt; mMovesList = new ArrayList&lt;&gt;(); ArrayList&lt;ArrayList&lt;ChangeInfo&gt;&gt; mChangesList = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mAddAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mMoveAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mRemoveAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mChangeAnimations = new ArrayList&lt;&gt;(); // 添加动画 @Override public boolean animateAdd(final RecyclerView.ViewHolder holder) &#123; //重置动画，设置默认差值器 resetAnimation(holder); //设置默认状态，透明度为0 holder.itemView.setAlpha(0); //添加到待执行列表中 mPendingAdditions.add(holder); return true; &#125; //fromX、fromY表示起始值 //toX、toY表示目标值 @Override public boolean animateMove(final RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) &#123; final View view = holder.itemView; //计算出未执行的值 fromX += (int) holder.itemView.getTranslationX(); fromY += (int) holder.itemView.getTranslationY(); resetAnimation(holder); int deltaX = toX - fromX; int deltaY = toY - fromY; if (deltaX == 0 &amp;&amp; deltaY == 0) &#123; dispatchMoveFinished(holder); return false; &#125; //把Item位移到未操作前的现位置 if (deltaX != 0) &#123; view.setTranslationX(-deltaX); &#125; if (deltaY != 0) &#123; view.setTranslationY(-deltaY); &#125; mPendingMoves.add(new MoveInfo(holder, fromX, fromY, toX, toY)); return true; &#125; @Override public void runPendingAnimations() &#123; boolean removalsPending = !mPendingRemovals.isEmpty();//判断移除队列是否为空 boolean movesPending = !mPendingMoves.isEmpty(); boolean changesPending = !mPendingChanges.isEmpty(); boolean additionsPending = !mPendingAdditions.isEmpty(); //如果都为空，则执行返回 if (!removalsPending &amp;&amp; !movesPending &amp;&amp; !additionsPending &amp;&amp; !changesPending) &#123; // nothing to animate return; &#125; // First, remove stuff // 先执行移除队列 for (RecyclerView.ViewHolder holder : mPendingRemovals) &#123; animateRemoveImpl(holder); &#125; mPendingRemovals.clear(); // Next, move stuff // 执行移动队列 if (movesPending) &#123; final ArrayList&lt;MoveInfo&gt; moves = new ArrayList&lt;&gt;(); moves.addAll(mPendingMoves); mMovesList.add(moves); mPendingMoves.clear(); Runnable mover = new Runnable() &#123; @Override public void run() &#123; for (MoveInfo moveInfo : moves) &#123; animateMoveImpl(moveInfo.holder, moveInfo.fromX, moveInfo.fromY, moveInfo.toX, moveInfo.toY); &#125; moves.clear(); mMovesList.remove(moves); &#125; &#125;; //是否需要删除动画 if (removalsPending) &#123; View view = moves.get(0).holder.itemView; ViewCompat.postOnAnimationDelayed(view, mover, getRemoveDuration());//等待删除动画结束 &#125; else &#123; mover.run(); &#125; &#125; // Next, change stuff, to run in parallel with move animations // if (changesPending) &#123; final ArrayList&lt;ChangeInfo&gt; changes = new ArrayList&lt;&gt;(); changes.addAll(mPendingChanges); mChangesList.add(changes); mPendingChanges.clear(); Runnable changer = new Runnable() &#123; @Override public void run() &#123; for (ChangeInfo change : changes) &#123; animateChangeImpl(change); &#125; changes.clear(); mChangesList.remove(changes); &#125; &#125;; if (removalsPending) &#123; RecyclerView.ViewHolder holder = changes.get(0).oldHolder; ViewCompat.postOnAnimationDelayed(holder.itemView, changer, getRemoveDuration()); &#125; else &#123; changer.run(); &#125; &#125; // Next, add stuff // 添加动画 if (additionsPending) &#123; final ArrayList&lt;RecyclerView.ViewHolder&gt; additions = new ArrayList&lt;&gt;(); additions.addAll(mPendingAdditions); mAdditionsList.add(additions); mPendingAdditions.clear(); Runnable adder = new Runnable() &#123; @Override public void run() &#123; for (RecyclerView.ViewHolder holder : additions) &#123; animateAddImpl(holder); &#125; additions.clear(); mAdditionsList.remove(additions); &#125; &#125;; if (removalsPending || movesPending || changesPending) &#123; long removeDuration = removalsPending ? getRemoveDuration() : 0; long moveDuration = movesPending ? getMoveDuration() : 0; long changeDuration = changesPending ? getChangeDuration() : 0; long totalDelay = removeDuration + Math.max(moveDuration, changeDuration); View view = additions.get(0).itemView; ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); &#125; else &#123; adder.run(); &#125; &#125; &#125; @Override public boolean animateRemove(final RecyclerView.ViewHolder holder) &#123; //清除、移除Item resetAnimation(holder); //将ViewHolder添加到待移除队列 mPendingRemovals.add(holder); return true; &#125;&#125; 源码流程 自定义ItemAnimator参考 https://www.jianshu.com/p/7171ea362513","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://airshu.github.io/tags/RecyclerView/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"LiveData原理","date":"2022-03-08T02:25:29.615Z","path":"wiki/Android/Jetpack/LiveData原理/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"http://airshu.github.io/categories/Android/Jetpack/"}]},{"title":"Android系统架构","date":"2022-03-08T02:25:29.614Z","path":"wiki/Android/Android系统架构/","text":"系统架构Linux内核层Linux Kernel：Android 的核心系统服务基于Linux 内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。 硬件抽象层Hardware Abstraction Layer：对Linux内核驱动程序的封装，向上提供接口，向下屏蔽了具体的实现细节。硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行进行成为可能。通俗来讲，就是将控制硬件的动作放在硬件抽象层中。 系统运行层Native C&#x2F;C++ Libraries：系统运行层分为C&#x2F;C++运行时库和Android运行时环境。 Android运行时环境在4.4以前使用的是Dalvik，之后使用ART。从5.0开始，正式废弃了Dalvik。 Dalvik什么是Dalvik？ Dalvik是用于Android平台的Java虚拟机 Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一 它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行 dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统 Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行 独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭 特点 Dalvik是依靠一个Just-In-Time(JIT编译)编译器去解释字节码 Dalvik虚拟机下运行Java时，要将字节码通过即时编译器（just in time ，JIT）转换为机器码（机器码才是能真正运行的），这会拖慢应用的运行效率 应用安装时，执行dexopt指令，将dex文件优化为odex文件 应用运行时，会将二进制翻译成机器码流程 Android RuntimeAndroid Runtime特点 应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用，这个过程叫做预编译（AOT,Ahead-Of-Time） 在移除解释代码这一过程后，应用程序执行将更有效率，启动更快 系统性能的显著提升 垃圾回收方面的优化 应用框架层Application Framework：应用框架层，提供了应用开发的核心功能。在实际开发中会使用里面的API。 名称 描述 Activity Manager(活动管理器) 管理各个应用程序生命周期以及通常的导航回退功能 Location Manager(位置管理器) 提供地理位置以及定位功能服务 Package Manager(包管理器) 管理所有安装在Android系统中的应用程序 Notification Manager(通知管理器) 使得应用程序可以在状态栏中显示自定义的提示信息 Resource Manager（资源管理器） 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 Telephony Manager(电话管理器) 管理所有的移动设备功能 Window Manager（窗口管理器） 管理所有开启的窗口程序 Content Providers（内容提供器） 使得不同应用程序之间可以共享数据 View System（视图系统） 构建应用程序的基本组件 应用层System Apps：这里存放的是Android自带的一些App，比如：电话、短信、图库、拍摄等。 源码目录可以从 这里 在线阅读源码，也可以从 https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 下载源码。 以下是Android9的源码目录结构： art：全新的ART运行环境 dalvlkvm：dalvik 运行时代码 dex2oat： dexdump： dexlayout： disassembler： openjdk|vm： openjdk|jvmti： runtime： simulator：模拟器 tools： ahat：Android堆栈分析工具 amm：Actionable Memory Metric bionic：google自己开发的内核库，比GNU的内核更适合移动设备 apex： libc：对系统调用的封装 arch-arm： arch-arm64： arch-common： arch-x86： arch-x86_64： stdio：标准IO tools：一些python工具脚本 libdl： 用于动态库的装载 libm：数学库 upstream-freebsd：很多来自FreeBSD的函数库 libstdc++：标准的C++的功能库 linker：链接模块 tools： bootable：启动引导相关代码 recovery：这个目录用于创建恢复程序 build：存放系统编译规则及generic等基础开发包配置 bazel： blueprint： make： common： core：构建系统的核心目录 clang： combo：编译、编译设置 tasks： envsetup.sh target： board：构建目标设备的配置 product： 哪些apps需要编译 tools：编译过程中需要用到的工具 acp： aplcheck： atree： check_prereq： drolddoc： rbb2565： zipalign： pesto： soong： compatibility cts：Android兼容性测试套件标准 dalvik：dalvik虚拟机 dexdump： dexgen： dexlist： dx： opcode-gen： developers：开发者目录 build： demos： docs： samples： development：应用程序开发相关 apps：包含没有部署到系统到应用 BluetoothDebug： SdkSetup： build： tools：构建过程中需要用到的一些工具 cmds：包含monkey tool python-packages： host： windows：包含Windows版USB驱动 ide：包含对IDE一些配置信息 clion eclipse intellij sdk： scripts： tools： apkcheck：APK检查工具 axl：TCP、HTTP测试 elftree： idegen： emulator： bugreport： ndk： ota_analysis： otagui： winscope： monkey：模拟用户点击的测试工具 vendor_snapshot： vndk： device：设备相关配置 amlogic： common： generic：包含不同设备的配置信息 arm64： art： goldfish： goldfish-opengl： x86： google： google_car： linaro： mediatek： ti： external：开源模组相关文件，可以理解成第三方库的依赖 ImageMagick： FXdiv： OpenCL-CTS： aac： adhd： adt-infra： android-clat： androidplot： angle： antlr：http://www.antlr.org apache-commons-bcel： apache-commons-compress： apache-commons-math： apache-harmony： apache-http： apache-xml： auto： clang： bsdiff： chromium-libpac： chromium-trace： chromium-webview： cpuinfo： curl： dagger2： dexmaker： exoplayer： libogg： libopus： libcap： libpng： lzma： skia：http://code.google.com/p/skia/ v8：Javascript引擎 webp：http://code.google.com/speed/webp webrtc：http://www.webrtc.org frameworks：应用程序框架，Android系统核心部分，由Java和C++编写 av： camera： media：C实现系统媒体库 base： api： boot： cmds：重要命令 am： app_process： pm：包管理工具 config： data：包含字体文件、音频文件、视频文件等 location： media：多媒体相关库 java： jni： audioeffect： soundpool： mca： native： multidex： native：本地库 opengl：2D&#x2F;3D 图形API sax：XML解析器 wifi：wifi无线网络 packages： BackupRestoreConfirmation： DefaultContainerService： SystemUI： Shell： VpnDialogs： compile： ex： hardware： layoutlib： libs： native： opengl：第三方图形渲染库 services： audiomanager： batteryservice： displayservice： gpuservice： inputflinger： surfaceflinger：图形显示库，主要负责图形的渲染、叠加和绘制等功能 sensorservice： vr： hardware：主要是硬件抽象层的代码 broadcom： google： libhardware： libhardware_legacy： nxp： samsung： st： kernel： libcore：核心库相关文件 api： dalvik： dom： json： xml： libnativehelper：动态库，实现JNI库的基础 packages：自带Apps应用程序包 apps：系统App Bluetooth： Calendar： Camera2： Dialer： Launcher3： inputmethods：输入法目录 modules： ArtPrebuilt: DnsResolver: DNS解析 Permission: 权限 adb：adb工具 providers：内容提供者目录 CalendarProvider: DownloadProvider: MediaProvider: TelephonyProvider: screensavers：屏幕保护 services：通信服务 AlternativeNetworkAccess： Telephony wallpapers：墙纸 pdk：Plug Development Kit 的缩写，本地开发套件 platform_testing：平台测试 prebuilts：x86和arm架构下预编译的一些资源 bazel： clang： devtools： gcc： go： gradle-plugin： jdk： python： mlsc： ndk： runtime： tools： common： darwln-x86： linux-x86： linux-x86_64： sdk：sdk和模拟器 annotations： apkbuilder：这个废弃了，推荐直接使用com.android.sdklib.build.ApkBuilder find_java： find_java2： sdklauncher： hierarchyviewer：视图查看器 system：底层文件系统库、应用和组件 apex： bpf： core： debuggerd： logcat： toolbox： watchdogd： extras： ANRdaemon： app-launcher： su： sound：播放wav文件工具 toolchain-extras： test： toolchain：工具链文件 tools：工具文件 参考 https://elinux.org/Master-android Android 虚拟机Art和Dalvik的区别 https://source.android.com/devices/tech/dalvik?hl=zh-cn Android 镜像使用帮助","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"}]},{"title":"ViewPager2","date":"2021-05-31T16:00:00.000Z","path":"wiki/Android/UI/ViewPager2/","text":"参考资料","tags":[],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"}]},{"title":"ANR问题分析和解决","date":"2021-05-31T16:00:00.000Z","path":"wiki/Android/性能优化/ANR问题分析和解决/","text":"ANR类型按键或触摸事件在特定时间内无响应1234//ActivityTaskManagerService.java// How long we wait until we timeout on key dispatching.public static final int KEY_DISPATCHING_TIMEOUT_MS = 5 * 1000; BroadcastRecevier超时12345//ActivityManagerService.java// How long we allow a receiver to run before giving up on it.static final int BROADCAST_FG_TIMEOUT = 10*1000;static final int BROADCAST_BG_TIMEOUT = 60*1000; 前台广播超时时间是 10s，后台广播超时是 60s，这类超时没有提示框弹出。 Service超时12345678ActiveServices.java// How long we wait for a service to finish executing.static final int SERVICE_TIMEOUT = 20 * 1000 * Build.HW_TIMEOUT_MULTIPLIER;// How long we wait for a service to finish executing.static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10; 当发生ANR时，会将相应信息记录到&#x2F;data&#x2F;anr&#x2F;traces.txt 降低ANR的一些技巧 将所有耗时操作，比如访问网络，Socket通信，查询大量SQL语句、IO操作、复杂逻辑计算等都放在子线程中去 onCreate 和 onResume 回调中尽量避免耗时的代码 View 的 onOnTouchevent 和 onclick 中避免耗时的代码 AMS系统时间调节原理 程序等待原理分析 参考","tags":[],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"启动速度优化","date":"2021-05-31T16:00:00.000Z","path":"wiki/Android/性能优化/启动速度优化/","text":"启动流程应用的启动流程如下： SystemServer 负责应用的启动流程调度、进程的创建和管理、 窗口的创建和管理(StartingWindow 和 AppWindow) 等 应用进程被 SystemServer 创建后，进行一系列的进程初始化、 组件初始化(Activity、Service、ContentProvider、Broadcast)、 主界面的构建、内容填充等 概念冷启动当启动应用时，后台没有该应用的进程，这时系统会重 新创建一个新的进程分配给该应用，然后再根据启动的参数，启 动对应的进程组件，这个启动方式就是冷启动 热启动当启动应用时，后台已有该应用的进程(例:按 back 键、home 键，应用虽然会退出，但是该应用的进程是依然会保 留在后台，可进入任务列表查看)，所以在已有进程的情况下， 这种启动会从已有的进程中来启动对应的进程组件，这个方式叫 热启动 温启动温启动包含了在冷启动期间发生的部分操作；同时，它的开销要比热启动高。 优化方案线程优化线程优化主要是减少 CPU 调度带来的波动，让启动时间更稳定。如果 启动过程中有太多的线程一起启动，会给 CPU 带来非常大的压力，尤 其是比较低端的机器。过多的线程同时跑会让主线程的 Sleep 和 Runnable 状态变多， 增加了应用的启动速度，优化的过程中要注意： 控制线程数量（使用线程池） 检查线程间的锁 ，防止依赖等待 使用合理的启动架构 系统调度优化 启动过程中减少系统调用：避免与 AMS、WMS 竞争锁。启动 过程中本身 AMS 和 WMS 的工作就很多，且 AMS 和 WMS 很多操作都是带锁的，如果此时 App 再有过多的Binder 调用 与 AMS、WMS 通信，SystemServer 就会出现大量的锁等待 启动过程中不要启动子进程，如果好几个进程同时启动，系统负 担则会加倍，SystemServer 也会更繁忙 启动过程中除了 Activity 之外的组件启动要谨慎， 因为四大组 件的启动都是在主线程的，如果组件启动慢，占用了 Message 通 道，也会影响应用的启动速度 Application 和主 Activity 的 onCreate 中异步初始化某些代码 GC的优化尽量减少GC的次数，比如： 避免进行大量的字符串操作，特别是序列化和反序列化 频繁创建的对象需要考虑复用 转移到 Native 实现 IO的优化启动过程中负载比较高，有许多系统 IO 都在此时发生，这时候 IO 的 性能下降会比较快，此时 App 中的 IO 操作会比平时更慢一些，尤其 是在性能比较差的机器上。IO 分网络 IO 和磁盘 IO ，启动过程中不建议进行网络 IO。 布局页面优化 通过减少冗余或者嵌套布局来降低视图层次结构 用 ViewStub 替代在启动过程中不需要显示的 UI 控件 使用自定义 View 替代复杂的 View 叠加 windowBackground开启预览窗口，设置主题背景，则可以让用户看起来舒服些。 参考 https://developer.android.com/topic/performance/vitals/launch-time https://juejin.cn/post/6844904080926572558","tags":[],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"adb工具","date":"2021-05-31T16:00:00.000Z","path":"wiki/Android/未分类/adb工具/","text":"查询设备 adb devices List of devices attached emulator-5554 device emulator-5556 device emulator-5558 device 将命令发送至特定设备 adb -s serial_number command adb -s emulator-5556 install helloWorld.apk 拉取&#x2F;推送文件 adb pull remote local adb push local remote adb push foo.txt /sdcard/foo.txt 开启&#x2F;停止adb服务器 adb start-server adb kill-server 将日志输出到屏幕 adb logcat [option] [filter-specs] 获取实例序列号 adb get-serialno 查看应用版本号 adb shell dumpsys package 包名 | findstr version 调用Activity Manager adb shell am start -a android.intent.action.VIEW 命令 说明 start [options] intent 启动 intent 指定的 Activity。 startservice [options] intent 启动 intent 指定的 Service force-stop package 强行停止与 package（应用的包名称）关联的所有应用。 kill [options] package 终止与 package（应用的包名称）关联的所有进程。此命令仅终止可安全终止且不会影响用户体验的进程。 kill-all 终止所有后台进程。 instrument [options] component 使用 Instrumentation 实例启动监控。通常，目标 component 是表单 test_package&#x2F;runner_class。 profile start process file 启动 process 的分析器，将结果写入 file。 set-debug-app [options] package 将应用 package 设为调试。 clear-debug-app 使用 set-debug-app 清除以前针对调试用途设置的软件包。 monitor [options] 启动对崩溃或 ANR 的监控。 screen-compat {on| off} package 控制 package 的屏幕兼容性模式 display-size [reset|widthxheight] 替换模拟器&#x2F;设备显示尺寸。此命令对于在不同尺寸的屏幕上测试您的应用非常有用，它支持使用大屏设备模仿小屏幕分辨率（反之亦然）。示例：am display-size 1280x800 display-density dpi 替换模拟器&#x2F;设备显示密度。此命令对于在不同密度的屏幕上测试您的应用非常有用，它支持使用低密度屏幕在高密度环境环境上进行测试（反之亦然）。示例：am display-density 480 软件包管理器 adb shell pm uninstall com.example.MyApp 命令 说明 list packages [options] filter 输出所有软件包，或者，仅输出包名称包含filter中的文本的软件包。 list permission-groups 输出所有已知的权限组。 list features 输出系统的所有功能。 list libraries 输出当前设备支持的所有库。 install [options] path 将软件包（通过path指定）安装到系统。 clear package 删除与软件包关联的所有数据。 set-install-location location 更改默认安装位置。 屏幕截图 adb shell screencap /sdcard/screen.png 录制视频 adb shell screenrecord /sdcard/demo.mp4 其他Shell命令 adb shell ls /sdcard Shell命令 | 说明dumpsys | 将系统数据转储到屏幕dumpstate | 将状态转储到文件dmesg | 将内核调试消息输出到屏幕。start |启动（重启）模拟器&#x2F;设备实例。stop |停止执行模拟器&#x2F;设备实例。 adb shell dumpsys activity log anr 2 可以打开anr的messagequeue adb shell dumpsys activity a 查看activity详细信息，如显示大小，布局等等 adb shell dumpsys activity | grep mFocusedActivity adb shell &quot;dumpsys activity top | grep ACTIVITY&quot; 显示当前的Activity adb shell dumpsys activity processes 进程信息 trimmemory adb shell &quot;ps | grep 包名&quot; 查看应用的进程id adb shell dumpsys activity recents adb shell dumpsys activity broadcasts 可以查看前台和后台broadcast详细信息(发送时间， 所有应用处理时间，监听广播的所有列表) adb shell dumpsys activity intents adb shell dumpsys activity oom adb shell dumpsys input | grep Focus 查看焦点窗口 //查看当前activity名字 adb shell dumpsys activity activities | grep mFocusedActivity # 8.0以下 adb shell dumpsys activity activities | grep mResumedActivity # 8.0 adb shell ps | findstr com.xxxx.xxx 查看进程信息 adb shell kill -10 pid 触发垃圾回收 adb kill-server &amp;&amp; adb server &amp;&amp; adb shell 重制adb连接 adb shell dumpsys activity activities 查看当前任务栈 gfxinfo123456789101112131415161718192021222324252627adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt;Applications Graphics Acceleration Info:Uptime: 83871844 Realtime: 83871844** Graphics info for pid 23289 [com.xxx.xxx] **Stats since: 74696703302664nsTotal frames rendered: 0 本次dump搜集了0帧的信息Janky frames: 0 (0.00%) 卡顿率50th percentile: 4950ms90th percentile: 4950ms95th percentile: 4950ms99th percentile: 4950msNumber Missed Vsync: 0 垂直同步失败的帧Number High input latency: 0 处理input时间超时的帧数Number Slow UI thread: 0 因UI线程上的工作导致超时的帧数Number Slow bitmap uploads: 0 因bitmap的加载耗时的帧数Number Slow issue draw commands: 0 因绘制导致耗时的帧数Number Frame deadline missed: 0//Android 6.0版本为gfxinfo提供了一个新的命令——framestats，其作用是可以从最近的帧中获取非常详细的帧耗时信息adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt; framestats 模拟用户行为1234567891011发送键盘事件adb shell input keyevent “value”发送鼠标事件(Touch)：adb shell sendevent [device] [type] [code] [value]input text input keyevent input tap input swipe 参考 官方文档 http://blog.hsujee.com/2017/09/25/Android/Framework/2017-09-25-Android%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86/","tags":[],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://airshu.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"IO","date":"2021-05-28T16:00:00.000Z","path":"wiki/Java/基础/IO/","text":"BIO：BlockIO，同步阻塞IO。发起请求 –&gt;一直阻塞–&gt;处理完成 NIO：New IO Non-Block IO，同步非阻塞IO。 Selector主动轮询channel–&gt;处理请求–&gt;处理完成 AIO：异步非阻塞IO。发起请求–&gt; 通知回调 NIO主要有三大核心部分:Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件(比如:连接打开，数据到 达)。因此，单个线程可以监听多个数据通道。 NIO和传统IO(一下简称IO)之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何 地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓 存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时 可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包 含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处 理的数据。 IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一 些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。NIO的非阻塞模式，使 一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用 时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继 续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完 全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执 行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道(channel)。 基于字节的IO操作 基于字符的IO操作 常用类节点流FileInputStream&#x2F;FileOutputStream， FileReader&#x2F;FileWriter 这四个类是专门操作文件流的，用法高度相似，区别在于前面两个是操作字节流， 后面两个是操作字符流。它们都会直接操作文件流，直接与 OS 底层交互。因此他们也被称为节点流。 包装流PrintStream&#x2F;PrintWriter&#x2F;Scanner PrintStream 可以封装(包装)直接与文件交互的节点流对象 OutputStream, 使 得编程人员可以忽略设备底层的差异，进行一致的 IO 操作。因此这种流也称为处理流或者包装流。 PrintWriter 除了可以包装字节流 OutputStream 之外，还能包装字符流 Writer Scanner 可以包装键盘输入，方便地将键盘输入的内容转换成我们想要的数据类 型。 字符串流StringReader&#x2F;StringWriter 这两个操作的是专门操作 String 字符串的流，其中 StringReader 能从 String 中 方便地读取数据并保存到 char 数组，而 StringWriter 则将字符串类型的数据写 入到 StringBuffer 中(因为 String 不可写)。 转换流InputStreamReader&#x2F;OutputStreamReader 这两个类可以将字节流转换成字符流，被称为字节流与字符流之间的桥梁。我们 经常在读取键盘输入(System.in)或网络通信的时候，需要使用这两个类 缓冲流BufferedReader&#x2F;BufferedWriter ， BufferedInputStream&#x2F;BufferedOutputStream 总结 FileInputStream&#x2F;FileOutputStream 需要逐个字节处理原始二进制流的时 候使用，效率低下 FileReader&#x2F;FileWriter 需要组个字符处理的时候使用 StringReader&#x2F;StringWriter 需要处理字符串的时候，可以将字符串保存为 字符数组 PrintStream&#x2F;PrintWriter 用来包装 FileOutputStream 对象，方便直接将 String 字符串写入文件 Scanner 用来包装 System.in 流，很方便地将输入的 String 字符串转换 成需要的数据类型 InputStreamReader&#x2F;OutputStreamReader , 字节和字符的转换桥梁，在网 络通信或者处理键盘输入的时候用 BufferedReader&#x2F;BufferedWriter ， BufferedInputStream&#x2F;BufferedOutputStream ， 缓冲流用来包装字节流后者 字符流，提升 IO 性能，BufferedReader 还可以方便地读取一行，简化编程。","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://airshu.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}]},{"title":"String","date":"2021-05-28T16:00:00.000Z","path":"wiki/Java/基础/String/","text":"StringBuilder和StringBuffer 和String类不同的是，StringBuffer和StringBuilder类的对象能够被多次的修改，并且不产生新的未使用对象。StringBuilder 类在Java5中被提出，它和StringBuffer之间的最大不同在于StringBuilder的方法不是线程安全的","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://airshu.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}]},{"title":"垃圾回收机制","date":"2021-05-28T16:00:00.000Z","path":"wiki/Java/虚拟机/垃圾回收机制/","text":"对象存活 GC算法 运行时数据区 可达性分析与引用计数引用计数法给对象增加一个引用计数器，每当有一个地方引用它时，计数器就+1;当引用失效时，计数器就-1;任何时刻计数器为 0 的对象就是不能再被使用的，即对象已“死”。在主流的 JVM 中没有选用引用计数法来管理内存，最主要的原因是引用计数法无法解决对象的循环引用问题。 可达性分析算法通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任 何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用。以下图为例: 对象 Object5 —Object7 之间虽然彼此还有联系，但是它们到 GC Roots 是不可 达的，因此它们会被判定为可回收对象。 在 Java 语言中，可作为 GC Roots 的对象包含以下几种: 虚拟机栈(栈帧中的本地变量表)中引用的对象。 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中(Native 方法)引用的对象 在 JDK1.2 之后，Java 对引用的概念做了扩充，将引用分为强引用(StrongReference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用 (Phantom Reference)四种，这四种引用的强度依次递减。 即使在可达性分析算法中不可达的对象，也并非”非死不可”的，这时候他们暂时处在”缓刑”阶段。要宣告一个对象的真正死亡，至少要经历两次标记过程: 如果对象在进行可达性分析之后发现没有与 GC Roots 相连接的引用链，那它 将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者finalize()方法已经被 JVM 调 用过，虚拟机会将这两种情况都视为”没有必要执行”，此时的对象才是真正” 死”的对象。 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在 一个叫做 F-Queue 的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer 线程去执行它(这里所说的执行指的是虚拟机会触发finalize() 方法)。finalize()方法是对象逃脱死亡的最后一次机会，稍后 GC 将对 F-Queue中的对象进行第二次小规模标记，如果对象在finalize()中成功拯救自己(只需 要重新与引用链上的任何一个对象建立起关联关系即可)，那在第二次标记时它将会被移除出”即将回收”的集合;如果对象这时候还是没有逃脱，那基本上它就是真的被回收了。 回收方法区方法区(永久代)的垃圾回收主要收集两部分内容:废弃常量和无用类。回收废弃常量和回收 Java 堆中的对象十分类似。以常量池中字面量(直接量)的回 收为例，假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个 String 对象引用常量池中的”abc”常量，也没有其他地方引用这个字面量，如果此时发生 GC 并且有必要的话，这个”abc”常量会被系统清理出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。 判定一个类是否是”无用类”则相对复杂很多。类需要同时满足下面三个条件才会 被算是”无用的类”。 该类的所有实例都已经被回收(即在 Java 堆中不存在任何该类的实例) 加载该类的 ClassLoader 已被回收 该类对应的 Class 对象没有任何其他地方被引用，无法在任何地方通过反射访问该类的方法 垃圾回收算法标记-清除算法复制算法（新生代回收算法）标记整理算法（老年代回收算法）分代收集算法","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://airshu.github.io/tags/JVM/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"虚拟机","slug":"Java/虚拟机","permalink":"http://airshu.github.io/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"内存分配策略","date":"2021-05-28T16:00:00.000Z","path":"wiki/Java/虚拟机/内存分配策略/","text":"JVM栈帧及方法调用详解 JMM、Java Memory Model 对象优先在Edenf分配大对象直接进入老年代长期存活的对象将进入老年代动态对象年龄判定空间分配担保","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://airshu.github.io/tags/JVM/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"虚拟机","slug":"Java/虚拟机","permalink":"http://airshu.github.io/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"AQS解析","date":"2021-05-28T16:00:00.000Z","path":"wiki/Java/并发编程/AQS解析/","text":"","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"CountDownLatch","date":"2021-05-28T16:00:00.000Z","path":"wiki/Java/并发编程/CountDownLatch/","text":"说明CountDownLatch是在java1.5被引入，使一个线程等待其他线程各自执行完毕后再执行。 CountDownLatch是通过共享锁实现的。在创建CountDownLatch中时，会传递一个int类型参数count，该参数是“锁计数器”的初始状态。当某线程调用该CountDownLatch对象的await()方法时，该线程会等待“共享锁”可用时，才能获取共享锁进而继续运行。而“共享锁”可用的条件，就是锁计数器的值为0！而锁计数器的初始值为count，每当一个线程调用该CountDownLatch对象的countDown()方法时，锁计数器减1；直到锁计数器为0时，前面的等待线程才能继续运行！ 使用场景 让多个线程等待：比如模拟多线程并发 让单个线程等待：等待其他线程都处理完后，再执行某个操作 实现原理参考 https://www.cnblogs.com/skywang12345/p/3533887.html https://zhuanlan.zhihu.com/p/148231820","tags":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"ReentrantLock","date":"2021-05-28T16:00:00.000Z","path":"wiki/Java/并发编程/ReentrantLock/","text":"概述ReentrantLock是重入锁。它实现了Lock接口，是基于AQS(一种用于构建同步器的框架)构造出来的一种同步器。 与synchronized相比增加了一些高级功能， 主要有以下三项:等待可中断、可实现公平锁、锁可以绑定多个条件。","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"集合知识点总结","date":"2021-05-28T16:00:00.000Z","path":"wiki/Java/集合/集合知识点总结/","text":"通过迭代器fail-fast属性，你明白了什么? 每次我们尝试获取下一个元素的时候，Iterator fail- fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出 ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的(ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外) fail-fast与fail-safe有什么区别? Iterator的fail-fast属性与当前的集合共同起作用，因此它不会 受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而 java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出 ConcurrentModificationException，而 fail-safe 迭 代 器 从 不 抛 出 ConcurrentModificationException。","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://airshu.github.io/categories/Java/%E9%9B%86%E5%90%88/"}]},{"title":"AsyncTask原理解析","date":"2021-05-28T16:00:00.000Z","path":"wiki/Android/基础/AsyncTask原理解析/","text":"","tags":[],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"作用域函数","date":"2021-05-28T16:00:00.000Z","path":"wiki/程序语言/Kotlin/作用域函数/","text":"","tags":[],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Kotlin","slug":"程序语言/Kotlin","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Kotlin/"}]},{"title":"Fragment","date":"2021-05-01T02:01:01.000Z","path":"wiki/Android/基础/Fragment/","text":"来源Fragment的概念来源于Android3.0，主要目的是为大屏幕（如平板电脑）上更加动态和灵活的界面设计提供支持。他可添加到Activity中，所以多个Activity可添加同一个Fragment，提高了代码复用性。 生命周期 Fragment跟Activity的生命周期类似，不过只有在显示调用addToBackStack()时，系统才会将片段放入由宿主 Activity 管理的返回栈。 生命周期方法onCreate() 系统会在创建片段时调用此方法。当片段经历暂停或停止状态继而恢复后， onCreateView() 系统会在片段首次绘制其界面时调用此方法。如要为片段绘制界面，从此方法中返回的 View 必须是片段布局的根视图。如果片段未提供界面，可以返回 null。 我们创建视图的方法。 onViewCreated onCrateView执行后立即执行，此时可以获取view onPause() 系统会将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。 onAttach() 在片段已与 Activity 关联时进行调用（Activity 传递到此方法内）。 onActivityCreated() 当 Activity 的 onCreate() 方法已返回时进行调用。此时可以进行fragment与activity的交换操作。 onDestroyView() 在移除与片段关联的视图层次结构时进行调用。 onDetach() 在取消片段与 Activity 的关联时进行调用。 Activity和Fragment的生命周期 Activity, Fragment和FragmentManager生命周期 注意点 注意生命周期的对应，比如Eventbus的注册和取消注册 事务为什么Fragment需要事务呢？我的理解是，由于需要对Fragment进行添加、移除、替换等操作，那么FragmentManager的出现是合适的，而FragmentManager内部使用事务的方式来进行管理，就能保证各种操作的原子性了。 基本用法 123456789101112// 1.获取FragmentManager，在活动中可以直接通过调用getFragmentManager()方法得到 fragmentManager = getSupportFragmentManager();// fragmentManager = getFragmentManager(); // 2.开启一个事务，通过调用beginTransaction()方法开启 transaction = fragmentManager.beginTransaction(); // 3.向容器内添加或替换碎片，一般使用replace()方法实现，需要传入容器的id和待添加的碎片实例 transaction.replace(R.id.testFragment, fragment); //fr_container不能为fragment布局，可使用线性布局相对布局等。 // 4.使用addToBackStack()方法，将事务添加到返回栈中，填入的是用于描述返回栈的一个名字 transaction.addToBackStack(null); // 5.提交事物,调用commit()方法来完成 transaction.commit(); 有几个注意点： FragmentActivity和Fragment都有自己的FragmentManager 事务的操作如何通信可通过以下一些方式进行通信： Framgnet中直接获取Activity的引用 Activity中通过FragmentManager获取对应Fragment的引用 通过函数回调 setArguments将参数传递给Fragment 共享ViewModel Fragment Result API 直接获取引用123456//Fragment中获取Activity中的控件View listView = getActivity().findViewById(R.id.list);//Activity中获取某个FragmentExampleFragment fragment = (ExampleFragment) getSupportFragmentManager().findFragmentById(R.id.example_fragment); 这种方式虽然能方便的获取，但从代码设计的角度看是不合适的，耦合性太高了 函数回调1234567891011121314151617181920212223242526272829303132333435363738public static class FragmentA extends ListFragment &#123; ... // Container Activity must implement this interface //定义回调接口 public interface OnArticleSelectedListener &#123; public void onArticleSelected(Uri articleUri); &#125; ...&#125;public static class FragmentA extends ListFragment &#123; OnArticleSelectedListener listener; ... @Override public void onAttach(Context context) &#123; super.onAttach(context); try &#123; //宿主实现该接口，context就是宿主Activity listener = (OnArticleSelectedListener) context; &#125; catch (ClassCastException e) &#123; throw new ClassCastException(context.toString() + &quot; must implement OnArticleSelectedListener&quot;); &#125; &#125; @Override public void onListItemClick(ListView l, View v, int position, long id) &#123; // Append the clicked item&#x27;s row ID with the content provider Uri Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id); // Send the event and Uri to the host activity // 将数据传给Activity，宿主中操作其他Fragment listener.onArticleSelected(noteUri); &#125; ...&#125; 共享ViewModel与宿主Activity通信123456789101112131415161718192021222324252627282930313233343536373839404142public class ItemViewModel extends ViewModel &#123; private final MutableLiveData&lt;Item&gt; selectedItem = new MutableLiveData&lt;Item&gt;(); public void selectItem(Item item) &#123; selectedItem.setValue(item); &#125; public LiveData&lt;Item&gt; getSelectedItem() &#123; return selectedItem; &#125;&#125;public class MainActivity extends AppCompatActivity &#123; private ItemViewModel viewModel; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //注意ViewModelProvider的参数 viewModel = new ViewModelProvider(this).get(ItemViewModel.class); viewModel.getSelectedItem().observe(this, item -&gt; &#123; // Perform an action with the latest item data &#125;); &#125;&#125;public class ListFragment extends Fragment &#123; private ItemViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); //注意requireActivity viewModel = new ViewModelProvider(requireActivity()).get(ItemViewModel.class); ... items.setOnClickListener(item -&gt; &#123; // Set a new item viewModel.select(item); &#125;); &#125;&#125; 将ViewModel放到同一范围，这样返回的是同一个ViewModel。 与其他Fragment通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ListViewModel extends ViewModel &#123; private final MutableLiveData&lt;Set&lt;Filter&gt;&gt; filters = new MutableLiveData&lt;&gt;(); private final LiveData&lt;List&lt;Item&gt;&gt; originalList = ...; private final LiveData&lt;List&lt;Item&gt;&gt; filteredList = ...; public LiveData&lt;List&lt;Item&gt;&gt; getFilteredList() &#123; return filteredList; &#125; public LiveData&lt;Set&lt;Filter&gt;&gt; getFilters() &#123; return filters; &#125; public void addFilter(Filter filter) &#123; ... &#125; public void removeFilter(Filter filter) &#123; ... &#125;&#125;public class ListFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); //保证在同一个范围 viewModel = new ViewModelProvider(requireActivity()).get(ListViewModel.class); viewModel.getFilteredList().observe(getViewLifecycleOwner(), list -&gt; &#123; // Update the list UI &#125;); &#125;&#125;public class FilterFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; //保证在同一个范围 viewModel = new ViewModelProvider(requireActivity()).get(ListViewModel.class); viewModel.getFilters().observe(getViewLifecycleOwner(), set -&gt; &#123; // Update the selected filters UI &#125;); &#125; public void onFilterSelected(Filter filter) &#123; viewModel.addFilter(filter); &#125; public void onFilterDeselected(Filter filter) &#123; viewModel.removeFilter(filter); &#125;&#125; 父子Fragment通信12345678910111213141516171819202122public class ListFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; viewModel = new ViewModelProvider(this).get(ListViewModel.class); viewModel.getFilteredList().observe(getViewLifecycleOwner(), list -&gt; &#123; // Update the list UI &#125; &#125;&#125;public class ChildFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; //注意参数 viewModel = new ViewModelProvider(requireParentFragment()).get(ListViewModel.class); ... &#125;&#125; Fragment Result API在某些情况下，您可能要在 Fragment 之间或 Fragment 与其宿主 Activity 之间传递一次性值。则可以使用setFragmentResultListener。它的原理是在getParentFragmentManager实现了观察者模式。 与其他Fragment通信 一旦 Fragment A 处于 STARTED 状态，它就会收到结果并执行监听器回调。 对于给定的键，只能有一个监听器和结果。如果您对同一个键多次调用 setFragmentResult()，并且监听器未处于 STARTED 状态，则系统会将所有待处理的结果替换为更新后的结果。如果您设置的结果没有相应的监听器来接收，则结果会存储在 FragmentManager 中，直到您设置一个具有相同键的监听器。监听器收到结果并触发 onFragmentResult() 回调后，结果会被清除。这种行为有两个主要影响： 返回堆栈上的 Fragment 只有在被弹出且处于 STARTED 状态之后才会收到结果。 如果在设置结果时监听结果的 Fragment 处于 STARTED 状态，则会立即触发监听器的回调。 123456789101112131415161718192021222324@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //监听某个事件 getParentFragmentManager().setFragmentResultListener(&quot;requestKey&quot;, this, new FragmentResultListener() &#123; @Override public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) &#123; // We use a String here, but any type that can be put in a Bundle is supported String result = bundle.getString(&quot;bundleKey&quot;); // Do something with the result &#125; &#125;);&#125;//在Fragment中触发该事件button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Bundle result = new Bundle(); result.putString(&quot;bundleKey&quot;, &quot;result&quot;); getParentFragmentManager().setFragmentResult(&quot;requestKey&quot;, result); &#125;&#125;); 父子Fragment通信 12345678910111213141516171819202122232425@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // We set the listener on the child fragmentManager getChildFragmentManager() .setFragmentResultListener(&quot;requestKey&quot;, this, new FragmentResultListener() &#123; @Override public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) &#123; String result = bundle.getString(&quot;bundleKey&quot;); // Do something with the result &#125; &#125;);&#125;button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Bundle result = new Bundle(); result.putString(&quot;bundleKey&quot;, &quot;result&quot;); // The child fragment needs to still set the result on its parent fragment manager getParentFragmentManager().setFragmentResult(&quot;requestKey&quot;, result); &#125;&#125;); 与宿主Activity通信123456789101112131415class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getSupportFragmentManager().setFragmentResultListener(&quot;requestKey&quot;, this, new FragmentResultListener() &#123; @Override public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) &#123; // We use a String here, but any type that can be put in a Bundle is supported String result = bundle.getString(&quot;bundleKey&quot;); // Do something with the result &#125; &#125;); &#125;&#125; 参考资料 https://developer.android.com/guide/components/fragments?hl=zh-cn https://developer.android.com/guide/fragments?hl=zh-cn https://github.com/xxv/android-lifecycle","tags":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}]},{"title":"原型模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/创建型模式/原型模式/","text":"定义原型模式(Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 有时候当你想复制一个对象时，先会想到用new，但有时候你拿到的只是抽象类，亦或者这个对象内部有一些私有属性你是拿不到的。还有时候，如果对象没有实现clone方法来实现克隆，则这个时候通过clone获取的是浅克隆，如果里面有其他对象，则返回的是引用。 原型模式是一种另类的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。 类图 角色 客户（Client）：客户类提出创建对象的请求。 抽象原型（Prototype）：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。 具体原型（Concrete Prototype）：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。 在进行克隆的时候，分为浅拷贝和深拷贝。我们的实际业务场景中大部分情况下需要深拷贝，深拷贝可以通过序列化或者直接new的方式实现。 优缺点优点 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 缺点 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 使用场景 Android中的Intent 12345678public class Intent implements Parcelable, Cloneable &#123;... @Override public Object clone() &#123; return new Intent(this); &#125;...&#125; 参考 https://refactoringguru.cn/design-patterns/prototype https://test-design-patterns.readthedocs.io/zh/latest/creational_patterns&#x2F;prototype.html","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/创建型模式/工厂方法模式/","text":"定义定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 结构图 角色 抽象工厂：实现了所有操纵产品的方法，但不实现工厂方法。factoryMethod是抽象方法。 具体工厂：必须实现抽象的抽象方法，以实际制造出产品。 抽象产品：所有产品的抽象。 具体产品：不同的具体产品。 优缺点优点： 符合开闭原则，具有很强的的扩展性、弹性和可维护性。扩展时只要添加一个ConcreteCreator，而无须修改原有的ConcreteCreator，因此维护性也好。解决了简单工厂对修改开放的问题。 使用了依赖倒置原则，依赖抽象而不是具体，使用（客户）和实现（具体类）松耦合。 客户只需要知道所需产品的具体工厂，而无须知道具体工厂的创建产品的过程，甚至不需要知道具体产品的类名。 缺点： 代码量增加 设计原则依赖倒置原则：要依赖抽象，不要依赖具体类。 我们写代码的时候应该尽量达到以下原则： 变量不可以持有具体类的引用 不要让类派生自具体类 不要覆盖基类中已实现的方法 使用场景 当需要一个对象时，我们不需要知道该对象所对应的具体类，只要知道哪个具体工厂可以生成该对象，实例化这个具体工厂即可创建该对象。 类的数目不固定，随时有新的子类增加进来，或者是还不知道将来需要实例化哪些具体类。 定义一个创建对象接口，由子类决定要实例化的类是哪一个；客户端可以动态地指定工厂子。 参考 《Head First设计模式》 https://blog.csdn.net/qq_39588630&#x2F;article&#x2F;details&#x2F;80478349","tags":[],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/创建型模式/抽象工厂模式/","text":"定义提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 它是工厂方法模式的扩展。工厂方法模式只能生产一种产品，而抽象工厂模式则扩展为多个。 结构图 角色 AbstractFactory：抽象工厂角色，它声明了一组用于创建一种产品的方法，每一个方法对应一种产品，如上述类图中的AbstractFactory就定义了两个方法，分别创建产品A和产品B ConcreteFactory：具体工厂角色，它实现了在抽象工厂中定义的创建产品的方法，生产一组具体产品，这饿产品构件成了一个产品种类，每一个产品都位于某个产品等级结构中，如上述类图中的ConcreteFactoryA和ConcreteFactoryB AbstractProduct：抽象产品角色，为每种产品声明接口，如图中AbstractProductA、AbstractProductB ConcreteProduct：具体产品角色，定义了工厂生产的具体产品对象，实现抽象产品接口声明的业务方法，如图中ConcreteProductA1、ConcreteProductA2、ConcreteProductB1、ConcreteProductB2 参考 《Head First设计模式》","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/创建型模式/建造者模式/","text":"定义建造者模式（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 类图 角色 Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 优缺点优点 产品本身与产品的创建过程解耦，结构更清晰 使用场景 多个参数初始化时，使用静态内部类Builder。比如Android中的NotificationCompat 链式调用，RxJava 参考 https://refactoringguru.cn/design-patterns/builder https://test-design-patterns.readthedocs.io/zh/latest/creational_patterns&#x2F;builder.html","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"享元模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/结构型模式/享元模式/","text":"定义享元模式（Flyweight Pattern）：减少创建对象的数量，以减少内存占用和提高性能。 类图 角色 Flyweight: 抽象享元类 ConcreteFlyweight: 具体享元类 UnsharedConcreteFlyweight: 非共享具体享元类 FlyweightFactory: 享元工厂类 使用场景 Java中的字符串池 Integer对象，当值在-128~+128时，返回的是缓存对象 参考 https://refactoringguru.cn/design-patterns/flyweight https://test-design-patterns.readthedocs.io/zh/latest/structural_patterns&#x2F;flyweight.html","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/结构型模式/代理模式/","text":"定义代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。它是一种对象结构型模式。 类图 角色 Subject: 抽象主题角色 Proxy: 代理主题角色 RealSubject: 真实主题角色 优缺点优点 封装了一层，高扩展 如果需要在真实对象执行操作的前后执行一些工作，则非常方便 缺点 代码会变多 比直接调用性能上会差些 使用场景 电脑中的快捷方式 商店是商品厂家的代理 中介 Java中的InvocationHandler 参考 https://refactoringguru.cn/design-patterns/proxy https://blog.csdn.net/carson_ho&#x2F;article&#x2F;details&#x2F;54910472","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/结构型模式/组合模式/","text":"定义组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 类图 角色 Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。 Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。 Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。 优缺点优点 满足开闭原则，在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改 使用场景 树形结构，比如文件夹的管理 参考 https://refactoringguru.cn/design-patterns/composite https://www.cnblogs.com/chenssy/p/3299719.html","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"外观模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/结构型模式/外观模式/","text":"定义提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 结构图 外观模式中的角色： 门面角色（Facade）:这是外观模式的核心。它被客户角色调用，因此它熟悉子系统的功能。它内部根据客户角色已有的需求预定了几种功能组合。 子系统角色（SystemA、SystemB、SystemC）:实现了子系统的功能。对子系统角色来说，facade角色与客户角色一样，是未知的，它没有任何facade角色的信息和链接。 客户角色（Client）：调用facade角色来完成要得到的功能。 优缺点优点： 降低了Client的使用难度，子系统对其是黑盒的。隐藏了内部细节 降低了耦合性 设计原则迪米特原则（LOW OF DEMETER）：也叫最少知识原则。只和你的密友谈话。 当你设计一个系统，不管是任何对象，都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。 使用场景 遥控器：一个按钮就能帮我们完成多件事情。 第三方库的启动封装：一般调用init方法就能完成初始化，其内部会做许多工作。 参考 《Head First设计模式》 https://www.cnblogs.com/jimoer/p/9463698.html","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/结构型模式/装饰模式/","text":"定义装饰器模式（Decorator Pattern）：在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）。 类图 角色 抽象构件(Component)角色：给出一个抽象接口，已规范准备接收附加责任的对象。 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 优缺点优点 符合开闭原则，单一职责原则 使用场景 Java中的IO相关API 参考 https://refactoringguru.cn/design-patterns/decorator https://test-design-patterns.readthedocs.io/zh/latest/structural_patterns&#x2F;decorator.html","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"桥接模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/结构型模式/桥接模式/","text":"定义桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 类图 角色 Abstraction：抽象类，保存一个对实现化对象（Implementor）的引用 RefinedAbstraction：扩充抽象类，改变和修正父类对抽象化的定义 Implementor：角色给出实现化角色的接口，但不给出具体的实现 ConcreteImplementor：具体实现类 优缺点优点 抽象和实现分离，扩展性高。 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。 缺点 增加系统的理解与设计难度 使用场景参考 https://test-design-patterns.readthedocs.io/zh/latest/structural_patterns&#x2F;bridge.html https://refactoringguru.cn/design-patterns/bridge https://zhuanlan.zhihu.com/p/58903776","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","date":"2018-06-01T02:01:01.000Z","path":"wiki/设计模式/结构型模式/适配器模式/","text":"定义适配器模式（Adapter Pattern）：将一个类的接口转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以相互合作。适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。 适配器模式优点 复用且不修改类 : 不改变现有类的基础上 , 提高类的复用性 , 透明性 ; 让现有类与目标类接口匹配 ; 降低耦合 : 目标类 ( 用户调用的接口所在类 ) 和 现有类 ( 被适配者 ) 解除耦合 , 降低了系统的耦合性 , 易于扩展维护; 符合开闭原则 : 用户调用适配器接口 , 只与适配器类进行交互 , 如果需要修改扩展 , 只需要修改适配器类即可 , 目标类和现有类各自都是相互独立的 , 互不影响 ; 适配器模式缺点 增加复杂性 : 编写适配器类时 , 需要考虑全面 , 包括被适配者 和 目标类 , 系统复杂性会增加; 降低可读性 : 系统代码可读性降低 , 可维护性降低 ; 对象适配器在对象适配器模式中，适配器与适配者之间是关联关系（适配者是适配器的成员变量）。 结构图 Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承(或者实现)Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.shjlone.designpattern.adapter.objectadapter;/** * 对象适配器模式 */public class ObjectAdapterTest &#123; public static void main(String[] args) &#123; TypeC typeC = new Phone(); MicroUsb microUsb = new Adapter(typeC); microUsb.microUsb(); &#125;&#125;// 供应接口interface MicroUsb &#123; public void microUsb();&#125;// 需求接口interface TypeC &#123; public void typeC();&#125;// 需求实现类class Phone implements TypeC &#123; public void typeC() &#123; System.out.println(&quot;Type-C接口&quot;); &#125;&#125;// 适配器class Adapter implements MicroUsb &#123; private TypeC typeC; public Adapter(TypeC typeC) &#123; this.typeC = typeC; &#125; @Override public void microUsb() &#123; typeC.typeC(); &#125;&#125; 类适配器在类适配器模式中，适配器与适配者之间是继承关系。 123456789101112131415161718192021222324252627282930313233343536package com.shjlone.designpattern.adapter.classadapter;/** * 类适配器 */public class ClassAdapterTest &#123; public static void main(String[] args) &#123; MicroUsb microUsb = new Adapter(); microUsb.microUsb(); &#125;&#125;//供应接口interface MicroUsb &#123; public void microUsb();&#125;//需求接口interface TypeC &#123; public void typeC();&#125;//需求实现类class Phone implements TypeC &#123; public void typeC() &#123; System.out.println(&quot;Type-C接口&quot;); &#125;&#125;//适配器class Adapter extends Phone implements MicroUsb &#123; public void microUsb() &#123; typeC(); &#125;&#125; 缺省适配器模式(Default Adapter Pattern)当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.shjlone.designpattern.adapter.defaultadapter;/** * 默认适配器，用于隐藏一些实现细节 */public class DefaultAdapterTest &#123; public static void main(String[] args) &#123; TypecToVGA typecToVGA = new TypecToVGA(); typecToVGA.isTypeC(); typecToVGA.isVGA(); &#125;&#125;// 接口类interface AllPorts &#123; public void isTypeC(); public void isVGA(); public void isHdmi();&#125;// 适配器的框架abstract class Adapter implements AllPorts &#123; @Override public void isTypeC() &#123; &#125; @Override public void isVGA() &#123; &#125; @Override public void isHdmi() &#123; &#125;&#125;// 适配器类class TypecToVGA extends Adapter &#123; @Override public void isTypeC() &#123; System.out.println(&quot;信号从TypeC接口进入&quot;); &#125; @Override public void isVGA() &#123; System.out.println(&quot;信号从VGA接口出&quot;); &#125;&#125; 使用场景 Java连接数据的JDBC工具 List Arrays.asList(T[]) InputStreamReader StringReader 123456789101112131415161718192021222324252627282930313233/*** 对象适配器* StringReader相当于Adapter，Reader相当于Target，String相当于Adaptee***/public class StringReader extends Reader &#123; // 维持对adaptee对象的引用 private String str; private int length; private int next = 0; private int mark = 0; /** * 构造注入一个String用于之后的read操作 */ public StringReader(String s) &#123; this.str = s; this.length = s.length(); &#125; // 这里相当于是在做适配操作，转为目标对象所期望的请求 public int read() throws IOException &#123; synchronized (lock) &#123; ensureOpen(); if (next &gt;= length) return -1; return str.charAt(next++); &#125; &#125;&#125; 参考 https://www.liaoxuefeng.com/wiki/1252599548343744/1281319245971489 https://www.cnblogs.com/bytesfly/p/adapter-pattern.html","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"《干就对了：业绩增长九大关键》读书笔记","date":"2017-03-11T16:00:00.000Z","path":"wiki/读书笔记/干就对了/","text":"摘要1 宁愿要三流的战略加上一流的组织，也不要一流的战略、三流的组织。 感悟： 好的团队很重要，一群优秀的人，目的明确，团结一致，想不成功都难。在团队建设过程中，一定要尽量留下优秀的人才。 摘要2组织架构的设计原则： 1.自上而下和自下而上要结合。 2.组织架构设计要保持弹性，也就是要跳出KPI做正确的事。 摘要3中台建设原则： 客户第一 赋能而非管控 前线要有授权 总部要有看板 善用双线汇报 摘要4岗位职责的设计注意点： 切忌“大而全” 要有颗力度和明确的比重 人事部门不能包揽岗位职责编写工作 岗位职责不能一成不变 岗位职责再纵深层次上不能一样 感悟： 每个岗位都应该有明确的职责要求，实际工作当中，很多人会把模棱两可的任务推来推去。 摘要5如何扣动员工的心灵扳机： 寻找心动点 寻找成就点 生理需求和安全需求 情感和归属需求 尊重需求 自我实现需求 管理者不要站在自己的角度思考员工的原动力 管理者要看到目标实现的可能性，不能画大饼 感悟： 说到底还是要关注”人”本身，关注他的真实需求，尽量在现有框架下满足他的需求，他才能给团队带来更多的价值。 摘要6 “No Surprise”：管理者在日常过程中发现问题没有及时提醒 当员工犯错的时候，不要急于批评，因为大多数批评解决不了问题。正确的步骤是判断这些错误会产生什么影响，然后再做处理。一般从两个维度判断——业绩和价值观。 感悟： 自己在实际工作中就出现过类似的问题，在问题刚刚出现时没有及时去处理，最终那个团队成员离职了。回过头想，其实在问题刚出现的时候，就处理的话，他应该在近期是不会离职的。 摘要6设计KPI时要关注的6个要素： 目标值； 权重； 计算方式； 评分标准； 评估周期。 摘要7 裸心会，真正的关心员工，而不是流于形式。 感悟： 阿里所谓但裸心会，说到底还是要真正但关心团队成员的内心真实想法，流于表面的生日会、聚餐，并不能跟大家交心。想要交心，是要真正的去了解对方，把对方当成好哥们，哥们家人生病了，你是要关怀的。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Welcome Shjlone's Blog","date":"2017-01-21T17:55:57.000Z","path":"wiki/index/","text":"这是我的个人博客，用于记录自己的点点滴滴！","tags":[],"categories":[]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/categories/JavaScript/"},{"name":"ReactNative","slug":"JavaScript/ReactNative","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/"},{"name":"技术开发","slug":"技术开发","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Git","slug":"技术开发/Git","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Git/"},{"name":"开源库","slug":"JavaScript/ReactNative/开源库","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/categories/Flutter/"},{"name":"源码分析","slug":"Flutter/源码分析","permalink":"http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"开源库","slug":"Flutter/开源库","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"单元测试","slug":"Flutter/单元测试","permalink":"http://airshu.github.io/categories/Flutter/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"Android端","slug":"Flutter/Android端","permalink":"http://airshu.github.io/categories/Flutter/Android%E7%AB%AF/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"},{"name":"UI","slug":"Flutter/UI","permalink":"http://airshu.github.io/categories/Flutter/UI/"},{"name":"动态化","slug":"Flutter/动态化","permalink":"http://airshu.github.io/categories/Flutter/%E5%8A%A8%E6%80%81%E5%8C%96/"},{"name":"Dart","slug":"Flutter/Dart","permalink":"http://airshu.github.io/categories/Flutter/Dart/"},{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"HuaWei","slug":"技术开发/HuaWei","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/HuaWei/"},{"name":"未分类","slug":"Flutter/未分类","permalink":"http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"},{"name":"随笔","slug":"随笔","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"技术管理","slug":"技术开发/技术管理","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"},{"name":"异步编程","slug":"Flutter/Dart/异步编程","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"name":"属性参数","slug":"JavaScript/ReactNative/属性参数","permalink":"http://airshu.github.io/categories/JavaScript/ReactNative/%E5%B1%9E%E6%80%A7%E5%8F%82%E6%95%B0/"},{"name":"React","slug":"JavaScript/React","permalink":"http://airshu.github.io/categories/JavaScript/React/"},{"name":"基础知识","slug":"JavaScript/React/基础知识","permalink":"http://airshu.github.io/categories/JavaScript/React/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"北京游玩攻略","slug":"随笔/北京游玩攻略","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/%E5%8C%97%E4%BA%AC%E6%B8%B8%E7%8E%A9%E6%94%BB%E7%95%A5/"},{"name":"技术方案","slug":"技术开发/技术方案","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"},{"name":"工具软件","slug":"工具软件","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"图片相关","slug":"Flutter/开源库/图片相关","permalink":"http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://airshu.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://airshu.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"},{"name":"程序语言","slug":"程序语言","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"网络编程","slug":"程序语言/网络编程","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"算法","slug":"程序语言/算法","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"程序语言/数据结构","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Mac","slug":"工具软件/Mac","permalink":"http://airshu.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Mac/"},{"name":"源码分析","slug":"JavaScript/React/源码分析","permalink":"http://airshu.github.io/categories/JavaScript/React/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/categories/Python/"},{"name":"PyQt","slug":"Python/PyQt","permalink":"http://airshu.github.io/categories/Python/PyQt/"},{"name":"基础","slug":"Flutter/Dart/基础","permalink":"http://airshu.github.io/categories/Flutter/Dart/%E5%9F%BA%E7%A1%80/"},{"name":"标准库","slug":"Flutter/UI/标准库","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"iOS","slug":"程序语言/iOS","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/"},{"name":"Shell","slug":"技术开发/Shell","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Shell/"},{"name":"Car","slug":"随笔/Car","permalink":"http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/Car/"},{"name":"widgets","slug":"Flutter/UI/标准库/widgets","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java编程思想","slug":"读书笔记/Java编程思想","permalink":"http://airshu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"},{"name":"Kotlin","slug":"程序语言/Kotlin","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Kotlin/"},{"name":"C++","slug":"程序语言/C","permalink":"http://airshu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"操作系统","slug":"操作系统","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"线程","slug":"操作系统/线程","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"操作系统/进程","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/"},{"name":"未分类","slug":"操作系统/未分类","permalink":"http://airshu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%AA%E5%88%86%E7%B1%BB/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://airshu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/categories/Java/"},{"name":"面试题","slug":"Java/面试题","permalink":"http://airshu.github.io/categories/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"集合","slug":"Java/集合","permalink":"http://airshu.github.io/categories/Java/%E9%9B%86%E5%90%88/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://airshu.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"},{"name":"虚拟机","slug":"Java/虚拟机","permalink":"http://airshu.github.io/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"开源库","slug":"Java/开源库","permalink":"http://airshu.github.io/categories/Java/%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"未分类","slug":"Java/未分类","permalink":"http://airshu.github.io/categories/Java/%E6%9C%AA%E5%88%86%E7%B1%BB/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://airshu.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"基础","slug":"Java/基础","permalink":"http://airshu.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"},{"name":"material","slug":"Flutter/UI/标准库/material","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/material/"},{"name":"framework","slug":"Flutter/UI/标准库/widgets/framework","permalink":"http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/framework/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://airshu.github.io/categories/Android/%E9%80%86%E5%90%91/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://airshu.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://airshu.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"基础","slug":"Android/基础","permalink":"http://airshu.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"},{"name":"UI","slug":"Android/UI","permalink":"http://airshu.github.io/categories/Android/UI/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"http://airshu.github.io/categories/Android/Jetpack/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://airshu.github.io/categories/Android/NDK/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://airshu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://airshu.github.io/tags/React-Native/"},{"name":"Git","slug":"Git","permalink":"http://airshu.github.io/tags/Git/"},{"name":"Flutter","slug":"Flutter","permalink":"http://airshu.github.io/tags/Flutter/"},{"name":"Flutter 单元测试","slug":"Flutter-单元测试","permalink":"http://airshu.github.io/tags/Flutter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"Rx","slug":"Rx","permalink":"http://airshu.github.io/tags/Rx/"},{"name":"Flutter 动态化","slug":"Flutter-动态化","permalink":"http://airshu.github.io/tags/Flutter-%E5%8A%A8%E6%80%81%E5%8C%96/"},{"name":"Dart","slug":"Dart","permalink":"http://airshu.github.io/tags/Dart/"},{"name":"Android","slug":"Android","permalink":"http://airshu.github.io/tags/Android/"},{"name":"HuaWei harmonyOS","slug":"HuaWei-harmonyOS","permalink":"http://airshu.github.io/tags/HuaWei-harmonyOS/"},{"name":"旅游","slug":"旅游","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8/"},{"name":"总结","slug":"总结","permalink":"http://airshu.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"技术管理","slug":"技术管理","permalink":"http://airshu.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"},{"name":"TypeScript JavaScript","slug":"TypeScript-JavaScript","permalink":"http://airshu.github.io/tags/TypeScript-JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://airshu.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://airshu.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://airshu.github.io/tags/React/"},{"name":"JavaScript Redux","slug":"JavaScript-Redux","permalink":"http://airshu.github.io/tags/JavaScript-Redux/"},{"name":"旅游 清华北大","slug":"旅游-清华北大","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E6%B8%85%E5%8D%8E%E5%8C%97%E5%A4%A7/"},{"name":"旅游 长城","slug":"旅游-长城","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E9%95%BF%E5%9F%8E/"},{"name":"旅游 颐和园","slug":"旅游-颐和园","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E9%A2%90%E5%92%8C%E5%9B%AD/"},{"name":"旅游 恭王府","slug":"旅游-恭王府","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E6%81%AD%E7%8E%8B%E5%BA%9C/"},{"name":"旅游 故宫","slug":"旅游-故宫","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E6%95%85%E5%AE%AB/"},{"name":"旅游 天坛","slug":"旅游-天坛","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E5%A4%A9%E5%9D%9B/"},{"name":"旅游 十三陵","slug":"旅游-十三陵","permalink":"http://airshu.github.io/tags/%E6%97%85%E6%B8%B8-%E5%8D%81%E4%B8%89%E9%99%B5/"},{"name":"埋点 技术方案","slug":"埋点-技术方案","permalink":"http://airshu.github.io/tags/%E5%9F%8B%E7%82%B9-%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"},{"name":"效率","slug":"效率","permalink":"http://airshu.github.io/tags/%E6%95%88%E7%8E%87/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://airshu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"mac","slug":"mac","permalink":"http://airshu.github.io/tags/mac/"},{"name":"服务端","slug":"服务端","permalink":"http://airshu.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://airshu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","permalink":"http://airshu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://airshu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://airshu.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Qt","slug":"Qt","permalink":"http://airshu.github.io/tags/Qt/"},{"name":"PyQt","slug":"PyQt","permalink":"http://airshu.github.io/tags/PyQt/"},{"name":"PyQt5","slug":"PyQt5","permalink":"http://airshu.github.io/tags/PyQt5/"},{"name":"Qt QtWebEngine","slug":"Qt-QtWebEngine","permalink":"http://airshu.github.io/tags/Qt-QtWebEngine/"},{"name":"iOS","slug":"iOS","permalink":"http://airshu.github.io/tags/iOS/"},{"name":"Shell","slug":"Shell","permalink":"http://airshu.github.io/tags/Shell/"},{"name":"Car","slug":"Car","permalink":"http://airshu.github.io/tags/Car/"},{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://airshu.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"设计模式","slug":"设计模式","permalink":"http://airshu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"PHP","slug":"PHP","permalink":"http://airshu.github.io/tags/PHP/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://airshu.github.io/tags/Kotlin/"},{"name":"C++","slug":"C","permalink":"http://airshu.github.io/tags/C/"},{"name":"技术","slug":"技术","permalink":"http://airshu.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://airshu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"按键精灵","slug":"按键精灵","permalink":"http://airshu.github.io/tags/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://airshu.github.io/tags/ffmpeg/"},{"name":"操作系统","slug":"操作系统","permalink":"http://airshu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"linux","permalink":"http://airshu.github.io/tags/linux/"},{"name":"PC","slug":"PC","permalink":"http://airshu.github.io/tags/PC/"},{"name":"charles","slug":"charles","permalink":"http://airshu.github.io/tags/charles/"},{"name":"Python","slug":"Python","permalink":"http://airshu.github.io/tags/Python/"},{"name":"Java","slug":"Java","permalink":"http://airshu.github.io/tags/Java/"},{"name":"Java集合","slug":"Java集合","permalink":"http://airshu.github.io/tags/Java%E9%9B%86%E5%90%88/"},{"name":"JVM","slug":"JVM","permalink":"http://airshu.github.io/tags/JVM/"},{"name":"IO","slug":"IO","permalink":"http://airshu.github.io/tags/IO/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://airshu.github.io/tags/RecyclerView/"}]}