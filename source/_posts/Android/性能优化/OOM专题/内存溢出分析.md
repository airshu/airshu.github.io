---
title: 内存溢出分析
tags: Android
toc: true
---


## 概述

OOM(Out of Memory)即内存溢出，是因为应用所需要分配的内存超过系统对应用内存的阈值，而抛出java.lang.OutOfMemoryError错误。

其根本原因是对象的生命周期不一致，导致内存泄漏。

### 内存泄漏和内存溢出的区别

- 内存溢出

    是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。

- 内存泄漏

    是指程序在申请内存后，无法释放已申请的内存空间。内存泄漏最终会导致内存溢出。

### 栈内存溢出和堆内存溢出

#### 堆內存溢出

- new出来的对象所需内存不够了

#### 栈內存溢出

- 抛出"StackOverflowError"的原因：线程请求的栈深度大于JVM所允许的最大深度。所以根本原因是，某个线程所需的栈内存超过了JVM的限制，
  而此时物理内存仍有足够的可用空间。出现的情况：方法中无限递归调用。
- 抛出"OutOfMemoryError"的原因：无法（向操作系统）申请到足够的内存空间用来拓展栈。根本原因是，（操作系统管理的）物理内存已没有足够的
  可用内存分配给JVM的栈使用。出现的情况：方法中不停的创建线程。


## 可能出现OOM的场景

### 静态变量导致的内存泄漏
    
#### 描述

比如某个静态变量持有Activity，则当Activity生命周期结束时不会被释放。

```java
Static Vector v = new Vector(10);//静态变量的生命周期跟应用一致
for (int i = 1; i<100; i++)
{
    Object o = new Object();
    v.add(o);
    o = null;
}
```

#### 解决办法：

及时释放静态变量
  
### 单例模式导致的内存泄漏

#### 描述  

单例持有Activity

#### 解决办法

如果需要持有Context，则使用ApplicationContext

### 属性动画导致的内存泄漏

#### 解决办法

视图销毁时停止动画

### for循环中不停的创建局部变量


### 非静态内部类（包括匿名内部类）默认会持有外部类的引用

当非静态内部类会持有外部类引用，如果在内部类中，将外部类的引用传入到另外的线程中，则可能造成内存泄漏。
  



### 未取消注册或回调导致的内存泄漏

比如在Activity中注册广播，如果Activity销毁后不取消注册，那么这个广播就会一直存在系统中


## 一些经验

- 在onDestroy中手动释放View上的资源
- 尽量避免使用静态变量



## 参考

