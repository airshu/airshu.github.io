---
title: 滚动条
toc: true
tags: Flutter
---


SingleChildScrollView：类似Android中的ScrollView，处理简单可滑动的页面布局视图，当内容足够多时，一屏显示不下时，就需要滑动处理。

```
const SingleChildScrollView({
    Key key,
    this.scrollDirection = Axis.vertical,//设置视图的滚动方向(默认垂直方向), 需要对应的设置其子 Widget 是 Column 或者 Row, 否则会报 Overflow 错误。
    this.reverse = false,//是否按照阅读方向相反的方向滑动。若 reverse: false，则滚动内容头部和左侧对其, 那么滑动方向就是从左向右
    this.padding,
    bool primary,//是否使用默认的 controller
    this.physics,//此属性接受一个 ScrollPhysics 对象，它决定可滚动 Widget 如何响应用户操作，比如用户滑动完抬起手指后，继续执行动画；或者滑动到边界时，如何显示。ClampingScrollPhysics：安卓下微光效果。ClampingScrollPhysics：安卓下微光效果。
    this.controller,
    this.child,
})
```



CustomScrollView：

```
  const CustomScrollView({
    Key key,
    Axis scrollDirection = Axis.vertical,
    bool reverse = false,
    ScrollController controller,
    bool primary,
    ScrollPhysics physics,
    bool shrinkWrap = false,
    Key center,
    double anchor = 0.0,
    double cacheExtent,//
    this.slivers = const <Widget>[], //Sliver家族列表
    int semanticChildCount,
    DragStartBehavior dragStartBehavior = DragStartBehavior.start,
  })
  
```

NestedScrollView：滑动可折叠部分内容，配合Sliver相关组件使用。帮我们解决滑动冲突的控件。通过为外部 ScrollView 和内部 ScrollView 提供自定义 ScrollController 来解决此问题，将它们链接在一起，以便它们作为一个连贯的滚动视图显示给用户。

```
  const NestedScrollView({
    Key key,
    this.controller,
    this.scrollDirection = Axis.vertical,
    this.reverse = false,
    this.physics,
    @required this.headerSliverBuilder,
    @required this.body,
    this.dragStartBehavior = DragStartBehavior.start,
  })
  
```

## 什么是Sliver？

通常指具有特定滚动效果的可滚动块，可滚动 widget，如 ListView、GridView 等都有对应的 Sliver 实现如 SliverList、SliverGrid 等。

对于大多数 Sliver 来说，它们和可滚动 Widget 最主要的区别是 Sliver 不会包含 Scrollable，也就是说 Sliver 本身不包含滚动交互模型。

正因如此，CustomScrollView 才可以将多个 Sliver "粘"在一起，这些 Sliver 共用 CustomScrollView 的 Scrollable，最终实现统一的滑动效果。


### SliverAppBar

```
  const SliverAppBar({
    Key key,
    this.leading,//导航栏左侧 widget
    this.automaticallyImplyLeading = true,//如果 leading 为 null，是否自动实现默认的 leading 按钮
    this.title,//导航栏标题
    this.actions,//如果 leading 为 null，是否自动实现默认的 leading 按钮
    this.flexibleSpace,//可缩放区域
    this.bottom,//控件底部固定区域，可以放tabbar等
    this.elevation,//控件的 z 坐标顺序?
    this.forceElevated = false,
    this.backgroundColor,
    this.brightness,//状态栏的颜色, 黑白两种, 取值: Brightness.dark
    this.iconTheme,//设置导航栏上图标的颜色、透明度、和尺寸信息
    this.actionsIconTheme,//action 按钮图标的颜色、透明度、和尺寸信息
    this.textTheme,
    this.primary = true,//导航栏的内容是否显示在顶部, 状态栏的下面
    this.centerTitle,//标题是否居中显示，默认值根据不同的操作系统，显示方式不一样
    this.titleSpacing = NavigationToolbar.kMiddleSpacing,
    this.expandedHeight,//展开最大高度
    this.floating = false,
    this.pinned = false,//是否固定在顶部
    this.snap = false,
    this.shape,//阴影设置
  })
  
```



### SliverPersistentHeader

可以根据滚动而变大变小的组件，SliverAppBar就是基于这个实现的。

- minHeight:固定高度
- maxHeight:最大显示高度
- delegate：SliverPersistentHeaderDelegate
- pinned：收缩到最小高度的时候SliverPersistentHeader是否可见，
	- true：会以折叠高度固定显示在头部，
	- false：缩小到折叠高度后滑出页面
- floating：true 的时候下滑先展示SliverPersistentHeader介绍，展示完成后才展示其他滑动组件内容


### SliverPersistentHeaderDelegate



### SliverList


```
  const SliverList({
    Key key,
    @required SliverChildDelegate delegate,
  })
  
  
    SliverChildListDelegate(
    this.children, {
    this.addAutomaticKeepAlives = true,
    this.addRepaintBoundaries = true,
    this.addSemanticIndexes = true,
    this.semanticIndexCallback = _kDefaultSemanticIndexCallback,
    this.semanticIndexOffset = 0,
  })
  
  
```


### SliverToBoxAdapter

用于包装非Sliver类型的Widget


### SliverFillRemaining

填充剩余部分

- hasScrollBody表示内容是否可以滚动，如果是为false，则只是填补空白。

- fillOverscroll表示子控件是否应该应该伸展以填充超出区域（比如iOS的ListView默认可伸展出一部分区域），当hasScrollBody为false时才起作用。
