---
title: 异步编程
toc: true
tags: Dart
---



## isolate机制

Dart是单线程模型，它的并发机制叫isolate。APP的启动入口`main`函数就是一个类似Android主线程的一个主isolate。和Java的Thread不同的是，Dart中的isolate无法共享内存。

```dart

// 导入isolate包
import 'dart:isolate';

// 使用async关键词将main函数标记为一个异步函数，这样才能使用await关键词
void main() async {
    // 使用await关键词等待任务执行完成
	await Isolate.spawn<String>(subTask, "Task1 parameter");
        
        // main函数结束标记 
	print("main func end.");
}

// Isolate入口函数定义，接受一个String参数
void subTask(String msg) {
	print("subTask recv: $msg");
}

```

## 消息机制

Dart在执行完main函数后，就会由Loop开始执行两个任务队列中的Event。首先Loop检查微服务队列，依次执行Event，当微服务队列执行完后，就检查Event queue队列依次执行，
在执行Event queue的过程中，没执行完一个Event就再检查一次微服务队列。所以微服务队列优先级高，可以利用微服务进行插队。


## Future

在 Dart 库中随处可见 Future 对象，通常异步函数返回的对象就是一个 Future。 当一个 future *执行完后*，他里面的值 就可以使用了，可以使用`then()`来在 future 完成的时候执行其他代码。Future对象其实就代表了在事件队列中的一个事件的结果。


## Stream

表示发出的一系列的异步数据。Stream 是一个异步数据源，它是 Dart 中处理异步事件流的统一 API。

Future 表示稍后获得的一个数据，所有异步的操作的返回值都用 Future 来表示。但是 Future 只能表示一次异步获得的数据。而 Stream 表示多次异步获得的数据。比如 IO 处理的时候，每次只会读取一部分数据和一次性读取整个文件的内容相比，Stream 的好处是处理过程中内存占用较小。而 File 的 `readAsString()`是一次性读取整个文件的内容进来，虽然获得完整内容处理起来比较方便，但是如果文件很大的话就会导致内存占用过大的问题。


```dart
 new File("/Users/enjoy/app-release.apk").openRead().listen((List<int> bytes) {
    print("stream执行"); //执行多次
  });

  new File("/Users/enjoy/app-release.apk").readAsBytes().then((_){
    print("future执行"); //执行1次
  });
```


`listen()`其实就是订阅这个Stream，它会返回一个`StreamSubscription`订阅者。订阅者肯定就提供了取消订阅的`cancel()`，去掉后我们的listen中就接不到任何信息了。除了`cancel()`取消方法之外，我们还可以使用`onData()`重置listene方法，`onDone`监听完成等等操作。

```dart
  StreamSubscription<List<int>> listen = new File("/Users/enjoy/app-release.apk").openRead().listen((List<int> bytes) {
    print("stream执行");
  });
  listen.onData((_){
    print("替代listene");
  });
  listen.onDone((){
    print("结束");
  });
  listen.onError((e,s){
    print("异常");
  });
  //暂停，如果没有继续则会退出程序
  listen.pause();
  //继续
  listen.resume();
```


### 广播模式

Stream有两种订阅模式：单订阅和多订阅。单订阅就是只能有一个订阅者，上面的使用我们都是单订阅模式，而广播是可以有多个订阅者。通过 Stream.asBroadcastStream() 可以将一个单订阅模式的 Stream 转换成一个多订阅模式的 Stream，isBroadcast 属性可以判断当前 Stream 所处的模式。


```dart
var stream = new File("/Users/enjoy/app-release.apk").openRead();
  stream.listen((List<int> bytes) {
  });
  //错误 单订阅只能有一个订阅者
//  stream.listen((_){
//    print("stream执行");
//  });

  var broadcastStream = new File("/Users/enjoy/app-release.apk").openRead().asBroadcastStream();
  broadcastStream.listen((_){
    print("订阅者1");
  });
  broadcastStream.listen((_){
    print("订阅者2");
  });
```

需要注意的是，多订阅模式如果没有及时添加订阅者则可能丢数据。

```dart
//默认是单订阅
  var stream = Stream.fromIterable([1, 2, 3]);
  //3s后添加订阅者 不会丢失数据
  new Timer(new Duration(seconds: 3), () => stream.listen(print));

  //创建一个流管理器 对一个stream进行管理
  var streamController = StreamController.broadcast();
  //添加
  streamController.add(1);
  //先发出事件再订阅 无法接到通知
  streamController.stream.listen((i){
    print("broadcast:$i");
  });
  //记得关闭
  streamController.close();


  //这里没有丢失，因为stream通过asBroadcastStream转为了多订阅，但是本质是单订阅流，并不改变原始 stream 的实现特性
  var broadcastStream = Stream.fromIterable([1, 2, 3]).asBroadcastStream();
  new Timer(new Duration(seconds: 3), () => broadcastStream.listen(print));
```


## async/await

使用`async`和`await`的代码是异步的，但是看起来很像同步代码。当我们需要获得A的结果，再执行B，时，你需要`then()->then()`,但是利用`async`与`await`能够非常好的解决回调地狱的问题：


```dart
//async 表示这是一个异步方法,await必须再async方法中使用
//异步方法只能返回 void和Future
Future<String> readFile() async {
  //await 等待future执行完成再执行后续代码
  String content = await new File("/Users/xiang/enjoy/a.txt").readAsString();
  String content2 = await new File("/Users/xiang/enjoy/a.txt").readAsString();
  //自动转换为 future
  return content;
}
```


