---
title: 线程间通讯方式
tags: Java
toc: true
---



## 什么是线程安全？

线程的工作原理，jvm有一个main memory，而每个线程有自己的working memory，一个线程对一个variable进行操作时，都要在自己的working memory里面建立一个copy，
操作完之后再写入main memory。多个线程同时操作同一个variable，就可能会出现不可预知的结果。

而用synchronized的关键是建立一个monitor，这个monitor可以是要修改的variable也可以其他你 认为合适的object比如method，然后通过给这个monitor加锁来
实现线程安全，每个线程在获得这个锁之后，要执行完load到workingmemory -> use&assign -> store到mainmemory 的过程，才会释放它得到的锁。
这样就实现了所谓的线程安全。

线程安全就是说多线程访问同一块内存，不会产生不确定的结果。编写线程安全的代码是依靠线程同步。



### CPU时间片轮转机制

cpu 给每个进程分配一个“时间段”，这个时间段就叫做这个进程的“时间片”，这个时间片就是这个进程允许运行的时间，如果当这个进程的时间片段结束，
操作系统就会把分配给这个进程的 cpu 剥夺，分配给另外一个进程。如果进程在时间片还没结束的情况下阻塞了，或者说进程跑完了，cpu 就会进行切换。
cpu 在两个进程之间的切换称为“上下文切换”，上下文切换是需要时间的，大约需要花费 5000~20000(5 毫秒到 20 毫秒，这个花费的时间是由操作系统决定)个时钟周期，
尽管我们平时感觉不到。所以在开发过程中要注意上下文切换(两个进程之间的切换)对我们程序性能的影响。




## 死锁

造成死锁的四个条件：

- 互斥条件：资源只能被一个线程占用,如果其它线程请求获取该资源,则请求者只能等待,直到占用资源的线程释放该资源. 
- 请求并持有条件：指一个线程已经持有了至少一个资源,但又提出了新的资源请求,而新的资源已被其他线程占 用,所以当前线程会被阻塞,但阻塞的同时不释放自己获取的资源.
- 不可剥夺条件：获取到的资源在自己使用完之前不能被其他线程抢占,只能在使用完之后释放.
- 环路等待条件：发生死锁的时候必然存在一个线程-资源的环形链,即线程集合{T0,T1,T2,...Tn}中的T0正在等待 一个T1占用的资源,T1正在等待T2占用的资源,...Tn正在等待T1占用的资源


## 通信方式

- 共享进程的变量
- ThreadLocal
- 同步锁、信号量（Synchronize、Semaphore、Lock）
