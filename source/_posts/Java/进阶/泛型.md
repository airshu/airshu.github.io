---
title: 泛型
date: 2021-05-29
toc: true
tags:
---


## 概述

范型的设计参考了C++中的模版，目的是写出更加通用的代码。泛型将代码安全性检查提前到编译期。添加了范型特性后，解决了Java中容器的类型安全问题。

泛型的本质是参数化类型。也就是说，泛型就是将所操作的数据类型作为参数的一种语法。

Java泛型为了向前兼容，采取运行期类型擦出泛型参数的方式来实现。这就意味着，你在使用泛型的时候，任何具体的类型都已经被擦除。

```java
public class Paly<T>{ 
    T play(){}
}

Play<Integer> playInteger=new Play<>();//这里 T 就会被实例化为 Integer
```

## 泛型类型

### 自定义泛型接口

```java
interface Observer<T>
```

### 泛型类

```java
class ImplObserver<T> implements Observer<T>
```


### 泛型方法

![](./genericity_1.png)

### 泛型作用域

- 如果将泛型声明放在泛型接口,泛型类上,则该泛型在该类中就是确定的了。
- 如果将泛型声明放在了泛型方法上,则该泛型只在该方法中有效。
- 如果泛型方法上声明的泛型类型和类或接口中声明的泛型一致,则会在该方法中隐藏类或接口上的泛型。

## 通配符与嵌套

### 通配符

?:表示类型不确定，只能用于声明变量或者形参上，不能用在创建泛型类，泛型方法和接口上

```java
public static void main(String[] args) { 
    List<?> list=new ArrayList<Integer>(); 
    list=new ArrayList<String>(); 
    test(list);
}
public static void test(List<?> list){ }
```

### 泛型嵌套

```java
class Student<T>{ 
    private T score; 
    public T getScore(){
        return score; 
    }
    public void setScore(T score){ 
        this.score=score;
    }
}

class MyClass<T> {
    private T cls;

    public T getCls() {
        return cls;
    }

    public void setCls(T cls) {
        this.cls = cls;
    }
}

public static void main(String[] args) {
    Student<String> stu = new Student<String>();
    stu.setScore("great");
    //泛型嵌套
    MyClass<Student<String>> cls = new MyClass<Student<String>>();
    cls.setCls(stu);
    Student<String> stu2 = new Student<String>();
    stu2 = cls.getCls();
    System.out.println(stu2.getScore());//great
}
```

定义两个泛型类 ，Myclass类的泛型就是Student类 ，而Student类的泛型是String类

## 泛型上下边界

### ? extends E 是泛型的上边界

List < ? extends A >表示这个 list 里面存的是 A 的子类，具体是啥不知道，只知道范围!



### ? super T 是泛型的下边界

List < ? super C > 表示 list 里面存的是 C 和其父类，具体是啥不确定，只知道范围。
