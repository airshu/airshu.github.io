---
title: Java笔试题收集
tags: Java
---



##### TCP、UDP区别

1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的,UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4. TCP首部开销20字节;UDP的首部开销小，只有8个字节
5. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

##### 三次握手、四次挥手

**三次握手**

![](./tcp_1.png)

第一次握手：客户端想跟服务器进行连接，所以状态变为**主动打开**，同时发送一个连接请求报文给服务器端SYN=1，并且会携带x个字节过去。发送完请求连接报文后，客户端的状态就变为**SYN_SENT**,这个状态等待发送确认。

第二次握手：服务端接收到连接请求报文后，从**LISTEN**状态变为**被动打开**状态，然后给客户端返回一个报文。这个报文有两层意思，一是确认报文，二是可以达到告诉客户端，我也打开连接了。发送完毕后，变为**SYN_RCVD**状态。

第三次握手：客户端得到服务端的确认和知道服务端已经准备好连接后，还会发一个确认报文到服务端，发送完后客户端进入**ESTABLISHED**状态，当服务端接收后，状态也变为**ESTABLISHED**。

**四次挥手**

![](./tcp_2.png)

第一次挥手：从**ESTABLISHED**变为**主动关闭**状态，客户端主动发送释放连接请求给服务器端，FIN=1。发送完之后就变为**FIN_WAIT_1**状态，这个状态可以说是等待确认状态。

第二次挥手：服务器接收到客户端发来的释放连接请求后，状态变为**CLOSE_WAIT**，然后发送确认报文给客户端，告诉他我接收到了你的请求。为什么变为CLOSE_WAIT，原因是客户端发送的释放连接请求，可能自己这端还有数据没有发送完呢，所以这个时候整个TCP连接的状态就变为了半关闭状态。服务器端还能发送数据，并且客户端也能接收数据，但是客户端不能在发送数据了，只能够发送确认报文。客户端接到服务器的确认报文后，就进入了**FIN_WAIT_2**状态。也可以说这是等待服务器释放连接状态。

第三次挥手：服务器端所有的数据度发送完了，认为可以关闭连接了，状态变为**被动关闭**，所以向客户端发送释放连接报文，发完之后自己变为**LAST_WAIT**状态，也就是等待客户端确认状态。

第四次挥手：客户端接到释放连接报文后，发送一个确认报文，然后自己变为**TIME_WAIT**,而不是立马关闭，因为客户端发送的确认报文可能会丢失，丢失的话服务器就会重传一个FIN，也就是释放连接报文，这个时候客户端必须还没关闭。 当服务器接受到确认报文后，服务器就进入**CLOSE**状态，也就是关闭了。但是由于上面说的这个原因，客户端必须等待一定的时间才能够进入**CLOSE**状态。



## volatile

执行控制：目的是控制代码执行（顺序）及是否可以并行执行。

内存可见：线程执行结果在内存中对其他线程的可见性。

1. volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3. volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
4. volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
5. volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化




* 内存模型
    * 定义
    * 为什么要有内存模型
    * 为什么要重排序，重排序在什么时候排
    * 如何约束重排序规则
    * happens-before

* 什么是顺序一致性
* CAS 实现的原理，是阻塞还是非阻塞方式？什么时候用，使用时需要考虑的问题
* 处理器和 Java 分别怎么保证原子操作
* 保证了原子性就能保证可见性吗？
* final 内存语义？什么时候用，使用时需要考虑的问题
* volatile 内存语义，什么时候用，用的时候需要考虑什么问题
* synchronized 内存语义，什么时候用，和锁比较一下优缺点
* synchronized 中涉及的锁升级流程
* 锁的内存语义，举例说明，加锁失败时候的处理流程
* 比较下 CAS 、volatile 、synchronized、Lock 区别
* 原子操作类底层实现机制？自增操作是怎么保证原子性的？


线程

* 线程的状态有哪些
* 如何在 Java 中实现线程？
* 如何在 Java 中启动一个线程？
* 设计线程中断的意义是什么
* Java 中 interrupted 和 isInterrupted 方法的区别？
* 如何停止一个线程？
* 线程 join 方法干什么用？
* 有三个线程 T1，T2，T3，怎么确保它们按顺序执行？
* 线程的等待通知机制实现机制？
* 为什么应该在循环中检查等待条件?
* 为什么 wait 和 notify 方法要在同步块中调用？
* 为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？
* ThreadLocal 是什么，怎么实现的
* 线程池是什么，提交一个任务进去，处理流程？
* Executor 框架介绍
* JUC 包中提供了哪些配置好的线程池，差异化是什么
* 什么是 FutureTask？
  

锁

* Lock 接口提供了哪些实现类
* AQS 是什么，提供了哪些方法
* AQS 中独占锁和共享锁的操作流程大体描述一下
* 重入锁有什么好处，什么时候考虑用
* 读写锁有什么好处，什么时候考虑用？读锁是什么类型的锁，写锁呢？
* 说下读写锁里的锁降级流程，什么时候可以考虑用这个机制
* park 方法是怎么实现的
* 锁的等待通知机制 Condition 是怎么实现的，有了线程的等待通知机制为什么还要设计 Condition？
* 死锁怎么产生的，如何避免
* 说说 Java 中有哪些锁
* sleep、wait、park、Condition 都能让线程等待，有什么区别？
  
容器与工具

* 阻塞和非阻塞有什么区别，他们可以用什么方式实现
* 队列（Queue）提供哪些操作
* 阻塞队列提供了哪些获取元素的方法，有什么区别？
* 阻塞队列有哪些实现？为什么要分有界无界？
* CountDownLatch 怎么实现的，什么时候考虑用？
* CyclicBarrier 怎么实现的，什么时候考虑用？
* Semaphore 怎么实现的，什么时候考虑用？
* 如何在两个线程间共享数据？
* Exchanger 怎么实现的，什么时候考虑用？
* ConcurrentHashMap 实现？
* fork/join 框架是什么？


内存管理

* 为什么需要 JVM？
* 简单描述 JMM 和 JVM 两个概念
* JVM 内存管理
* 永久代、元空间、方法区的关系
* 类加载过程
* 双亲委派模式有什么好处
* 如何覆盖 JDK 提供的组件，比如覆盖 ArrayList 的实现
* new 一个对象的过程发生了什么（类加载、变量初始化、内存分配）
* 对象的死亡过程
* JVM 可能会抛出哪些 OOM
* 垃圾回收算法有哪些？优缺点比较
* 熟知的垃圾回收器有哪些，简单描述每个应用场景
* CMS 和 G1 的垃圾回收步骤是？
* G1 相对于 CMS 的优缺点


性能监控与调优

* 如何监控 GC
* 常见 OutOfMemoryError 有哪些
* 常见的 JDK 诊断命令有哪些，应用场景？
* CPU 较高，如何定位问题
* 内存占用较高，如何定位大对象
* 内存泄漏时，如何实时跟踪内存变化情况
* 内存泄漏时，如何定位问题代码
* 大型项目如何进行性能瓶颈调优？
  虚拟机子系统

* 字节码是如何在 JVM 中进行流转的（栈帧）
* 方法调用的底层实现
* 方法重写和重载的实现过程
* invokedynamic 指令实现
* 如何修改字节码
* JIT 参数配置如何影响程序运行？
* 虚拟机有哪些性能优化策略


Java基础

1.JAVA 中的几种数据类型是什么，各自占用多少字节。
2.String 类能被继承吗，为什么。
3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？
4. String 属于基础的数据类型吗？
5.Java 中操作字符串都有哪些类？它们之间有什么区别？
6.Java 中 IO 流分为几种？
7.BIO、NIO、AIO 有什么区别？
8.用过哪些 Map 类，都有什么区别，HashMap 时线程安全的吗，并发下使用的 Map 是什么，他们的内部原理分别是什么，比如存储方法，hashcode，扩容，默认容量等。
9. 如何将字符串反转？
10.抽象类必须要有抽象方法吗？
11.普通类和抽象类有哪些区别？
12.抽象类能使用 final 修饰吗？
13.ArrayList 和 LinkedList 有什么区别？
14.ConcurrentHashMap的数据结构 
15.volatile作用 
16.Atomic类如何保证原子性（CAS操作） 
17.为什么要使用线程池 


JVM

* 运行时数据区域（内存模型） 
* 垃圾回收机制 
* 垃圾回收算法 
* Minor GC和Full GC触发条件
* GC中Stop the world（STW）
* 各垃圾回收器的特点及区别
* 双亲委派模型
* JDBC和双亲委派模型关系
* JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数


操作系统篇

* 进程和线程的区别
* 进程同步的几种方式
* 线程间同步的方式
* 什么是缓冲区溢出。有什么危害，其原因是什么
* 进程中有哪几种状态
* 分页和分段有什么区别
