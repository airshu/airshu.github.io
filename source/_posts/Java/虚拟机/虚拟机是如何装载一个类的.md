---
title: 虚拟机是如何装载一个类的
toc: true
tags: [JVM, Java]
---


Java语言的类型可以分为两大类:基本类型(primitive types)和引用类型(reference types)。 基本类型是由Java虚拟机预先定义好的。

另一个大类引用类型，Java将其细分为四种:类、接口、数组类和泛型参数。由于泛型参数会在 编译过程中被擦除，因此Java虚拟机实际上只有前三种。
在类、接口和数组类中，数组类是由 Java虚拟机直接生成的，其他两种则有对应的字节流。

说到字节流，最常见的形式要属由Java编译器生成的class文件。除此之外，我们也可以在程序内 部直接生成，或者从网络中获取(例如网页中内嵌的小程序Java applet)字节流。
这些不同形式的字节流，都会被加载到Java虚拟机中，成为类或接口。为了叙述方便，下面我就用“类”来统称它们。

无论是直接生成的数组类，还是加载的类，Java虚拟机都需要对其进行链接和初始化。


## 加载

加载，是指查找字节流，并且据此创建类的过程。对于数组类来说，它并没有对应的字节流，而 是由Java虚拟机直接生成的。对于其他的类来说，Java虚拟机则需要借助类加载器来完成查找字 节流的过程。

java中有很多类加载器，共同的祖师爷，叫启动类加载器(bootstrap class loader)。启动类加载 器是由C++实现的，没有对应的Java对象，因此在Java种只能用null来指代。

除了启动类加载器之外，其他的类加载器都是java.lang.ClassLoader的子类，因此有对应的Java对 象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至Java虚拟机中，方能 执行类加载。

每当一个类加载器接收到加载请求时，它会将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。叫双亲委派模型。

在Java9之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在JRE的lib目录下jar包中的类(以及由虚拟机参数-Xbootclasspath 指定的类)。
除了启动类加载器之外，另外两个重要 的类加载器是扩展加载器(extension class loader)和应用类加载器(application class loader)， 均由Java核心类库提供。

扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如放在JRE 的lib/ext目录下jar包中的类(以及由系统变量java.ext.dirs指定的类)。

应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。(这里的应用 程序路径，便是指虚拟机参数 -cp/-classpath、系统变量java.class.path或环境变量CLASSPATH所 指定的路径。)默认情况下，应用程序中包含的类便是由应用类加载器加载的。

Java9引入模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器 (platform class loader)。Java SE中除了少数几个关键模块，比如说java.base是由启动类加载器 加载之外，其他的模块均由平台类加载器所加载。

除了由Java核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载 方式。举例来说，我们可以对class文件进行加密，加载时再利用自定义的类加载器对其解密。

在Java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节 流，经过不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特 性，来运行同一个类的不同版本


## 链接

链接，是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。它可以分为`验证`、`准备`以及`解析`三个阶段。

验证阶段的目的，在于确保被加载的类能够满足Java虚拟机的约束条件。通常而言，Java编译器 生成的类文件必然满足Java虚拟机的约束条件。

准备阶段的目的，则是为被加载类的静态字段分配内存。Java代码中对静态字段的具体初始化， 则会在稍后的初始化阶段中进行。除了分配内存外，部分Java虚拟机还会在此阶段构造 其他跟类 层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。

在class文件被加载至Java虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java编译器会生成一 个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。

举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收餐宿和类型以及返回值类型的符号引用，来指代所要调用的方法。

解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载的字段或方法，那么解析将触发这个类的加载(但未必触发这个类的链接以及初始化。)

Java虚拟机规范并没有要求在链接过程中完成解析。它仅规定了:如果某些字节码使用了符号引 用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。

## 初始化

在Java代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块 中对其赋值。

如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段便会 被Java编译器标记成为常量值(ConstantValue)，其初始化直接由Java虚拟机完成。除此之外的 直接赋值操作，以及所有静态代码块中的代码，则会被Java编译器置于同一方法中，并把它命名 为。

类加载的最后一步时初始化，便是为标记为常量值的字段赋值，以及执行方法的过程。Java虚拟 机会通过加锁来确保类的方法仅被执行一次。

只有当初始化完成之后，类才正式成为可执行的状态。那么，类的初始化何时会被触发呢?JVM 规范枚举了下述多种触发情况:

1. 当虚拟机启动时，初始化用户指定的主类;
2. 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类;
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类;
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类;
5. 子类的初始化会触发父类的初始化;
6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该 接口的初始化;
7. 使用反射API对某个类进行反射调用时，初始化这个类;
8. 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。


## 使用

## 卸载
